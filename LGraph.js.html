<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Adding meta -->
    

    <!-- Adding external script-->
    

    <!-- Adding external style-->
    

    <!-- Adding scripts-->
    

    <!-- Adding style-->
    

    <!-- Adding overlay script-->
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/overlayscrollbars/1.13.0/js/OverlayScrollbars.min.js" integrity="sha512-5R3ngaUdvyhXkQkIqTf/k+Noq3phjmrqlUQyQYbgfI34Mzcx7vLIIYTy/K1VMHkL33T709kfh5y6R9Xy/Cbt7Q==" crossorigin="anonymous"></script>
    

    <!-- Adding overlay style-->
    


    <title>LGraph.js</title>

    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/third-party/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/third-party/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-base.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-dark.css">
    
<svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none">
    <defs>
        <symbol id="copy-icon" viewbox="0 0 488.3 488.3">
            <g>
                <path d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z"/>
                <path d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z"/>
            </g>
        </symbol>
    </defs>
</svg>

</head>
<body>
<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html"><div class="text">Home</div></a></h2><div class="search-box"><input type="text" placeholder="Search..." id="search-box" /><div class="search-item-container" id="search-item-container"><ul class="search-item-ul" id="search-item-ul"></ul></div></div><div class="sidebar-list-div"><ul><li><a href='https://paladium-pvp.fr/' class='' id='' target='_blank'>Paladium Website</a></li><li><a href='https://github.com/Paladium-Developpement/litegraph.js/' class='' id='' target='_blank'>Project GitHub</a></li></ul><h3>Classes</h3><ul><li class="" id=""><a href="ContextMenu.html">ContextMenu</a></li><li class="" id=""><a href="CurveEditor.html">CurveEditor</a></li><li class="" id=""><a href="DragAndScale.html">DragAndScale</a></li><li class="" id=""><a href="Editor.html">Editor</a></li><li class="accordion collapsed" id=4991326><div class="accordion-title"><a href="LGraph.html">LGraph</a><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16">
    <path 
        fill-rule="evenodd" 
        clip-rule="evenodd" 
        d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z">
    </path>
</svg></div><ul class='methods accordion-content'><li data-type='method'><a href="LGraph.html#.add">add</a></li><li data-type='method'><a href="LGraph.html#.addGlobalInput">addGlobalInput</a></li><li data-type='method'><a href="LGraph.html#.addOutput">addOutput</a></li><li data-type='method'><a href="LGraph.html#.arrange">arrange</a></li><li data-type='method'><a href="LGraph.html#.attachCanvas">attachCanvas</a></li><li data-type='method'><a href="LGraph.html#.changeInputType">changeInputType</a></li><li data-type='method'><a href="LGraph.html#.changeOutputType">changeOutputType</a></li><li data-type='method'><a href="LGraph.html#.checkNodeTypes">checkNodeTypes</a></li><li data-type='method'><a href="LGraph.html#.clear">clear</a></li><li data-type='method'><a href="LGraph.html#.clearTriggeredSlots">clearTriggeredSlots</a></li><li data-type='method'><a href="LGraph.html#.configure">configure</a></li><li data-type='method'><a href="LGraph.html#.detachCanvas">detachCanvas</a></li><li data-type='method'><a href="LGraph.html#.findNodeByTitle">findNodeByTitle</a></li><li data-type='method'><a href="LGraph.html#.findNodesByClass">findNodesByClass</a></li><li data-type='method'><a href="LGraph.html#.findNodesByTitle">findNodesByTitle</a></li><li data-type='method'><a href="LGraph.html#.findNodesByType">findNodesByType</a></li><li data-type='method'><a href="LGraph.html#.getAncestors">getAncestors</a></li><li data-type='method'><a href="LGraph.html#.getElapsedTime">getElapsedTime</a></li><li data-type='method'><a href="LGraph.html#.getFixedTime">getFixedTime</a></li><li data-type='method'><a href="LGraph.html#.getGroupOnPos">getGroupOnPos</a></li><li data-type='method'><a href="LGraph.html#.getInputData">getInputData</a></li><li data-type='method'><a href="LGraph.html#.getNodeById">getNodeById</a></li><li data-type='method'><a href="LGraph.html#.getNodeOnPos">getNodeOnPos</a></li><li data-type='method'><a href="LGraph.html#.getOutputData">getOutputData</a></li><li data-type='method'><a href="LGraph.html#.getTime">getTime</a></li><li data-type='method'><a href="LGraph.html#.isLive">isLive</a></li><li data-type='method'><a href="LGraph.html#.remove">remove</a></li><li data-type='method'><a href="LGraph.html#.removeInput">removeInput</a></li><li data-type='method'><a href="LGraph.html#.removeLink">removeLink</a></li><li data-type='method'><a href="LGraph.html#.removeOutput">removeOutput</a></li><li data-type='method'><a href="LGraph.html#.renameInput">renameInput</a></li><li data-type='method'><a href="LGraph.html#.renameOutput">renameOutput</a></li><li data-type='method'><a href="LGraph.html#.runStep">runStep</a></li><li data-type='method'><a href="LGraph.html#.sendEventToAllNodes">sendEventToAllNodes</a></li><li data-type='method'><a href="LGraph.html#.serialize">serialize</a></li><li data-type='method'><a href="LGraph.html#.setGlobalInputData">setGlobalInputData</a></li><li data-type='method'><a href="LGraph.html#.setOutputData">setOutputData</a></li><li data-type='method'><a href="LGraph.html#.start">start</a></li><li data-type='method'><a href="LGraph.html#.stopexecution">stop execution</a></li><li data-type='method'><a href="LGraph.html#.updateExecutionOrder">updateExecutionOrder</a></li><li data-type='method'><a href="LGraph.html#computeExecutionOrder">computeExecutionOrder</a></li><li data-type='method'><a href="LGraph.html#onNodeTrace">onNodeTrace</a></li></ul></li><li class="accordion collapsed" id=9280215><div class="accordion-title"><a href="LGraphCanvas.html">LGraphCanvas</a><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16">
    <path 
        fill-rule="evenodd" 
        clip-rule="evenodd" 
        d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z">
    </path>
</svg></div><ul class='methods accordion-content'><li data-type='method'><a href="LGraphCanvas.html#.adjustMouseEvent">adjustMouseEvent</a></li><li data-type='method'><a href="LGraphCanvas.html#.bindEvents">bindEvents</a></li><li data-type='method'><a href="LGraphCanvas.html#.blockClick">blockClick</a></li><li data-type='method'><a href="LGraphCanvas.html#.bringToFront">bringToFront</a></li><li data-type='method'><a href="LGraphCanvas.html#.centerOnNode">centerOnNode</a></li><li data-type='method'><a href="LGraphCanvas.html#.clear">clear</a></li><li data-type='method'><a href="LGraphCanvas.html#.closeSubgraph">closeSubgraph</a></li><li data-type='method'><a href="LGraphCanvas.html#.computeConnectionPoint">computeConnectionPoint</a></li><li data-type='method'><a href="LGraphCanvas.html#.computeVisibleNodes">computeVisibleNodes</a></li><li data-type='method'><a href="LGraphCanvas.html#.convertCanvasToOffset">convertCanvasToOffset</a></li><li data-type='method'><a href="LGraphCanvas.html#.convertEventToCanvasOffset">convertEventToCanvasOffset</a></li><li data-type='method'><a href="LGraphCanvas.html#.convertOffsetToCanvas">convertOffsetToCanvas</a></li><li data-type='method'><a href="LGraphCanvas.html#.deleteSelectedNodes">deleteSelectedNodes</a></li><li data-type='method'><a href="LGraphCanvas.html#.deselectAllNodes">deselectAllNodes</a></li><li data-type='method'><a href="LGraphCanvas.html#.deselectNode">deselectNode</a></li><li data-type='method'><a href="LGraphCanvas.html#.draw">draw</a></li><li data-type='method'><a href="LGraphCanvas.html#.drawBackCanvas">drawBackCanvas</a></li><li data-type='method'><a href="LGraphCanvas.html#.drawButton">drawButton</a></li><li data-type='method'><a href="LGraphCanvas.html#.drawConnections">drawConnections</a></li><li data-type='method'><a href="LGraphCanvas.html#.drawFrontCanvas">drawFrontCanvas</a></li><li data-type='method'><a href="LGraphCanvas.html#.drawGroups">drawGroups</a></li><li data-type='method'><a href="LGraphCanvas.html#.drawNode">drawNode</a></li><li data-type='method'><a href="LGraphCanvas.html#.drawNodeShape">drawNodeShape</a></li><li data-type='method'><a href="LGraphCanvas.html#.drawNodeWidgets">drawNodeWidgets</a></li><li data-type='method'><a href="LGraphCanvas.html#.drawSubgraphPanel">drawSubgraphPanel</a></li><li data-type='method'><a href="LGraphCanvas.html#.enableWebGL">enableWebGL</a></li><li data-type='method'><a href="LGraphCanvas.html#.getCanvasWindow">getCanvasWindow</a></li><li data-type='method'><a href="LGraphCanvas.html#.getCurrentGraph">getCurrentGraph</a></li><li data-type='method'><a href="LGraphCanvas.html#.getTopGraph">getTopGraph</a></li><li data-type='method'><a href="LGraphCanvas.html#.isOverNodeBox">isOverNodeBox</a></li><li data-type='method'><a href="LGraphCanvas.html#.isOverNodeInput">isOverNodeInput</a></li><li data-type='method'><a href="LGraphCanvas.html#.onGroupAdd">onGroupAdd</a></li><li data-type='method'><a href="LGraphCanvas.html#.onMenuCollapseAll">onMenuCollapseAll</a></li><li data-type='method'><a href="LGraphCanvas.html#.onMenuNodeEdit">onMenuNodeEdit</a></li><li data-type='method'><a href="LGraphCanvas.html#.onNodeSelectionChange">onNodeSelectionChange</a></li><li data-type='method'><a href="LGraphCanvas.html#.openSubgraph">openSubgraph</a></li><li data-type='method'><a href="LGraphCanvas.html#.processDrop">processDrop</a></li><li data-type='method'><a href="LGraphCanvas.html#.processKey">processKey</a></li><li data-type='method'><a href="LGraphCanvas.html#.processMouseMove">processMouseMove</a></li><li data-type='method'><a href="LGraphCanvas.html#.processMouseUp">processMouseUp</a></li><li data-type='method'><a href="LGraphCanvas.html#.processMouseWheel">processMouseWheel</a></li><li data-type='method'><a href="LGraphCanvas.html#.processNodeWidgets">processNodeWidgets</a></li><li data-type='method'><a href="LGraphCanvas.html#.renderFrame">renderFrame</a></li><li data-type='method'><a href="LGraphCanvas.html#.renderInfo">renderInfo</a></li><li data-type='method'><a href="LGraphCanvas.html#.renderLink">renderLink</a></li><li data-type='method'><a href="LGraphCanvas.html#.resize">resize</a></li><li data-type='method'><a href="LGraphCanvas.html#.selectNode">selectNode</a></li><li data-type='method'><a href="LGraphCanvas.html#.selectNodes">selectNodes</a></li><li data-type='method'><a href="LGraphCanvas.html#.sendToBack">sendToBack</a></li><li data-type='method'><a href="LGraphCanvas.html#.setCanvas">setCanvas</a></li><li data-type='method'><a href="LGraphCanvas.html#.setDirty">setDirty</a></li><li data-type='method'><a href="LGraphCanvas.html#.setGraph">setGraph</a></li><li data-type='method'><a href="LGraphCanvas.html#.setZoom">setZoom</a></li><li data-type='method'><a href="LGraphCanvas.html#.startRendering">startRendering</a></li><li data-type='method'><a href="LGraphCanvas.html#.stopRendering">stopRendering</a></li><li data-type='method'><a href="LGraphCanvas.html#.switchLiveMode">switchLiveMode</a></li><li data-type='method'><a href="LGraphCanvas.html#.touchHandler">touchHandler</a></li><li data-type='method'><a href="LGraphCanvas.html#.unbindEvents">unbindEvents</a></li></ul></li><li class="" id=""><a href="LGraphGroup.html">LGraphGroup</a></li><li class="accordion collapsed" id=1613131><div class="accordion-title"><a href="LGraphNode.html">LGraphNode</a><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16">
    <path 
        fill-rule="evenodd" 
        clip-rule="evenodd" 
        d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z">
    </path>
</svg></div><ul class='methods accordion-content'><li data-type='method'><a href="LGraphNode.html#.addConnection">addConnection</a></li><li data-type='method'><a href="LGraphNode.html#.addInput">addInput</a></li><li data-type='method'><a href="LGraphNode.html#.addInputs">addInputs</a></li><li data-type='method'><a href="LGraphNode.html#.addNodeMethod">addNodeMethod</a></li><li data-type='method'><a href="LGraphNode.html#.addOutput">addOutput</a></li><li data-type='method'><a href="LGraphNode.html#.addOutputs">addOutputs</a></li><li data-type='method'><a href="LGraphNode.html#.addProperty">addProperty</a></li><li data-type='method'><a href="LGraphNode.html#.addWidget">addWidget</a></li><li data-type='method'><a href="LGraphNode.html#.clearTriggeredSlot">clearTriggeredSlot</a></li><li data-type='method'><a href="LGraphNode.html#.collapse">collapse</a></li><li data-type='method'><a href="LGraphNode.html#.computeSize">computeSize</a></li><li data-type='method'><a href="LGraphNode.html#.configure">configure</a></li><li data-type='method'><a href="LGraphNode.html#.connect">connect</a></li><li data-type='method'><a href="LGraphNode.html#.createNode">createNode</a></li><li data-type='method'><a href="LGraphNode.html#.disconnectInput">disconnectInput</a></li><li data-type='method'><a href="LGraphNode.html#.disconnectOutput">disconnectOutput</a></li><li data-type='method'><a href="LGraphNode.html#.findInputSlot">findInputSlot</a></li><li data-type='method'><a href="LGraphNode.html#.findOutputSlot">findOutputSlot</a></li><li data-type='method'><a href="LGraphNode.html#.getBounding">getBounding</a></li><li data-type='method'><a href="LGraphNode.html#.getConnectionPos">getConnectionPos</a></li><li data-type='method'><a href="LGraphNode.html#.getInputData">getInputData</a></li><li data-type='method'><a href="LGraphNode.html#.getInputDataByName">getInputDataByName</a></li><li data-type='method'><a href="LGraphNode.html#.getInputDataType">getInputDataType</a></li><li data-type='method'><a href="LGraphNode.html#.getInputInfo">getInputInfo</a></li><li data-type='method'><a href="LGraphNode.html#.getInputLink">getInputLink</a></li><li data-type='method'><a href="LGraphNode.html#.getInputNode">getInputNode</a></li><li data-type='method'><a href="LGraphNode.html#.getInputOrProperty">getInputOrProperty</a></li><li data-type='method'><a href="LGraphNode.html#.getOutputData">getOutputData</a></li><li data-type='method'><a href="LGraphNode.html#.getOutputInfo">getOutputInfo</a></li><li data-type='method'><a href="LGraphNode.html#.getOutputNodes">getOutputNodes</a></li><li data-type='method'><a href="LGraphNode.html#.getPropertyInfo">getPropertyInfo</a></li><li data-type='method'><a href="LGraphNode.html#.getSlotInPosition">getSlotInPosition</a></li><li data-type='method'><a href="LGraphNode.html#.getTitle">getTitle</a></li><li data-type='method'><a href="LGraphNode.html#.isAnyOutputConnected">isAnyOutputConnected</a></li><li data-type='method'><a href="LGraphNode.html#.isInputConnected">isInputConnected</a></li><li data-type='method'><a href="LGraphNode.html#.isOutputConnected">isOutputConnected</a></li><li data-type='method'><a href="LGraphNode.html#.isPointInside">isPointInside</a></li><li data-type='method'><a href="LGraphNode.html#.pin">pin</a></li><li data-type='method'><a href="LGraphNode.html#.removeInput">removeInput</a></li><li data-type='method'><a href="LGraphNode.html#.removeOutput">removeOutput</a></li><li data-type='method'><a href="LGraphNode.html#.serialize">serialize</a></li><li data-type='method'><a href="LGraphNode.html#.setOutputData">setOutputData</a></li><li data-type='method'><a href="LGraphNode.html#.setOutputDataType">setOutputDataType</a></li><li data-type='method'><a href="LGraphNode.html#.setProperty">setProperty</a></li><li data-type='method'><a href="LGraphNode.html#.setSize">setSize</a></li><li data-type='method'><a href="LGraphNode.html#.toString">toString</a></li><li data-type='method'><a href="LGraphNode.html#.trigger">trigger</a></li><li data-type='method'><a href="LGraphNode.html#.triggerSlot">triggerSlot</a></li></ul></li><li class="" id=""><a href="LLink.html">LLink</a></li></ul><h3>Modules</h3><ul><li class="accordion collapsed" id=1078892><div class="accordion-title"><a href="module-File%2520Utils.html">File Utils</a><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16">
    <path 
        fill-rule="evenodd" 
        clip-rule="evenodd" 
        d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z">
    </path>
</svg></div><ul class='methods accordion-content'><li data-type='method'><a href="module-File%252520Utils.html#~fetchFile">fetchFile</a></li></ul></li><li class="accordion collapsed" id=7747951><div class="accordion-title"><a href="module-Function%2520Utils.html">Function Utils</a><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16">
    <path 
        fill-rule="evenodd" 
        clip-rule="evenodd" 
        d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z">
    </path>
</svg></div><ul class='methods accordion-content'><li data-type='method'><a href="module-Function%252520Utils.html#~isValidConnection">isValidConnection</a></li><li data-type='method'><a href="module-Function%252520Utils.html#~wrapFunctionAsNode">wrapFunctionAsNode</a></li></ul></li><li class="" id=""><a href="module-Math%2520Utils.html">Math Utils</a></li><li class="" id=""><a href="module-Object%2520Utils.html">Object Utils</a></li><li class="accordion collapsed" id=1533334><div class="accordion-title"><a href="module-Registry%2520Manager.html">Registry Manager</a><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16">
    <path 
        fill-rule="evenodd" 
        clip-rule="evenodd" 
        d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z">
    </path>
</svg></div><ul class='methods accordion-content'><li data-type='method'><a href="module-Registry%252520Manager.html#.clearRegisteredTypes">clearRegisteredTypes</a></li><li data-type='method'><a href="module-Registry%252520Manager.html#~getNodeType">getNodeType</a></li><li data-type='method'><a href="module-Registry%252520Manager.html#~getNodeType">getNodeType</a></li><li data-type='method'><a href="module-Registry%252520Manager.html#~getNodeTypesCategories">getNodeTypesCategories</a></li><li data-type='method'><a href="module-Registry%252520Manager.html#~registerNodeType">registerNodeType</a></li><li data-type='method'><a href="module-Registry%252520Manager.html#~registerSearchboxExtra">registerSearchboxExtra</a></li><li data-type='method'><a href="module-Registry%252520Manager.html#~unregisterNodeType">unregisterNodeType</a></li></ul></li><li class="" id=""><a href="module-Time%2520Utils.html">Time Utils</a></li></ul></div>
</nav>

<div id="main">
    
    <h1 id='page-title' class="page-title">LGraph.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import defaultConfig from "./utils/defaultConfig";
import getTime from "./utils/time";
import LGraphNode from "./LGraphNode";
import LGraphGroup from "./LGraphGroup";
import LGraphCanvas from "./LGraphCanvas";
import LLink from "./LLink";

/**
 * LGraph is the class that contain a full graph.
 * We instantiate one and add nodes to it, and then we can run the execution loop.
 * supported callbacks:
 + onNodeAdded: when a new node is added to the graph
 + onNodeRemoved: when a node inside this graph is removed
 + onNodeConnectionChange: some connection has changed in the graph (connected or disconnected)
 *
 * @class LGraph
 * @constructor
 * @param {Object} o data from previous serialization [optional]
 */
export default class LGraph {
    constructor(o) {
        if (defaultConfig.debug) {
            console.log("Graph created");
        }
        this.list_of_graphcanvas = null;
        this.clear();

        if (o) {
            this.configure(o);
        }
    }

    getSupportedTypes() {
        return this.supportedTypes || LGraph.supportedTypes;
    }

    STATUS_STOPPED = 1;

    STATUS_RUNNING = 2;

    supportedTypes = ["number", "string", "boolean"];

    static supportedTypes = ["number", "string", "boolean"];
    // used to know which types of connections support this graph (some graphs do not allow certain
    // types)

    /**
     * Removes all nodes from this graph
     * @method clear
     * @memberOf LGraph
     */
    clear() {
        this.stop();
        this.status = this.STATUS_STOPPED;

        this.last_node_id = 0;
        this.last_link_id = 0;

        this._version = -1; // used to detect changes

        // safe clear
        if (this._nodes) {
            for (const node of this._nodes) {
                if (node.onRemoved) node.onRemoved();
            }
        }

        // nodes
        this._nodes = [];
        this._nodes_by_id = {};
        this._nodes_in_order = []; // nodes sorted in execution order
        this._nodes_executable = null; // nodes that contain onExecute sorted in execution order

        // other scene stuff
        this._groups = [];

        // links
        this.links = {}; // container with all the links

        // iterations
        this.iteration = 0;

        // custom data
        this.config = {};
        this.vars = {};
        this.extra = {}; // to store custom data

        // timing
        this.globaltime = 0;
        this.runningtime = 0;
        this.fixedtime = 0;
        this.fixedtime_lapse = 0.01;
        this.elapsed_time = 0.01;
        this.last_update_time = 0;
        this.starttime = 0;

        this.catch_errors = true;

        // subgraph_data
        this.inputs = {};
        this.outputs = {};

        // notify canvas to redraw
        this.change();

        this.sendActionToCanvas("clear");
    }

    /**
     * Attach Canvas to this graph
     * @method attachCanvas
     * @param {GraphCanvas} graphcanvas
     * @memberOf LGraph
     */
    attachCanvas(graphcanvas) {
        if (graphcanvas.constructor !== LGraphCanvas) {
            throw new Error("attachCanvas expects a LGraphCanvas instance");
        }
        if (graphcanvas.graph &amp;&amp; graphcanvas.graph !== this) {
            graphcanvas.graph.detachCanvas(graphcanvas);
        }

        graphcanvas.graph = this;

        if (!this.list_of_graphcanvas) this.list_of_graphcanvas = [];
        this.list_of_graphcanvas.push(graphcanvas);
    }

    /**
     * Detach Canvas from this graph
     * @method detachCanvas
     * @param {GraphCanvas} graphcanvas
     * @memberOf LGraph
     */
    detachCanvas(graphcanvas) {
        if (!this.list_of_graphcanvas) {
            return;
        }

        const pos = this.list_of_graphcanvas.indexOf(graphcanvas);
        if (pos === -1) {
            return;
        }
        graphcanvas.graph = null;
        this.list_of_graphcanvas.splice(pos, 1);
    }

    /**
     * Starts running this graph every interval milliseconds.
     * @method start
     * @param {number} interval amount of milliseconds between executions, if 0 then it renders to
     *     the monitor refresh rate
     * @memberOf LGraph
     */
    start(interval) {
        if (this.status === LGraph.STATUS_RUNNING) {
            return;
        }
        this.status = LGraph.STATUS_RUNNING;

        if (this.onPlayEvent) {
            this.onPlayEvent();
        }

        this.sendEventToAllNodes("onStart");

        // launch
        this.starttime = getTime();
        this.last_update_time = this.starttime;
        interval = interval || 0;
        const that = this;

        // execute once per frame
        if (interval === 0 &amp;&amp; typeof window !== "undefined" &amp;&amp; window.requestAnimationFrame) {
            // eslint-disable-next-line no-inner-declarations
            function onFrame() {
                if (that.execution_timer_id !== -1) {
                    return;
                }
                window.requestAnimationFrame(onFrame);
                if (that.onBeforeStep) that.onBeforeStep();
                that.runStep(1, !that.catch_errors);
                if (that.onAfterStep) that.onAfterStep();
            }

            this.execution_timer_id = -1;
            onFrame();
        } else { // execute every 'interval' ms
            this.execution_timer_id = setInterval(() => {
                // execute
                if (that.onBeforeStep) that.onBeforeStep();
                that.runStep(1, !that.catch_errors);
                if (that.onAfterStep) that.onAfterStep();
            }, interval);
        }
    }

    /**
     * Stops the execution loop of the graph
     * @method stop execution
     * @memberOf LGraph
     */
    stop() {
        if (this.status === LGraph.STATUS_STOPPED) {
            return;
        }

        this.status = LGraph.STATUS_STOPPED;

        if (this.onStopEvent) {
            this.onStopEvent();
        }

        if (this.execution_timer_id) {
            if (this.execution_timer_id !== -1) {
                clearInterval(this.execution_timer_id);
            }
            this.execution_timer_id = null;
        }

        this.sendEventToAllNodes("onStop");
    }

    /**
     * Run N steps (cycles) of the graph
     * @method runStep
     * @param {number} num number of steps to run, default is 1
     * @param {Boolean} doNotCatchError [optional] if you want to try/catch errors
     * @param {number} limit max number of nodes to execute (used to execute from start to a node)
     * @memberOf LGraph
     */
    runStep(num, doNotCatchError, limit) {
        num = num || 1;

        const start = getTime();
        this.globaltime = 0.001 * (start - this.starttime);

        const nodes = this._nodes_executable
            ? this._nodes_executable
            : this._nodes;
        if (!nodes) {
            return;
        }

        limit = limit || nodes.length;

        if (doNotCatchError) {
            // iterations
            for (let i = 0; i &lt; num; i++) {
                for (let j = 0; j &lt; limit; j++) {
                    const node = nodes[j];
                    if (node.mode === defaultConfig.ALWAYS &amp;&amp; node.onExecute) {
                        node.onExecute(); // hard to send elapsed time
                    }
                }

                this.fixedtime += this.fixedtime_lapse;
                if (this.onExecuteStep) {
                    this.onExecuteStep();
                }
            }

            if (this.onAfterExecute) {
                this.onAfterExecute();
            }
        } else {
            try {
                // iterations
                for (let i = 0; i &lt; num; i++) {
                    for (let j = 0; j &lt; limit; ++j) {
                        const node = nodes[j];
                        if (node.mode === defaultConfig.ALWAYS &amp;&amp; node.onExecute) {
                            node.onExecute();
                        }
                    }

                    this.fixedtime += this.fixedtime_lapse;
                    if (this.onExecuteStep) {
                        this.onExecuteStep();
                    }
                }

                if (this.onAfterExecute) {
                    this.onAfterExecute();
                }
                this.errors_in_execution = false;
            } catch (err) {
                this.errors_in_execution = true;
                if (defaultConfig.throw_errors) {
                    throw err;
                }
                if (defaultConfig.debug) {
                    console.log(`Error during execution: ${err}`);
                }
                this.stop();
            }
        }

        const now = getTime();
        let elapsed = now - start;
        if (elapsed === 0) {
            elapsed = 1;
        }
        this.execution_time = 0.001 * elapsed;
        this.globaltime += 0.001 * elapsed;
        this.iteration += 1;
        this.elapsed_time = (now - this.last_update_time) * 0.001;
        this.last_update_time = now;
    }

    /**
     * Updates the graph execution order according to relevance of the nodes (nodes with only
     * outputs have more relevance than nodes with only inputs.
     * @method updateExecutionOrder
     * @memberOf LGraph
     */
    updateExecutionOrder() {
        this._nodes_in_order = this.computeExecutionOrder(false);
        this._nodes_executable = [];
        for (const node of this._nodes_in_order) {
            if (node.onExecute) {
                this._nodes_executable.push(node);
            }
        }
    }

    /**
     * It computes the executable nodes in order and returns it
     * @param onlyOnExecute
     * @param setLevel
     * @returns {this}
     * @internal
     * @memberOf LGraph
     */
    computeExecutionOrder(onlyOnExecute, setLevel) {
        let L = [];
        const S = [];
        const M = {};
        const visitedLinks = {}; // to avoid repeating links
        const remainingLinks = {}; // to a

        // search for the nodes without inputs (starting nodes)
        for (const node of this._nodes) {
            if (onlyOnExecute &amp;&amp; !node.onExecute) {
                continue;
            }

            M[node.id] = node; // add to pending nodes

            let num = 0; // num of input connections
            if (node.inputs) {
                for (let j = 0, l2 = node.inputs.length; j &lt; l2; j++) {
                    if (node.inputs[j] &amp;&amp; node.inputs[j].link != null) {
                        num += 1;
                    }
                }
            }

            if (num === 0) {
                // is a starting node
                S.push(node);
                if (setLevel) {
                    node._level = 1;
                }
            } else {
                if (setLevel) {
                    node._level = 0;
                }
                remainingLinks[node.id] = num;
            }
        }

        while (true) {
            if (S.length === 0) {
                break;
            }

            // get an starting node
            const node = S.shift();
            L.push(node); // add to ordered list
            delete M[node.id]; // remove from the pending nodes

            if (!node.outputs) {
                continue;
            }

            // for every output
            for (const output of node.outputs) {
                if (
                    output == null
                    || output.links == null
                    || output.links.length === 0
                ) {
                    continue;
                }

                // for every connection
                for (const linkId of output.links) {
                    const link = this.links[linkId];
                    if (!link) {
                        continue;
                    }

                    // already visited link (ignore it)
                    if (visitedLinks[link.id]) {
                        continue;
                    }

                    const targetNode = this.getNodeById(link.target_id);
                    if (targetNode == null) {
                        visitedLinks[link.id] = true;
                        continue;
                    }

                    if (
                        setLevel
                        &amp;&amp; (!targetNode._level
                        || targetNode._level &lt;= node._level)
                    ) {
                        targetNode._level = node._level + 1;
                    }

                    visitedLinks[link.id] = true; // mark as visited
                    remainingLinks[targetNode.id] -= 1; // reduce the number of links remaining
                    if (remainingLinks[targetNode.id] === 0) {
                        S.push(targetNode);
                    } // if no more links, then add to starters array
                }
            }
        }

        // the remaining ones (loops)
        // eslint-disable-next-line guard-for-in,no-restricted-syntax
        for (const i in M) L.push(M[i]);

        if (L.length !== this._nodes.length &amp;&amp; defaultConfig.debug) {
            console.warn("something went wrong, nodes missing");
        }

        const l = L.length;

        // save order number in the node
        for (let i = 0; i &lt; l; i++) L[i].order = i;

        // sort now by priority
        L = L.sort((A, B) => {
            const Ap = A.constructor.priority || A.priority || 0;
            const Bp = B.constructor.priority || B.priority || 0;
            if (Ap === Bp) {
                // if same priority, sort by order
                return A.order - B.order;
            }
            return Ap - Bp; // sort by priority
        });

        // save order number in the node, again...
        for (let i = 0; i &lt; l; ++i) L[i].order = i;

        return L;
    }

    /**
     * Returns all the nodes that could affect this one (ancestors) by crawling all the inputs
     * recursively. It doesn't include the node itself
     * @method getAncestors
     * @memberOf LGraph
     * @return {Array} an array with all the LGraphNodes that affect this node, in order of
     *     execution
     */
    // eslint-disable-next-line class-methods-use-this
    getAncestors(node) {
        const ancestors = [];
        const pending = [node];
        const visited = {};

        while (pending.length) {
            const current = pending.shift();
            if (!current.inputs) {
                continue;
            }
            if (!visited[current.id] &amp;&amp; current !== node) {
                visited[current.id] = true;
                ancestors.push(current);
            }

            for (let i = 0; i &lt; current.inputs.length; ++i) {
                const input = current.getInputNode(i);
                if (input &amp;&amp; ancestors.indexOf(input) === -1) {
                    pending.push(input);
                }
            }
        }

        ancestors.sort((a, b) => a.order - b.order);
        return ancestors;
    }

    /**
     * Positions every node in a more readable manner
     * @method arrange
     * @memberOf LGraph
     */
    arrange(margin) {
        margin = margin || 100;

        const nodes = this.computeExecutionOrder(false, true);
        const columns = [];
        for (const node of nodes) {
            const col = node._level || 1;
            if (!columns[col]) {
                columns[col] = [];
            }
            columns[col].push(node);
        }

        let x = margin;

        for (const column of columns) {
            if (!column) {
                continue;
            }
            let maxSize = 100;
            let y = margin + defaultConfig.NODE_TITLE_HEIGHT;
            for (const node of column) {
                node.pos[0] = x;
                node.pos[1] = y;
                if (node.size[0] > maxSize) maxSize = node.size[0];
                y += node.size[1] + margin + defaultConfig.NODE_TITLE_HEIGHT;
            }
            x += maxSize + margin;
        }

        this.setDirtyCanvas(true, true);
    }

    /**
     * Returns the amount of time the graph has been running in milliseconds
     * @method getTime
     * @return {number} number of milliseconds the graph has been running
     * @memberOf LGraph
     */
    getTime() {
        return this.globaltime;
    }

    /**
     * Returns the amount of time accumulated using the fixedtime_lapse var. This is used in
     * context where the time increments should be constant
     * @method getFixedTime
     * @return {number} number of milliseconds the graph has been running
     * @memberOf LGraph
     */

    getFixedTime() {
        return this.fixedtime;
    }

    /**
     * Returns the amount of time it took to compute the latest iteration. Take into account that
     * this number could be not correct if the nodes are using graphical actions
     * @method getElapsedTime
     * @return {number} number of milliseconds it took the last cycle
     * @memberOf LGraph
     */

    getElapsedTime() {
        return this.elapsed_time;
    }

    /**
     * Sends an event to all the nodes, useful to trigger stuff
     * @method sendEventToAllNodes
     * @param {String} eventname the name of the event (function to be called)
     * @param {Array} params parameters in array format
     * @memberOf LGraph
     */
    sendEventToAllNodes(eventname, params, mode) {
        mode = mode || defaultConfig.ALWAYS;

        const nodes = this._nodes_in_order ? this._nodes_in_order : this._nodes;
        if (!nodes) {
            return;
        }

        for (let j = 0, l = nodes.length; j &lt; l; ++j) {
            const node = nodes[j];

            if (
                node.constructor.name === "Subgraph"
                &amp;&amp; eventname !== "onExecute"
            ) {
                if (node.mode === mode) {
                    node.sendEventToAllNodes(eventname, params, mode);
                }
                continue;
            }

            if (!node[eventname] || node.mode !== mode) {
                continue;
            }
            if (params === undefined) {
                node[eventname]();
            } else if (params &amp;&amp; params.constructor === Array) {
                node[eventname](...params);
            } else {
                node[eventname](params);
            }
        }
    }

    sendActionToCanvas(action, params = []) {
        if (!this.list_of_graphcanvas) {
            return;
        }

        for (const c of this.list_of_graphcanvas) {
            if (c[action]) {
                c[action](...params);
            }
        }
    }

    /**
     * Adds a new node instance to this graph
     * @method add
     * @param {LGraphNode} node the instance of the node
     * @param {boolean} skipComputeOrder
     * @memberOf LGraph
     */

    add(node, skipComputeOrder) {
        if (!node) {
            return;
        }

        // groups
        if (node.constructor === LGraphGroup) {
            this._groups.push(node);
            this.setDirtyCanvas(true);
            this.change();
            node.graph = this;
            this._version++;
            return;
        }

        // nodes
        if (node.id !== -1 &amp;&amp; this._nodes_by_id[node.id]) {
            console.warn(
                "LiteGraph: there is already a node with this ID, changing it",
            );
            node.id = ++this.last_node_id;
        }

        if (this._nodes.length >= defaultConfig.MAX_NUMBER_OF_NODES) {
            throw new Error("LiteGraph: max number of nodes in a graph reached");
        }

        // give him an id
        if (!node.id || node.id === -1) {
            node.id = ++this.last_node_id;
        } else if (this.last_node_id &lt; node.id) {
            this.last_node_id = node.id;
        }

        node.graph = this;
        this._version++;

        this._nodes.push(node);
        this._nodes_by_id[node.id] = node;

        if (node.onAdded) node.onAdded(this);

        if (this.config.align_to_grid) node.alignToGrid();

        if (!skipComputeOrder) this.updateExecutionOrder();

        if (this.onNodeAdded) this.onNodeAdded(node);

        this.setDirtyCanvas(true);
        this.change();

        return node; // to chain actions
    }

    /**
     * Removes a node from the graph
     * @method remove
     * @param {LGraphNode} node the instance of the node
     * @memberOf LGraph
     */

    remove(node) {
        if (node.constructor.name === "LGraphGroup") {
            const index = this._groups.indexOf(node);
            if (index !== -1) {
                this._groups.splice(index, 1);
            }
            node.graph = null;
            this._version++;
            this.setDirtyCanvas(true, true);
            this.change();
            return;
        }

        if (this._nodes_by_id[node.id] == null) {
            return;
        } // not found

        if (node.ignore_remove) {
            return;
        } // cannot be removed

        this.beforeChange(); // sure?

        // disconnect inputs
        if (node.inputs) {
            for (let i = 0; i &lt; node.inputs.length; i++) {
                const slot = node.inputs[i];
                if (slot.link != null) {
                    node.disconnectInput(i);
                }
            }
        }

        // disconnect outputs
        if (node.outputs) {
            for (let i = 0; i &lt; node.outputs.length; i++) {
                const slot = node.outputs[i];
                if (slot.links != null &amp;&amp; slot.links.length) {
                    node.disconnectOutput(i);
                }
            }
        }

        // node.id = -1; //why?

        // callback
        if (node.onRemoved) {
            node.onRemoved();
        }

        node.graph = null;
        this._version++;

        // remove from canvas render
        if (this.list_of_graphcanvas) {
            for (const canvas of this.list_of_graphcanvas) {
                if (canvas.selected_nodes[node.id]) {
                    delete canvas.selected_nodes[node.id];
                }
                if (canvas.node_dragged === node) {
                    canvas.node_dragged = null;
                }
            }
        }

        // remove from containers
        if (this._nodes.includes(node)) {
            this._nodes = this._nodes.filter(n => n !== node);
        }
        delete this._nodes_by_id[node.id];

        if (this.onNodeRemoved) {
            this.onNodeRemoved(node);
        }

        // close panels
        this.sendActionToCanvas("checkPanels");

        this.setDirtyCanvas(true, true);
        this.afterChange(); // sure?
        this.change();

        this.updateExecutionOrder();
    }

    /**
     * Returns a node by its id.
     * @method getNodeById
     * @param {Number} id
     * @memberOf LGraph
     */

    getNodeById(id) {
        if (id == null) {
            return null;
        }
        return this._nodes_by_id[id];
    }

    /**
     * Returns a list of nodes that matches a class
     * @method findNodesByClass
     * @param {Class} classObject the class itself (not an string)
     * @param {Array} result
     * @return {Array} a list with all the nodes of this type
     * @memberOf LGraph
     */
    findNodesByClass(classObject, result = []) {
        result.length = 0;
        for (const node of this._nodes) {
            if (node.constructor === classObject) result.push(node);
        }
        return result;
    }

    /**
     * Returns a list of nodes that matches a type
     * @method findNodesByType
     * @param {String} type the name of the node type
     * @param {Array} result
     * @return {Array} a list with all the nodes of this type
     * @memberOf LGraph
     */
    findNodesByType(type, result = []) {
        type = type.toLowerCase();
        result = result || [];
        result.length = 0;
        for (const node of this._nodes) {
            if (node.type.toLowerCase() === type) result.push(node);
        }
        return result;
    }

    /**
     * Returns the first node that matches a name in its title
     * @method findNodeByTitle
     * @param {String} title the name of the node to search
     * @return {Node} the node or null
     * @memberOf LGraph
     */
    findNodeByTitle(title) {
        for (const node of this._nodes) {
            if (node.title === title) return node;
        }
        return null;
    }

    /**
     * Returns a list of nodes that matches a name
     * @method findNodesByTitle
     * @param {String} title the name of the node to search
     * @return {Array} a list with all the nodes with this name
     * @memberOf LGraph
     */
    findNodesByTitle(title) {
        const result = [];
        for (const node of this._nodes) {
            if (node.title === title) result.push(node);
        }
        return result;
    }

    /**
     * Returns the top-most node in this position of the canvas
     * @method getNodeOnPos
     * @param {number} x the x coordinate in canvas space
     * @param {number} y the y coordinate in canvas space
     * @param {Array} nodesList a list with all the nodes to search from, by default is all the
     *     nodes in the graph
     * @param {number} margin
     * @return {LGraphNode} the node at this position or null
     * @memberOf LGraph
     */
    getNodeOnPos(x, y, nodesList = this._nodes, margin) {
        for (const n of nodesList) {
            if (n.isPointInside(x, y, margin)) return n;
        }
        return null;
    }

    /**
     * Returns the top-most group in that position
     * @method getGroupOnPos
     * @param {number} x the x coordinate in canvas space
     * @param {number} y the y coordinate in canvas space
     * @return {LGraphGroup} the group or null
     * @memberOf LGraph
     */
    getGroupOnPos(x, y) {
        for (const g of this._groups) {
            if (g.isPointInside(x, y, 2, true)) return g;
        }
        return null;
    }

    /**
     * Checks that the node type matches the node type registered, used when replacing a nodetype
     * by a newer version during execution this replaces the ones using the old version with the
     * new version
     * @method checkNodeTypes
     * @memberOf LGraph
     */
    checkNodeTypes() {
        for (let node of this._nodes) {
            const ctor = defaultConfig.registered_node_types[node.type];
            if (node.constructor === ctor) {
                continue;
            }
            console.log(`node being replaced by newer version: ${node.type}`);
            const newnode = LGraphNode.createNode(node.type);
            node = newnode;
            newnode.configure(node.serialize());
            newnode.graph = this;
            this._nodes_by_id[newnode.id] = newnode;
            if (node.inputs) {
                newnode.inputs = node.inputs.concat();
            }
            if (node.outputs) {
                newnode.outputs = node.outputs.concat();
            }
        }
        this.updateExecutionOrder();
    }

    onAction(action, param) {
        this._input_nodes = this.findNodesByClass(
            LiteGraph.GraphInput,
            this._input_nodes,
        );
        for (const node of this._input_nodes) {
            if (node.properties.name !== action) {
                continue;
            }
            node.onAction(action, param);
            break;
        }
    }

    trigger(action, param) {
        if (this.onTrigger) {
            this.onTrigger(action, param);
        }
    }

    /**
     * Tell this graph it has a global graph input of this type
     * @method addGlobalInput
     * @param {String} name
     * @param {String} type
     * @param {*} value [optional]
     * @memberOf LGraph
     */
    addInput(name, type, value) {
        const input = this.inputs[name];
        if (input) {
            // already exist
            return;
        }

        this.beforeChange();
        this.inputs[name] = {
            name,
            type,
            value,
        };
        this._version++;
        this.afterChange();

        if (this.onInputAdded) {
            this.onInputAdded(name, type);
        }

        if (this.onInputsOutputsChange) {
            this.onInputsOutputsChange();
        }
    }

    /**
     * Assign a data to the global graph input
     * @method setGlobalInputData
     * @param {String} name
     * @param {*} data
     * @memberOf LGraph
     */
    setInputData(name, data) {
        const input = this.inputs[name];
        if (!input) {
            return;
        }
        input.value = data;
    }

    /**
     * Returns the current value of a global graph input
     * @method getInputData
     * @param {String} name
     * @return {*} the data
     * @memberOf LGraph
     */
    getInputData(name) {
        const input = this.inputs[name];
        if (!input) {
            return null;
        }
        return input.value;
    }

    /**
     * Changes the newName of a global graph input
     * @method renameInput
     * @param {String} oldName
     * @param {String} new_name
     * @memberOf LGraph
     */
    renameInput(oldName, newName) {
        if (newName === oldName) {
            return;
        }

        if (!this.inputs[oldName]) {
            return false;
        }

        if (this.inputs[newName]) {
            console.error("there is already one input with that newName");
            return false;
        }

        this.inputs[newName] = this.inputs[oldName];
        delete this.inputs[oldName];
        this._version++;

        if (this.onInputRenamed) {
            this.onInputRenamed(oldName, newName);
        }

        if (this.onInputsOutputsChange) {
            this.onInputsOutputsChange();
        }
    }

    /**
     * Changes the type of a global graph input
     * @method changeInputType
     * @param {String} name
     * @param {String} type
     * @memberOf LGraph
     */
    changeInputType(name, type) {
        if (!this.inputs[name]) {
            return false;
        }

        if (
            this.inputs[name].type
            &amp;&amp; String(this.inputs[name].type).toLowerCase()
            === String(type).toLowerCase()
        ) {
            return;
        }

        this.inputs[name].type = type;
        this._version++;
        if (this.onInputTypeChanged) {
            this.onInputTypeChanged(name, type);
        }
    }

    /**
     * Removes a global graph input
     * @method removeInput
     * @param {String} name
     * @memberOf LGraph
     */
    removeInput(name) {
        if (!this.inputs[name]) {
            return false;
        }

        delete this.inputs[name];
        this._version++;

        if (this.onInputRemoved) {
            this.onInputRemoved(name);
        }

        if (this.onInputsOutputsChange) {
            this.onInputsOutputsChange();
        }
        return true;
    }

    /**
     * Creates a global graph output
     * @method addOutput
     * @param {String} name
     * @param {String} type
     * @param {*} value
     * @memberOf LGraph
     */
    addOutput(name, type, value) {
        this.outputs[name] = {
            name,
            type,
            value,
        };
        this._version++;

        if (this.onOutputAdded) {
            this.onOutputAdded(name, type);
        }

        if (this.onInputsOutputsChange) {
            this.onInputsOutputsChange();
        }
    }

    /**
     * Assign a data to the global output
     * @method setOutputData
     * @param {String} name
     * @param {String} value
     * @memberOf LGraph
     */
    setOutputData(name, value) {
        const output = this.outputs[name];
        if (!output) {
            return;
        }
        output.value = value;
    }

    /**
     * Returns the current value of a global graph output
     * @method getOutputData
     * @param {String} name
     * @return {*} the data
     * @memberOf LGraph
     */
    getOutputData(name) {
        const output = this.outputs[name];
        if (!output) {
            return null;
        }
        return output.value;
    }

    /**
     * Renames a global graph output
     * @method renameOutput
     * @param {String} oldName
     * @param {String} newName
     * @memberOf LGraph
     */
    renameOutput(oldName, newName) {
        if (!this.outputs[oldName]) {
            return false;
        }

        if (this.outputs[newName]) {
            console.error("there is already one output with that newName");
            return false;
        }

        this.outputs[newName] = this.outputs[oldName];
        delete this.outputs[oldName];
        this._version++;

        if (this.onOutputRenamed) {
            this.onOutputRenamed(oldName, newName);
        }

        if (this.onInputsOutputsChange) {
            this.onInputsOutputsChange();
        }
    }

    /**
     * Changes the type of a global graph output
     * @method changeOutputType
     * @param {String} name
     * @param {String} type
     * @memberOf LGraph
     */
    changeOutputType(name, type) {
        if (!this.outputs[name]) {
            return false;
        }

        if (
            this.outputs[name].type
            &amp;&amp; String(this.outputs[name].type).toLowerCase()
            === String(type).toLowerCase()
        ) {
            return;
        }

        this.outputs[name].type = type;
        this._version++;
        if (this.onOutputTypeChanged) {
            this.onOutputTypeChanged(name, type);
        }
    }

    /**
     * Removes a global graph output
     * @method removeOutput
     * @param {String} name
     * @memberOf LGraph
     */
    removeOutput(name) {
        if (!this.outputs[name]) {
            return false;
        }
        delete this.outputs[name];
        this._version++;

        if (this.onOutputRemoved) {
            this.onOutputRemoved(name);
        }

        if (this.onInputsOutputsChange) {
            this.onInputsOutputsChange();
        }
        return true;
    }

    triggerInput(name, value) {
        const nodes = this.findNodesByTitle(name);
        for (let i = 0; i &lt; nodes.length; ++i) {
            nodes[i].onTrigger(value);
        }
    }

    setCallback(name, func) {
        const nodes = this.findNodesByTitle(name);
        for (let i = 0; i &lt; nodes.length; ++i) {
            nodes[i].setTrigger(func);
        }
    }

    // used for undo, called before any change is made to the graph
    beforeChange(info) {
        if (this.onBeforeChange) {
            this.onBeforeChange(this, info);
        }
        this.sendActionToCanvas("onBeforeChange", this);
    }

    // used to resend actions, called after any change is made to the graph
    afterChange(info) {
        if (this.onAfterChange) {
            this.onAfterChange(this, info);
        }
        this.sendActionToCanvas("onAfterChange", this);
    }

    connectionChange(node) {
        this.updateExecutionOrder();
        if (this.onConnectionChange) {
            this.onConnectionChange(node);
        }
        this._version++;
        this.sendActionToCanvas("onConnectionChange");
    }

    /**
     * returns if the graph is in live mode
     * @method isLive
     * @memberOf LGraph
     */

    isLive() {
        if (!this.list_of_graphcanvas) {
            return false;
        }

        for (let i = 0; i &lt; this.list_of_graphcanvas.length; ++i) {
            const c = this.list_of_graphcanvas[i];
            if (c.live_mode) {
                return true;
            }
        }
        return false;
    }

    /**
     * clears the triggered slot animation in all links (stop visual animation)
     * @method clearTriggeredSlots
     * @memberOf LGraph
     */
    clearTriggeredSlots() {
        // eslint-disable-next-line guard-for-in,no-restricted-syntax
        for (const i in this.links) {
            const linkInfo = this.links[i];
            if (!linkInfo) {
                continue;
            }
            if (linkInfo._last_time) {
                linkInfo._last_time = 0;
            }
        }
    }

    /* Called when something visually changed (not the graph!) */
    change() {
        if (defaultConfig.debug) {
            console.log("Graph changed");
        }
        this.sendActionToCanvas("setDirty", [true, true]);
        if (this.on_change) this.on_change(this);
    }

    setDirtyCanvas(fg, bg) {
        this.sendActionToCanvas("setDirty", [fg, bg]);
    }

    /**
     * Destroys a link
     * @method removeLink
     * @param {Number} linkId
     * @memberOf LGraph
     */
    removeLink(linkId) {
        const link = this.links[linkId];
        if (!link) {
            return;
        }
        const node = this.getNodeById(link.target_id);
        if (node) {
            node.disconnectInput(link.target_slot);
        }
    }

    // save and recover app state ***************************************
    /**
     * Creates a Object containing all the info about this graph, it can be serialized
     * @method serialize
     * @return {Object} value of the node
     * @memberOf LGraph
     */
    serialize() {
        const nodesInfo = [];
        for (const node of this._nodes) {
            nodesInfo.push(node.serialize());
        }

        // pack link info into a non-verbose format
        const links = [];
        // eslint-disable-next-line guard-for-in,no-restricted-syntax
        for (const i in this.links) {
            // links is an OBJECT
            let link = this.links[i];
            if (!link.serialize) {
                // weird bug I havent solved yet
                console.warn(
                    "weird LLink bug, link info is not a LLink but a regular object",
                );
                const link2 = new LLink();
                // eslint-disable-next-line guard-for-in,no-restricted-syntax
                for (const j in link) {
                    link2[j] = link[j];
                }
                this.links[i] = link2;
                link = link2;
            }

            links.push(link.serialize());
        }

        const groupsInfo = [];
        for (const group of this._groups) groupsInfo.push(group.serialize());

        const data = {
            last_node_id: this.last_node_id,
            last_link_id: this.last_link_id,
            nodes: nodesInfo,
            links,
            groups: groupsInfo,
            config: this.config,
            extra: this.extra,
            version: defaultConfig.VERSION,
        };

        if (this.onSerialize) this.onSerialize(data);

        return data;
    }

    /**
     * Configure a graph from a JSON string
     * @method configure
     * @param {String} str configure a graph from a JSON string
     * @param {Boolean} returns if there was any error parsing
     * @memberOf LGraph
     */
    configure(data, keepOld) {
        if (!data) {
            return;
        }

        if (!keepOld) this.clear();

        const { nodes } = data;

        // decode links info (they are very verbose)
        if (data.links &amp;&amp; data.links.constructor === Array) {
            const links = [];
            for (const linkData of data.links) {
                if (!linkData) {
                    console.warn("serialized graph link data contains errors, skipping.");
                    continue;
                }
                const link = new LLink();
                link.configure(linkData);
                links[link.id] = link;
            }
            data.links = links;
        }

        // copy all stored fields
        // eslint-disable-next-line guard-for-in,no-restricted-syntax
        for (const i in data) {
            if (i === "nodes" || i === "groups") {
                continue;
            }
            this[i] = data[i];
        }

        let error = false;

        // create nodes
        this._nodes = [];
        if (nodes) {
            for (const nInfo of nodes) {
                let node = LGraphNode.createNode(nInfo.type, nInfo.title);
                if (!node) {
                    if (defaultConfig.debug) {
                        console.log(
                            `Node not found or has errors: ${nInfo.type}`,
                        );
                    }

                    // in case of error we create a replacement node to avoid losing info
                    node = new LGraphNode();
                    node.last_serialization = nInfo;
                    node.has_errors = true;
                    error = true;
                    // continue;
                }

                node.id = nInfo.id; // id it or it will create a new id
                this.add(node, true); // add before configure, otherwise configure cannot create
                // links
            }

            // configure nodes afterwards so they can reach each other
            for (const nInfo of nodes) {
                const node = this.getNodeById(nInfo.id);
                if (node) {
                    node.configure(nInfo);
                }
            }
        }

        // groups
        this._groups.length = 0;
        if (data.groups) {
            for (const dataGroup of data.groups) {
                const group = new LGraphGroup();
                group.configure(dataGroup);
                this.add(group);
            }
        }

        this.updateExecutionOrder();

        this.extra = data.extra || {};

        if (this.onConfigure) this.onConfigure(data);

        this._version++;
        this.setDirtyCanvas(true, true);
        return error;
    }

    load(url, callback) {
        const that = this;

        // from file
        if (url.constructor === File || url.constructor === Blob) {
            const reader = new FileReader();
            reader.addEventListener("load", (event) => {
                const data = JSON.parse(event.target.result);
                that.configure(data);
                if (callback) callback();
            });

            reader.readAsText(url);
            return;
        }

        // is a string, then an URL
        const req = new XMLHttpRequest();
        req.open("GET", url, true);
        req.send(null);
        req.onload(() => {
            if (req.status !== 200) {
                console.error("Error loading graph:", req.status, req.response);
                return;
            }
            const data = JSON.parse(req.response);
            that.configure(data);
            if (callback) callback();
        });
        req.onerror((err) => {
            console.error("Error loading graph:", err);
        });
    }

    /**
     * Node event manager
     * @todo Need create event
     * @param node
     * @param msg
     * @param color
     * @memberOf LGraph
     */
    onNodeTrace(node, msg, color) {
        // TODO
    }
}
</code></pre>
        </article>
    </section>




</div>

<footer id="footer">
  
</footer>

<script src="scripts/third-party/prettify.js"></script>
<script src="scripts/third-party/lang-css.js"></script>
<script src="scripts/search.js"></script>
<script src="scripts/third-party/fuse.js"></script>
<script type="text/javascript" src="scripts/misc.js"></script>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
<script src="scripts/fix-code-block.js"></script>
<script>
  var list = [{"title":"ContextMenu","link":"<a href=\"ContextMenu.html\">ContextMenu</a>"},{"title":"CurveEditor","link":"<a href=\"CurveEditor.html\">CurveEditor</a>"},{"title":"DragAndScale","link":"<a href=\"DragAndScale.html\">DragAndScale</a>"},{"title":"Editor","link":"<a href=\"Editor.html\">Editor</a>"},{"title":"LGraph","link":"<a href=\"LGraph.html\">LGraph</a>"},{"title":"LGraph.add","link":"<a href=\"LGraph.html#.add\">LGraph.add &rtrif; undefined</a>"},{"title":"LGraph.addGlobalInput","link":"<a href=\"LGraph.html#.addGlobalInput\">LGraph.addGlobalInput &rtrif; undefined</a>"},{"title":"LGraph.addOutput","link":"<a href=\"LGraph.html#.addOutput\">LGraph.addOutput &rtrif; undefined</a>"},{"title":"LGraph.arrange","link":"<a href=\"LGraph.html#.arrange\">LGraph.arrange &rtrif; undefined</a>"},{"title":"LGraph.attachCanvas","link":"<a href=\"LGraph.html#.attachCanvas\">LGraph.attachCanvas &rtrif; undefined</a>"},{"title":"LGraph.changeInputType","link":"<a href=\"LGraph.html#.changeInputType\">LGraph.changeInputType &rtrif; undefined</a>"},{"title":"LGraph.changeOutputType","link":"<a href=\"LGraph.html#.changeOutputType\">LGraph.changeOutputType &rtrif; undefined</a>"},{"title":"LGraph.checkNodeTypes","link":"<a href=\"LGraph.html#.checkNodeTypes\">LGraph.checkNodeTypes &rtrif; undefined</a>"},{"title":"LGraph.clear","link":"<a href=\"LGraph.html#.clear\">LGraph.clear &rtrif; undefined</a>"},{"title":"LGraph.clearTriggeredSlots","link":"<a href=\"LGraph.html#.clearTriggeredSlots\">LGraph.clearTriggeredSlots &rtrif; undefined</a>"},{"title":"LGraph.configure","link":"<a href=\"LGraph.html#.configure\">LGraph.configure &rtrif; undefined</a>"},{"title":"LGraph.detachCanvas","link":"<a href=\"LGraph.html#.detachCanvas\">LGraph.detachCanvas &rtrif; undefined</a>"},{"title":"LGraph.findNodeByTitle","link":"<a href=\"LGraph.html#.findNodeByTitle\">LGraph.findNodeByTitle &rtrif; undefined</a>"},{"title":"LGraph.findNodesByClass","link":"<a href=\"LGraph.html#.findNodesByClass\">LGraph.findNodesByClass &rtrif; undefined</a>"},{"title":"LGraph.findNodesByTitle","link":"<a href=\"LGraph.html#.findNodesByTitle\">LGraph.findNodesByTitle &rtrif; undefined</a>"},{"title":"LGraph.findNodesByType","link":"<a href=\"LGraph.html#.findNodesByType\">LGraph.findNodesByType &rtrif; undefined</a>"},{"title":"LGraph.getAncestors","link":"<a href=\"LGraph.html#.getAncestors\">LGraph.getAncestors &rtrif; undefined</a>"},{"title":"LGraph.getElapsedTime","link":"<a href=\"LGraph.html#.getElapsedTime\">LGraph.getElapsedTime &rtrif; undefined</a>"},{"title":"LGraph.getFixedTime","link":"<a href=\"LGraph.html#.getFixedTime\">LGraph.getFixedTime &rtrif; undefined</a>"},{"title":"LGraph.getGroupOnPos","link":"<a href=\"LGraph.html#.getGroupOnPos\">LGraph.getGroupOnPos &rtrif; undefined</a>"},{"title":"LGraph.getInputData","link":"<a href=\"LGraph.html#.getInputData\">LGraph.getInputData &rtrif; undefined</a>"},{"title":"LGraph.getNodeById","link":"<a href=\"LGraph.html#.getNodeById\">LGraph.getNodeById &rtrif; undefined</a>"},{"title":"LGraph.getNodeOnPos","link":"<a href=\"LGraph.html#.getNodeOnPos\">LGraph.getNodeOnPos &rtrif; undefined</a>"},{"title":"LGraph.getOutputData","link":"<a href=\"LGraph.html#.getOutputData\">LGraph.getOutputData &rtrif; undefined</a>"},{"title":"LGraph.getTime","link":"<a href=\"LGraph.html#.getTime\">LGraph.getTime &rtrif; undefined</a>"},{"title":"LGraph.isLive","link":"<a href=\"LGraph.html#.isLive\">LGraph.isLive &rtrif; undefined</a>"},{"title":"LGraph.remove","link":"<a href=\"LGraph.html#.remove\">LGraph.remove &rtrif; undefined</a>"},{"title":"LGraph.removeInput","link":"<a href=\"LGraph.html#.removeInput\">LGraph.removeInput &rtrif; undefined</a>"},{"title":"LGraph.removeLink","link":"<a href=\"LGraph.html#.removeLink\">LGraph.removeLink &rtrif; undefined</a>"},{"title":"LGraph.removeOutput","link":"<a href=\"LGraph.html#.removeOutput\">LGraph.removeOutput &rtrif; undefined</a>"},{"title":"LGraph.renameInput","link":"<a href=\"LGraph.html#.renameInput\">LGraph.renameInput &rtrif; undefined</a>"},{"title":"LGraph.renameOutput","link":"<a href=\"LGraph.html#.renameOutput\">LGraph.renameOutput &rtrif; undefined</a>"},{"title":"LGraph.runStep","link":"<a href=\"LGraph.html#.runStep\">LGraph.runStep &rtrif; undefined</a>"},{"title":"LGraph.sendEventToAllNodes","link":"<a href=\"LGraph.html#.sendEventToAllNodes\">LGraph.sendEventToAllNodes &rtrif; undefined</a>"},{"title":"LGraph.serialize","link":"<a href=\"LGraph.html#.serialize\">LGraph.serialize &rtrif; undefined</a>"},{"title":"LGraph.setGlobalInputData","link":"<a href=\"LGraph.html#.setGlobalInputData\">LGraph.setGlobalInputData &rtrif; undefined</a>"},{"title":"LGraph.setOutputData","link":"<a href=\"LGraph.html#.setOutputData\">LGraph.setOutputData &rtrif; undefined</a>"},{"title":"LGraph.start","link":"<a href=\"LGraph.html#.start\">LGraph.start &rtrif; undefined</a>"},{"title":"LGraph.stop execution","link":"<a href=\"LGraph.html#.stopexecution\">LGraph.stop execution &rtrif; undefined</a>"},{"title":"LGraph.updateExecutionOrder","link":"<a href=\"LGraph.html#.updateExecutionOrder\">LGraph.updateExecutionOrder &rtrif; undefined</a>"},{"title":"LGraph#computeExecutionOrder","link":"<a href=\"LGraph.html#computeExecutionOrder\">LGraph &rtrif; computeExecutionOrder</a>"},{"title":"LGraph#onNodeTrace","link":"<a href=\"LGraph.html#onNodeTrace\">LGraph &rtrif; onNodeTrace</a>"},{"title":"LGraphCanvas","link":"<a href=\"LGraphCanvas.html\">LGraphCanvas</a>"},{"title":"LGraphCanvas.adjustMouseEvent","link":"<a href=\"LGraphCanvas.html#.adjustMouseEvent\">LGraphCanvas.adjustMouseEvent &rtrif; undefined</a>"},{"title":"LGraphCanvas.bindEvents","link":"<a href=\"LGraphCanvas.html#.bindEvents\">LGraphCanvas.bindEvents &rtrif; undefined</a>"},{"title":"LGraphCanvas.blockClick","link":"<a href=\"LGraphCanvas.html#.blockClick\">LGraphCanvas.blockClick &rtrif; undefined</a>"},{"title":"LGraphCanvas.bringToFront","link":"<a href=\"LGraphCanvas.html#.bringToFront\">LGraphCanvas.bringToFront &rtrif; undefined</a>"},{"title":"LGraphCanvas.centerOnNode","link":"<a href=\"LGraphCanvas.html#.centerOnNode\">LGraphCanvas.centerOnNode &rtrif; undefined</a>"},{"title":"LGraphCanvas.clear","link":"<a href=\"LGraphCanvas.html#.clear\">LGraphCanvas.clear &rtrif; undefined</a>"},{"title":"LGraphCanvas.closeSubgraph","link":"<a href=\"LGraphCanvas.html#.closeSubgraph\">LGraphCanvas.closeSubgraph &rtrif; undefined</a>"},{"title":"LGraphCanvas.computeConnectionPoint","link":"<a href=\"LGraphCanvas.html#.computeConnectionPoint\">LGraphCanvas.computeConnectionPoint &rtrif; undefined</a>"},{"title":"LGraphCanvas.computeVisibleNodes","link":"<a href=\"LGraphCanvas.html#.computeVisibleNodes\">LGraphCanvas.computeVisibleNodes &rtrif; undefined</a>"},{"title":"LGraphCanvas.convertCanvasToOffset","link":"<a href=\"LGraphCanvas.html#.convertCanvasToOffset\">LGraphCanvas.convertCanvasToOffset &rtrif; undefined</a>"},{"title":"LGraphCanvas.convertEventToCanvasOffset","link":"<a href=\"LGraphCanvas.html#.convertEventToCanvasOffset\">LGraphCanvas.convertEventToCanvasOffset &rtrif; undefined</a>"},{"title":"LGraphCanvas.convertOffsetToCanvas","link":"<a href=\"LGraphCanvas.html#.convertOffsetToCanvas\">LGraphCanvas.convertOffsetToCanvas &rtrif; undefined</a>"},{"title":"LGraphCanvas.deleteSelectedNodes","link":"<a href=\"LGraphCanvas.html#.deleteSelectedNodes\">LGraphCanvas.deleteSelectedNodes &rtrif; undefined</a>"},{"title":"LGraphCanvas.deselectAllNodes","link":"<a href=\"LGraphCanvas.html#.deselectAllNodes\">LGraphCanvas.deselectAllNodes &rtrif; undefined</a>"},{"title":"LGraphCanvas.deselectNode","link":"<a href=\"LGraphCanvas.html#.deselectNode\">LGraphCanvas.deselectNode &rtrif; undefined</a>"},{"title":"LGraphCanvas.draw","link":"<a href=\"LGraphCanvas.html#.draw\">LGraphCanvas.draw &rtrif; undefined</a>"},{"title":"LGraphCanvas.drawBackCanvas","link":"<a href=\"LGraphCanvas.html#.drawBackCanvas\">LGraphCanvas.drawBackCanvas &rtrif; undefined</a>"},{"title":"LGraphCanvas.drawButton","link":"<a href=\"LGraphCanvas.html#.drawButton\">LGraphCanvas.drawButton &rtrif; undefined</a>"},{"title":"LGraphCanvas.drawConnections","link":"<a href=\"LGraphCanvas.html#.drawConnections\">LGraphCanvas.drawConnections &rtrif; undefined</a>"},{"title":"LGraphCanvas.drawFrontCanvas","link":"<a href=\"LGraphCanvas.html#.drawFrontCanvas\">LGraphCanvas.drawFrontCanvas &rtrif; undefined</a>"},{"title":"LGraphCanvas.drawGroups","link":"<a href=\"LGraphCanvas.html#.drawGroups\">LGraphCanvas.drawGroups &rtrif; undefined</a>"},{"title":"LGraphCanvas.drawNode","link":"<a href=\"LGraphCanvas.html#.drawNode\">LGraphCanvas.drawNode &rtrif; undefined</a>"},{"title":"LGraphCanvas.drawNodeShape","link":"<a href=\"LGraphCanvas.html#.drawNodeShape\">LGraphCanvas.drawNodeShape &rtrif; undefined</a>"},{"title":"LGraphCanvas.drawNodeWidgets","link":"<a href=\"LGraphCanvas.html#.drawNodeWidgets\">LGraphCanvas.drawNodeWidgets &rtrif; undefined</a>"},{"title":"LGraphCanvas.drawSubgraphPanel","link":"<a href=\"LGraphCanvas.html#.drawSubgraphPanel\">LGraphCanvas.drawSubgraphPanel &rtrif; undefined</a>"},{"title":"LGraphCanvas.enableWebGL","link":"<a href=\"LGraphCanvas.html#.enableWebGL\">LGraphCanvas.enableWebGL &rtrif; undefined</a>"},{"title":"LGraphCanvas.getCanvasWindow","link":"<a href=\"LGraphCanvas.html#.getCanvasWindow\">LGraphCanvas.getCanvasWindow &rtrif; undefined</a>"},{"title":"LGraphCanvas.getCurrentGraph","link":"<a href=\"LGraphCanvas.html#.getCurrentGraph\">LGraphCanvas.getCurrentGraph &rtrif; undefined</a>"},{"title":"LGraphCanvas.getTopGraph","link":"<a href=\"LGraphCanvas.html#.getTopGraph\">LGraphCanvas.getTopGraph &rtrif; undefined</a>"},{"title":"LGraphCanvas.isOverNodeBox","link":"<a href=\"LGraphCanvas.html#.isOverNodeBox\">LGraphCanvas.isOverNodeBox &rtrif; undefined</a>"},{"title":"LGraphCanvas.isOverNodeInput","link":"<a href=\"LGraphCanvas.html#.isOverNodeInput\">LGraphCanvas.isOverNodeInput &rtrif; undefined</a>"},{"title":"LGraphCanvas.onGroupAdd","link":"<a href=\"LGraphCanvas.html#.onGroupAdd\">LGraphCanvas.onGroupAdd &rtrif; undefined</a>"},{"title":"LGraphCanvas.onMenuCollapseAll","link":"<a href=\"LGraphCanvas.html#.onMenuCollapseAll\">LGraphCanvas.onMenuCollapseAll &rtrif; undefined</a>"},{"title":"LGraphCanvas.onMenuNodeEdit","link":"<a href=\"LGraphCanvas.html#.onMenuNodeEdit\">LGraphCanvas.onMenuNodeEdit &rtrif; undefined</a>"},{"title":"LGraphCanvas.onNodeSelectionChange","link":"<a href=\"LGraphCanvas.html#.onNodeSelectionChange\">LGraphCanvas.onNodeSelectionChange &rtrif; undefined</a>"},{"title":"LGraphCanvas.openSubgraph","link":"<a href=\"LGraphCanvas.html#.openSubgraph\">LGraphCanvas.openSubgraph &rtrif; undefined</a>"},{"title":"LGraphCanvas.processDrop","link":"<a href=\"LGraphCanvas.html#.processDrop\">LGraphCanvas.processDrop &rtrif; undefined</a>"},{"title":"LGraphCanvas.processKey","link":"<a href=\"LGraphCanvas.html#.processKey\">LGraphCanvas.processKey &rtrif; undefined</a>"},{"title":"LGraphCanvas.processMouseMove","link":"<a href=\"LGraphCanvas.html#.processMouseMove\">LGraphCanvas.processMouseMove &rtrif; undefined</a>"},{"title":"LGraphCanvas.processMouseUp","link":"<a href=\"LGraphCanvas.html#.processMouseUp\">LGraphCanvas.processMouseUp &rtrif; undefined</a>"},{"title":"LGraphCanvas.processMouseWheel","link":"<a href=\"LGraphCanvas.html#.processMouseWheel\">LGraphCanvas.processMouseWheel &rtrif; undefined</a>"},{"title":"LGraphCanvas.processNodeWidgets","link":"<a href=\"LGraphCanvas.html#.processNodeWidgets\">LGraphCanvas.processNodeWidgets &rtrif; undefined</a>"},{"title":"LGraphCanvas.renderFrame","link":"<a href=\"LGraphCanvas.html#.renderFrame\">LGraphCanvas.renderFrame &rtrif; undefined</a>"},{"title":"LGraphCanvas.renderInfo","link":"<a href=\"LGraphCanvas.html#.renderInfo\">LGraphCanvas.renderInfo &rtrif; undefined</a>"},{"title":"LGraphCanvas.renderLink","link":"<a href=\"LGraphCanvas.html#.renderLink\">LGraphCanvas.renderLink &rtrif; undefined</a>"},{"title":"LGraphCanvas.resize","link":"<a href=\"LGraphCanvas.html#.resize\">LGraphCanvas.resize &rtrif; undefined</a>"},{"title":"LGraphCanvas.selectNode","link":"<a href=\"LGraphCanvas.html#.selectNode\">LGraphCanvas.selectNode &rtrif; undefined</a>"},{"title":"LGraphCanvas.selectNodes","link":"<a href=\"LGraphCanvas.html#.selectNodes\">LGraphCanvas.selectNodes &rtrif; undefined</a>"},{"title":"LGraphCanvas.sendToBack","link":"<a href=\"LGraphCanvas.html#.sendToBack\">LGraphCanvas.sendToBack &rtrif; undefined</a>"},{"title":"LGraphCanvas.setCanvas","link":"<a href=\"LGraphCanvas.html#.setCanvas\">LGraphCanvas.setCanvas &rtrif; undefined</a>"},{"title":"LGraphCanvas.setDirty","link":"<a href=\"LGraphCanvas.html#.setDirty\">LGraphCanvas.setDirty &rtrif; undefined</a>"},{"title":"LGraphCanvas.setGraph","link":"<a href=\"LGraphCanvas.html#.setGraph\">LGraphCanvas.setGraph &rtrif; undefined</a>"},{"title":"LGraphCanvas.setZoom","link":"<a href=\"LGraphCanvas.html#.setZoom\">LGraphCanvas.setZoom &rtrif; undefined</a>"},{"title":"LGraphCanvas.startRendering","link":"<a href=\"LGraphCanvas.html#.startRendering\">LGraphCanvas.startRendering &rtrif; undefined</a>"},{"title":"LGraphCanvas.stopRendering","link":"<a href=\"LGraphCanvas.html#.stopRendering\">LGraphCanvas.stopRendering &rtrif; undefined</a>"},{"title":"LGraphCanvas.switchLiveMode","link":"<a href=\"LGraphCanvas.html#.switchLiveMode\">LGraphCanvas.switchLiveMode &rtrif; undefined</a>"},{"title":"LGraphCanvas.touchHandler","link":"<a href=\"LGraphCanvas.html#.touchHandler\">LGraphCanvas.touchHandler &rtrif; undefined</a>"},{"title":"LGraphCanvas.unbindEvents","link":"<a href=\"LGraphCanvas.html#.unbindEvents\">LGraphCanvas.unbindEvents &rtrif; undefined</a>"},{"title":"LGraphGroup","link":"<a href=\"LGraphGroup.html\">LGraphGroup</a>"},{"title":"LGraphNode","link":"<a href=\"LGraphNode.html\">LGraphNode</a>"},{"title":"LGraphNode.addConnection","link":"<a href=\"LGraphNode.html#.addConnection\">LGraphNode.addConnection &rtrif; undefined</a>"},{"title":"LGraphNode.addInput","link":"<a href=\"LGraphNode.html#.addInput\">LGraphNode.addInput &rtrif; undefined</a>"},{"title":"LGraphNode.addInputs","link":"<a href=\"LGraphNode.html#.addInputs\">LGraphNode.addInputs &rtrif; undefined</a>"},{"title":"LGraphNode.addNodeMethod","link":"<a href=\"LGraphNode.html#.addNodeMethod\">LGraphNode.addNodeMethod &rtrif; undefined</a>"},{"title":"LGraphNode.addOutput","link":"<a href=\"LGraphNode.html#.addOutput\">LGraphNode.addOutput &rtrif; undefined</a>"},{"title":"LGraphNode.addOutputs","link":"<a href=\"LGraphNode.html#.addOutputs\">LGraphNode.addOutputs &rtrif; undefined</a>"},{"title":"LGraphNode.addProperty","link":"<a href=\"LGraphNode.html#.addProperty\">LGraphNode.addProperty &rtrif; undefined</a>"},{"title":"LGraphNode.addWidget","link":"<a href=\"LGraphNode.html#.addWidget\">LGraphNode.addWidget &rtrif; undefined</a>"},{"title":"LGraphNode.clearTriggeredSlot","link":"<a href=\"LGraphNode.html#.clearTriggeredSlot\">LGraphNode.clearTriggeredSlot &rtrif; undefined</a>"},{"title":"LGraphNode.collapse","link":"<a href=\"LGraphNode.html#.collapse\">LGraphNode.collapse &rtrif; undefined</a>"},{"title":"LGraphNode.computeSize","link":"<a href=\"LGraphNode.html#.computeSize\">LGraphNode.computeSize &rtrif; undefined</a>"},{"title":"LGraphNode.configure","link":"<a href=\"LGraphNode.html#.configure\">LGraphNode.configure &rtrif; undefined</a>"},{"title":"LGraphNode.connect","link":"<a href=\"LGraphNode.html#.connect\">LGraphNode.connect &rtrif; undefined</a>"},{"title":"LGraphNode.createNode","link":"<a href=\"LGraphNode.html#.createNode\">LGraphNode.createNode &rtrif; undefined</a>"},{"title":"LGraphNode.disconnectInput","link":"<a href=\"LGraphNode.html#.disconnectInput\">LGraphNode.disconnectInput &rtrif; undefined</a>"},{"title":"LGraphNode.disconnectOutput","link":"<a href=\"LGraphNode.html#.disconnectOutput\">LGraphNode.disconnectOutput &rtrif; undefined</a>"},{"title":"LGraphNode.findInputSlot","link":"<a href=\"LGraphNode.html#.findInputSlot\">LGraphNode.findInputSlot &rtrif; undefined</a>"},{"title":"LGraphNode.findOutputSlot","link":"<a href=\"LGraphNode.html#.findOutputSlot\">LGraphNode.findOutputSlot &rtrif; undefined</a>"},{"title":"LGraphNode.getBounding","link":"<a href=\"LGraphNode.html#.getBounding\">LGraphNode.getBounding &rtrif; undefined</a>"},{"title":"LGraphNode.getConnectionPos","link":"<a href=\"LGraphNode.html#.getConnectionPos\">LGraphNode.getConnectionPos &rtrif; undefined</a>"},{"title":"LGraphNode.getInputData","link":"<a href=\"LGraphNode.html#.getInputData\">LGraphNode.getInputData &rtrif; undefined</a>"},{"title":"LGraphNode.getInputDataByName","link":"<a href=\"LGraphNode.html#.getInputDataByName\">LGraphNode.getInputDataByName &rtrif; undefined</a>"},{"title":"LGraphNode.getInputDataType","link":"<a href=\"LGraphNode.html#.getInputDataType\">LGraphNode.getInputDataType &rtrif; undefined</a>"},{"title":"LGraphNode.getInputInfo","link":"<a href=\"LGraphNode.html#.getInputInfo\">LGraphNode.getInputInfo &rtrif; undefined</a>"},{"title":"LGraphNode.getInputLink","link":"<a href=\"LGraphNode.html#.getInputLink\">LGraphNode.getInputLink &rtrif; undefined</a>"},{"title":"LGraphNode.getInputNode","link":"<a href=\"LGraphNode.html#.getInputNode\">LGraphNode.getInputNode &rtrif; undefined</a>"},{"title":"LGraphNode.getInputOrProperty","link":"<a href=\"LGraphNode.html#.getInputOrProperty\">LGraphNode.getInputOrProperty &rtrif; undefined</a>"},{"title":"LGraphNode.getOutputData","link":"<a href=\"LGraphNode.html#.getOutputData\">LGraphNode.getOutputData &rtrif; undefined</a>"},{"title":"LGraphNode.getOutputInfo","link":"<a href=\"LGraphNode.html#.getOutputInfo\">LGraphNode.getOutputInfo &rtrif; undefined</a>"},{"title":"LGraphNode.getOutputNodes","link":"<a href=\"LGraphNode.html#.getOutputNodes\">LGraphNode.getOutputNodes &rtrif; undefined</a>"},{"title":"LGraphNode.getPropertyInfo","link":"<a href=\"LGraphNode.html#.getPropertyInfo\">LGraphNode.getPropertyInfo &rtrif; undefined</a>"},{"title":"LGraphNode.getSlotInPosition","link":"<a href=\"LGraphNode.html#.getSlotInPosition\">LGraphNode.getSlotInPosition &rtrif; undefined</a>"},{"title":"LGraphNode.getTitle","link":"<a href=\"LGraphNode.html#.getTitle\">LGraphNode.getTitle &rtrif; undefined</a>"},{"title":"LGraphNode.isAnyOutputConnected","link":"<a href=\"LGraphNode.html#.isAnyOutputConnected\">LGraphNode.isAnyOutputConnected &rtrif; undefined</a>"},{"title":"LGraphNode.isInputConnected","link":"<a href=\"LGraphNode.html#.isInputConnected\">LGraphNode.isInputConnected &rtrif; undefined</a>"},{"title":"LGraphNode.isOutputConnected","link":"<a href=\"LGraphNode.html#.isOutputConnected\">LGraphNode.isOutputConnected &rtrif; undefined</a>"},{"title":"LGraphNode.isPointInside","link":"<a href=\"LGraphNode.html#.isPointInside\">LGraphNode.isPointInside &rtrif; undefined</a>"},{"title":"LGraphNode.pin","link":"<a href=\"LGraphNode.html#.pin\">LGraphNode.pin &rtrif; undefined</a>"},{"title":"LGraphNode.removeInput","link":"<a href=\"LGraphNode.html#.removeInput\">LGraphNode.removeInput &rtrif; undefined</a>"},{"title":"LGraphNode.removeOutput","link":"<a href=\"LGraphNode.html#.removeOutput\">LGraphNode.removeOutput &rtrif; undefined</a>"},{"title":"LGraphNode.serialize","link":"<a href=\"LGraphNode.html#.serialize\">LGraphNode.serialize &rtrif; undefined</a>"},{"title":"LGraphNode.setOutputData","link":"<a href=\"LGraphNode.html#.setOutputData\">LGraphNode.setOutputData &rtrif; undefined</a>"},{"title":"LGraphNode.setOutputDataType","link":"<a href=\"LGraphNode.html#.setOutputDataType\">LGraphNode.setOutputDataType &rtrif; undefined</a>"},{"title":"LGraphNode.setProperty","link":"<a href=\"LGraphNode.html#.setProperty\">LGraphNode.setProperty &rtrif; undefined</a>"},{"title":"LGraphNode.setSize","link":"<a href=\"LGraphNode.html#.setSize\">LGraphNode.setSize &rtrif; undefined</a>"},{"title":"LGraphNode.toString","link":"<a href=\"LGraphNode.html#.toString\">LGraphNode.toString &rtrif; undefined</a>"},{"title":"LGraphNode.trigger","link":"<a href=\"LGraphNode.html#.trigger\">LGraphNode.trigger &rtrif; undefined</a>"},{"title":"LGraphNode.triggerSlot","link":"<a href=\"LGraphNode.html#.triggerSlot\">LGraphNode.triggerSlot &rtrif; undefined</a>"},{"title":"LLink","link":"<a href=\"LLink.html\">LLink</a>"},{"title":"File Utils","link":"<a href=\"module-File%2520Utils.html\">File Utils</a>"},{"title":"module:File Utils~fetchFile","link":"<a href=\"module-File%252520Utils.html#~fetchFile\">module:File Utils~fetchFile &rtrif; undefined</a>"},{"title":"Function Utils","link":"<a href=\"module-Function%2520Utils.html\">Function Utils</a>"},{"title":"module:Function Utils~isValidConnection","link":"<a href=\"module-Function%252520Utils.html#~isValidConnection\">module:Function Utils~isValidConnection &rtrif; undefined</a>"},{"title":"module:Function Utils~wrapFunctionAsNode","link":"<a href=\"module-Function%252520Utils.html#~wrapFunctionAsNode\">module:Function Utils~wrapFunctionAsNode &rtrif; undefined</a>"},{"title":"Math Utils","link":"<a href=\"module-Math%2520Utils.html\">Math Utils</a>"},{"title":"Object Utils","link":"<a href=\"module-Object%2520Utils.html\">Object Utils</a>"},{"title":"Registry Manager","link":"<a href=\"module-Registry%2520Manager.html\">Registry Manager</a>"},{"title":"module:Registry Manager.clearRegisteredTypes","link":"<a href=\"module-Registry%252520Manager.html#.clearRegisteredTypes\">module:Registry Manager.clearRegisteredTypes &rtrif; undefined</a>"},{"title":"module:Registry Manager~getNodeType","link":"<a href=\"module-Registry%252520Manager.html#~getNodeType\">module:Registry Manager~getNodeType &rtrif; undefined</a>"},{"title":"module:Registry Manager~getNodeType","link":"<a href=\"module-Registry%252520Manager.html#~getNodeType\">module:Registry Manager~getNodeType &rtrif; undefined</a>"},{"title":"module:Registry Manager~getNodeTypesCategories","link":"<a href=\"module-Registry%252520Manager.html#~getNodeTypesCategories\">module:Registry Manager~getNodeTypesCategories &rtrif; undefined</a>"},{"title":"module:Registry Manager~registerNodeType","link":"<a href=\"module-Registry%252520Manager.html#~registerNodeType\">module:Registry Manager~registerNodeType &rtrif; undefined</a>"},{"title":"module:Registry Manager~registerSearchboxExtra","link":"<a href=\"module-Registry%252520Manager.html#~registerSearchboxExtra\">module:Registry Manager~registerSearchboxExtra &rtrif; undefined</a>"},{"title":"module:Registry Manager~unregisterNodeType","link":"<a href=\"module-Registry%252520Manager.html#~unregisterNodeType\">module:Registry Manager~unregisterNodeType &rtrif; undefined</a>"},{"title":"Time Utils","link":"<a href=\"module-Time%2520Utils.html\">Time Utils</a>"}];
  var options = 
  setupSearch(list, options)
</script>

 




  <script type="text/javascript">
    var option = JSON.parse('{"option":{}}')
    console.log(option)
    document.addEventListener("DOMContentLoaded", function() {
    OverlayScrollbars(document.querySelectorAll('body'), option.option || {});
  });
  </script>



</body>
</html>

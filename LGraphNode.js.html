<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Adding meta -->
    

    <!-- Adding external script-->
    

    <!-- Adding external style-->
    

    <!-- Adding scripts-->
    

    <!-- Adding style-->
    

    <!-- Adding overlay script-->
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/overlayscrollbars/1.13.0/js/OverlayScrollbars.min.js" integrity="sha512-5R3ngaUdvyhXkQkIqTf/k+Noq3phjmrqlUQyQYbgfI34Mzcx7vLIIYTy/K1VMHkL33T709kfh5y6R9Xy/Cbt7Q==" crossorigin="anonymous"></script>
    

    <!-- Adding overlay style-->
    


    <title>LGraphNode.js</title>

    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/third-party/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/third-party/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-base.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-dark.css">
    
<svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none">
    <defs>
        <symbol id="copy-icon" viewbox="0 0 488.3 488.3">
            <g>
                <path d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z"/>
                <path d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z"/>
            </g>
        </symbol>
    </defs>
</svg>

</head>
<body>
<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html"><div class="text">Home</div></a></h2><div class="search-box"><input type="text" placeholder="Search..." id="search-box" /><div class="search-item-container" id="search-item-container"><ul class="search-item-ul" id="search-item-ul"></ul></div></div><div class="sidebar-list-div"><ul><li><a href='https://paladium-pvp.fr/' class='' id='' target='_blank'>Paladium Website</a></li><li><a href='https://github.com/Paladium-Developpement/litegraph.js/' class='' id='' target='_blank'>Project GitHub</a></li></ul><h3>Classes</h3><ul><li class="" id=""><a href="ContextMenu.html">ContextMenu</a></li><li class="" id=""><a href="CurveEditor.html">CurveEditor</a></li><li class="" id=""><a href="DragAndScale.html">DragAndScale</a></li><li class="" id=""><a href="Editor.html">Editor</a></li><li class="accordion collapsed" id=909412><div class="accordion-title"><a href="LGraph.html">LGraph</a><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16">
    <path 
        fill-rule="evenodd" 
        clip-rule="evenodd" 
        d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z">
    </path>
</svg></div><ul class='methods accordion-content'><li data-type='method'><a href="LGraph.html#.add">add</a></li><li data-type='method'><a href="LGraph.html#.addGlobalInput">addGlobalInput</a></li><li data-type='method'><a href="LGraph.html#.addOutput">addOutput</a></li><li data-type='method'><a href="LGraph.html#.arrange">arrange</a></li><li data-type='method'><a href="LGraph.html#.attachCanvas">attachCanvas</a></li><li data-type='method'><a href="LGraph.html#.changeInputType">changeInputType</a></li><li data-type='method'><a href="LGraph.html#.changeOutputType">changeOutputType</a></li><li data-type='method'><a href="LGraph.html#.checkNodeTypes">checkNodeTypes</a></li><li data-type='method'><a href="LGraph.html#.clear">clear</a></li><li data-type='method'><a href="LGraph.html#.clearTriggeredSlots">clearTriggeredSlots</a></li><li data-type='method'><a href="LGraph.html#.configure">configure</a></li><li data-type='method'><a href="LGraph.html#.detachCanvas">detachCanvas</a></li><li data-type='method'><a href="LGraph.html#.findNodeByTitle">findNodeByTitle</a></li><li data-type='method'><a href="LGraph.html#.findNodesByClass">findNodesByClass</a></li><li data-type='method'><a href="LGraph.html#.findNodesByTitle">findNodesByTitle</a></li><li data-type='method'><a href="LGraph.html#.findNodesByType">findNodesByType</a></li><li data-type='method'><a href="LGraph.html#.getAncestors">getAncestors</a></li><li data-type='method'><a href="LGraph.html#.getElapsedTime">getElapsedTime</a></li><li data-type='method'><a href="LGraph.html#.getFixedTime">getFixedTime</a></li><li data-type='method'><a href="LGraph.html#.getGroupOnPos">getGroupOnPos</a></li><li data-type='method'><a href="LGraph.html#.getInputData">getInputData</a></li><li data-type='method'><a href="LGraph.html#.getNodeById">getNodeById</a></li><li data-type='method'><a href="LGraph.html#.getNodeOnPos">getNodeOnPos</a></li><li data-type='method'><a href="LGraph.html#.getOutputData">getOutputData</a></li><li data-type='method'><a href="LGraph.html#.getTime">getTime</a></li><li data-type='method'><a href="LGraph.html#.isLive">isLive</a></li><li data-type='method'><a href="LGraph.html#.remove">remove</a></li><li data-type='method'><a href="LGraph.html#.removeInput">removeInput</a></li><li data-type='method'><a href="LGraph.html#.removeLink">removeLink</a></li><li data-type='method'><a href="LGraph.html#.removeOutput">removeOutput</a></li><li data-type='method'><a href="LGraph.html#.renameInput">renameInput</a></li><li data-type='method'><a href="LGraph.html#.renameOutput">renameOutput</a></li><li data-type='method'><a href="LGraph.html#.runStep">runStep</a></li><li data-type='method'><a href="LGraph.html#.sendEventToAllNodes">sendEventToAllNodes</a></li><li data-type='method'><a href="LGraph.html#.serialize">serialize</a></li><li data-type='method'><a href="LGraph.html#.setGlobalInputData">setGlobalInputData</a></li><li data-type='method'><a href="LGraph.html#.setOutputData">setOutputData</a></li><li data-type='method'><a href="LGraph.html#.start">start</a></li><li data-type='method'><a href="LGraph.html#.stopexecution">stop execution</a></li><li data-type='method'><a href="LGraph.html#.updateExecutionOrder">updateExecutionOrder</a></li><li data-type='method'><a href="LGraph.html#computeExecutionOrder">computeExecutionOrder</a></li><li data-type='method'><a href="LGraph.html#onNodeTrace">onNodeTrace</a></li></ul></li><li class="accordion collapsed" id=1552559><div class="accordion-title"><a href="LGraphCanvas.html">LGraphCanvas</a><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16">
    <path 
        fill-rule="evenodd" 
        clip-rule="evenodd" 
        d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z">
    </path>
</svg></div><ul class='methods accordion-content'><li data-type='method'><a href="LGraphCanvas.html#.adjustMouseEvent">adjustMouseEvent</a></li><li data-type='method'><a href="LGraphCanvas.html#.bindEvents">bindEvents</a></li><li data-type='method'><a href="LGraphCanvas.html#.blockClick">blockClick</a></li><li data-type='method'><a href="LGraphCanvas.html#.bringToFront">bringToFront</a></li><li data-type='method'><a href="LGraphCanvas.html#.centerOnNode">centerOnNode</a></li><li data-type='method'><a href="LGraphCanvas.html#.clear">clear</a></li><li data-type='method'><a href="LGraphCanvas.html#.closeSubgraph">closeSubgraph</a></li><li data-type='method'><a href="LGraphCanvas.html#.computeConnectionPoint">computeConnectionPoint</a></li><li data-type='method'><a href="LGraphCanvas.html#.computeVisibleNodes">computeVisibleNodes</a></li><li data-type='method'><a href="LGraphCanvas.html#.convertCanvasToOffset">convertCanvasToOffset</a></li><li data-type='method'><a href="LGraphCanvas.html#.convertEventToCanvasOffset">convertEventToCanvasOffset</a></li><li data-type='method'><a href="LGraphCanvas.html#.convertOffsetToCanvas">convertOffsetToCanvas</a></li><li data-type='method'><a href="LGraphCanvas.html#.deleteSelectedNodes">deleteSelectedNodes</a></li><li data-type='method'><a href="LGraphCanvas.html#.deselectAllNodes">deselectAllNodes</a></li><li data-type='method'><a href="LGraphCanvas.html#.deselectNode">deselectNode</a></li><li data-type='method'><a href="LGraphCanvas.html#.draw">draw</a></li><li data-type='method'><a href="LGraphCanvas.html#.drawBackCanvas">drawBackCanvas</a></li><li data-type='method'><a href="LGraphCanvas.html#.drawButton">drawButton</a></li><li data-type='method'><a href="LGraphCanvas.html#.drawConnections">drawConnections</a></li><li data-type='method'><a href="LGraphCanvas.html#.drawFrontCanvas">drawFrontCanvas</a></li><li data-type='method'><a href="LGraphCanvas.html#.drawGroups">drawGroups</a></li><li data-type='method'><a href="LGraphCanvas.html#.drawNode">drawNode</a></li><li data-type='method'><a href="LGraphCanvas.html#.drawNodeShape">drawNodeShape</a></li><li data-type='method'><a href="LGraphCanvas.html#.drawNodeWidgets">drawNodeWidgets</a></li><li data-type='method'><a href="LGraphCanvas.html#.drawSubgraphPanel">drawSubgraphPanel</a></li><li data-type='method'><a href="LGraphCanvas.html#.enableWebGL">enableWebGL</a></li><li data-type='method'><a href="LGraphCanvas.html#.getCanvasWindow">getCanvasWindow</a></li><li data-type='method'><a href="LGraphCanvas.html#.getCurrentGraph">getCurrentGraph</a></li><li data-type='method'><a href="LGraphCanvas.html#.getTopGraph">getTopGraph</a></li><li data-type='method'><a href="LGraphCanvas.html#.isOverNodeBox">isOverNodeBox</a></li><li data-type='method'><a href="LGraphCanvas.html#.isOverNodeInput">isOverNodeInput</a></li><li data-type='method'><a href="LGraphCanvas.html#.onGroupAdd">onGroupAdd</a></li><li data-type='method'><a href="LGraphCanvas.html#.onMenuCollapseAll">onMenuCollapseAll</a></li><li data-type='method'><a href="LGraphCanvas.html#.onMenuNodeEdit">onMenuNodeEdit</a></li><li data-type='method'><a href="LGraphCanvas.html#.onNodeSelectionChange">onNodeSelectionChange</a></li><li data-type='method'><a href="LGraphCanvas.html#.openSubgraph">openSubgraph</a></li><li data-type='method'><a href="LGraphCanvas.html#.processDrop">processDrop</a></li><li data-type='method'><a href="LGraphCanvas.html#.processKey">processKey</a></li><li data-type='method'><a href="LGraphCanvas.html#.processMouseMove">processMouseMove</a></li><li data-type='method'><a href="LGraphCanvas.html#.processMouseUp">processMouseUp</a></li><li data-type='method'><a href="LGraphCanvas.html#.processMouseWheel">processMouseWheel</a></li><li data-type='method'><a href="LGraphCanvas.html#.processNodeWidgets">processNodeWidgets</a></li><li data-type='method'><a href="LGraphCanvas.html#.renderFrame">renderFrame</a></li><li data-type='method'><a href="LGraphCanvas.html#.renderInfo">renderInfo</a></li><li data-type='method'><a href="LGraphCanvas.html#.renderLink">renderLink</a></li><li data-type='method'><a href="LGraphCanvas.html#.resize">resize</a></li><li data-type='method'><a href="LGraphCanvas.html#.selectNode">selectNode</a></li><li data-type='method'><a href="LGraphCanvas.html#.selectNodes">selectNodes</a></li><li data-type='method'><a href="LGraphCanvas.html#.sendToBack">sendToBack</a></li><li data-type='method'><a href="LGraphCanvas.html#.setCanvas">setCanvas</a></li><li data-type='method'><a href="LGraphCanvas.html#.setDirty">setDirty</a></li><li data-type='method'><a href="LGraphCanvas.html#.setGraph">setGraph</a></li><li data-type='method'><a href="LGraphCanvas.html#.setZoom">setZoom</a></li><li data-type='method'><a href="LGraphCanvas.html#.startRendering">startRendering</a></li><li data-type='method'><a href="LGraphCanvas.html#.stopRendering">stopRendering</a></li><li data-type='method'><a href="LGraphCanvas.html#.switchLiveMode">switchLiveMode</a></li><li data-type='method'><a href="LGraphCanvas.html#.touchHandler">touchHandler</a></li><li data-type='method'><a href="LGraphCanvas.html#.unbindEvents">unbindEvents</a></li></ul></li><li class="" id=""><a href="LGraphGroup.html">LGraphGroup</a></li><li class="accordion collapsed" id=6900034><div class="accordion-title"><a href="LGraphNode.html">LGraphNode</a><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16">
    <path 
        fill-rule="evenodd" 
        clip-rule="evenodd" 
        d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z">
    </path>
</svg></div><ul class='methods accordion-content'><li data-type='method'><a href="LGraphNode.html#.addConnection">addConnection</a></li><li data-type='method'><a href="LGraphNode.html#.addInput">addInput</a></li><li data-type='method'><a href="LGraphNode.html#.addInputs">addInputs</a></li><li data-type='method'><a href="LGraphNode.html#.addNodeMethod">addNodeMethod</a></li><li data-type='method'><a href="LGraphNode.html#.addOutput">addOutput</a></li><li data-type='method'><a href="LGraphNode.html#.addOutputs">addOutputs</a></li><li data-type='method'><a href="LGraphNode.html#.addProperty">addProperty</a></li><li data-type='method'><a href="LGraphNode.html#.addWidget">addWidget</a></li><li data-type='method'><a href="LGraphNode.html#.clearTriggeredSlot">clearTriggeredSlot</a></li><li data-type='method'><a href="LGraphNode.html#.collapse">collapse</a></li><li data-type='method'><a href="LGraphNode.html#.computeSize">computeSize</a></li><li data-type='method'><a href="LGraphNode.html#.configure">configure</a></li><li data-type='method'><a href="LGraphNode.html#.connect">connect</a></li><li data-type='method'><a href="LGraphNode.html#.createNode">createNode</a></li><li data-type='method'><a href="LGraphNode.html#.disconnectInput">disconnectInput</a></li><li data-type='method'><a href="LGraphNode.html#.disconnectOutput">disconnectOutput</a></li><li data-type='method'><a href="LGraphNode.html#.findInputSlot">findInputSlot</a></li><li data-type='method'><a href="LGraphNode.html#.findOutputSlot">findOutputSlot</a></li><li data-type='method'><a href="LGraphNode.html#.getBounding">getBounding</a></li><li data-type='method'><a href="LGraphNode.html#.getConnectionPos">getConnectionPos</a></li><li data-type='method'><a href="LGraphNode.html#.getInputData">getInputData</a></li><li data-type='method'><a href="LGraphNode.html#.getInputDataByName">getInputDataByName</a></li><li data-type='method'><a href="LGraphNode.html#.getInputDataType">getInputDataType</a></li><li data-type='method'><a href="LGraphNode.html#.getInputInfo">getInputInfo</a></li><li data-type='method'><a href="LGraphNode.html#.getInputLink">getInputLink</a></li><li data-type='method'><a href="LGraphNode.html#.getInputNode">getInputNode</a></li><li data-type='method'><a href="LGraphNode.html#.getInputOrProperty">getInputOrProperty</a></li><li data-type='method'><a href="LGraphNode.html#.getOutputData">getOutputData</a></li><li data-type='method'><a href="LGraphNode.html#.getOutputInfo">getOutputInfo</a></li><li data-type='method'><a href="LGraphNode.html#.getOutputNodes">getOutputNodes</a></li><li data-type='method'><a href="LGraphNode.html#.getPropertyInfo">getPropertyInfo</a></li><li data-type='method'><a href="LGraphNode.html#.getSlotInPosition">getSlotInPosition</a></li><li data-type='method'><a href="LGraphNode.html#.getTitle">getTitle</a></li><li data-type='method'><a href="LGraphNode.html#.isAnyOutputConnected">isAnyOutputConnected</a></li><li data-type='method'><a href="LGraphNode.html#.isInputConnected">isInputConnected</a></li><li data-type='method'><a href="LGraphNode.html#.isOutputConnected">isOutputConnected</a></li><li data-type='method'><a href="LGraphNode.html#.isPointInside">isPointInside</a></li><li data-type='method'><a href="LGraphNode.html#.pin">pin</a></li><li data-type='method'><a href="LGraphNode.html#.removeInput">removeInput</a></li><li data-type='method'><a href="LGraphNode.html#.removeOutput">removeOutput</a></li><li data-type='method'><a href="LGraphNode.html#.serialize">serialize</a></li><li data-type='method'><a href="LGraphNode.html#.setOutputData">setOutputData</a></li><li data-type='method'><a href="LGraphNode.html#.setOutputDataType">setOutputDataType</a></li><li data-type='method'><a href="LGraphNode.html#.setProperty">setProperty</a></li><li data-type='method'><a href="LGraphNode.html#.setSize">setSize</a></li><li data-type='method'><a href="LGraphNode.html#.toString">toString</a></li><li data-type='method'><a href="LGraphNode.html#.trigger">trigger</a></li><li data-type='method'><a href="LGraphNode.html#.triggerSlot">triggerSlot</a></li></ul></li><li class="" id=""><a href="LLink.html">LLink</a></li></ul><h3>Modules</h3><ul><li class="accordion collapsed" id=155646><div class="accordion-title"><a href="module-File%2520Utils.html">File Utils</a><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16">
    <path 
        fill-rule="evenodd" 
        clip-rule="evenodd" 
        d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z">
    </path>
</svg></div><ul class='methods accordion-content'><li data-type='method'><a href="module-File%252520Utils.html#~fetchFile">fetchFile</a></li></ul></li><li class="accordion collapsed" id=8866743><div class="accordion-title"><a href="module-Function%2520Utils.html">Function Utils</a><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16">
    <path 
        fill-rule="evenodd" 
        clip-rule="evenodd" 
        d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z">
    </path>
</svg></div><ul class='methods accordion-content'><li data-type='method'><a href="module-Function%252520Utils.html#~isValidConnection">isValidConnection</a></li><li data-type='method'><a href="module-Function%252520Utils.html#~wrapFunctionAsNode">wrapFunctionAsNode</a></li></ul></li><li class="" id=""><a href="module-Math%2520Utils.html">Math Utils</a></li><li class="" id=""><a href="module-Object%2520Utils.html">Object Utils</a></li><li class="accordion collapsed" id=4165437><div class="accordion-title"><a href="module-Registry%2520Manager.html">Registry Manager</a><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="16" height="16">
    <path 
        fill-rule="evenodd" 
        clip-rule="evenodd" 
        d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z">
    </path>
</svg></div><ul class='methods accordion-content'><li data-type='method'><a href="module-Registry%252520Manager.html#.clearRegisteredTypes">clearRegisteredTypes</a></li><li data-type='method'><a href="module-Registry%252520Manager.html#~getNodeType">getNodeType</a></li><li data-type='method'><a href="module-Registry%252520Manager.html#~getNodeType">getNodeType</a></li><li data-type='method'><a href="module-Registry%252520Manager.html#~getNodeTypesCategories">getNodeTypesCategories</a></li><li data-type='method'><a href="module-Registry%252520Manager.html#~registerNodeType">registerNodeType</a></li><li data-type='method'><a href="module-Registry%252520Manager.html#~registerSearchboxExtra">registerSearchboxExtra</a></li><li data-type='method'><a href="module-Registry%252520Manager.html#~unregisterNodeType">unregisterNodeType</a></li></ul></li><li class="" id=""><a href="module-Time%2520Utils.html">Time Utils</a></li></ul></div>
</nav>

<div id="main">
    
    <h1 id='page-title' class="page-title">LGraphNode.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import defaultConfig from "./utils/defaultConfig";
import cloneObject from "./utils/object";
import getTime from "./utils/time";
import { isValidConnection } from "./utils/function";
import LLink from "./LLink";
import { isInsideRectangle } from "./utils/math";

/*
title: string
pos: [x,y]
size: [x,y]

input|output: every connection
+  { name:string, type:string, pos: [x,y]=Optional, direction: "input"|"output", links: Array });

general properties:
+ clip_area: if you render outside the node, it will be clipped
+ unsafe_execution: not allowed for safe execution
+ skip_repeated_outputs: when adding new outputs, it wont show if there is one already connected
+ resizable: if set to false it wont be resizable with the mouse
+ horizontal: slots are distributed horizontally
+ widgets_start_y: widgets start at y distance from the top of the node

flags object:
+ collapsed: if it is collapsed

supported callbacks:
+ onAdded: when added to graph (warning: this is called BEFORE the node is configured when loading)
+ onRemoved: when removed from graph
+ onStart:	when the graph starts playing
+ onStop:	when the graph stops playing
+ onDrawForeground: render the inside widgets inside the node
+ onDrawBackground: render the background area inside the node (only in edit mode)
+ onMouseDown
+ onMouseMove
+ onMouseUp
+ onMouseEnter
+ onMouseLeave
+ onExecute: execute the node
+ onPropertyChanged: when a property is changed in the panel (return true to skip default behaviour)
+ onGetInputs: returns an array of possible inputs
+ onGetOutputs: returns an array of possible outputs
+ onBounding: in case this node has a bigger bounding than the node itself (the callback receives the bounding as [x,y,w,h])
+ onDblClick: double clicked in the node
+ onInputDblClick: input slot double clicked (can be used to automatically create a node connected)
+ onOutputDblClick: output slot double clicked (can be used to automatically create a node connected)
+ onConfigure: called after the node has been configured
+ onSerialize: to add extra info when serializing (the callback receives the object that should be filled with the data)
+ onSelected
+ onDeselected
+ onDropItem : DOM item dropped over the node
+ onDropFile : file dropped over the node
+ onConnectInput : if returns false the incoming connection will be canceled
+ onConnectionsChange : a connection changed (new one or removed) (LiteGraph.INPUT or LiteGraph.OUTPUT, slot, true if connected, link_info, input_info )
+ onAction: action slot triggered
+ getExtraMenuOptions: to add option to context menu
*/

/**
 * Base Class for all the node type classes
 * @class LGraphNode
 * @param {String} title a name for the node
 */
export default class LGraphNode {
    constructor(title) {
        this.title = title || "Unnamed";
        this.size = [defaultConfig.NODE_WIDTH, 60];
        this.graph = null;
        this.id = -1; // not know till not added
        this.type = null;
        // inputs available: array of inputs
        this.inputs = [];
        this.outputs = [];
        this.connections = [];

        // local data
        this.properties = {}; // for the values
        this.properties_info = []; // for the info

        this.flags = {};
    }

    /**
     * Internal position array
     * @internal
     * @type {Float32Array}
     * @private
     * @memberOf LGraphNode
     */
    _pos = new Float32Array(10, 10)

    set pos(v) {
        if (!v || v.length &lt; 2) {
            return;
        }
        this._pos[0] = v[0];
        this._pos[1] = v[1];
    }

    get pos() {
        return this._pos;
    }

    /**
     * configure a node from an object containing the serialized info
     * @method configure
     * @memberOf LGraphNode
     */
    configure(info) {
        if (this.graph) {
            this.graph._version++;
        }
        // eslint-disable-next-line guard-for-in,no-restricted-syntax
        for (const j in info) {
            if (j === "properties") {
                // i don't want to clone properties, I want to reuse the old container
                // eslint-disable-next-line guard-for-in,no-restricted-syntax
                for (const k in info.properties) {
                    this.properties[k] = info.properties[k];
                    if (this.onPropertyChanged) {
                        this.onPropertyChanged(k, info.properties[k]);
                    }
                }
                continue;
            }

            if (info[j] == null) {
                continue;
            } else if (typeof info[j] === "object") {
                // object
                if (this[j] &amp;&amp; this[j].configure) {
                    this[j].configure(info[j]);
                } else {
                    this[j] = cloneObject(info[j], this[j]);
                }
            } else {
                this[j] = info[j];
            }
        }

        if (!info.title) {
            this.title = this.constructor.title;
        }

        if (this.onConnectionsChange) {
            if (this.inputs) {
                for (let i = 0; i &lt; this.inputs.length; ++i) {
                    const input = this.inputs[i];
                    const linkInfo = this.graph
                        ? this.graph.links[input.link]
                        : null;
                    this.onConnectionsChange(
                        defaultConfig.INPUT,
                        i,
                        true,
                        linkInfo,
                        input,
                    ); // linkInfo has been created now, so its updated
                }
            }

            if (this.outputs) {
                for (let i = 0; i &lt; this.outputs.length; ++i) {
                    const output = this.outputs[i];
                    if (!output.links) {
                        continue;
                    }
                    for (let j = 0; j &lt; output.links.length; ++j) {
                        const linkInfo = this.graph
                            ? this.graph.links[output.links[j]]
                            : null;
                        this.onConnectionsChange(
                            defaultConfig.OUTPUT,
                            i,
                            true,
                            linkInfo,
                            output,
                        ); // link_info has been created now, so its updated
                    }
                }
            }
        }

        if (this.widgets) {
            for (const widget of this.widgets) {
                if (!widget) continue;
                if (widget.options
                    &amp;&amp; widget.options.property
                    // eslint-disable-next-line max-len
                    &amp;&amp; this.properties[widget.options.property]) widget.value = JSON.parse(JSON.stringify(this.properties[widget.options.property]));
            }
            if (info.widgets_values) {
                for (let i = 0; i &lt; info.widgets_values.length; ++i) {
                    if (this.widgets[i]) {
                        this.widgets[i].value = info.widgets_values[i];
                    }
                }
            }
        }

        if (this.onConfigure) {
            this.onConfigure(info);
        }
    }

    /**
     * serialize the content
     * @method serialize
     * @memberOf LGraphNode
     */

    serialize() {
        // create serialization object
        const o = {
            id: this.id,
            type: this.type,
            pos: this.pos,
            size: this.size,
            flags: cloneObject(this.flags),
            order: this.order,
            mode: this.mode,
        };

        // special case for when there were errors
        if (this.constructor === LGraphNode &amp;&amp; this.last_serialization) {
            return this.last_serialization;
        }

        if (this.inputs) {
            o.inputs = this.inputs;
        }

        if (this.outputs) {
            // clear outputs last data (because data in connections is never serialized but stored
            // inside the outputs info)
            for (let i = 0; i &lt; this.outputs.length; i++) {
                delete this.outputs[i]._data;
            }
            o.outputs = this.outputs;
        }

        if (this.title &amp;&amp; this.title != this.constructor.title) {
            o.title = this.title;
        }

        if (this.properties) {
            o.properties = cloneObject(this.properties);
        }

        if (this.widgets &amp;&amp; this.serialize_widgets) {
            o.widgets_values = [];
            for (let i = 0; i &lt; this.widgets.length; ++i) {
                if (this.widgets[i]) {
                    o.widgets_values[i] = this.widgets[i].value;
                } else {
                    o.widgets_values[i] = null;
                }
            }
        }

        if (!o.type) o.type = this.constructor.type;

        if (this.color) o.color = this.color;
        if (this.bgcolor) o.bgcolor = this.bgcolor;
        if (this.boxcolor) o.boxcolor = this.boxcolor;
        if (this.shape) o.shape = this.shape;

        if (this.onSerialize) {
            if (this.onSerialize(o)) {
                console.warn(
                    "node onSerialize shouldnt return anything, data should be stored in the object pass in the first parameter",
                );
            }
        }

        return o;
    }

    /* Creates a clone of this node */
    clone() {
        const node = LGraphNode.createNode(this.type);
        if (!node) {
            return null;
        }

        // we clone it because serialize returns shared containers
        const data = LGraphNode.cloneObject(this.serialize());

        // remove links
        if (data.inputs) {
            for (let i = 0; i &lt; data.inputs.length; ++i) {
                data.inputs[i].link = null;
            }
        }

        if (data.outputs) {
            for (let i = 0; i &lt; data.outputs.length; ++i) {
                if (data.outputs[i].links) {
                    data.outputs[i].links.length = 0;
                }
            }
        }

        delete data.id;
        // remove links
        node.configure(data);

        return node;
    }

    /**
     * serialize and stringify
     * @method toString
     * @memberOf LGraphNode
     */

    toString() {
        return JSON.stringify(this.serialize());
    }

    // deserialize = function(info) {} //this cannot be done from within, must
    // be done in LiteGraph

    /**
     * get the title string
     * @method getTitle
     * @memberOf LGraphNode
     */

    getTitle() {
        return this.title || this.constructor.title;
    }

    /**
     * sets the value of a property
     * @method setProperty
     * @param {String} name
     * @param {*} value
     * @memberOf LGraphNode
     */
    setProperty(name, value) {
        if (!this.properties) {
            this.properties = {};
        }
        if (value === this.properties[name]) return;
        const prevValue = this.properties[name];
        this.properties[name] = value;
        if (this.onPropertyChanged &amp;&amp; this.onPropertyChanged(name, value, prevValue) === false) {
            this.properties[name] = prevValue;
        }
        if (this.widgets) {
            for (let i = 0; i &lt; this.widgets.length; ++i) {
                const w = this.widgets[i];
                if (!w) continue;
                if (w.options.property == name) {
                    w.value = value;
                    break;
                }
            }
        }
    }

    // Execution *************************
    /**
     * sets the output data
     * @method setOutputData
     * @param {number} slot
     * @param {*} data
     * @memberOf LGraphNode
     */
    setOutputData(slot, data) {
        if (!this.outputs) {
            return;
        }

        // this maybe slow and a niche case
        // if(slot &amp;&amp; slot.constructor === String)
        //	slot = this.findOutputSlot(slot);

        if (slot == -1 || slot >= this.outputs.length) {
            return;
        }

        const output_info = this.outputs[slot];
        if (!output_info) {
            return;
        }

        // store data in the output itself in case we want to debug
        output_info._data = data;

        // if there are connections, pass the data to the connections
        if (this.outputs[slot].links) {
            for (let i = 0; i &lt; this.outputs[slot].links.length; i++) {
                const link_id = this.outputs[slot].links[i];
                const link = this.graph.links[link_id];
                if (link) link.data = data;
            }
        }
    }

    /**
     * sets the output data type, useful when you want to be able to overwrite the data type
     * @method setOutputDataType
     * @param {number} slot
     * @param {String} datatype
     * @memberOf LGraphNode
     */
    setOutputDataType(slot, type) {
        if (!this.outputs) {
            return;
        }
        if (slot == -1 || slot >= this.outputs.length) {
            return;
        }
        const output_info = this.outputs[slot];
        if (!output_info) {
            return;
        }
        // store data in the output itself in case we want to debug
        output_info.type = type;

        // if there are connections, pass the data to the connections
        if (this.outputs[slot].links) {
            for (let i = 0; i &lt; this.outputs[slot].links.length; i++) {
                const link_id = this.outputs[slot].links[i];
                this.graph.links[link_id].type = type;
            }
        }
    }

    /**
     * Retrieves the input data (data traveling through the connection) from one slot
     * @method getInputData
     * @param {number} slot
     * @param {boolean} force_update if set to true it will force the connected node of this slot
     *     to output data into this link
     * @return {*} data or if it is not connected returns undefined
     * @memberOf LGraphNode
     */
    getInputData(slot, force_update) {
        if (!this.inputs) {
            return;
        } // undefined;

        if (slot >= this.inputs.length || this.inputs[slot].link == null) {
            return;
        }

        const link_id = this.inputs[slot].link;
        const link = this.graph.links[link_id];
        if (!link) {
            // bug: weird case but it happens sometimes
            return null;
        }

        if (!force_update) {
            return link.data;
        }

        // special case: used to extract data from the incoming connection before the graph has
        // been executed
        const node = this.graph.getNodeById(link.origin_id);
        if (!node) {
            return link.data;
        }

        if (node.updateOutputData) {
            node.updateOutputData(link.origin_slot);
        } else if (node.onExecute) {
            node.onExecute();
        }

        return link.data;
    }

    /**
     * Retrieves the input data type (in case this supports multiple input types)
     * @method getInputDataType
     * @param {number} slot
     * @return {String} datatype in string format
     * @memberOf LGraphNode
     */
    getInputDataType(slot) {
        if (!this.inputs) {
            return null;
        } // undefined;

        if (slot >= this.inputs.length || this.inputs[slot].link == null) {
            return null;
        }
        const link_id = this.inputs[slot].link;
        const link = this.graph.links[link_id];
        if (!link) {
            // bug: weird case but it happens sometimes
            return null;
        }
        const node = this.graph.getNodeById(link.origin_id);
        if (!node) {
            return link.type;
        }
        const output_info = node.outputs[link.origin_slot];
        if (output_info) {
            return output_info.type;
        }
        return null;
    }

    /**
     * Retrieves the input data from one slot using its name instead of slot number
     * @method getInputDataByName
     * @param {String} slot_name
     * @param {boolean} force_update if set to true it will force the connected node of this slot
     *     to output data into this link
     * @return {*} data or if it is not connected returns null
     * @memberOf LGraphNode
     */
    getInputDataByName(
        slot_name,
        force_update,
    ) {
        const slot = this.findInputSlot(slot_name);
        if (slot == -1) {
            return null;
        }
        return this.getInputData(slot, force_update);
    }

    /**
     * tells you if there is a connection in one input slot
     * @method isInputConnected
     * @param {number} slot
     * @return {boolean}
     * @memberOf LGraphNode
     */
    isInputConnected(slot) {
        if (!this.inputs) {
            return false;
        }
        return slot &lt; this.inputs.length &amp;&amp; this.inputs[slot].link != null;
    }

    /**
     * tells you info about an input connection (which node, type, etc)
     * @method getInputInfo
     * @param {number} slot
     * @return {Object} object or null { link: id, name: string, type: string or 0 }
     * @memberOf LGraphNode
     */
    getInputInfo(slot) {
        if (!this.inputs) {
            return null;
        }
        if (slot &lt; this.inputs.length) {
            return this.inputs[slot];
        }
        return null;
    }

    /**
     * Returns the link info in the connection of an input slot
     * @method getInputLink
     * @param {number} slot
     * @return {LLink} object or null
     * @memberOf LGraphNode
     */
    getInputLink(slot) {
        if (!this.inputs) {
            return null;
        }
        if (slot &lt; this.inputs.length) {
            const slot_info = this.inputs[slot];
            return this.graph.links[slot_info.link];
        }
        return null;
    }

    /**
     * returns the node connected in the input slot
     * @method getInputNode
     * @param {number} slot
     * @return {LGraphNode} node or null
     * @memberOf LGraphNode
     */
    getInputNode(slot) {
        if (!this.inputs) {
            return null;
        }
        if (slot >= this.inputs.length) {
            return null;
        }
        const input = this.inputs[slot];
        if (!input || input.link === null) {
            return null;
        }
        const link_info = this.graph.links[input.link];
        if (!link_info) {
            return null;
        }
        return this.graph.getNodeById(link_info.origin_id);
    }

    /**
     * returns the value of an input with this name, otherwise checks if there is a property with
     * that name
     * @method getInputOrProperty
     * @param {string} name
     * @return {*} value
     * @memberOf LGraphNode
     */
    getInputOrProperty(name) {
        if (!this.inputs || !this.inputs.length) {
            return this.properties ? this.properties[name] : null;
        }

        for (let i = 0, l = this.inputs.length; i &lt; l; ++i) {
            const input_info = this.inputs[i];
            if (name == input_info.name &amp;&amp; input_info.link != null) {
                const link = this.graph.links[input_info.link];
                if (link) {
                    return link.data;
                }
            }
        }
        return this.properties[name];
    }

    /**
     * tells you the last output data that went in that slot
     * @method getOutputData
     * @param {number} slot
     * @return {Object}  object or null
     * @memberOf LGraphNode
     */
    getOutputData(slot) {
        if (!this.outputs) {
            return null;
        }
        if (slot >= this.outputs.length) {
            return null;
        }

        const info = this.outputs[slot];
        return info._data;
    }

    /**
     * tells you info about an output connection (which node, type, etc)
     * @method getOutputInfo
     * @param {number} slot
     * @return {Object}  object or null { name: string, type: string, links: [ ids of links in
     *     number ] }
     * @memberOf LGraphNode
     */
    getOutputInfo(slot) {
        if (!this.outputs) {
            return null;
        }
        if (slot &lt; this.outputs.length) {
            return this.outputs[slot];
        }
        return null;
    }

    /**
     * tells you if there is a connection in one output slot
     * @method isOutputConnected
     * @param {number} slot
     * @return {boolean}
     * @memberOf LGraphNode
     */
    isOutputConnected(slot) {
        if (!this.outputs) {
            return false;
        }
        return (
            slot &lt; this.outputs.length
            &amp;&amp; this.outputs[slot].links
            &amp;&amp; this.outputs[slot].links.length
        );
    }

    /**
     * tells you if there is any connection in the output slots
     * @method isAnyOutputConnected
     * @return {boolean}
     * @memberOf LGraphNode
     */
    isAnyOutputConnected() {
        if (!this.outputs) {
            return false;
        }
        for (let i = 0; i &lt; this.outputs.length; ++i) {
            if (this.outputs[i].links &amp;&amp; this.outputs[i].links.length) {
                return true;
            }
        }
        return false;
    }

    /**
     * retrieves all the nodes connected to this output slot
     * @method getOutputNodes
     * @param {number} slot
     * @return {array}
     * @memberOf LGraphNode
     */
    getOutputNodes(slot) {
        if (!this.outputs || this.outputs.length == 0) {
            return null;
        }

        if (slot >= this.outputs.length) {
            return null;
        }

        const output = this.outputs[slot];
        if (!output.links || output.links.length == 0) {
            return null;
        }

        const r = [];
        for (let i = 0; i &lt; output.links.length; i++) {
            const link_id = output.links[i];
            const link = this.graph.links[link_id];
            if (link) {
                const target_node = this.graph.getNodeById(link.target_id);
                if (target_node) {
                    r.push(target_node);
                }
            }
        }
        return r;
    }

    /**
     * Triggers an event in this node, this will trigger any output with the same name
     * @method trigger
     * @param {String} event name ( "on_play", ... ) if action is equivalent to false then the
     *     event is send to all
     * @param {*} param
     * @memberOf LGraphNode
     */
    trigger(action, param) {
        if (!this.outputs || !this.outputs.length) {
            return;
        }

        if (this.graph) this.graph._last_trigger_time = getTime();

        for (let i = 0; i &lt; this.outputs.length; ++i) {
            const output = this.outputs[i];
            if (!output || output.type !== defaultConfig.EVENT || (action &amp;&amp; output.name != action)) continue;
            this.triggerSlot(i, param);
        }
    }

    /**
     * Triggers an slot event in this node
     * @method triggerSlot
     * @param {Number} slot the index of the output slot
     * @param {*} param
     * @param {Number} link_id [optional] in case you want to trigger and specific output link in a
     *     slot
     * @memberOf LGraphNode
     */
    triggerSlot(slot, param, link_id) {
        if (!this.outputs) {
            return;
        }

        const output = this.outputs[slot];
        if (!output) {
            return;
        }

        const { links } = output;
        if (!links || !links.length) {
            return;
        }

        if (this.graph) {
            this.graph._last_trigger_time = getTime();
        }

        // for every link attached here
        for (let k = 0; k &lt; links.length; ++k) {
            const id = links[k];
            if (link_id != null &amp;&amp; link_id != id) {
                // to skip links
                continue;
            }
            const link_info = this.graph.links[links[k]];
            if (!link_info) {
                // not connected
                continue;
            }
            link_info._last_time = getTime();
            const node = this.graph.getNodeById(link_info.target_id);
            if (!node) {
                // node not found?
                continue;
            }

            // used to mark events in graph
            const target_connection = node.inputs[link_info.target_slot];

            if (node.mode === defaultConfig.ON_TRIGGER) {
                if (node.onExecute) {
                    node.onExecute(param);
                }
            } else if (node.onAction) {
                node.onAction(target_connection.name, param);
            }
        }
    }

    /**
     * clears the trigger slot animation
     * @method clearTriggeredSlot
     * @param {Number} slot the index of the output slot
     * @param {Number} link_id [optional] in case you want to trigger and specific output link in a
     *     slot
     * @memberOf LGraphNode
     */
    clearTriggeredSlot(slot, link_id) {
        if (!this.outputs) {
            return;
        }

        const output = this.outputs[slot];
        if (!output) {
            return;
        }

        const { links } = output;
        if (!links || !links.length) {
            return;
        }

        // for every link attached here
        for (let k = 0; k &lt; links.length; ++k) {
            const id = links[k];
            if (link_id != null &amp;&amp; link_id != id) {
                // to skip links
                continue;
            }
            const link_info = this.graph.links[links[k]];
            if (!link_info) {
                // not connected
                continue;
            }
            link_info._last_time = 0;
        }
    }

    /**
     * changes node size and triggers callback
     * @method setSize
     * @param {vec2} size
     * @memberOf LGraphNode
     */
    setSize(size) {
        this.size = size;
        if (this.onResize) this.onResize(this.size);
    }

    /**
     * add a new property to this node
     * @method addProperty
     * @param {string} name
     * @param {*} default_value
     * @param {string} type string defining the output type ("vec3","number",...)
     * @param {Object} extra_info this can be used to have special properties of the property (like
     *     values, etc)
     * @memberOf LGraphNode
     */
    addProperty(
        name,
        default_value,
        type,
        extra_info,
    ) {
        const o = {
            name,
            type,
            default_value,
        };
        if (extra_info) {
            for (const i in extra_info) {
                o[i] = extra_info[i];
            }
        }
        if (!this.properties_info) {
            this.properties_info = [];
        }
        this.properties_info.push(o);
        if (!this.properties) {
            this.properties = {};
        }
        this.properties[name] = default_value;
        return o;
    }

    // connections

    /**
     * add a new output slot to use in this node
     * @method addOutput
     * @param {string} name
     * @param {string} type string defining the output type ("vec3","number",...)
     * @param {Object} extra_info this can be used to have special properties of an output (label,
     *     special color, position, etc)
     * @memberOf LGraphNode
     */
    addOutput(name, type, extra_info) {
        const o = {
            name,
            type,
            links: null,
        };
        if (extra_info) {
            for (const i in extra_info) {
                o[i] = extra_info[i];
            }
        }

        if (!this.outputs) {
            this.outputs = [];
        }
        this.outputs.push(o);
        if (this.onOutputAdded) {
            this.onOutputAdded(o);
        }
        this.setSize(this.computeSize());
        this.setDirtyCanvas(true, true);
        return o;
    }

    /**
     * add a new output slot to use in this node
     * @method addOutputs
     * @param {Array} array of triplets like [[name,type,extra_info],[...]]
     * @memberOf LGraphNode
     */
    addOutputs(array) {
        for (let i = 0; i &lt; array.length; ++i) {
            const info = array[i];
            const o = {
                name: info[0],
                type: info[1],
                link: null,
            };
            if (array[2]) {
                for (const j in info[2]) {
                    o[j] = info[2][j];
                }
            }

            if (!this.outputs) {
                this.outputs = [];
            }
            this.outputs.push(o);
            if (this.onOutputAdded) {
                this.onOutputAdded(o);
            }
        }

        this.setSize(this.computeSize());
        this.setDirtyCanvas(true, true);
    }

    /**
     * remove an existing output slot
     * @method removeOutput
     * @param {number} slot
     * @memberOf LGraphNode
     */
    removeOutput(slot) {
        this.disconnectOutput(slot);
        this.outputs.splice(slot, 1);
        for (let i = slot; i &lt; this.outputs.length; ++i) {
            if (!this.outputs[i] || !this.outputs[i].links) {
                continue;
            }
            const { links } = this.outputs[i];
            for (let j = 0; j &lt; links.length; ++j) {
                const link = this.graph.links[links[j]];
                if (!link) {
                    continue;
                }
                link.origin_slot -= 1;
            }
        }

        this.setSize(this.computeSize());
        if (this.onOutputRemoved) {
            this.onOutputRemoved(slot);
        }
        this.setDirtyCanvas(true, true);
    }

    /**
     * add a new input slot to use in this node
     * @method addInput
     * @param {string} name
     * @param {string} type string defining the input type ("vec3","number",...), it its a generic
     *     one use 0
     * @param {Object} extra_info this can be used to have special properties of an input (label,
     *     color, position, etc)
     * @memberOf LGraphNode
     */
    addInput(name, type, extra_info) {
        type = type || 0;
        const o = {
            name,
            type,
            link: null,
        };
        if (extra_info) {
            for (const i in extra_info) {
                o[i] = extra_info[i];
            }
        }

        if (!this.inputs) {
            this.inputs = [];
        }

        this.inputs.push(o);
        this.setSize(this.computeSize());

        if (this.onInputAdded) {
            this.onInputAdded(o);
        }

        this.setDirtyCanvas(true, true);
        return o;
    }

    /**
     * add several new input slots in this node
     * @method addInputs
     * @param {Array} array of triplets like [[name,type,extra_info],[...]]
     * @memberOf LGraphNode
     */
    addInputs(array) {
        for (let i = 0; i &lt; array.length; ++i) {
            const info = array[i];
            const o = {
                name: info[0],
                type: info[1],
                link: null,
            };
            if (array[2]) {
                for (const j in info[2]) {
                    o[j] = info[2][j];
                }
            }

            if (!this.inputs) {
                this.inputs = [];
            }
            this.inputs.push(o);
            if (this.onInputAdded) {
                this.onInputAdded(o);
            }
        }

        this.setSize(this.computeSize());
        this.setDirtyCanvas(true, true);
    }

    /**
     * remove an existing input slot
     * @method removeInput
     * @param {number} slot
     * @memberOf LGraphNode
     */
    removeInput(slot) {
        this.disconnectInput(slot);
        const slot_info = this.inputs.splice(slot, 1);
        for (let i = slot; i &lt; this.inputs.length; ++i) {
            if (!this.inputs[i]) {
                continue;
            }
            const link = this.graph.links[this.inputs[i].link];
            if (!link) {
                continue;
            }
            link.target_slot -= 1;
        }
        this.setSize(this.computeSize());
        if (this.onInputRemoved) {
            this.onInputRemoved(slot, slot_info[0]);
        }
        this.setDirtyCanvas(true, true);
    }

    /**
     * add an special connection to this node (used for special kinds of graphs)
     * @method addConnection
     * @param {string} name
     * @param {string} type string defining the input type ("vec3","number",...)
     * @param {number[]} pos position of the connection inside the node
     * @param {string} direction if is input or output
     * @memberOf LGraphNode
     */
    addConnection(name, type, pos, direction) {
        const o = {
            name,
            type,
            pos,
            direction,
            links: null,
        };
        this.connections.push(o);
        return o;
    }

    /**
     * computes the minimum size of a node according to its inputs and output slots
     * @method computeSize
     * @param {number} minHeight
     * @return {number} the total size
     * @memberOf LGraphNode
     */
    computeSize(out) {
        if (this.constructor.size) {
            return this.constructor.size.concat();
        }

        let rows = Math.max(
            this.inputs ? this.inputs.length : 1,
            this.outputs ? this.outputs.length : 1,
        );
        const size = out || new Float32Array([0, 0]);
        rows = Math.max(rows, 1);
        var font_size = defaultConfig.NODE_TEXT_SIZE; // although it should be
        // graphcanvas.inner_text_font size

        var font_size = font_size;
        const title_width = compute_text_size(this.title);
        let input_width = 0;
        let output_width = 0;

        if (this.inputs) {
            for (var i = 0, l = this.inputs.length; i &lt; l; ++i) {
                const input = this.inputs[i];
                var text = input.label || input.name || "";
                var text_width = compute_text_size(text);
                if (input_width &lt; text_width) {
                    input_width = text_width;
                }
            }
        }

        if (this.outputs) {
            for (var i = 0, l = this.outputs.length; i &lt; l; ++i) {
                const output = this.outputs[i];
                var text = output.label || output.name || "";
                var text_width = compute_text_size(text);
                if (output_width &lt; text_width) {
                    output_width = text_width;
                }
            }
        }

        size[0] = Math.max(input_width + output_width + 10, title_width);
        size[0] = Math.max(size[0], defaultConfig.NODE_WIDTH);
        if (this.widgets &amp;&amp; this.widgets.length) {
            size[0] = Math.max(size[0], defaultConfig.NODE_WIDTH * 1.5);
        }

        size[1] = (this.constructor.slot_start_y || 0) + rows * defaultConfig.NODE_SLOT_HEIGHT;

        let widgets_height = 0;
        if (this.widgets &amp;&amp; this.widgets.length) {
            for (var i = 0, l = this.widgets.length; i &lt; l; ++i) {
                if (this.widgets[i].computeSize) {
                    widgets_height += this.widgets[i].computeSize(size[0])[1] + 4;
                } else {
                    widgets_height += defaultConfig.NODE_WIDGET_HEIGHT + 4;
                }
            }
            widgets_height += 8;
        }

        // compute height using widgets height
        if (this.widgets_up) {
            size[1] = Math.max(size[1], widgets_height);
        } else if (this.widgets_start_y != null) {
            size[1] = Math.max(size[1], widgets_height + this.widgets_start_y);
        } else {
            size[1] += widgets_height;
        }

        function compute_text_size(text) {
            if (!text) {
                return 0;
            }
            return font_size * text.length * 0.6;
        }

        if (
            this.constructor.min_height
            &amp;&amp; size[1] &lt; this.constructor.min_height
        ) {
            size[1] = this.constructor.min_height;
        }

        size[1] += 6; // margin

        return size;
    }

    /**
     * returns all the info available about a property of this node.
     *
     * @method getPropertyInfo
     * @param {String} property name of the property
     * @return {Object} the object with all the available info
     * @memberOf LGraphNode
     */
    getPropertyInfo(property) {
        let info = null;

        // there are several ways to define info about a property
        // legacy mode
        if (this.properties_info) {
            for (let i = 0; i &lt; this.properties_info.length; ++i) {
                if (this.properties_info[i].name == property) {
                    info = this.properties_info[i];
                    break;
                }
            }
        }
        // litescene mode using the constructor
        if (this.constructor[`@${property}`]) info = this.constructor[`@${property}`];

        if (this.constructor.widgets_info &amp;&amp; this.constructor.widgets_info[property]) info = this.constructor.widgets_info[property];

        // litescene mode using the constructor
        if (!info &amp;&amp; this.onGetPropertyInfo) {
            info = this.onGetPropertyInfo(property);
        }

        if (!info) info = {};
        if (!info.type) info.type = typeof this.properties[property];
        if (info.widget == "combo") info.type = "enum";

        return info;
    }

    /**
     * Defines a widget inside the node, it will be rendered on top of the node, you can control
     * lots of properties
     *
     * @method addWidget
     * @param {String} type the widget type (could be "number","string","combo"
     * @param {String} name the text to show on the widget
     * @param {String} value the default value
     * @param {Function|String} callback function to call when it changes (optionally, it can be
     *     the name of the property to modify)
     * @param {Object} options the object that contains special properties of this widget
     * @return {Object} the created widget object
     * @memberOf LGraphNode
     */
    addWidget(type, name, value, callback, options) {
        if (!this.widgets) {
            this.widgets = [];
        }

        if (!options &amp;&amp; callback &amp;&amp; callback.constructor === Object) {
            options = callback;
            callback = null;
        }

        if (options &amp;&amp; options.constructor === String) // options can be the property name
        {
            options = { property: options };
        }

        if (callback &amp;&amp; callback.constructor === String) // callback can be the property name
        {
            if (!options) options = {};
            options.property = callback;
            callback = null;
        }

        if (callback &amp;&amp; callback.constructor !== Function) {
            console.warn("addWidget: callback must be a function");
            callback = null;
        }

        const w = {
            type: type.toLowerCase(),
            name,
            value,
            callback,
            options: options || {},
        };

        if (w.options.y) {
            w.y = w.options.y;
        }

        if (!callback &amp;&amp; !w.options.callback &amp;&amp; !w.options.property) {
            console.warn("LiteGraph addWidget(...) without a callback or property assigned");
        }
        if (type == "combo" &amp;&amp; !w.options.values) {
            throw "LiteGraph addWidget('combo',...) requires to pass values in options: { values:['red','blue'] }";
        }
        this.widgets.push(w);
        this.setSize(this.computeSize());
        return w;
    }

    addCustomWidget(custom_widget) {
        if (!this.widgets) {
            this.widgets = [];
        }
        this.widgets.push(custom_widget);
        return custom_widget;
    }

    /**
     * returns the bounding of the object, used for rendering purposes
     * bounding is: [topleft_cornerx, topleft_cornery, width, height]
     * @method getBounding
     * @return {Float32Array} the total size
     * @memberOf LGraphNode
     */
    getBounding(out) {
        out = out || new Float32Array(4);
        out[0] = this.pos[0] - 4;
        out[1] = this.pos[1] - defaultConfig.NODE_TITLE_HEIGHT;
        out[2] = this.size[0] + 4;
        out[3] = this.size[1] + defaultConfig.NODE_TITLE_HEIGHT;

        if (this.onBounding) {
            this.onBounding(out);
        }
        return out;
    }

    /**
     * checks if a point is inside the shape of a node
     * @method isPointInside
     * @param {number} x
     * @param {number} y
     * @return {boolean}
     * @memberOf LGraphNode
     */
    isPointInside(x, y, margin, skip_title) {
        margin = margin || 0;

        let margin_top = this.graph &amp;&amp; this.graph.isLive() ? 0 : defaultConfig.NODE_TITLE_HEIGHT;
        if (skip_title) {
            margin_top = 0;
        }
        if (this.flags &amp;&amp; this.flags.collapsed) {
            // if ( distance([x,y], [this.pos[0] + this.size[0]*0.5, this.pos[1] +
            // this.size[1]*0.5]) &lt; LiteGraph.NODE_COLLAPSED_RADIUS)
            if (
                isInsideRectangle(
                    x,
                    y,
                    this.pos[0] - margin,
                    this.pos[1] - defaultConfig.NODE_TITLE_HEIGHT - margin,
                    (this._collapsed_width || defaultConfig.NODE_COLLAPSED_WIDTH)
                    + 2 * margin,
                    defaultConfig.NODE_TITLE_HEIGHT + 2 * margin,
                )
            ) {
                return true;
            }
        } else if (
            this.pos[0] - 4 - margin &lt; x
            &amp;&amp; this.pos[0] + this.size[0] + 4 + margin > x
            &amp;&amp; this.pos[1] - margin_top - margin &lt; y
            &amp;&amp; this.pos[1] + this.size[1] + margin > y
        ) {
            return true;
        }
        return false;
    }

    /**
     * checks if a point is inside a node slot, and returns info about which slot
     * @method getSlotInPosition
     * @param {number} x
     * @param {number} y
     * @return {Object} if found the object contains { input|output: slot object, slot: number,
     *     link_pos: [x,y] }
     * @memberOf LGraphNode
     */
    getSlotInPosition(x, y) {
        // search for inputs
        const link_pos = new Float32Array(2);
        if (this.inputs) {
            for (var i = 0, l = this.inputs.length; i &lt; l; ++i) {
                const input = this.inputs[i];
                this.getConnectionPos(true, i, link_pos);
                if (
                    isInsideRectangle(
                        x,
                        y,
                        link_pos[0] - 10,
                        link_pos[1] - 5,
                        20,
                        10,
                    )
                ) {
                    return {
                        input,
                        slot: i,
                        link_pos,
                    };
                }
            }
        }

        if (this.outputs) {
            for (var i = 0, l = this.outputs.length; i &lt; l; ++i) {
                const output = this.outputs[i];
                this.getConnectionPos(false, i, link_pos);
                if (
                    isInsideRectangle(
                        x,
                        y,
                        link_pos[0] - 10,
                        link_pos[1] - 5,
                        20,
                        10,
                    )
                ) {
                    return {
                        output,
                        slot: i,
                        link_pos,
                    };
                }
            }
        }

        return null;
    }

    /**
     * returns the input slot with a given name (used for dynamic slots), -1 if not found
     * @method findInputSlot
     * @param {string} name the name of the slot
     * @return {number} the slot (-1 if not found)
     * @memberOf LGraphNode
     */
    findInputSlot(name) {
        if (!this.inputs) {
            return -1;
        }
        for (let i = 0, l = this.inputs.length; i &lt; l; ++i) {
            if (name == this.inputs[i].name) {
                return i;
            }
        }
        return -1;
    }

    /**
     * returns the output slot with a given name (used for dynamic slots), -1 if not found
     * @method findOutputSlot
     * @param {string} name the name of the slot
     * @return {number} the slot (-1 if not found)
     * @memberOf LGraphNode
     */
    findOutputSlot(name) {
        if (!this.outputs) {
            return -1;
        }
        for (let i = 0, l = this.outputs.length; i &lt; l; ++i) {
            if (name == this.outputs[i].name) {
                return i;
            }
        }
        return -1;
    }

    /**
     * connect this node output to the input of another node
     * @method connect
     * @param {number_or_string} slot (could be the number of the slot or the string with the name
     *     of the slot)
     * @param {LGraphNode} node the target node
     * @param {number_or_string} target_slot the input slot of the target node (could be the number
     *     of the slot or the string with the name of the slot, or -1 to connect a trigger)
     * @return {Object} the link_info is created, otherwise null
     * @memberOf LGraphNode
     */
    connect(slot, target_node, target_slot) {
        target_slot = target_slot || 0;

        if (!this.graph) {
            // could be connected before adding it to a graph
            console.log(
                "Connect: Error, node doesn't belong to any graph. Nodes must be added first to a graph before connecting them.",
            ); // due to link ids being associated with graphs
            return null;
        }

        // seek for the output slot
        if (slot.constructor === String) {
            slot = this.findOutputSlot(slot);
            if (slot == -1) {
                if (defaultConfig.debug) {
                    console.log(`Connect: Error, no slot of name ${slot}`);
                }
                return null;
            }
        } else if (!this.outputs || slot >= this.outputs.length) {
            if (defaultConfig.debug) {
                console.log("Connect: Error, slot number not found");
            }
            return null;
        }

        if (target_node &amp;&amp; target_node.constructor === Number) {
            target_node = this.graph.getNodeById(target_node);
        }
        if (!target_node) {
            throw "target node is null";
        }

        // avoid loopback
        if (target_node == this) {
            return null;
        }

        // you can specify the slot by name
        if (target_slot.constructor === String) {
            target_slot = target_node.findInputSlot(target_slot);
            if (target_slot == -1) {
                if (defaultConfig.debug) {
                    console.log(
                        `Connect: Error, no slot of name ${target_slot}`,
                    );
                }
                return null;
            }
        } else if (target_slot === defaultConfig.EVENT) {
            // search for first slot with event?
            /*
    //create input for trigger
    var input = target_node.addInput("onTrigger", LiteGraph.EVENT );
    target_slot = target_node.inputs.length - 1; //last one is the one created
    target_node.mode = LiteGraph.ON_TRIGGER;
    */
            return null;
        } else if (
            !target_node.inputs
            || target_slot >= target_node.inputs.length
        ) {
            if (defaultConfig.debug) {
                console.log("Connect: Error, slot number not found");
            }
            return null;
        }

        let changed = false;

        // if there is something already plugged there, disconnect
        if (target_node.inputs[target_slot].link != null) {
            this.graph.beforeChange();
            target_node.disconnectInput(target_slot);
            changed = true;
        }

        // why here??
        // this.setDirtyCanvas(false,true);
        // this.graph.connectionChange( this );

        const output = this.outputs[slot];

        // allows nodes to block connection
        if (target_node.onConnectInput) {
            if (target_node.onConnectInput(target_slot, output.type, output, this, slot) === false) {
                return null;
            }
        }

        const input = target_node.inputs[target_slot];
        let link_info = null;

        // this slots cannot be connected (different types)
        if (!isValidConnection(output.type, input.type)) {
            this.setDirtyCanvas(false, true);
            if (changed) this.graph.connectionChange(this, link_info);
            return null;
        }

        if (!changed) this.graph.beforeChange();

        // create link class
        link_info = new LLink(
            ++this.graph.last_link_id,
            input.type,
            this.id,
            slot,
            target_node.id,
            target_slot,
        );

        // add to graph links list
        this.graph.links[link_info.id] = link_info;

        // connect in output
        if (output.links == null) {
            output.links = [];
        }
        output.links.push(link_info.id);
        // connect in input
        target_node.inputs[target_slot].link = link_info.id;
        if (this.graph) {
            this.graph._version++;
        }
        if (this.onConnectionsChange) {
            this.onConnectionsChange(
                defaultConfig.OUTPUT,
                slot,
                true,
                link_info,
                output,
            );
        } // link_info has been created now, so its updated
        if (target_node.onConnectionsChange) {
            target_node.onConnectionsChange(
                defaultConfig.INPUT,
                target_slot,
                true,
                link_info,
                input,
            );
        }
        if (this.graph &amp;&amp; this.graph.onNodeConnectionChange) {
            this.graph.onNodeConnectionChange(
                defaultConfig.INPUT,
                target_node,
                target_slot,
                this,
                slot,
            );
            this.graph.onNodeConnectionChange(
                defaultConfig.OUTPUT,
                this,
                slot,
                target_node,
                target_slot,
            );
        }

        this.setDirtyCanvas(false, true);
        this.graph.afterChange();
        this.graph.connectionChange(this, link_info);

        return link_info;
    }

    /**
     * disconnect one output to an specific node
     * @method disconnectOutput
     * @param {number_or_string} slot (could be the number of the slot or the string with the name
     *     of the slot)
     * @param {LGraphNode} target_node the target node to which this slot is connected [Optional,
     *     if not target_node is specified all nodes will be disconnected]
     * @return {boolean} if it was disconnected successfully
     * @memberOf LGraphNode
     */
    disconnectOutput(slot, target_node) {
        if (slot.constructor === String) {
            slot = this.findOutputSlot(slot);
            if (slot == -1) {
                if (defaultConfig.debug) {
                    console.log(`Connect: Error, no slot of name ${slot}`);
                }
                return false;
            }
        } else if (!this.outputs || slot >= this.outputs.length) {
            if (defaultConfig.debug) {
                console.log("Connect: Error, slot number not found");
            }
            return false;
        }

        // get output slot
        const output = this.outputs[slot];
        if (!output || !output.links || output.links.length == 0) {
            return false;
        }

        // one of the output links in this slot
        if (target_node) {
            if (target_node.constructor === Number) {
                target_node = this.graph.getNodeById(target_node);
            }
            if (!target_node) {
                throw "Target Node not found";
            }

            for (var i = 0, l = output.links.length; i &lt; l; i++) {
                var link_id = output.links[i];
                var link_info = this.graph.links[link_id];

                // is the link we are searching for...
                if (link_info.target_id == target_node.id) {
                    output.links.splice(i, 1); // remove here
                    var input = target_node.inputs[link_info.target_slot];
                    input.link = null; // remove there
                    delete this.graph.links[link_id]; // remove the link from the links pool
                    if (this.graph) {
                        this.graph._version++;
                    }
                    if (target_node.onConnectionsChange) {
                        target_node.onConnectionsChange(
                            defaultConfig.INPUT,
                            link_info.target_slot,
                            false,
                            link_info,
                            input,
                        );
                    } // link_info hasn't been modified so its ok
                    if (this.onConnectionsChange) {
                        this.onConnectionsChange(
                            defaultConfig.OUTPUT,
                            slot,
                            false,
                            link_info,
                            output,
                        );
                    }
                    if (this.graph &amp;&amp; this.graph.onNodeConnectionChange) {
                        this.graph.onNodeConnectionChange(
                            defaultConfig.OUTPUT,
                            this,
                            slot,
                        );
                    }
                    if (this.graph &amp;&amp; this.graph.onNodeConnectionChange) {
                        this.graph.onNodeConnectionChange(
                            defaultConfig.OUTPUT,
                            this,
                            slot,
                        );
                        this.graph.onNodeConnectionChange(
                            defaultConfig.INPUT,
                            target_node,
                            link_info.target_slot,
                        );
                    }
                    break;
                }
            }
        } // all the links in this output slot
        else {
            for (var i = 0, l = output.links.length; i &lt; l; i++) {
                var link_id = output.links[i];
                var link_info = this.graph.links[link_id];
                if (!link_info) {
                    // bug: it happens sometimes
                    continue;
                }

                var target_node = this.graph.getNodeById(link_info.target_id);
                var input = null;
                if (this.graph) {
                    this.graph._version++;
                }
                if (target_node) {
                    input = target_node.inputs[link_info.target_slot];
                    input.link = null; // remove other side link
                    if (target_node.onConnectionsChange) {
                        target_node.onConnectionsChange(
                            defaultConfig.INPUT,
                            link_info.target_slot,
                            false,
                            link_info,
                            input,
                        );
                    } // link_info hasn't been modified so its ok
                    if (this.graph &amp;&amp; this.graph.onNodeConnectionChange) {
                        this.graph.onNodeConnectionChange(
                            defaultConfig.INPUT,
                            target_node,
                            link_info.target_slot,
                        );
                    }
                }
                delete this.graph.links[link_id]; // remove the link from the links pool
                if (this.onConnectionsChange) {
                    this.onConnectionsChange(
                        defaultConfig.OUTPUT,
                        slot,
                        false,
                        link_info,
                        output,
                    );
                }
                if (this.graph &amp;&amp; this.graph.onNodeConnectionChange) {
                    this.graph.onNodeConnectionChange(
                        defaultConfig.OUTPUT,
                        this,
                        slot,
                    );
                    this.graph.onNodeConnectionChange(
                        defaultConfig.INPUT,
                        target_node,
                        link_info.target_slot,
                    );
                }
            }
            output.links = null;
        }

        this.setDirtyCanvas(false, true);
        this.graph.connectionChange(this);
        return true;
    }

    /**
     * disconnect one input
     * @method disconnectInput
     * @param {number_or_string} slot (could be the number of the slot or the string with the name
     *     of the slot)
     * @return {boolean} if it was disconnected successfully
     * @memberOf LGraphNode
     */
    disconnectInput(slot) {
        // seek for the output slot
        if (slot.constructor === String) {
            slot = this.findInputSlot(slot);
            if (slot == -1) {
                if (defaultConfig.debug) {
                    console.log(`Connect: Error, no slot of name ${slot}`);
                }
                return false;
            }
        } else if (!this.inputs || slot >= this.inputs.length) {
            if (defaultConfig.debug) {
                console.log("Connect: Error, slot number not found");
            }
            return false;
        }

        const input = this.inputs[slot];
        if (!input) {
            return false;
        }

        const link_id = this.inputs[slot].link;
        if (link_id != null) {
            this.inputs[slot].link = null;

            // remove other side
            const link_info = this.graph.links[link_id];
            if (link_info) {
                const target_node = this.graph.getNodeById(link_info.origin_id);
                if (!target_node) {
                    return false;
                }

                const output = target_node.outputs[link_info.origin_slot];
                if (!output || !output.links || output.links.length == 0) {
                    return false;
                }

                // search in the inputs list for this link
                for (var i = 0, l = output.links.length; i &lt; l; i++) {
                    if (output.links[i] == link_id) {
                        output.links.splice(i, 1);
                        break;
                    }
                }

                delete this.graph.links[link_id]; // remove from the pool
                if (this.graph) {
                    this.graph._version++;
                }
                if (this.onConnectionsChange) {
                    this.onConnectionsChange(
                        defaultConfig.INPUT,
                        slot,
                        false,
                        link_info,
                        input,
                    );
                }
                if (target_node.onConnectionsChange) {
                    target_node.onConnectionsChange(
                        defaultConfig.OUTPUT,
                        i,
                        false,
                        link_info,
                        output,
                    );
                }
                if (this.graph &amp;&amp; this.graph.onNodeConnectionChange) {
                    this.graph.onNodeConnectionChange(
                        defaultConfig.OUTPUT,
                        target_node,
                        i,
                    );
                    this.graph.onNodeConnectionChange(defaultConfig.INPUT, this, slot);
                }
            }
        } // link != null

        this.setDirtyCanvas(false, true);
        if (this.graph) this.graph.connectionChange(this);
        return true;
    }

    /**
     * returns the center of a connection point in canvas coords
     * @method getConnectionPos
     * @param {boolean} is_input true if if a input slot, false if it is an output
     * @param {number_or_string} slot (could be the number of the slot or the string with the name
     *     of the slot)
     * @param {vec2} out [optional] a place to store the output, to free garbage
     * @return {number[]} the position
     * @memberOf LGraphNode
     * */
    getConnectionPos(
        is_input,
        slot_number,
        out,
    ) {
        out = out || new Float32Array(2);
        let num_slots = 0;
        if (is_input &amp;&amp; this.inputs) {
            num_slots = this.inputs.length;
        }
        if (!is_input &amp;&amp; this.outputs) {
            num_slots = this.outputs.length;
        }

        const offset = defaultConfig.NODE_SLOT_HEIGHT * 0.5;

        if (this.flags.collapsed) {
            const w = this._collapsed_width || defaultConfig.NODE_COLLAPSED_WIDTH;
            if (this.horizontal) {
                out[0] = this.pos[0] + w * 0.5;
                if (is_input) {
                    out[1] = this.pos[1] - defaultConfig.NODE_TITLE_HEIGHT;
                } else {
                    out[1] = this.pos[1];
                }
            } else {
                if (is_input) {
                    out[0] = this.pos[0];
                } else {
                    out[0] = this.pos[0] + w;
                }
                out[1] = this.pos[1] - defaultConfig.NODE_TITLE_HEIGHT * 0.5;
            }
            return out;
        }

        // weird feature that never got finished
        if (is_input &amp;&amp; slot_number == -1) {
            out[0] = this.pos[0] + defaultConfig.NODE_TITLE_HEIGHT * 0.5;
            out[1] = this.pos[1] + defaultConfig.NODE_TITLE_HEIGHT * 0.5;
            return out;
        }

        // hard-coded pos
        if (
            is_input
            &amp;&amp; num_slots > slot_number
            &amp;&amp; this.inputs[slot_number].pos
        ) {
            out[0] = this.pos[0] + this.inputs[slot_number].pos[0];
            out[1] = this.pos[1] + this.inputs[slot_number].pos[1];
            return out;
        }
        if (
            !is_input
            &amp;&amp; num_slots > slot_number
            &amp;&amp; this.outputs[slot_number].pos
        ) {
            out[0] = this.pos[0] + this.outputs[slot_number].pos[0];
            out[1] = this.pos[1] + this.outputs[slot_number].pos[1];
            return out;
        }

        // horizontal distributed slots
        if (this.horizontal) {
            out[0] = this.pos[0] + (slot_number + 0.5) * (this.size[0] / num_slots);
            if (is_input) {
                out[1] = this.pos[1] - defaultConfig.NODE_TITLE_HEIGHT;
            } else {
                out[1] = this.pos[1] + this.size[1];
            }
            return out;
        }

        // default vertical slots
        if (is_input) {
            out[0] = this.pos[0] + offset;
        } else {
            out[0] = this.pos[0] + this.size[0] + 1 - offset;
        }
        out[1] = this.pos[1]
            + (slot_number + 0.7) * defaultConfig.NODE_SLOT_HEIGHT
            + (this.constructor.slot_start_y || 0);
        return out;
    }

    /* Force align to grid */
    alignToGrid() {
        this.pos[0] = defaultConfig.CANVAS_GRID_SIZE
            * Math.round(this.pos[0] / defaultConfig.CANVAS_GRID_SIZE);
        this.pos[1] = defaultConfig.CANVAS_GRID_SIZE
            * Math.round(this.pos[1] / defaultConfig.CANVAS_GRID_SIZE);
    }

    /* Console output */
    trace(msg) {
        if (!this.console) {
            this.console = [];
        }

        this.console.push(msg);
        if (this.console.length > LGraphNode.MAX_CONSOLE) {
            this.console.shift();
        }

        if (this.graph.onNodeTrace) this.graph.onNodeTrace(this, msg);
    }

    /* Forces to redraw or the main canvas (LGraphNode) or the bg canvas (links) */
    setDirtyCanvas(
        dirty_foreground,
        dirty_background,
    ) {
        if (!this.graph) {
            return;
        }
        this.graph.sendActionToCanvas("setDirty", [
            dirty_foreground,
            dirty_background,
        ]);
    }

    loadImage(url) {
        const img = new Image();
        img.src = defaultConfig.node_images_path + url;
        img.ready = false;

        img.onload = () => {
            img.ready = true;
            this.setDirtyCanvas(true);
        };
        return img;
    }

    // safe LGraphNode action execution (not sure if safe)
    /*
    executeAction = function(action)
    {
    if(action == "") return false;

    if( action.indexOf(";") != -1 || action.indexOf("}") != -1)
    {
    this.trace("Error: Action contains unsafe characters");
    return false;
    }

    var tokens = action.split("(");
    var func_name = tokens[0];
    if( typeof(this[func_name]) != "function")
    {
    this.trace("Error: Action not found on node: " + func_name);
    return false;
    }

    var code = action;

    try
    {
    var _foo = eval;
    eval = null;
    (new Function("with(this) { " + code + "}")).call(this);
    eval = _foo;
    }
    catch (err)
    {
    this.trace("Error executing action {" + action + "} :" + err);
    return false;
    }

    return true;
    }
    */

    /* Allows to get onMouseMove and onMouseUp events even if the mouse is out of focus */
    captureInput(v) {
        if (!this.graph || !this.graph.list_of_graphcanvas) {
            return;
        }

        const list = this.graph.list_of_graphcanvas;

        for (let i = 0; i &lt; list.length; ++i) {
            const c = list[i];
            // releasing somebody elses capture?!
            if (!v &amp;&amp; c.node_capturing_input != this) {
                continue;
            }

            // change
            c.node_capturing_input = v ? this : null;
        }
    }

    /**
     * Collapse the node to make it smaller on the canvas
     * @method collapse
     * @memberOf LGraphNode
     * */
    collapse(force) {
        this.graph._version++;
        if (this.constructor.collapsable === false &amp;&amp; !force) {
            return;
        }
        this.flags.collapsed = !this.flags.collapsed;
        this.setDirtyCanvas(true, true);
    }

    /**
     * Forces the node to do not move or realign on Z
     * @method pin
     * @memberOf LGraphNode
     * */

    pin(v) {
        this.graph._version++;
        if (v === undefined) {
            this.flags.pinned = !this.flags.pinned;
        } else {
            this.flags.pinned = v;
        }
    }

    localToScreen(x, y, graphcanvas) {
        return [
            (x + this.pos[0]) * graphcanvas.scale + graphcanvas.offset[0],
            (y + this.pos[1]) * graphcanvas.scale + graphcanvas.offset[1],
        ];
    }

    /**
     * Create a node of a given type with a name. The node is not attached to any graph yet.
     * @method createNode
     * @param {String} type full name of the node class. p.e. "math/sin"
     * @param {String} name a name to distinguish from other nodes
     * @param {Object} options to set options
     * @memberOf LGraphNode
     */
    static createNode(type, title, options) {
        const baseClass = defaultConfig.registered_node_types[type];
        if (!baseClass) {
            if (defaultConfig.debug) console.log(`GraphNode type "${type}" not registered.`);
            return null;
        }

        const prototype = baseClass.prototype || baseClass;

        title = title || baseClass.title || type;

        let node = null;

        if (defaultConfig.catch_exceptions) {
            try {
                node = new baseClass(title);
            } catch (err) {
                console.error(err);
                return null;
            }
        } else {
            node = new baseClass(title);
        }

        node.type = type;

        if (!node.title &amp;&amp; title) {
            node.title = title;
        }
        if (!node.properties) {
            node.properties = {};
        }
        if (!node.properties_info) {
            node.properties_info = [];
        }
        if (!node.flags) {
            node.flags = {};
        }
        if (!node.size) {
            node.size = node.computeSize();
            // call onresize?
        }
        if (!node.pos) {
            node.pos = defaultConfig.DEFAULT_POSITION.concat();
        }
        if (!node.mode) {
            node.mode = defaultConfig.ALWAYS;
        }

        // extra options
        if (options) {
            // eslint-disable-next-line
            for (const i in options) node[i] = options[i];
        }

        return node;
    }

    // debug purposes: reloads all the js scripts that matches a wildcard
    static reloadNodes(folderWildcard) {
        const tmp = document.getElementsByTagName("script");
        // weird, this array changes by its own, so we use a copy
        const scriptFiles = [];
        for (const t of tmp) scriptFiles.push(t);

        const docHeadObj = document.getElementsByTagName("head")[0];
        folderWildcard = document.location.href + folderWildcard;

        for (const script of scriptFiles) {
            const { src } = script;
            if (
                !src
                || src.substr(0, folderWildcard.length) !== folderWildcard
            ) continue;

            try {
                if (defaultConfig.debug) {
                    console.log(`Reloading: ${src}`);
                }
                const dynamicScript = document.createElement("script");
                dynamicScript.type = "text/javascript";
                dynamicScript.src = src;
                docHeadObj.appendChild(dynamicScript);
                docHeadObj.removeChild(scriptFiles[i]);
            } catch (err) {
                if (defaultConfig.throw_errors) {
                    throw err;
                }
                if (defaultConfig.debug) console.log(`Error while reloading ${src}`);
            }
        }

        if (defaultConfig.debug) {
            console.log("Nodes reloaded");
        }
    }

    /**
     * Adds this method to all nodetypes, existing and to be created
     * (You can add it to LGraphNode.prototype but then existing node types wont have it)
     * @method addNodeMethod
     * @param {Function} func
     * @memberOf LGraphNode
     */
    static addNodeMethod(name, func) {
        LGraphNode.prototype[name] = func;
        for (const i in defaultConfig.registered_node_types) {
            const type = defaultConfig.registered_node_types[i];
            if (type.prototype[name]) type.prototype[`_${name}`] = type.prototype[name];
            type.prototype[name] = func;
        }
    }

    static extendNode(object) {
        for (const i of Object.getOwnPropertyNames(LGraphNode.prototype)) {
            if (!object.prototype[i]) {
                object.prototype[i] = LGraphNode.prototype[i];
            }
        }
    }

}
</code></pre>
        </article>
    </section>




</div>

<footer id="footer">
  
</footer>

<script src="scripts/third-party/prettify.js"></script>
<script src="scripts/third-party/lang-css.js"></script>
<script src="scripts/search.js"></script>
<script src="scripts/third-party/fuse.js"></script>
<script type="text/javascript" src="scripts/misc.js"></script>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
<script src="scripts/fix-code-block.js"></script>
<script>
  var list = [{"title":"ContextMenu","link":"<a href=\"ContextMenu.html\">ContextMenu</a>"},{"title":"CurveEditor","link":"<a href=\"CurveEditor.html\">CurveEditor</a>"},{"title":"DragAndScale","link":"<a href=\"DragAndScale.html\">DragAndScale</a>"},{"title":"Editor","link":"<a href=\"Editor.html\">Editor</a>"},{"title":"LGraph","link":"<a href=\"LGraph.html\">LGraph</a>"},{"title":"LGraph.add","link":"<a href=\"LGraph.html#.add\">LGraph.add &rtrif; undefined</a>"},{"title":"LGraph.addGlobalInput","link":"<a href=\"LGraph.html#.addGlobalInput\">LGraph.addGlobalInput &rtrif; undefined</a>"},{"title":"LGraph.addOutput","link":"<a href=\"LGraph.html#.addOutput\">LGraph.addOutput &rtrif; undefined</a>"},{"title":"LGraph.arrange","link":"<a href=\"LGraph.html#.arrange\">LGraph.arrange &rtrif; undefined</a>"},{"title":"LGraph.attachCanvas","link":"<a href=\"LGraph.html#.attachCanvas\">LGraph.attachCanvas &rtrif; undefined</a>"},{"title":"LGraph.changeInputType","link":"<a href=\"LGraph.html#.changeInputType\">LGraph.changeInputType &rtrif; undefined</a>"},{"title":"LGraph.changeOutputType","link":"<a href=\"LGraph.html#.changeOutputType\">LGraph.changeOutputType &rtrif; undefined</a>"},{"title":"LGraph.checkNodeTypes","link":"<a href=\"LGraph.html#.checkNodeTypes\">LGraph.checkNodeTypes &rtrif; undefined</a>"},{"title":"LGraph.clear","link":"<a href=\"LGraph.html#.clear\">LGraph.clear &rtrif; undefined</a>"},{"title":"LGraph.clearTriggeredSlots","link":"<a href=\"LGraph.html#.clearTriggeredSlots\">LGraph.clearTriggeredSlots &rtrif; undefined</a>"},{"title":"LGraph.configure","link":"<a href=\"LGraph.html#.configure\">LGraph.configure &rtrif; undefined</a>"},{"title":"LGraph.detachCanvas","link":"<a href=\"LGraph.html#.detachCanvas\">LGraph.detachCanvas &rtrif; undefined</a>"},{"title":"LGraph.findNodeByTitle","link":"<a href=\"LGraph.html#.findNodeByTitle\">LGraph.findNodeByTitle &rtrif; undefined</a>"},{"title":"LGraph.findNodesByClass","link":"<a href=\"LGraph.html#.findNodesByClass\">LGraph.findNodesByClass &rtrif; undefined</a>"},{"title":"LGraph.findNodesByTitle","link":"<a href=\"LGraph.html#.findNodesByTitle\">LGraph.findNodesByTitle &rtrif; undefined</a>"},{"title":"LGraph.findNodesByType","link":"<a href=\"LGraph.html#.findNodesByType\">LGraph.findNodesByType &rtrif; undefined</a>"},{"title":"LGraph.getAncestors","link":"<a href=\"LGraph.html#.getAncestors\">LGraph.getAncestors &rtrif; undefined</a>"},{"title":"LGraph.getElapsedTime","link":"<a href=\"LGraph.html#.getElapsedTime\">LGraph.getElapsedTime &rtrif; undefined</a>"},{"title":"LGraph.getFixedTime","link":"<a href=\"LGraph.html#.getFixedTime\">LGraph.getFixedTime &rtrif; undefined</a>"},{"title":"LGraph.getGroupOnPos","link":"<a href=\"LGraph.html#.getGroupOnPos\">LGraph.getGroupOnPos &rtrif; undefined</a>"},{"title":"LGraph.getInputData","link":"<a href=\"LGraph.html#.getInputData\">LGraph.getInputData &rtrif; undefined</a>"},{"title":"LGraph.getNodeById","link":"<a href=\"LGraph.html#.getNodeById\">LGraph.getNodeById &rtrif; undefined</a>"},{"title":"LGraph.getNodeOnPos","link":"<a href=\"LGraph.html#.getNodeOnPos\">LGraph.getNodeOnPos &rtrif; undefined</a>"},{"title":"LGraph.getOutputData","link":"<a href=\"LGraph.html#.getOutputData\">LGraph.getOutputData &rtrif; undefined</a>"},{"title":"LGraph.getTime","link":"<a href=\"LGraph.html#.getTime\">LGraph.getTime &rtrif; undefined</a>"},{"title":"LGraph.isLive","link":"<a href=\"LGraph.html#.isLive\">LGraph.isLive &rtrif; undefined</a>"},{"title":"LGraph.remove","link":"<a href=\"LGraph.html#.remove\">LGraph.remove &rtrif; undefined</a>"},{"title":"LGraph.removeInput","link":"<a href=\"LGraph.html#.removeInput\">LGraph.removeInput &rtrif; undefined</a>"},{"title":"LGraph.removeLink","link":"<a href=\"LGraph.html#.removeLink\">LGraph.removeLink &rtrif; undefined</a>"},{"title":"LGraph.removeOutput","link":"<a href=\"LGraph.html#.removeOutput\">LGraph.removeOutput &rtrif; undefined</a>"},{"title":"LGraph.renameInput","link":"<a href=\"LGraph.html#.renameInput\">LGraph.renameInput &rtrif; undefined</a>"},{"title":"LGraph.renameOutput","link":"<a href=\"LGraph.html#.renameOutput\">LGraph.renameOutput &rtrif; undefined</a>"},{"title":"LGraph.runStep","link":"<a href=\"LGraph.html#.runStep\">LGraph.runStep &rtrif; undefined</a>"},{"title":"LGraph.sendEventToAllNodes","link":"<a href=\"LGraph.html#.sendEventToAllNodes\">LGraph.sendEventToAllNodes &rtrif; undefined</a>"},{"title":"LGraph.serialize","link":"<a href=\"LGraph.html#.serialize\">LGraph.serialize &rtrif; undefined</a>"},{"title":"LGraph.setGlobalInputData","link":"<a href=\"LGraph.html#.setGlobalInputData\">LGraph.setGlobalInputData &rtrif; undefined</a>"},{"title":"LGraph.setOutputData","link":"<a href=\"LGraph.html#.setOutputData\">LGraph.setOutputData &rtrif; undefined</a>"},{"title":"LGraph.start","link":"<a href=\"LGraph.html#.start\">LGraph.start &rtrif; undefined</a>"},{"title":"LGraph.stop execution","link":"<a href=\"LGraph.html#.stopexecution\">LGraph.stop execution &rtrif; undefined</a>"},{"title":"LGraph.updateExecutionOrder","link":"<a href=\"LGraph.html#.updateExecutionOrder\">LGraph.updateExecutionOrder &rtrif; undefined</a>"},{"title":"LGraph#computeExecutionOrder","link":"<a href=\"LGraph.html#computeExecutionOrder\">LGraph &rtrif; computeExecutionOrder</a>"},{"title":"LGraph#onNodeTrace","link":"<a href=\"LGraph.html#onNodeTrace\">LGraph &rtrif; onNodeTrace</a>"},{"title":"LGraphCanvas","link":"<a href=\"LGraphCanvas.html\">LGraphCanvas</a>"},{"title":"LGraphCanvas.adjustMouseEvent","link":"<a href=\"LGraphCanvas.html#.adjustMouseEvent\">LGraphCanvas.adjustMouseEvent &rtrif; undefined</a>"},{"title":"LGraphCanvas.bindEvents","link":"<a href=\"LGraphCanvas.html#.bindEvents\">LGraphCanvas.bindEvents &rtrif; undefined</a>"},{"title":"LGraphCanvas.blockClick","link":"<a href=\"LGraphCanvas.html#.blockClick\">LGraphCanvas.blockClick &rtrif; undefined</a>"},{"title":"LGraphCanvas.bringToFront","link":"<a href=\"LGraphCanvas.html#.bringToFront\">LGraphCanvas.bringToFront &rtrif; undefined</a>"},{"title":"LGraphCanvas.centerOnNode","link":"<a href=\"LGraphCanvas.html#.centerOnNode\">LGraphCanvas.centerOnNode &rtrif; undefined</a>"},{"title":"LGraphCanvas.clear","link":"<a href=\"LGraphCanvas.html#.clear\">LGraphCanvas.clear &rtrif; undefined</a>"},{"title":"LGraphCanvas.closeSubgraph","link":"<a href=\"LGraphCanvas.html#.closeSubgraph\">LGraphCanvas.closeSubgraph &rtrif; undefined</a>"},{"title":"LGraphCanvas.computeConnectionPoint","link":"<a href=\"LGraphCanvas.html#.computeConnectionPoint\">LGraphCanvas.computeConnectionPoint &rtrif; undefined</a>"},{"title":"LGraphCanvas.computeVisibleNodes","link":"<a href=\"LGraphCanvas.html#.computeVisibleNodes\">LGraphCanvas.computeVisibleNodes &rtrif; undefined</a>"},{"title":"LGraphCanvas.convertCanvasToOffset","link":"<a href=\"LGraphCanvas.html#.convertCanvasToOffset\">LGraphCanvas.convertCanvasToOffset &rtrif; undefined</a>"},{"title":"LGraphCanvas.convertEventToCanvasOffset","link":"<a href=\"LGraphCanvas.html#.convertEventToCanvasOffset\">LGraphCanvas.convertEventToCanvasOffset &rtrif; undefined</a>"},{"title":"LGraphCanvas.convertOffsetToCanvas","link":"<a href=\"LGraphCanvas.html#.convertOffsetToCanvas\">LGraphCanvas.convertOffsetToCanvas &rtrif; undefined</a>"},{"title":"LGraphCanvas.deleteSelectedNodes","link":"<a href=\"LGraphCanvas.html#.deleteSelectedNodes\">LGraphCanvas.deleteSelectedNodes &rtrif; undefined</a>"},{"title":"LGraphCanvas.deselectAllNodes","link":"<a href=\"LGraphCanvas.html#.deselectAllNodes\">LGraphCanvas.deselectAllNodes &rtrif; undefined</a>"},{"title":"LGraphCanvas.deselectNode","link":"<a href=\"LGraphCanvas.html#.deselectNode\">LGraphCanvas.deselectNode &rtrif; undefined</a>"},{"title":"LGraphCanvas.draw","link":"<a href=\"LGraphCanvas.html#.draw\">LGraphCanvas.draw &rtrif; undefined</a>"},{"title":"LGraphCanvas.drawBackCanvas","link":"<a href=\"LGraphCanvas.html#.drawBackCanvas\">LGraphCanvas.drawBackCanvas &rtrif; undefined</a>"},{"title":"LGraphCanvas.drawButton","link":"<a href=\"LGraphCanvas.html#.drawButton\">LGraphCanvas.drawButton &rtrif; undefined</a>"},{"title":"LGraphCanvas.drawConnections","link":"<a href=\"LGraphCanvas.html#.drawConnections\">LGraphCanvas.drawConnections &rtrif; undefined</a>"},{"title":"LGraphCanvas.drawFrontCanvas","link":"<a href=\"LGraphCanvas.html#.drawFrontCanvas\">LGraphCanvas.drawFrontCanvas &rtrif; undefined</a>"},{"title":"LGraphCanvas.drawGroups","link":"<a href=\"LGraphCanvas.html#.drawGroups\">LGraphCanvas.drawGroups &rtrif; undefined</a>"},{"title":"LGraphCanvas.drawNode","link":"<a href=\"LGraphCanvas.html#.drawNode\">LGraphCanvas.drawNode &rtrif; undefined</a>"},{"title":"LGraphCanvas.drawNodeShape","link":"<a href=\"LGraphCanvas.html#.drawNodeShape\">LGraphCanvas.drawNodeShape &rtrif; undefined</a>"},{"title":"LGraphCanvas.drawNodeWidgets","link":"<a href=\"LGraphCanvas.html#.drawNodeWidgets\">LGraphCanvas.drawNodeWidgets &rtrif; undefined</a>"},{"title":"LGraphCanvas.drawSubgraphPanel","link":"<a href=\"LGraphCanvas.html#.drawSubgraphPanel\">LGraphCanvas.drawSubgraphPanel &rtrif; undefined</a>"},{"title":"LGraphCanvas.enableWebGL","link":"<a href=\"LGraphCanvas.html#.enableWebGL\">LGraphCanvas.enableWebGL &rtrif; undefined</a>"},{"title":"LGraphCanvas.getCanvasWindow","link":"<a href=\"LGraphCanvas.html#.getCanvasWindow\">LGraphCanvas.getCanvasWindow &rtrif; undefined</a>"},{"title":"LGraphCanvas.getCurrentGraph","link":"<a href=\"LGraphCanvas.html#.getCurrentGraph\">LGraphCanvas.getCurrentGraph &rtrif; undefined</a>"},{"title":"LGraphCanvas.getTopGraph","link":"<a href=\"LGraphCanvas.html#.getTopGraph\">LGraphCanvas.getTopGraph &rtrif; undefined</a>"},{"title":"LGraphCanvas.isOverNodeBox","link":"<a href=\"LGraphCanvas.html#.isOverNodeBox\">LGraphCanvas.isOverNodeBox &rtrif; undefined</a>"},{"title":"LGraphCanvas.isOverNodeInput","link":"<a href=\"LGraphCanvas.html#.isOverNodeInput\">LGraphCanvas.isOverNodeInput &rtrif; undefined</a>"},{"title":"LGraphCanvas.onGroupAdd","link":"<a href=\"LGraphCanvas.html#.onGroupAdd\">LGraphCanvas.onGroupAdd &rtrif; undefined</a>"},{"title":"LGraphCanvas.onMenuCollapseAll","link":"<a href=\"LGraphCanvas.html#.onMenuCollapseAll\">LGraphCanvas.onMenuCollapseAll &rtrif; undefined</a>"},{"title":"LGraphCanvas.onMenuNodeEdit","link":"<a href=\"LGraphCanvas.html#.onMenuNodeEdit\">LGraphCanvas.onMenuNodeEdit &rtrif; undefined</a>"},{"title":"LGraphCanvas.onNodeSelectionChange","link":"<a href=\"LGraphCanvas.html#.onNodeSelectionChange\">LGraphCanvas.onNodeSelectionChange &rtrif; undefined</a>"},{"title":"LGraphCanvas.openSubgraph","link":"<a href=\"LGraphCanvas.html#.openSubgraph\">LGraphCanvas.openSubgraph &rtrif; undefined</a>"},{"title":"LGraphCanvas.processDrop","link":"<a href=\"LGraphCanvas.html#.processDrop\">LGraphCanvas.processDrop &rtrif; undefined</a>"},{"title":"LGraphCanvas.processKey","link":"<a href=\"LGraphCanvas.html#.processKey\">LGraphCanvas.processKey &rtrif; undefined</a>"},{"title":"LGraphCanvas.processMouseMove","link":"<a href=\"LGraphCanvas.html#.processMouseMove\">LGraphCanvas.processMouseMove &rtrif; undefined</a>"},{"title":"LGraphCanvas.processMouseUp","link":"<a href=\"LGraphCanvas.html#.processMouseUp\">LGraphCanvas.processMouseUp &rtrif; undefined</a>"},{"title":"LGraphCanvas.processMouseWheel","link":"<a href=\"LGraphCanvas.html#.processMouseWheel\">LGraphCanvas.processMouseWheel &rtrif; undefined</a>"},{"title":"LGraphCanvas.processNodeWidgets","link":"<a href=\"LGraphCanvas.html#.processNodeWidgets\">LGraphCanvas.processNodeWidgets &rtrif; undefined</a>"},{"title":"LGraphCanvas.renderFrame","link":"<a href=\"LGraphCanvas.html#.renderFrame\">LGraphCanvas.renderFrame &rtrif; undefined</a>"},{"title":"LGraphCanvas.renderInfo","link":"<a href=\"LGraphCanvas.html#.renderInfo\">LGraphCanvas.renderInfo &rtrif; undefined</a>"},{"title":"LGraphCanvas.renderLink","link":"<a href=\"LGraphCanvas.html#.renderLink\">LGraphCanvas.renderLink &rtrif; undefined</a>"},{"title":"LGraphCanvas.resize","link":"<a href=\"LGraphCanvas.html#.resize\">LGraphCanvas.resize &rtrif; undefined</a>"},{"title":"LGraphCanvas.selectNode","link":"<a href=\"LGraphCanvas.html#.selectNode\">LGraphCanvas.selectNode &rtrif; undefined</a>"},{"title":"LGraphCanvas.selectNodes","link":"<a href=\"LGraphCanvas.html#.selectNodes\">LGraphCanvas.selectNodes &rtrif; undefined</a>"},{"title":"LGraphCanvas.sendToBack","link":"<a href=\"LGraphCanvas.html#.sendToBack\">LGraphCanvas.sendToBack &rtrif; undefined</a>"},{"title":"LGraphCanvas.setCanvas","link":"<a href=\"LGraphCanvas.html#.setCanvas\">LGraphCanvas.setCanvas &rtrif; undefined</a>"},{"title":"LGraphCanvas.setDirty","link":"<a href=\"LGraphCanvas.html#.setDirty\">LGraphCanvas.setDirty &rtrif; undefined</a>"},{"title":"LGraphCanvas.setGraph","link":"<a href=\"LGraphCanvas.html#.setGraph\">LGraphCanvas.setGraph &rtrif; undefined</a>"},{"title":"LGraphCanvas.setZoom","link":"<a href=\"LGraphCanvas.html#.setZoom\">LGraphCanvas.setZoom &rtrif; undefined</a>"},{"title":"LGraphCanvas.startRendering","link":"<a href=\"LGraphCanvas.html#.startRendering\">LGraphCanvas.startRendering &rtrif; undefined</a>"},{"title":"LGraphCanvas.stopRendering","link":"<a href=\"LGraphCanvas.html#.stopRendering\">LGraphCanvas.stopRendering &rtrif; undefined</a>"},{"title":"LGraphCanvas.switchLiveMode","link":"<a href=\"LGraphCanvas.html#.switchLiveMode\">LGraphCanvas.switchLiveMode &rtrif; undefined</a>"},{"title":"LGraphCanvas.touchHandler","link":"<a href=\"LGraphCanvas.html#.touchHandler\">LGraphCanvas.touchHandler &rtrif; undefined</a>"},{"title":"LGraphCanvas.unbindEvents","link":"<a href=\"LGraphCanvas.html#.unbindEvents\">LGraphCanvas.unbindEvents &rtrif; undefined</a>"},{"title":"LGraphGroup","link":"<a href=\"LGraphGroup.html\">LGraphGroup</a>"},{"title":"LGraphNode","link":"<a href=\"LGraphNode.html\">LGraphNode</a>"},{"title":"LGraphNode.addConnection","link":"<a href=\"LGraphNode.html#.addConnection\">LGraphNode.addConnection &rtrif; undefined</a>"},{"title":"LGraphNode.addInput","link":"<a href=\"LGraphNode.html#.addInput\">LGraphNode.addInput &rtrif; undefined</a>"},{"title":"LGraphNode.addInputs","link":"<a href=\"LGraphNode.html#.addInputs\">LGraphNode.addInputs &rtrif; undefined</a>"},{"title":"LGraphNode.addNodeMethod","link":"<a href=\"LGraphNode.html#.addNodeMethod\">LGraphNode.addNodeMethod &rtrif; undefined</a>"},{"title":"LGraphNode.addOutput","link":"<a href=\"LGraphNode.html#.addOutput\">LGraphNode.addOutput &rtrif; undefined</a>"},{"title":"LGraphNode.addOutputs","link":"<a href=\"LGraphNode.html#.addOutputs\">LGraphNode.addOutputs &rtrif; undefined</a>"},{"title":"LGraphNode.addProperty","link":"<a href=\"LGraphNode.html#.addProperty\">LGraphNode.addProperty &rtrif; undefined</a>"},{"title":"LGraphNode.addWidget","link":"<a href=\"LGraphNode.html#.addWidget\">LGraphNode.addWidget &rtrif; undefined</a>"},{"title":"LGraphNode.clearTriggeredSlot","link":"<a href=\"LGraphNode.html#.clearTriggeredSlot\">LGraphNode.clearTriggeredSlot &rtrif; undefined</a>"},{"title":"LGraphNode.collapse","link":"<a href=\"LGraphNode.html#.collapse\">LGraphNode.collapse &rtrif; undefined</a>"},{"title":"LGraphNode.computeSize","link":"<a href=\"LGraphNode.html#.computeSize\">LGraphNode.computeSize &rtrif; undefined</a>"},{"title":"LGraphNode.configure","link":"<a href=\"LGraphNode.html#.configure\">LGraphNode.configure &rtrif; undefined</a>"},{"title":"LGraphNode.connect","link":"<a href=\"LGraphNode.html#.connect\">LGraphNode.connect &rtrif; undefined</a>"},{"title":"LGraphNode.createNode","link":"<a href=\"LGraphNode.html#.createNode\">LGraphNode.createNode &rtrif; undefined</a>"},{"title":"LGraphNode.disconnectInput","link":"<a href=\"LGraphNode.html#.disconnectInput\">LGraphNode.disconnectInput &rtrif; undefined</a>"},{"title":"LGraphNode.disconnectOutput","link":"<a href=\"LGraphNode.html#.disconnectOutput\">LGraphNode.disconnectOutput &rtrif; undefined</a>"},{"title":"LGraphNode.findInputSlot","link":"<a href=\"LGraphNode.html#.findInputSlot\">LGraphNode.findInputSlot &rtrif; undefined</a>"},{"title":"LGraphNode.findOutputSlot","link":"<a href=\"LGraphNode.html#.findOutputSlot\">LGraphNode.findOutputSlot &rtrif; undefined</a>"},{"title":"LGraphNode.getBounding","link":"<a href=\"LGraphNode.html#.getBounding\">LGraphNode.getBounding &rtrif; undefined</a>"},{"title":"LGraphNode.getConnectionPos","link":"<a href=\"LGraphNode.html#.getConnectionPos\">LGraphNode.getConnectionPos &rtrif; undefined</a>"},{"title":"LGraphNode.getInputData","link":"<a href=\"LGraphNode.html#.getInputData\">LGraphNode.getInputData &rtrif; undefined</a>"},{"title":"LGraphNode.getInputDataByName","link":"<a href=\"LGraphNode.html#.getInputDataByName\">LGraphNode.getInputDataByName &rtrif; undefined</a>"},{"title":"LGraphNode.getInputDataType","link":"<a href=\"LGraphNode.html#.getInputDataType\">LGraphNode.getInputDataType &rtrif; undefined</a>"},{"title":"LGraphNode.getInputInfo","link":"<a href=\"LGraphNode.html#.getInputInfo\">LGraphNode.getInputInfo &rtrif; undefined</a>"},{"title":"LGraphNode.getInputLink","link":"<a href=\"LGraphNode.html#.getInputLink\">LGraphNode.getInputLink &rtrif; undefined</a>"},{"title":"LGraphNode.getInputNode","link":"<a href=\"LGraphNode.html#.getInputNode\">LGraphNode.getInputNode &rtrif; undefined</a>"},{"title":"LGraphNode.getInputOrProperty","link":"<a href=\"LGraphNode.html#.getInputOrProperty\">LGraphNode.getInputOrProperty &rtrif; undefined</a>"},{"title":"LGraphNode.getOutputData","link":"<a href=\"LGraphNode.html#.getOutputData\">LGraphNode.getOutputData &rtrif; undefined</a>"},{"title":"LGraphNode.getOutputInfo","link":"<a href=\"LGraphNode.html#.getOutputInfo\">LGraphNode.getOutputInfo &rtrif; undefined</a>"},{"title":"LGraphNode.getOutputNodes","link":"<a href=\"LGraphNode.html#.getOutputNodes\">LGraphNode.getOutputNodes &rtrif; undefined</a>"},{"title":"LGraphNode.getPropertyInfo","link":"<a href=\"LGraphNode.html#.getPropertyInfo\">LGraphNode.getPropertyInfo &rtrif; undefined</a>"},{"title":"LGraphNode.getSlotInPosition","link":"<a href=\"LGraphNode.html#.getSlotInPosition\">LGraphNode.getSlotInPosition &rtrif; undefined</a>"},{"title":"LGraphNode.getTitle","link":"<a href=\"LGraphNode.html#.getTitle\">LGraphNode.getTitle &rtrif; undefined</a>"},{"title":"LGraphNode.isAnyOutputConnected","link":"<a href=\"LGraphNode.html#.isAnyOutputConnected\">LGraphNode.isAnyOutputConnected &rtrif; undefined</a>"},{"title":"LGraphNode.isInputConnected","link":"<a href=\"LGraphNode.html#.isInputConnected\">LGraphNode.isInputConnected &rtrif; undefined</a>"},{"title":"LGraphNode.isOutputConnected","link":"<a href=\"LGraphNode.html#.isOutputConnected\">LGraphNode.isOutputConnected &rtrif; undefined</a>"},{"title":"LGraphNode.isPointInside","link":"<a href=\"LGraphNode.html#.isPointInside\">LGraphNode.isPointInside &rtrif; undefined</a>"},{"title":"LGraphNode.pin","link":"<a href=\"LGraphNode.html#.pin\">LGraphNode.pin &rtrif; undefined</a>"},{"title":"LGraphNode.removeInput","link":"<a href=\"LGraphNode.html#.removeInput\">LGraphNode.removeInput &rtrif; undefined</a>"},{"title":"LGraphNode.removeOutput","link":"<a href=\"LGraphNode.html#.removeOutput\">LGraphNode.removeOutput &rtrif; undefined</a>"},{"title":"LGraphNode.serialize","link":"<a href=\"LGraphNode.html#.serialize\">LGraphNode.serialize &rtrif; undefined</a>"},{"title":"LGraphNode.setOutputData","link":"<a href=\"LGraphNode.html#.setOutputData\">LGraphNode.setOutputData &rtrif; undefined</a>"},{"title":"LGraphNode.setOutputDataType","link":"<a href=\"LGraphNode.html#.setOutputDataType\">LGraphNode.setOutputDataType &rtrif; undefined</a>"},{"title":"LGraphNode.setProperty","link":"<a href=\"LGraphNode.html#.setProperty\">LGraphNode.setProperty &rtrif; undefined</a>"},{"title":"LGraphNode.setSize","link":"<a href=\"LGraphNode.html#.setSize\">LGraphNode.setSize &rtrif; undefined</a>"},{"title":"LGraphNode.toString","link":"<a href=\"LGraphNode.html#.toString\">LGraphNode.toString &rtrif; undefined</a>"},{"title":"LGraphNode.trigger","link":"<a href=\"LGraphNode.html#.trigger\">LGraphNode.trigger &rtrif; undefined</a>"},{"title":"LGraphNode.triggerSlot","link":"<a href=\"LGraphNode.html#.triggerSlot\">LGraphNode.triggerSlot &rtrif; undefined</a>"},{"title":"LLink","link":"<a href=\"LLink.html\">LLink</a>"},{"title":"File Utils","link":"<a href=\"module-File%2520Utils.html\">File Utils</a>"},{"title":"module:File Utils~fetchFile","link":"<a href=\"module-File%252520Utils.html#~fetchFile\">module:File Utils~fetchFile &rtrif; undefined</a>"},{"title":"Function Utils","link":"<a href=\"module-Function%2520Utils.html\">Function Utils</a>"},{"title":"module:Function Utils~isValidConnection","link":"<a href=\"module-Function%252520Utils.html#~isValidConnection\">module:Function Utils~isValidConnection &rtrif; undefined</a>"},{"title":"module:Function Utils~wrapFunctionAsNode","link":"<a href=\"module-Function%252520Utils.html#~wrapFunctionAsNode\">module:Function Utils~wrapFunctionAsNode &rtrif; undefined</a>"},{"title":"Math Utils","link":"<a href=\"module-Math%2520Utils.html\">Math Utils</a>"},{"title":"Object Utils","link":"<a href=\"module-Object%2520Utils.html\">Object Utils</a>"},{"title":"Registry Manager","link":"<a href=\"module-Registry%2520Manager.html\">Registry Manager</a>"},{"title":"module:Registry Manager.clearRegisteredTypes","link":"<a href=\"module-Registry%252520Manager.html#.clearRegisteredTypes\">module:Registry Manager.clearRegisteredTypes &rtrif; undefined</a>"},{"title":"module:Registry Manager~getNodeType","link":"<a href=\"module-Registry%252520Manager.html#~getNodeType\">module:Registry Manager~getNodeType &rtrif; undefined</a>"},{"title":"module:Registry Manager~getNodeType","link":"<a href=\"module-Registry%252520Manager.html#~getNodeType\">module:Registry Manager~getNodeType &rtrif; undefined</a>"},{"title":"module:Registry Manager~getNodeTypesCategories","link":"<a href=\"module-Registry%252520Manager.html#~getNodeTypesCategories\">module:Registry Manager~getNodeTypesCategories &rtrif; undefined</a>"},{"title":"module:Registry Manager~registerNodeType","link":"<a href=\"module-Registry%252520Manager.html#~registerNodeType\">module:Registry Manager~registerNodeType &rtrif; undefined</a>"},{"title":"module:Registry Manager~registerSearchboxExtra","link":"<a href=\"module-Registry%252520Manager.html#~registerSearchboxExtra\">module:Registry Manager~registerSearchboxExtra &rtrif; undefined</a>"},{"title":"module:Registry Manager~unregisterNodeType","link":"<a href=\"module-Registry%252520Manager.html#~unregisterNodeType\">module:Registry Manager~unregisterNodeType &rtrif; undefined</a>"},{"title":"Time Utils","link":"<a href=\"module-Time%2520Utils.html\">Time Utils</a>"}];
  var options = 
  setupSearch(list, options)
</script>

 




  <script type="text/javascript">
    var option = JSON.parse('{"option":{}}')
    console.log(option)
    document.addEventListener("DOMContentLoaded", function() {
    OverlayScrollbars(document.querySelectorAll('body'), option.option || {});
  });
  </script>



</body>
</html>

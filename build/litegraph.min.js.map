{"version":3,"file":"litegraph.min.js","sources":["../node_modules/style-inject/dist/style-inject.es.js","../src/utils/defaultConfig.js","../src/utils/time.js","../src/utils/object.js","../src/utils/registry.js","../src/utils/function.js","../src/LLink.js","../src/utils/math.js","../src/LGraphNode.js","../src/LGraphGroup.js","../src/DragAndScale.js","../src/ContextMenu.js","../src/LGraphCanvas.js","../src/utils/file.js","../src/LGraph.js","../src/CurveEditor.js","../src/litegraph-editor.js","../src/index.js"],"sourcesContent":["function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","export default {\n    VERSION: 0.4,\n\n    CANVAS_GRID_SIZE: 10,\n\n    NODE_TITLE_HEIGHT: 30,\n    NODE_TITLE_TEXT_Y: 20,\n    NODE_SLOT_HEIGHT: 20,\n    NODE_WIDGET_HEIGHT: 20,\n    NODE_WIDTH: 140,\n    NODE_MIN_WIDTH: 50,\n    NODE_COLLAPSED_RADIUS: 10,\n    NODE_COLLAPSED_WIDTH: 80,\n    NODE_TITLE_COLOR: \"#999\",\n    NODE_SELECTED_TITLE_COLOR: \"#FFF\",\n    NODE_TEXT_SIZE: 14,\n    NODE_TEXT_COLOR: \"#AAA\",\n    NODE_SUBTEXT_SIZE: 12,\n    NODE_DEFAULT_COLOR: \"#333\",\n    NODE_DEFAULT_BGCOLOR: \"#353535\",\n    NODE_DEFAULT_BOXCOLOR: \"#666\",\n    NODE_DEFAULT_SHAPE: \"box\",\n    NODE_BOX_OUTLINE_COLOR: \"#FFF\",\n    DEFAULT_SHADOW_COLOR: \"rgba(0,0,0,0.5)\",\n    DEFAULT_GROUP_FONT: 24,\n\n    WIDGET_BGCOLOR: \"#222\",\n    WIDGET_OUTLINE_COLOR: \"#666\",\n    WIDGET_TEXT_COLOR: \"#DDD\",\n    WIDGET_SECONDARY_TEXT_COLOR: \"#999\",\n\n    LINK_COLOR: \"#9A9\",\n    EVENT_LINK_COLOR: \"#A86\",\n    CONNECTING_LINK_COLOR: \"#AFA\",\n\n    MAX_NUMBER_OF_NODES: 1000, // avoid infinite loops\n    DEFAULT_POSITION: [100, 100], // default node position\n    VALID_SHAPES: [\"default\", \"box\", \"round\", \"card\"], // ,\"circle\"\n\n    // shapes are used for nodes but also for slots\n    BOX_SHAPE: 1,\n    ROUND_SHAPE: 2,\n    CIRCLE_SHAPE: 3,\n    CARD_SHAPE: 4,\n    ARROW_SHAPE: 5,\n\n    // enums\n    INPUT: 1,\n    OUTPUT: 2,\n\n    EVENT: -1, // for outputs\n    ACTION: -1, // for inputs\n\n    ALWAYS: 0,\n    ON_EVENT: 1,\n    NEVER: 2,\n    ON_TRIGGER: 3,\n\n    UP: 1,\n    DOWN: 2,\n    LEFT: 3,\n    RIGHT: 4,\n    CENTER: 5,\n\n    STRAIGHT_LINK: 0,\n    LINEAR_LINK: 1,\n    SPLINE_LINK: 2,\n\n    NORMAL_TITLE: 0,\n    NO_TITLE: 1,\n    TRANSPARENT_TITLE: 2,\n    AUTOHIDE_TITLE: 3,\n\n    proxy: null, // used to redirect calls\n    node_images_path: \"\",\n\n    debug: true,\n    catch_exceptions: true,\n    throw_errors: true,\n    allow_scripts: false,\n    // if set to true some nodes like Formula would be allowed\n    // to evaluate code that comes from unsafe sources\n    // (like node configuration), which could lead to exploits\n    registered_node_types: {}, // nodetypes by string\n    node_types_by_file_extension: {}, // used for dropping files in the canvas\n    Nodes: {}, // node types by classname\n    Globals: {}, // used to store vars between graphs\n\n    searchbox_extras: {}, // used to add extra features to the search box\n    auto_sort_node_types: false,\n    // If set to true, will automatically sort node types / categories in the context menus\n};\n","/**\n * @module Time Utils\n */\n\nexport default function getTime() {\n    if (typeof performance !== \"undefined\") return performance.now();\n    if (typeof Date !== \"undefined\" && typeof Date.now !== \"undefined\") return Date.now;\n    if (typeof process !== \"undefined\") {\n        const t = process.hrtime();\n        return t[0] * 0.001 + t[1] * 1e-6;\n    }\n    return new Date().getTime();\n}\n","/**\n * @module Object Utils\n */\n\n// separated just to improve if it doesn't work\nexport default function cloneObject(obj, target) {\n    if (obj == null) return null;\n    const r = JSON.parse(JSON.stringify(obj));\n    if (!target) return r;\n\n    // eslint-disable-next-line guard-for-in,no-restricted-syntax\n    for (const i in r) target[i] = r[i];\n    return target;\n}\n","/**\n * @module Registry Manager\n */\n\n/**\n * removes a node type from the system\n * @method unregisterNodeType\n * @param {String|Object} type name of the node or the node constructor itself\n */\nimport defaultConfig from \"./defaultConfig\";\n\nexport function unregisterNodeType(type) {\n    const baseClass = type.constructor === String ? defaultConfig.registered_node_types[type] : type;\n    if (!baseClass) throw new Error(`node type not found: ${type}`);\n    delete defaultConfig.registered_node_types[baseClass.type];\n    if (baseClass.constructor.name) delete defaultConfig.Nodes[baseClass.constructor.name];\n}\n\n/**\n * Register a node class so it can be listed when the user wants to create a new one\n * @method registerNodeType\n * @param {LGraphNode} type name of the node and path\n * @param {Class} baseClass class containing the structure of a node\n */\nexport function registerNodeType(type, baseClass) {\n    if (!baseClass.prototype) {\n        throw new TypeError(\"Cannot register a simple object, it must be a class with a prototype\");\n    }\n    baseClass.type = type;\n\n    if (defaultConfig.debug) {\n        console.log(`Node registered: ${type}`);\n    }\n\n    const classname = baseClass.name;\n\n    const pos = type.lastIndexOf(\"/\");\n    baseClass.category = type.substr(0, pos);\n\n    if (!baseClass.title) {\n        baseClass.title = classname;\n    }\n\n    // info.name = name.substr(pos+1,name.length - pos);\n\n    const prev = defaultConfig.registered_node_types[type];\n    if (prev) {\n        console.log(`replacing node type: ${type}`);\n    } else {\n        if (!Object.hasOwnProperty.call(baseClass.prototype, \"shape\")) {\n            Object.defineProperty(baseClass.prototype, \"shape\", {\n                set(v) {\n                    switch (v) {\n                        case \"default\":\n                            delete this._shape;\n                            break;\n                        case \"box\":\n                            this._shape = defaultConfig.BOX_SHAPE;\n                            break;\n                        case \"round\":\n                            this._shape = defaultConfig.ROUND_SHAPE;\n                            break;\n                        case \"circle\":\n                            this._shape = defaultConfig.CIRCLE_SHAPE;\n                            break;\n                        case \"card\":\n                            this._shape = defaultConfig.CARD_SHAPE;\n                            break;\n                        default:\n                            this._shape = v;\n                    }\n                },\n                get() {\n                    return this._shape;\n                },\n                enumerable: true,\n                configurable: true,\n            });\n        }\n\n        // warnings\n        if (baseClass.prototype.onPropertyChange) {\n            console.warn(\n                `LiteGraph node class ${\n                    type\n                } has onPropertyChange method, it must be called onPropertyChanged with d at the end`,\n            );\n        }\n\n        // used to know which nodes create when dragging files to the canvas\n        if (baseClass.supported_extensions) {\n            for (const ext of baseClass.supported_extensions) {\n                if (ext && ext.constructor === String) {\n                    defaultConfig.node_types_by_file_extension[ext.toLowerCase()] = baseClass;\n                }\n            }\n        }\n    }\n\n    defaultConfig.registered_node_types[type] = baseClass;\n    if (baseClass.constructor.name) defaultConfig.Nodes[classname] = baseClass;\n\n    if (defaultConfig.onNodeTypeRegistered) defaultConfig.onNodeTypeRegistered(type, baseClass);\n    if (prev && defaultConfig.onNodeTypeReplaced) {\n        defaultConfig.onNodeTypeReplaced(type, baseClass, prev);\n    }\n\n    // warnings\n    if (baseClass.prototype.onPropertyChange) {\n        console.warn(\n            `LiteGraph node class ${\n                type\n            } has onPropertyChange method, it must be called onPropertyChanged with d at the end`,\n        );\n    }\n\n    // used to know which nodes create when dragging files to the canvas\n    if (baseClass.supported_extensions) {\n        for (const ext of baseClass.supported_extensions) {\n            if (ext && ext.constructor === String) {\n                defaultConfig.node_types_by_file_extension[ext.toLowerCase()] = baseClass;\n            }\n        }\n    }\n}\n\n/**\n * Removes all previously registered node's types\n */\nexport function clearRegisteredTypes() {\n    defaultConfig.registered_node_types = {};\n    defaultConfig.node_types_by_file_extension = {};\n    defaultConfig.Nodes = {};\n    defaultConfig.searchbox_extras = {};\n}\n\n/**\n * Returns a registered node type with a given name\n * @method getNodeType\n * @param {String} type full name of the node class. p.e. \"math/sin\"\n * @return {Class} the node class\n */\nexport function getNodeType(type) {\n    return defaultConfig.registered_node_types[type];\n}\n\n/**\n * Returns a list of node types matching one category\n * @method getNodeType\n * @param {String} category category name\n * @return {Array} array with all the node classes\n */\nexport function getNodeTypesInCategory(category, filter) {\n    const r = [];\n    // eslint-disable-next-line\n    for (const i in defaultConfig.registered_node_types) {\n        const type = defaultConfig.registered_node_types[i];\n        if (type.filter !== filter) continue;\n\n        if (category === \"\") {\n            if (!type.category) r.push(type);\n        } else if (type.category === category) {\n            r.push(type);\n        }\n    }\n\n    return defaultConfig.auto_sort_node_types ? r.sort() : r;\n}\n\n/**\n * Register a string in the search box so when the user types it it will recommend this node\n * @method registerSearchboxExtra\n * @param {String} nodeType the node recommended\n * @param {String} description text to show next to it\n * @param {Object} data it could contain info of how the node should be configured\n * @return {Boolean} true if they can be connected\n */\nexport function registerSearchboxExtra(nodeType, description, data) {\n    defaultConfig.searchbox_extras[description.toLowerCase()] = {\n        type: nodeType,\n        desc: description,\n        data,\n    };\n}\n/**\n * Returns a list with all the node type categories\n * @method getNodeTypesCategories\n * @param {String} filter only nodes with ctor.filter equal can be shown\n * @return {Array} array with all the names of the categories\n */\nexport function getNodeTypesCategories(filter) {\n    const categories = { \"\": 1 };\n    // eslint-disable-next-line\n    for (const id in defaultConfig.registered_node_types) {\n        const type = defaultConfig.registered_node_types[id];\n        if (type.category && !type.skip_list) {\n            if (type.filter !== filter) continue;\n            categories[type.category] = 1;\n        }\n    }\n    const result = [];\n    // eslint-disable-next-line\n    for (const i in categories) result.push(i);\n    return defaultConfig.auto_sort_node_types ? result.sort() : result;\n}\n","/**\n * @module Function Utils\n */\nimport defaultConfig from \"./defaultConfig\";\nimport { registerNodeType } from \"./registry\";\n\n// used to create nodes from wrapping function\nexport function getParameterNames(func) {\n    return (`${func}`)\n        .replace(/[/][/].*$/gm, \"\") // strip single-line comments\n        .replace(/\\s+/g, \"\") // strip white space\n        .replace(/[/][*][^/*]*[*][/]/g, \"\") // strip multi-line comments  /**/\n        .split(\"){\", 1)[0]\n        .replace(/^[^(]*[(]/, \"\") // extract the parameters\n        .replace(/=[^,]+/g, \"\") // strip any ES6 defaults\n        .split(\",\")\n        .filter(Boolean); // split & filter [\"\"]\n}\n\n/**\n * Create a new nodetype by passing a function, it wraps it with a proper class and\n * generates inputs according to the parameters of the function. Useful to wrap simple\n * methods that do not require properties, and that only process some input to generate an\n * output.\n * @method wrapFunctionAsNode\n * @param {String} name node name with namespace (p.e.: 'math/sum')\n * @param {Function} func\n * @param {Array} paramType [optional] an array containing the type of every parameter,\n *     otherwise parameters will accept any type\n * @param {String} returnType [optional] string with the return type, otherwise it will be\n *     generic\n * @param {Object} properties [optional] properties to be configurable\n */\nexport function wrapFunctionAsNode(\n    name,\n    func,\n    paramType,\n    returnType,\n    properties,\n) {\n    const params = Array(func.length);\n    let code = \"\";\n    const names = getParameterNames(func);\n    for (let i = 0; i < names.length; ++i) {\n        code += `this.addInput('${names[i]}',${paramType && paramType[i] ? `'${paramType[i]}'` : \"0\"});\\n`;\n    }\n    code += `this.addOutput('out',${returnType ? `'${returnType}'` : 0});\\n`;\n    if (properties) code += `this.properties = ${JSON.stringify(properties)};\\n`;\n    const classobj = Function(\"code\");\n    classobj.title = name.split(\"/\").pop();\n    classobj.desc = `Generated from ${func.name}`;\n    classobj.prototype.onExecute = function onExecute() {\n        for (let i = 0; i < params.length; ++i) {\n            params[i] = this.getInputData(i);\n        }\n        const r = func.apply(this, params);\n        this.setOutputData(0, r);\n    };\n    registerNodeType(name, classobj);\n}\n/**\n * Returns if the types of two slots are compatible (taking into account wildcards, etc)\n * @method isValidConnection\n * @param {String} typeA\n * @param {String} typeB\n * @return {Boolean} true if they can be connected\n */\nexport function isValidConnection(typeA, typeB) {\n    if (\n        !typeA\n        || !typeB\n        || typeA === typeB\n        || (typeA === defaultConfig.EVENT && typeB === defaultConfig.ACTION)\n    ) {\n        return true;\n    }\n\n    // Enforce string type to handle toLowerCase call (-1 number not ok)\n    typeA = String(typeA);\n    typeB = String(typeB);\n    typeA = typeA.toLowerCase();\n    typeB = typeB.toLowerCase();\n\n    // For nodes supporting multiple connection types\n    if (typeA.indexOf(\",\") === -1 && typeB.indexOf(\",\") === -1) return typeA === typeB;\n\n    // Check all permutations to see if one is valid\n    const supportedTypesA = typeA.split(\",\");\n    const supportedTypesB = typeB.split(\",\");\n    for (let i = 0; i < supportedTypesA.length; ++i) {\n        for (let j = 0; j < supportedTypesB.length; ++j) {\n            if (supportedTypesA[i] === supportedTypesB[j]) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n","/**\n * @class LLink\n * @param id\n * @param type\n * @param origin_id\n * @param origin_slot\n * @param target_id\n * @param target_slot\n */\nexport default class LLink {\n    constructor(id, type, origin_id, origin_slot, target_id, target_slot) {\n        this.id = id;\n        this.type = type;\n        this.origin_id = origin_id;\n        this.origin_slot = origin_slot;\n        this.target_id = target_id;\n        this.target_slot = target_slot;\n\n        this._data = null;\n        this._pos = new Float32Array(2); // center\n    }\n\n    configure(o) {\n        if (o.constructor === Array) {\n            this.id = o[0];\n            this.origin_id = o[1];\n            this.origin_slot = o[2];\n            this.target_id = o[3];\n            this.target_slot = o[4];\n            this.type = o[5];\n        } else {\n            this.id = o.id;\n            this.type = o.type;\n            this.origin_id = o.origin_id;\n            this.origin_slot = o.origin_slot;\n            this.target_id = o.target_id;\n            this.target_slot = o.target_slot;\n        }\n    }\n\n    serialize() {\n        return [\n            this.id,\n            this.origin_id,\n            this.origin_slot,\n            this.target_id,\n            this.target_slot,\n            this.type,\n        ];\n    }\n}\n","/**\n * @module Math Utils\n */\n\nexport function distance(a, b) {\n    return Math.sqrt(\n        (b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1]),\n    );\n}\n\nexport function isInsideRectangle(x, y, left, top, width, height) {\n    return left < x && left + width > x && top < y && top + height > y;\n}\n\n// bounding overlap, format: [ startx, starty, width, height ]\nexport function overlapBounding(a, b) {\n    const AEndX = a[0] + a[2];\n    const AEndY = a[1] + a[3];\n    const BEndX = b[0] + b[2];\n    const BEndY = b[1] + b[3];\n\n    return !(a[0] > BEndX\n        || a[1] > BEndY\n        || AEndX < b[0]\n        || AEndY < b[1]);\n}\n\nexport function clamp(v, a, b) {\n    // eslint-disable-next-line no-nested-ternary\n    return a > v ? a : b < v ? b : v;\n}\n","import defaultConfig from \"./utils/defaultConfig\";\nimport cloneObject from \"./utils/object\";\nimport getTime from \"./utils/time\";\nimport { isValidConnection } from \"./utils/function\";\nimport LLink from \"./LLink\";\nimport { isInsideRectangle } from \"./utils/math\";\n\n/*\ntitle: string\npos: [x,y]\nsize: [x,y]\n\ninput|output: every connection\n+  { name:string, type:string, pos: [x,y]=Optional, direction: \"input\"|\"output\", links: Array });\n\ngeneral properties:\n+ clip_area: if you render outside the node, it will be clipped\n+ unsafe_execution: not allowed for safe execution\n+ skip_repeated_outputs: when adding new outputs, it wont show if there is one already connected\n+ resizable: if set to false it wont be resizable with the mouse\n+ horizontal: slots are distributed horizontally\n+ widgets_start_y: widgets start at y distance from the top of the node\n\nflags object:\n+ collapsed: if it is collapsed\n\nsupported callbacks:\n+ onAdded: when added to graph (warning: this is called BEFORE the node is configured when loading)\n+ onRemoved: when removed from graph\n+ onStart:\twhen the graph starts playing\n+ onStop:\twhen the graph stops playing\n+ onDrawForeground: render the inside widgets inside the node\n+ onDrawBackground: render the background area inside the node (only in edit mode)\n+ onMouseDown\n+ onMouseMove\n+ onMouseUp\n+ onMouseEnter\n+ onMouseLeave\n+ onExecute: execute the node\n+ onPropertyChanged: when a property is changed in the panel (return true to skip default behaviour)\n+ onGetInputs: returns an array of possible inputs\n+ onGetOutputs: returns an array of possible outputs\n+ onBounding: in case this node has a bigger bounding than the node itself (the callback receives the bounding as [x,y,w,h])\n+ onDblClick: double clicked in the node\n+ onInputDblClick: input slot double clicked (can be used to automatically create a node connected)\n+ onOutputDblClick: output slot double clicked (can be used to automatically create a node connected)\n+ onConfigure: called after the node has been configured\n+ onSerialize: to add extra info when serializing (the callback receives the object that should be filled with the data)\n+ onSelected\n+ onDeselected\n+ onDropItem : DOM item dropped over the node\n+ onDropFile : file dropped over the node\n+ onConnectInput : if returns false the incoming connection will be canceled\n+ onConnectionsChange : a connection changed (new one or removed) (LiteGraph.INPUT or LiteGraph.OUTPUT, slot, true if connected, link_info, input_info )\n+ onAction: action slot triggered\n+ getExtraMenuOptions: to add option to context menu\n*/\n\n/**\n * Base Class for all the node type classes\n * @class LGraphNode\n * @param {String} title a name for the node\n */\nexport default class LGraphNode {\n    constructor(title) {\n        this.title = title || \"Unnamed\";\n        this.size = [defaultConfig.NODE_WIDTH, 60];\n        this.graph = null;\n        this.id = -1; // not know till not added\n        this.type = null;\n        // inputs available: array of inputs\n        this.inputs = [];\n        this.outputs = [];\n        this.connections = [];\n\n        // local data\n        this.properties = {}; // for the values\n        this.properties_info = []; // for the info\n\n        this.flags = {};\n    }\n\n    /**\n     * Internal position array\n     * @internal\n     * @type {Float32Array}\n     * @private\n     * @memberOf LGraphNode\n     */\n    _pos = new Float32Array(10, 10)\n\n    set pos(v) {\n        if (!v || v.length < 2) {\n            return;\n        }\n        this._pos[0] = v[0];\n        this._pos[1] = v[1];\n    }\n\n    get pos() {\n        return this._pos;\n    }\n\n    /**\n     * configure a node from an object containing the serialized info\n     * @method configure\n     * @memberOf LGraphNode\n     */\n    configure(info) {\n        if (this.graph) {\n            this.graph._version++;\n        }\n        // eslint-disable-next-line guard-for-in,no-restricted-syntax\n        for (const j in info) {\n            if (j === \"properties\") {\n                // i don't want to clone properties, I want to reuse the old container\n                // eslint-disable-next-line guard-for-in,no-restricted-syntax\n                for (const k in info.properties) {\n                    this.properties[k] = info.properties[k];\n                    if (this.onPropertyChanged) {\n                        this.onPropertyChanged(k, info.properties[k]);\n                    }\n                }\n                continue;\n            }\n\n            if (info[j] == null) {\n                continue;\n            } else if (typeof info[j] === \"object\") {\n                // object\n                if (this[j] && this[j].configure) {\n                    this[j].configure(info[j]);\n                } else {\n                    this[j] = cloneObject(info[j], this[j]);\n                }\n            } else {\n                this[j] = info[j];\n            }\n        }\n\n        if (!info.title) {\n            this.title = this.constructor.title;\n        }\n\n        if (this.onConnectionsChange) {\n            if (this.inputs) {\n                for (let i = 0; i < this.inputs.length; ++i) {\n                    const input = this.inputs[i];\n                    const linkInfo = this.graph\n                        ? this.graph.links[input.link]\n                        : null;\n                    this.onConnectionsChange(\n                        defaultConfig.INPUT,\n                        i,\n                        true,\n                        linkInfo,\n                        input,\n                    ); // linkInfo has been created now, so its updated\n                }\n            }\n\n            if (this.outputs) {\n                for (let i = 0; i < this.outputs.length; ++i) {\n                    const output = this.outputs[i];\n                    if (!output.links) {\n                        continue;\n                    }\n                    for (let j = 0; j < output.links.length; ++j) {\n                        const linkInfo = this.graph\n                            ? this.graph.links[output.links[j]]\n                            : null;\n                        this.onConnectionsChange(\n                            defaultConfig.OUTPUT,\n                            i,\n                            true,\n                            linkInfo,\n                            output,\n                        ); // link_info has been created now, so its updated\n                    }\n                }\n            }\n        }\n\n        if (this.widgets) {\n            for (const widget of this.widgets) {\n                if (!widget) continue;\n                if (widget.options\n                    && widget.options.property\n                    // eslint-disable-next-line max-len\n                    && this.properties[widget.options.property]) widget.value = JSON.parse(JSON.stringify(this.properties[widget.options.property]));\n            }\n            if (info.widgets_values) {\n                for (let i = 0; i < info.widgets_values.length; ++i) {\n                    if (this.widgets[i]) {\n                        this.widgets[i].value = info.widgets_values[i];\n                    }\n                }\n            }\n        }\n\n        if (this.onConfigure) {\n            this.onConfigure(info);\n        }\n    }\n\n    /**\n     * serialize the content\n     * @method serialize\n     * @memberOf LGraphNode\n     */\n\n    serialize() {\n        // create serialization object\n        const o = {\n            id: this.id,\n            type: this.type,\n            pos: this.pos,\n            size: this.size,\n            flags: cloneObject(this.flags),\n            order: this.order,\n            mode: this.mode,\n        };\n\n        // special case for when there were errors\n        if (this.constructor === LGraphNode && this.last_serialization) {\n            return this.last_serialization;\n        }\n\n        if (this.inputs) {\n            o.inputs = this.inputs;\n        }\n\n        if (this.outputs) {\n            // clear outputs last data (because data in connections is never serialized but stored\n            // inside the outputs info)\n            for (let i = 0; i < this.outputs.length; i++) {\n                delete this.outputs[i]._data;\n            }\n            o.outputs = this.outputs;\n        }\n\n        if (this.title && this.title != this.constructor.title) {\n            o.title = this.title;\n        }\n\n        if (this.properties) {\n            o.properties = cloneObject(this.properties);\n        }\n\n        if (this.widgets && this.serialize_widgets) {\n            o.widgets_values = [];\n            for (let i = 0; i < this.widgets.length; ++i) {\n                if (this.widgets[i]) {\n                    o.widgets_values[i] = this.widgets[i].value;\n                } else {\n                    o.widgets_values[i] = null;\n                }\n            }\n        }\n\n        if (!o.type) o.type = this.constructor.type;\n\n        if (this.color) o.color = this.color;\n        if (this.bgcolor) o.bgcolor = this.bgcolor;\n        if (this.boxcolor) o.boxcolor = this.boxcolor;\n        if (this.shape) o.shape = this.shape;\n\n        if (this.onSerialize) {\n            if (this.onSerialize(o)) {\n                console.warn(\n                    \"node onSerialize shouldnt return anything, data should be stored in the object pass in the first parameter\",\n                );\n            }\n        }\n\n        return o;\n    }\n\n    /* Creates a clone of this node */\n    clone() {\n        const node = LGraphNode.createNode(this.type);\n        if (!node) {\n            return null;\n        }\n\n        // we clone it because serialize returns shared containers\n        const data = LGraphNode.cloneObject(this.serialize());\n\n        // remove links\n        if (data.inputs) {\n            for (let i = 0; i < data.inputs.length; ++i) {\n                data.inputs[i].link = null;\n            }\n        }\n\n        if (data.outputs) {\n            for (let i = 0; i < data.outputs.length; ++i) {\n                if (data.outputs[i].links) {\n                    data.outputs[i].links.length = 0;\n                }\n            }\n        }\n\n        delete data.id;\n        // remove links\n        node.configure(data);\n\n        return node;\n    }\n\n    /**\n     * serialize and stringify\n     * @method toString\n     * @memberOf LGraphNode\n     */\n\n    toString() {\n        return JSON.stringify(this.serialize());\n    }\n\n    // deserialize = function(info) {} //this cannot be done from within, must\n    // be done in LiteGraph\n\n    /**\n     * get the title string\n     * @method getTitle\n     * @memberOf LGraphNode\n     */\n\n    getTitle() {\n        return this.title || this.constructor.title;\n    }\n\n    /**\n     * sets the value of a property\n     * @method setProperty\n     * @param {String} name\n     * @param {*} value\n     * @memberOf LGraphNode\n     */\n    setProperty(name, value) {\n        if (!this.properties) {\n            this.properties = {};\n        }\n        if (value === this.properties[name]) return;\n        const prevValue = this.properties[name];\n        this.properties[name] = value;\n        if (this.onPropertyChanged && this.onPropertyChanged(name, value, prevValue) === false) {\n            this.properties[name] = prevValue;\n        }\n        if (this.widgets) {\n            for (let i = 0; i < this.widgets.length; ++i) {\n                const w = this.widgets[i];\n                if (!w) continue;\n                if (w.options.property == name) {\n                    w.value = value;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Execution *************************\n    /**\n     * sets the output data\n     * @method setOutputData\n     * @param {number} slot\n     * @param {*} data\n     * @memberOf LGraphNode\n     */\n    setOutputData(slot, data) {\n        if (!this.outputs) {\n            return;\n        }\n\n        // this maybe slow and a niche case\n        // if(slot && slot.constructor === String)\n        //\tslot = this.findOutputSlot(slot);\n\n        if (slot == -1 || slot >= this.outputs.length) {\n            return;\n        }\n\n        const output_info = this.outputs[slot];\n        if (!output_info) {\n            return;\n        }\n\n        // store data in the output itself in case we want to debug\n        output_info._data = data;\n\n        // if there are connections, pass the data to the connections\n        if (this.outputs[slot].links) {\n            for (let i = 0; i < this.outputs[slot].links.length; i++) {\n                const link_id = this.outputs[slot].links[i];\n                const link = this.graph.links[link_id];\n                if (link) link.data = data;\n            }\n        }\n    }\n\n    /**\n     * sets the output data type, useful when you want to be able to overwrite the data type\n     * @method setOutputDataType\n     * @param {number} slot\n     * @param {String} datatype\n     * @memberOf LGraphNode\n     */\n    setOutputDataType(slot, type) {\n        if (!this.outputs) {\n            return;\n        }\n        if (slot == -1 || slot >= this.outputs.length) {\n            return;\n        }\n        const output_info = this.outputs[slot];\n        if (!output_info) {\n            return;\n        }\n        // store data in the output itself in case we want to debug\n        output_info.type = type;\n\n        // if there are connections, pass the data to the connections\n        if (this.outputs[slot].links) {\n            for (let i = 0; i < this.outputs[slot].links.length; i++) {\n                const link_id = this.outputs[slot].links[i];\n                this.graph.links[link_id].type = type;\n            }\n        }\n    }\n\n    /**\n     * Retrieves the input data (data traveling through the connection) from one slot\n     * @method getInputData\n     * @param {number} slot\n     * @param {boolean} forceUpdate if set to true it will force the connected node of this slot\n     *     to output data into this link\n     * @return {*} data or if it is not connected returns undefined\n     * @memberOf LGraphNode\n     */\n    getInputData(slot, forceUpdate) {\n        if (!this.inputs) {\n            return;\n        } // undefined;\n\n        if (slot >= this.inputs.length || this.inputs[slot].link == null) {\n            return;\n        }\n\n        const linkId = this.inputs[slot].link;\n        const link = this.graph.links[linkId];\n        if (!link) {\n            // bug: weird case but it happens sometimes\n            return null;\n        }\n\n        if (link.data && !forceUpdate) {\n            return link.data;\n        }\n\n        // special case: used to extract data from the incoming connection before the graph has\n        // been executed\n        const node = this.graph.getNodeById(link.origin_id);\n        if (!node) {\n            return link.data;\n        }\n\n        if (node.updateOutputData) {\n            node.updateOutputData(link.origin_slot);\n        } else if (node.onExecute) {\n            node.onExecute();\n        }\n\n        return link.data;\n    }\n\n    /**\n     * Retrieves the input data type (in case this supports multiple input types)\n     * @method getInputDataType\n     * @param {number} slot\n     * @return {String} datatype in string format\n     * @memberOf LGraphNode\n     */\n    getInputDataType(slot) {\n        if (!this.inputs) {\n            return null;\n        } // undefined;\n\n        if (slot >= this.inputs.length || this.inputs[slot].link == null) {\n            return null;\n        }\n        const link_id = this.inputs[slot].link;\n        const link = this.graph.links[link_id];\n        if (!link) {\n            // bug: weird case but it happens sometimes\n            return null;\n        }\n        const node = this.graph.getNodeById(link.origin_id);\n        if (!node) {\n            return link.type;\n        }\n        const output_info = node.outputs[link.origin_slot];\n        if (output_info) {\n            return output_info.type;\n        }\n        return null;\n    }\n\n    /**\n     * Retrieves the input data from one slot using its name instead of slot number\n     * @method getInputDataByName\n     * @param {String} slot_name\n     * @param {boolean} force_update if set to true it will force the connected node of this slot\n     *     to output data into this link\n     * @return {*} data or if it is not connected returns null\n     * @memberOf LGraphNode\n     */\n    getInputDataByName(\n        slot_name,\n        force_update,\n    ) {\n        const slot = this.findInputSlot(slot_name);\n        if (slot == -1) {\n            return null;\n        }\n        return this.getInputData(slot, force_update);\n    }\n\n    /**\n     * tells you if there is a connection in one input slot\n     * @method isInputConnected\n     * @param {number} slot\n     * @return {boolean}\n     * @memberOf LGraphNode\n     */\n    isInputConnected(slot) {\n        if (!this.inputs) {\n            return false;\n        }\n        return slot < this.inputs.length && this.inputs[slot].link != null;\n    }\n\n    /**\n     * tells you info about an input connection (which node, type, etc)\n     * @method getInputInfo\n     * @param {number} slot\n     * @return {Object} object or null { link: id, name: string, type: string or 0 }\n     * @memberOf LGraphNode\n     */\n    getInputInfo(slot) {\n        if (!this.inputs) {\n            return null;\n        }\n        if (slot < this.inputs.length) {\n            return this.inputs[slot];\n        }\n        return null;\n    }\n\n    /**\n     * Returns the link info in the connection of an input slot\n     * @method getInputLink\n     * @param {number} slot\n     * @return {LLink} object or null\n     * @memberOf LGraphNode\n     */\n    getInputLink(slot) {\n        if (!this.inputs) {\n            return null;\n        }\n        if (slot < this.inputs.length) {\n            const slot_info = this.inputs[slot];\n            return this.graph.links[slot_info.link];\n        }\n        return null;\n    }\n\n    /**\n     * returns the node connected in the input slot\n     * @method getInputNode\n     * @param {number} slot\n     * @return {LGraphNode} node or null\n     * @memberOf LGraphNode\n     */\n    getInputNode(slot) {\n        if (!this.inputs) {\n            return null;\n        }\n        if (slot >= this.inputs.length) {\n            return null;\n        }\n        const input = this.inputs[slot];\n        if (!input || input.link === null) {\n            return null;\n        }\n        const link_info = this.graph.links[input.link];\n        if (!link_info) {\n            return null;\n        }\n        return this.graph.getNodeById(link_info.origin_id);\n    }\n\n    /**\n     * returns the value of an input with this name, otherwise checks if there is a property with\n     * that name\n     * @method getInputOrProperty\n     * @param {string} name\n     * @return {*} value\n     * @memberOf LGraphNode\n     */\n    getInputOrProperty(name) {\n        if (!this.inputs || !this.inputs.length) {\n            return this.properties ? this.properties[name] : null;\n        }\n\n        for (let i = 0, l = this.inputs.length; i < l; ++i) {\n            const input_info = this.inputs[i];\n            if (name == input_info.name && input_info.link != null) {\n                const link = this.graph.links[input_info.link];\n                if (link) {\n                    return link.data;\n                }\n            }\n        }\n        return this.properties[name];\n    }\n\n    /**\n     * tells you the last output data that went in that slot\n     * @method getOutputData\n     * @param {number} slot\n     * @return {Object}  object or null\n     * @memberOf LGraphNode\n     */\n    getOutputData(slot) {\n        if (!this.outputs) {\n            return null;\n        }\n        if (slot >= this.outputs.length) {\n            return null;\n        }\n\n        const info = this.outputs[slot];\n        return info._data;\n    }\n\n    /**\n     * tells you info about an output connection (which node, type, etc)\n     * @method getOutputInfo\n     * @param {number} slot\n     * @return {Object}  object or null { name: string, type: string, links: [ ids of links in\n     *     number ] }\n     * @memberOf LGraphNode\n     */\n    getOutputInfo(slot) {\n        if (!this.outputs) {\n            return null;\n        }\n        if (slot < this.outputs.length) {\n            return this.outputs[slot];\n        }\n        return null;\n    }\n\n    /**\n     * tells you if there is a connection in one output slot\n     * @method isOutputConnected\n     * @param {number} slot\n     * @return {boolean}\n     * @memberOf LGraphNode\n     */\n    isOutputConnected(slot) {\n        if (!this.outputs) {\n            return false;\n        }\n        return (\n            slot < this.outputs.length\n            && this.outputs[slot].links\n            && this.outputs[slot].links.length\n        );\n    }\n\n    /**\n     * tells you if there is any connection in the output slots\n     * @method isAnyOutputConnected\n     * @return {boolean}\n     * @memberOf LGraphNode\n     */\n    isAnyOutputConnected() {\n        if (!this.outputs) {\n            return false;\n        }\n        for (let i = 0; i < this.outputs.length; ++i) {\n            if (this.outputs[i].links && this.outputs[i].links.length) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * retrieves all the nodes connected to this output slot\n     * @method getOutputNodes\n     * @param {number} slot\n     * @return {array}\n     * @memberOf LGraphNode\n     */\n    getOutputNodes(slot) {\n        if (!this.outputs || this.outputs.length == 0) {\n            return null;\n        }\n\n        if (slot >= this.outputs.length) {\n            return null;\n        }\n\n        const output = this.outputs[slot];\n        if (!output.links || output.links.length == 0) {\n            return null;\n        }\n\n        const r = [];\n        for (let i = 0; i < output.links.length; i++) {\n            const link_id = output.links[i];\n            const link = this.graph.links[link_id];\n            if (link) {\n                const target_node = this.graph.getNodeById(link.target_id);\n                if (target_node) {\n                    r.push(target_node);\n                }\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Triggers an event in this node, this will trigger any output with the same name\n     * @method trigger\n     * @param {String} event name ( \"on_play\", ... ) if action is equivalent to false then the\n     *     event is send to all\n     * @param {*} param\n     * @memberOf LGraphNode\n     */\n    trigger(action, param) {\n        if (!this.outputs || !this.outputs.length) {\n            return;\n        }\n\n        if (this.graph) this.graph._last_trigger_time = getTime();\n\n        for (let i = 0; i < this.outputs.length; ++i) {\n            const output = this.outputs[i];\n            if (!output || output.type !== defaultConfig.EVENT || (action && output.name != action)) continue;\n            this.triggerSlot(i, param);\n        }\n    }\n\n    /**\n     * Triggers an slot event in this node\n     * @method triggerSlot\n     * @param {Number} slot the index of the output slot\n     * @param {*} param\n     * @param {Number} link_id [optional] in case you want to trigger and specific output link in a\n     *     slot\n     * @memberOf LGraphNode\n     */\n    triggerSlot(slot, param, link_id) {\n        if (!this.outputs) {\n            return;\n        }\n\n        const output = this.outputs[slot];\n        if (!output) {\n            return;\n        }\n\n        const { links } = output;\n        if (!links || !links.length) {\n            return;\n        }\n\n        if (this.graph) {\n            this.graph._last_trigger_time = getTime();\n        }\n\n        // for every link attached here\n        for (let k = 0; k < links.length; ++k) {\n            const id = links[k];\n            if (link_id != null && link_id != id) {\n                // to skip links\n                continue;\n            }\n            const link_info = this.graph.links[links[k]];\n            if (!link_info) {\n                // not connected\n                continue;\n            }\n            link_info._last_time = getTime();\n            const node = this.graph.getNodeById(link_info.target_id);\n            if (!node) {\n                // node not found?\n                continue;\n            }\n\n            // used to mark events in graph\n            const target_connection = node.inputs[link_info.target_slot];\n\n            if (node.mode === defaultConfig.ON_TRIGGER) {\n                if (node.onExecute) {\n                    node.onExecute(param);\n                }\n            } else if (node.onAction) {\n                node.onAction(target_connection.name, param);\n            }\n        }\n    }\n\n    /**\n     * clears the trigger slot animation\n     * @method clearTriggeredSlot\n     * @param {Number} slot the index of the output slot\n     * @param {Number} link_id [optional] in case you want to trigger and specific output link in a\n     *     slot\n     * @memberOf LGraphNode\n     */\n    clearTriggeredSlot(slot, link_id) {\n        if (!this.outputs) {\n            return;\n        }\n\n        const output = this.outputs[slot];\n        if (!output) {\n            return;\n        }\n\n        const { links } = output;\n        if (!links || !links.length) {\n            return;\n        }\n\n        // for every link attached here\n        for (let k = 0; k < links.length; ++k) {\n            const id = links[k];\n            if (link_id != null && link_id != id) {\n                // to skip links\n                continue;\n            }\n            const link_info = this.graph.links[links[k]];\n            if (!link_info) {\n                // not connected\n                continue;\n            }\n            link_info._last_time = 0;\n        }\n    }\n\n    /**\n     * changes node size and triggers callback\n     * @method setSize\n     * @param {vec2} size\n     * @memberOf LGraphNode\n     */\n    setSize(size) {\n        this.size = size;\n        if (this.onResize) this.onResize(this.size);\n    }\n\n    /**\n     * add a new property to this node\n     * @method addProperty\n     * @param {string} name\n     * @param {*} default_value\n     * @param {string} type string defining the output type (\"vec3\",\"number\",...)\n     * @param {Object} extra_info this can be used to have special properties of the property (like\n     *     values, etc)\n     * @memberOf LGraphNode\n     */\n    addProperty(\n        name,\n        default_value,\n        type,\n        extra_info,\n    ) {\n        const o = {\n            name,\n            type,\n            default_value,\n        };\n        if (extra_info) {\n            for (const i in extra_info) {\n                o[i] = extra_info[i];\n            }\n        }\n        if (!this.properties_info) {\n            this.properties_info = [];\n        }\n        this.properties_info.push(o);\n        if (!this.properties) {\n            this.properties = {};\n        }\n        this.properties[name] = default_value;\n        return o;\n    }\n\n    // connections\n\n    /**\n     * add a new output slot to use in this node\n     * @method addOutput\n     * @param {string} name\n     * @param {string} type string defining the output type (\"vec3\",\"number\",...)\n     * @param {Object} extra_info this can be used to have special properties of an output (label,\n     *     special color, position, etc)\n     * @memberOf LGraphNode\n     */\n    addOutput(name, type, extra_info) {\n        const o = {\n            name,\n            type,\n            links: null,\n        };\n        if (extra_info) {\n            for (const i in extra_info) {\n                o[i] = extra_info[i];\n            }\n        }\n\n        if (!this.outputs) {\n            this.outputs = [];\n        }\n        this.outputs.push(o);\n        if (this.onOutputAdded) {\n            this.onOutputAdded(o);\n        }\n        this.setSize(this.computeSize());\n        this.setDirtyCanvas(true, true);\n        return o;\n    }\n\n    /**\n     * add a new output slot to use in this node\n     * @method addOutputs\n     * @param {Array} array of triplets like [[name,type,extra_info],[...]]\n     * @memberOf LGraphNode\n     */\n    addOutputs(array) {\n        for (let i = 0; i < array.length; ++i) {\n            const info = array[i];\n            const o = {\n                name: info[0],\n                type: info[1],\n                link: null,\n            };\n            if (array[2]) {\n                for (const j in info[2]) {\n                    o[j] = info[2][j];\n                }\n            }\n\n            if (!this.outputs) {\n                this.outputs = [];\n            }\n            this.outputs.push(o);\n            if (this.onOutputAdded) {\n                this.onOutputAdded(o);\n            }\n        }\n\n        this.setSize(this.computeSize());\n        this.setDirtyCanvas(true, true);\n    }\n\n    /**\n     * remove an existing output slot\n     * @method removeOutput\n     * @param {number} slot\n     * @memberOf LGraphNode\n     */\n    removeOutput(slot) {\n        this.disconnectOutput(slot);\n        this.outputs.splice(slot, 1);\n        for (let i = slot; i < this.outputs.length; ++i) {\n            if (!this.outputs[i] || !this.outputs[i].links) {\n                continue;\n            }\n            const { links } = this.outputs[i];\n            for (let j = 0; j < links.length; ++j) {\n                const link = this.graph.links[links[j]];\n                if (!link) {\n                    continue;\n                }\n                link.origin_slot -= 1;\n            }\n        }\n\n        this.setSize(this.computeSize());\n        if (this.onOutputRemoved) {\n            this.onOutputRemoved(slot);\n        }\n        this.setDirtyCanvas(true, true);\n    }\n\n    /**\n     * add a new input slot to use in this node\n     * @method addInput\n     * @param {string} name\n     * @param {string} type string defining the input type (\"vec3\",\"number\",...), it its a generic\n     *     one use 0\n     * @param {Object} extra_info this can be used to have special properties of an input (label,\n     *     color, position, etc)\n     * @memberOf LGraphNode\n     */\n    addInput(name, type, extra_info) {\n        type = type || 0;\n        const o = {\n            name,\n            type,\n            link: null,\n        };\n        if (extra_info) {\n            for (const i in extra_info) {\n                o[i] = extra_info[i];\n            }\n        }\n\n        if (!this.inputs) {\n            this.inputs = [];\n        }\n\n        this.inputs.push(o);\n        this.setSize(this.computeSize());\n\n        if (this.onInputAdded) {\n            this.onInputAdded(o);\n        }\n\n        this.setDirtyCanvas(true, true);\n        return o;\n    }\n\n    /**\n     * add several new input slots in this node\n     * @method addInputs\n     * @param {Array} array of triplets like [[name,type,extra_info],[...]]\n     * @memberOf LGraphNode\n     */\n    addInputs(array) {\n        for (let i = 0; i < array.length; ++i) {\n            const info = array[i];\n            const o = {\n                name: info[0],\n                type: info[1],\n                link: null,\n            };\n            if (array[2]) {\n                for (const j in info[2]) {\n                    o[j] = info[2][j];\n                }\n            }\n\n            if (!this.inputs) {\n                this.inputs = [];\n            }\n            this.inputs.push(o);\n            if (this.onInputAdded) {\n                this.onInputAdded(o);\n            }\n        }\n\n        this.setSize(this.computeSize());\n        this.setDirtyCanvas(true, true);\n    }\n\n    /**\n     * remove an existing input slot\n     * @method removeInput\n     * @param {number} slot\n     * @memberOf LGraphNode\n     */\n    removeInput(slot) {\n        this.disconnectInput(slot);\n        const slot_info = this.inputs.splice(slot, 1);\n        for (let i = slot; i < this.inputs.length; ++i) {\n            if (!this.inputs[i]) {\n                continue;\n            }\n            const link = this.graph.links[this.inputs[i].link];\n            if (!link) {\n                continue;\n            }\n            link.target_slot -= 1;\n        }\n        this.setSize(this.computeSize());\n        if (this.onInputRemoved) {\n            this.onInputRemoved(slot, slot_info[0]);\n        }\n        this.setDirtyCanvas(true, true);\n    }\n\n    /**\n     * add an special connection to this node (used for special kinds of graphs)\n     * @method addConnection\n     * @param {string} name\n     * @param {string} type string defining the input type (\"vec3\",\"number\",...)\n     * @param {number[]} pos position of the connection inside the node\n     * @param {string} direction if is input or output\n     * @memberOf LGraphNode\n     */\n    addConnection(name, type, pos, direction) {\n        const o = {\n            name,\n            type,\n            pos,\n            direction,\n            links: null,\n        };\n        this.connections.push(o);\n        return o;\n    }\n\n    /**\n     * computes the minimum size of a node according to its inputs and output slots\n     * @method computeSize\n     * @param {number} minHeight\n     * @return {number} the total size\n     * @memberOf LGraphNode\n     */\n    computeSize(out) {\n        if (this.constructor.size) {\n            return this.constructor.size.concat();\n        }\n\n        let rows = Math.max(\n            this.inputs ? this.inputs.length : 1,\n            this.outputs ? this.outputs.length : 1,\n        );\n        const size = out || new Float32Array([0, 0]);\n        rows = Math.max(rows, 1);\n        var font_size = defaultConfig.NODE_TEXT_SIZE; // although it should be\n        // graphcanvas.inner_text_font size\n\n        var font_size = font_size;\n        const title_width = compute_text_size(this.title);\n        let input_width = 0;\n        let output_width = 0;\n\n        if (this.inputs) {\n            for (var i = 0, l = this.inputs.length; i < l; ++i) {\n                const input = this.inputs[i];\n                var text = input.label || input.name || \"\";\n                var text_width = compute_text_size(text);\n                if (input_width < text_width) {\n                    input_width = text_width;\n                }\n            }\n        }\n\n        if (this.outputs) {\n            for (var i = 0, l = this.outputs.length; i < l; ++i) {\n                const output = this.outputs[i];\n                var text = output.label || output.name || \"\";\n                var text_width = compute_text_size(text);\n                if (output_width < text_width) {\n                    output_width = text_width;\n                }\n            }\n        }\n\n        size[0] = Math.max(input_width + output_width + 10, title_width);\n        size[0] = Math.max(size[0], defaultConfig.NODE_WIDTH);\n        if (this.widgets && this.widgets.length) {\n            size[0] = Math.max(size[0], defaultConfig.NODE_WIDTH * 1.5);\n        }\n\n        size[1] = (this.constructor.slot_start_y || 0) + rows * defaultConfig.NODE_SLOT_HEIGHT;\n\n        let widgets_height = 0;\n        if (this.widgets && this.widgets.length) {\n            for (var i = 0, l = this.widgets.length; i < l; ++i) {\n                if (this.widgets[i].computeSize) {\n                    widgets_height += this.widgets[i].computeSize(size[0])[1] + 4;\n                } else {\n                    widgets_height += defaultConfig.NODE_WIDGET_HEIGHT + 4;\n                }\n            }\n            widgets_height += 8;\n        }\n\n        // compute height using widgets height\n        if (this.widgets_up) {\n            size[1] = Math.max(size[1], widgets_height);\n        } else if (this.widgets_start_y != null) {\n            size[1] = Math.max(size[1], widgets_height + this.widgets_start_y);\n        } else {\n            size[1] += widgets_height;\n        }\n\n        function compute_text_size(text) {\n            if (!text) {\n                return 0;\n            }\n            return font_size * text.length * 0.6;\n        }\n\n        if (\n            this.constructor.min_height\n            && size[1] < this.constructor.min_height\n        ) {\n            size[1] = this.constructor.min_height;\n        }\n\n        size[1] += 6; // margin\n\n        return size;\n    }\n\n    /**\n     * returns all the info available about a property of this node.\n     *\n     * @method getPropertyInfo\n     * @param {String} property name of the property\n     * @return {Object} the object with all the available info\n     * @memberOf LGraphNode\n     */\n    getPropertyInfo(property) {\n        let info = null;\n\n        // there are several ways to define info about a property\n        // legacy mode\n        if (this.properties_info) {\n            for (let i = 0; i < this.properties_info.length; ++i) {\n                if (this.properties_info[i].name == property) {\n                    info = this.properties_info[i];\n                    break;\n                }\n            }\n        }\n        // litescene mode using the constructor\n        if (this.constructor[`@${property}`]) info = this.constructor[`@${property}`];\n\n        if (this.constructor.widgets_info && this.constructor.widgets_info[property]) info = this.constructor.widgets_info[property];\n\n        // litescene mode using the constructor\n        if (!info && this.onGetPropertyInfo) {\n            info = this.onGetPropertyInfo(property);\n        }\n\n        if (!info) info = {};\n        if (!info.type) info.type = typeof this.properties[property];\n        if (info.widget == \"combo\") info.type = \"enum\";\n\n        return info;\n    }\n\n    /**\n     * Defines a widget inside the node, it will be rendered on top of the node, you can control\n     * lots of properties\n     *\n     * @method addWidget\n     * @param {String} type the widget type (could be \"number\",\"string\",\"combo\"\n     * @param {String} name the text to show on the widget\n     * @param {String} value the default value\n     * @param {Function|String} callback function to call when it changes (optionally, it can be\n     *     the name of the property to modify)\n     * @param {Object} options the object that contains special properties of this widget\n     * @return {Object} the created widget object\n     * @memberOf LGraphNode\n     */\n    addWidget(type, name, value, callback, options) {\n        if (!this.widgets) {\n            this.widgets = [];\n        }\n\n        if (!options && callback && callback.constructor === Object) {\n            options = callback;\n            callback = null;\n        }\n\n        if (options && options.constructor === String) // options can be the property name\n        {\n            options = { property: options };\n        }\n\n        if (callback && callback.constructor === String) // callback can be the property name\n        {\n            if (!options) options = {};\n            options.property = callback;\n            callback = null;\n        }\n\n        if (callback && callback.constructor !== Function) {\n            console.warn(\"addWidget: callback must be a function\");\n            callback = null;\n        }\n\n        const w = {\n            type: type.toLowerCase(),\n            name,\n            value,\n            callback,\n            options: options || {},\n        };\n\n        if (w.options.y) {\n            w.y = w.options.y;\n        }\n\n        if (!callback && !w.options.callback && !w.options.property) {\n            console.warn(\"LiteGraph addWidget(...) without a callback or property assigned\");\n        }\n        if (type == \"combo\" && !w.options.values) {\n            throw \"LiteGraph addWidget('combo',...) requires to pass values in options: { values:['red','blue'] }\";\n        }\n        this.widgets.push(w);\n        this.setSize(this.computeSize());\n        return w;\n    }\n\n    addCustomWidget(custom_widget) {\n        if (!this.widgets) {\n            this.widgets = [];\n        }\n        this.widgets.push(custom_widget);\n        return custom_widget;\n    }\n\n    /**\n     * returns the bounding of the object, used for rendering purposes\n     * bounding is: [topleft_cornerx, topleft_cornery, width, height]\n     * @method getBounding\n     * @return {Float32Array} the total size\n     * @memberOf LGraphNode\n     */\n    getBounding(out) {\n        out = out || new Float32Array(4);\n        out[0] = this.pos[0] - 4;\n        out[1] = this.pos[1] - defaultConfig.NODE_TITLE_HEIGHT;\n        out[2] = this.size[0] + 4;\n        out[3] = this.size[1] + defaultConfig.NODE_TITLE_HEIGHT;\n\n        if (this.onBounding) {\n            this.onBounding(out);\n        }\n        return out;\n    }\n\n    /**\n     * checks if a point is inside the shape of a node\n     * @method isPointInside\n     * @param {number} x\n     * @param {number} y\n     * @return {boolean}\n     * @memberOf LGraphNode\n     */\n    isPointInside(x, y, margin, skip_title) {\n        margin = margin || 0;\n\n        let margin_top = this.graph && this.graph.isLive() ? 0 : defaultConfig.NODE_TITLE_HEIGHT;\n        if (skip_title) {\n            margin_top = 0;\n        }\n        if (this.flags && this.flags.collapsed) {\n            // if ( distance([x,y], [this.pos[0] + this.size[0]*0.5, this.pos[1] +\n            // this.size[1]*0.5]) < LiteGraph.NODE_COLLAPSED_RADIUS)\n            if (\n                isInsideRectangle(\n                    x,\n                    y,\n                    this.pos[0] - margin,\n                    this.pos[1] - defaultConfig.NODE_TITLE_HEIGHT - margin,\n                    (this._collapsed_width || defaultConfig.NODE_COLLAPSED_WIDTH)\n                    + 2 * margin,\n                    defaultConfig.NODE_TITLE_HEIGHT + 2 * margin,\n                )\n            ) {\n                return true;\n            }\n        } else if (\n            this.pos[0] - 4 - margin < x\n            && this.pos[0] + this.size[0] + 4 + margin > x\n            && this.pos[1] - margin_top - margin < y\n            && this.pos[1] + this.size[1] + margin > y\n        ) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * checks if a point is inside a node slot, and returns info about which slot\n     * @method getSlotInPosition\n     * @param {number} x\n     * @param {number} y\n     * @return {Object} if found the object contains { input|output: slot object, slot: number,\n     *     link_pos: [x,y] }\n     * @memberOf LGraphNode\n     */\n    getSlotInPosition(x, y) {\n        // search for inputs\n        const link_pos = new Float32Array(2);\n        if (this.inputs) {\n            for (var i = 0, l = this.inputs.length; i < l; ++i) {\n                const input = this.inputs[i];\n                this.getConnectionPos(true, i, link_pos);\n                if (\n                    isInsideRectangle(\n                        x,\n                        y,\n                        link_pos[0] - 10,\n                        link_pos[1] - 5,\n                        20,\n                        10,\n                    )\n                ) {\n                    return {\n                        input,\n                        slot: i,\n                        link_pos,\n                    };\n                }\n            }\n        }\n\n        if (this.outputs) {\n            for (var i = 0, l = this.outputs.length; i < l; ++i) {\n                const output = this.outputs[i];\n                this.getConnectionPos(false, i, link_pos);\n                if (\n                    isInsideRectangle(\n                        x,\n                        y,\n                        link_pos[0] - 10,\n                        link_pos[1] - 5,\n                        20,\n                        10,\n                    )\n                ) {\n                    return {\n                        output,\n                        slot: i,\n                        link_pos,\n                    };\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * returns the input slot with a given name (used for dynamic slots), -1 if not found\n     * @method findInputSlot\n     * @param {string} name the name of the slot\n     * @return {number} the slot (-1 if not found)\n     * @memberOf LGraphNode\n     */\n    findInputSlot(name) {\n        if (!this.inputs) {\n            return -1;\n        }\n        for (let i = 0, l = this.inputs.length; i < l; ++i) {\n            if (name == this.inputs[i].name) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * returns the output slot with a given name (used for dynamic slots), -1 if not found\n     * @method findOutputSlot\n     * @param {string} name the name of the slot\n     * @return {number} the slot (-1 if not found)\n     * @memberOf LGraphNode\n     */\n    findOutputSlot(name) {\n        if (!this.outputs) {\n            return -1;\n        }\n        for (let i = 0, l = this.outputs.length; i < l; ++i) {\n            if (name == this.outputs[i].name) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * connect this node output to the input of another node\n     * @method connect\n     * @param {number_or_string} slot (could be the number of the slot or the string with the name\n     *     of the slot)\n     * @param {LGraphNode} node the target node\n     * @param {number_or_string} target_slot the input slot of the target node (could be the number\n     *     of the slot or the string with the name of the slot, or -1 to connect a trigger)\n     * @return {Object} the link_info is created, otherwise null\n     * @memberOf LGraphNode\n     */\n    connect(slot, target_node, target_slot) {\n        target_slot = target_slot || 0;\n\n        if (!this.graph) {\n            // could be connected before adding it to a graph\n            console.log(\n                \"Connect: Error, node doesn't belong to any graph. Nodes must be added first to a graph before connecting them.\",\n            ); // due to link ids being associated with graphs\n            return null;\n        }\n\n        // seek for the output slot\n        if (slot.constructor === String) {\n            slot = this.findOutputSlot(slot);\n            if (slot == -1) {\n                if (defaultConfig.debug) {\n                    console.log(`Connect: Error, no slot of name ${slot}`);\n                }\n                return null;\n            }\n        } else if (!this.outputs || slot >= this.outputs.length) {\n            if (defaultConfig.debug) {\n                console.log(\"Connect: Error, slot number not found\");\n            }\n            return null;\n        }\n\n        if (target_node && target_node.constructor === Number) {\n            target_node = this.graph.getNodeById(target_node);\n        }\n        if (!target_node) {\n            throw \"target node is null\";\n        }\n\n        // avoid loopback\n        if (target_node == this) {\n            return null;\n        }\n\n        // you can specify the slot by name\n        if (target_slot.constructor === String) {\n            target_slot = target_node.findInputSlot(target_slot);\n            if (target_slot == -1) {\n                if (defaultConfig.debug) {\n                    console.log(\n                        `Connect: Error, no slot of name ${target_slot}`,\n                    );\n                }\n                return null;\n            }\n        } else if (target_slot === defaultConfig.EVENT) {\n            // search for first slot with event?\n            /*\n    //create input for trigger\n    var input = target_node.addInput(\"onTrigger\", LiteGraph.EVENT );\n    target_slot = target_node.inputs.length - 1; //last one is the one created\n    target_node.mode = LiteGraph.ON_TRIGGER;\n    */\n            return null;\n        } else if (\n            !target_node.inputs\n            || target_slot >= target_node.inputs.length\n        ) {\n            if (defaultConfig.debug) {\n                console.log(\"Connect: Error, slot number not found\");\n            }\n            return null;\n        }\n\n        let changed = false;\n\n        // if there is something already plugged there, disconnect\n        if (target_node.inputs[target_slot].link != null) {\n            this.graph.beforeChange();\n            target_node.disconnectInput(target_slot);\n            changed = true;\n        }\n\n        // why here??\n        // this.setDirtyCanvas(false,true);\n        // this.graph.connectionChange( this );\n\n        const output = this.outputs[slot];\n\n        // allows nodes to block connection\n        if (target_node.onConnectInput) {\n            if (target_node.onConnectInput(target_slot, output.type, output, this, slot) === false) {\n                return null;\n            }\n        }\n\n        const input = target_node.inputs[target_slot];\n        let link_info = null;\n\n        // this slots cannot be connected (different types)\n        if (!isValidConnection(output.type, input.type)) {\n            this.setDirtyCanvas(false, true);\n            if (changed) this.graph.connectionChange(this, link_info);\n            return null;\n        }\n\n        if (!changed) this.graph.beforeChange();\n\n        // create link class\n        link_info = new LLink(\n            ++this.graph.last_link_id,\n            input.type,\n            this.id,\n            slot,\n            target_node.id,\n            target_slot,\n        );\n\n        // add to graph links list\n        this.graph.links[link_info.id] = link_info;\n\n        // connect in output\n        if (output.links == null) {\n            output.links = [];\n        }\n        output.links.push(link_info.id);\n        // connect in input\n        target_node.inputs[target_slot].link = link_info.id;\n        if (this.graph) {\n            this.graph._version++;\n        }\n        if (this.onConnectionsChange) {\n            this.onConnectionsChange(\n                defaultConfig.OUTPUT,\n                slot,\n                true,\n                link_info,\n                output,\n            );\n        } // link_info has been created now, so its updated\n        if (target_node.onConnectionsChange) {\n            target_node.onConnectionsChange(\n                defaultConfig.INPUT,\n                target_slot,\n                true,\n                link_info,\n                input,\n            );\n        }\n        if (this.graph && this.graph.onNodeConnectionChange) {\n            this.graph.onNodeConnectionChange(\n                defaultConfig.INPUT,\n                target_node,\n                target_slot,\n                this,\n                slot,\n            );\n            this.graph.onNodeConnectionChange(\n                defaultConfig.OUTPUT,\n                this,\n                slot,\n                target_node,\n                target_slot,\n            );\n        }\n\n        this.setDirtyCanvas(false, true);\n        this.graph.afterChange();\n        this.graph.connectionChange(this, link_info);\n\n        return link_info;\n    }\n\n    /**\n     * disconnect one output to an specific node\n     * @method disconnectOutput\n     * @param {number_or_string} slot (could be the number of the slot or the string with the name\n     *     of the slot)\n     * @param {LGraphNode} target_node the target node to which this slot is connected [Optional,\n     *     if not target_node is specified all nodes will be disconnected]\n     * @return {boolean} if it was disconnected successfully\n     * @memberOf LGraphNode\n     */\n    disconnectOutput(slot, target_node) {\n        if (slot.constructor === String) {\n            slot = this.findOutputSlot(slot);\n            if (slot == -1) {\n                if (defaultConfig.debug) {\n                    console.log(`Connect: Error, no slot of name ${slot}`);\n                }\n                return false;\n            }\n        } else if (!this.outputs || slot >= this.outputs.length) {\n            if (defaultConfig.debug) {\n                console.log(\"Connect: Error, slot number not found\");\n            }\n            return false;\n        }\n\n        // get output slot\n        const output = this.outputs[slot];\n        if (!output || !output.links || output.links.length == 0) {\n            return false;\n        }\n\n        // one of the output links in this slot\n        if (target_node) {\n            if (target_node.constructor === Number) {\n                target_node = this.graph.getNodeById(target_node);\n            }\n            if (!target_node) {\n                throw \"Target Node not found\";\n            }\n\n            for (var i = 0, l = output.links.length; i < l; i++) {\n                var link_id = output.links[i];\n                var link_info = this.graph.links[link_id];\n\n                // is the link we are searching for...\n                if (link_info.target_id == target_node.id) {\n                    output.links.splice(i, 1); // remove here\n                    var input = target_node.inputs[link_info.target_slot];\n                    input.link = null; // remove there\n                    delete this.graph.links[link_id]; // remove the link from the links pool\n                    if (this.graph) {\n                        this.graph._version++;\n                    }\n                    if (target_node.onConnectionsChange) {\n                        target_node.onConnectionsChange(\n                            defaultConfig.INPUT,\n                            link_info.target_slot,\n                            false,\n                            link_info,\n                            input,\n                        );\n                    } // link_info hasn't been modified so its ok\n                    if (this.onConnectionsChange) {\n                        this.onConnectionsChange(\n                            defaultConfig.OUTPUT,\n                            slot,\n                            false,\n                            link_info,\n                            output,\n                        );\n                    }\n                    if (this.graph && this.graph.onNodeConnectionChange) {\n                        this.graph.onNodeConnectionChange(\n                            defaultConfig.OUTPUT,\n                            this,\n                            slot,\n                        );\n                    }\n                    if (this.graph && this.graph.onNodeConnectionChange) {\n                        this.graph.onNodeConnectionChange(\n                            defaultConfig.OUTPUT,\n                            this,\n                            slot,\n                        );\n                        this.graph.onNodeConnectionChange(\n                            defaultConfig.INPUT,\n                            target_node,\n                            link_info.target_slot,\n                        );\n                    }\n                    break;\n                }\n            }\n        } // all the links in this output slot\n        else {\n            for (var i = 0, l = output.links.length; i < l; i++) {\n                var link_id = output.links[i];\n                var link_info = this.graph.links[link_id];\n                if (!link_info) {\n                    // bug: it happens sometimes\n                    continue;\n                }\n\n                var target_node = this.graph.getNodeById(link_info.target_id);\n                var input = null;\n                if (this.graph) {\n                    this.graph._version++;\n                }\n                if (target_node) {\n                    input = target_node.inputs[link_info.target_slot];\n                    input.link = null; // remove other side link\n                    if (target_node.onConnectionsChange) {\n                        target_node.onConnectionsChange(\n                            defaultConfig.INPUT,\n                            link_info.target_slot,\n                            false,\n                            link_info,\n                            input,\n                        );\n                    } // link_info hasn't been modified so its ok\n                    if (this.graph && this.graph.onNodeConnectionChange) {\n                        this.graph.onNodeConnectionChange(\n                            defaultConfig.INPUT,\n                            target_node,\n                            link_info.target_slot,\n                        );\n                    }\n                }\n                delete this.graph.links[link_id]; // remove the link from the links pool\n                if (this.onConnectionsChange) {\n                    this.onConnectionsChange(\n                        defaultConfig.OUTPUT,\n                        slot,\n                        false,\n                        link_info,\n                        output,\n                    );\n                }\n                if (this.graph && this.graph.onNodeConnectionChange) {\n                    this.graph.onNodeConnectionChange(\n                        defaultConfig.OUTPUT,\n                        this,\n                        slot,\n                    );\n                    this.graph.onNodeConnectionChange(\n                        defaultConfig.INPUT,\n                        target_node,\n                        link_info.target_slot,\n                    );\n                }\n            }\n            output.links = null;\n        }\n\n        this.setDirtyCanvas(false, true);\n        this.graph.connectionChange(this);\n        return true;\n    }\n\n    /**\n     * disconnect one input\n     * @method disconnectInput\n     * @param {number_or_string} slot (could be the number of the slot or the string with the name\n     *     of the slot)\n     * @return {boolean} if it was disconnected successfully\n     * @memberOf LGraphNode\n     */\n    disconnectInput(slot) {\n        // seek for the output slot\n        if (slot.constructor === String) {\n            slot = this.findInputSlot(slot);\n            if (slot == -1) {\n                if (defaultConfig.debug) {\n                    console.log(`Connect: Error, no slot of name ${slot}`);\n                }\n                return false;\n            }\n        } else if (!this.inputs || slot >= this.inputs.length) {\n            if (defaultConfig.debug) {\n                console.log(\"Connect: Error, slot number not found\");\n            }\n            return false;\n        }\n\n        const input = this.inputs[slot];\n        if (!input) {\n            return false;\n        }\n\n        const link_id = this.inputs[slot].link;\n        if (link_id != null) {\n            this.inputs[slot].link = null;\n\n            // remove other side\n            const link_info = this.graph.links[link_id];\n            if (link_info) {\n                const target_node = this.graph.getNodeById(link_info.origin_id);\n                if (!target_node) {\n                    return false;\n                }\n\n                const output = target_node.outputs[link_info.origin_slot];\n                if (!output || !output.links || output.links.length == 0) {\n                    return false;\n                }\n\n                // search in the inputs list for this link\n                for (var i = 0, l = output.links.length; i < l; i++) {\n                    if (output.links[i] == link_id) {\n                        output.links.splice(i, 1);\n                        break;\n                    }\n                }\n\n                delete this.graph.links[link_id]; // remove from the pool\n                if (this.graph) {\n                    this.graph._version++;\n                }\n                if (this.onConnectionsChange) {\n                    this.onConnectionsChange(\n                        defaultConfig.INPUT,\n                        slot,\n                        false,\n                        link_info,\n                        input,\n                    );\n                }\n                if (target_node.onConnectionsChange) {\n                    target_node.onConnectionsChange(\n                        defaultConfig.OUTPUT,\n                        i,\n                        false,\n                        link_info,\n                        output,\n                    );\n                }\n                if (this.graph && this.graph.onNodeConnectionChange) {\n                    this.graph.onNodeConnectionChange(\n                        defaultConfig.OUTPUT,\n                        target_node,\n                        i,\n                    );\n                    this.graph.onNodeConnectionChange(defaultConfig.INPUT, this, slot);\n                }\n            }\n        } // link != null\n\n        this.setDirtyCanvas(false, true);\n        if (this.graph) this.graph.connectionChange(this);\n        return true;\n    }\n\n    /**\n     * returns the center of a connection point in canvas coords\n     * @method getConnectionPos\n     * @param {boolean} is_input true if if a input slot, false if it is an output\n     * @param {number_or_string} slot (could be the number of the slot or the string with the name\n     *     of the slot)\n     * @param {vec2} out [optional] a place to store the output, to free garbage\n     * @return {number[]} the position\n     * @memberOf LGraphNode\n     * */\n    getConnectionPos(\n        is_input,\n        slot_number,\n        out,\n    ) {\n        out = out || new Float32Array(2);\n        let num_slots = 0;\n        if (is_input && this.inputs) {\n            num_slots = this.inputs.length;\n        }\n        if (!is_input && this.outputs) {\n            num_slots = this.outputs.length;\n        }\n\n        const offset = defaultConfig.NODE_SLOT_HEIGHT * 0.5;\n\n        if (this.flags.collapsed) {\n            const w = this._collapsed_width || defaultConfig.NODE_COLLAPSED_WIDTH;\n            if (this.horizontal) {\n                out[0] = this.pos[0] + w * 0.5;\n                if (is_input) {\n                    out[1] = this.pos[1] - defaultConfig.NODE_TITLE_HEIGHT;\n                } else {\n                    out[1] = this.pos[1];\n                }\n            } else {\n                if (is_input) {\n                    out[0] = this.pos[0];\n                } else {\n                    out[0] = this.pos[0] + w;\n                }\n                out[1] = this.pos[1] - defaultConfig.NODE_TITLE_HEIGHT * 0.5;\n            }\n            return out;\n        }\n\n        // weird feature that never got finished\n        if (is_input && slot_number == -1) {\n            out[0] = this.pos[0] + defaultConfig.NODE_TITLE_HEIGHT * 0.5;\n            out[1] = this.pos[1] + defaultConfig.NODE_TITLE_HEIGHT * 0.5;\n            return out;\n        }\n\n        // hard-coded pos\n        if (\n            is_input\n            && num_slots > slot_number\n            && this.inputs[slot_number].pos\n        ) {\n            out[0] = this.pos[0] + this.inputs[slot_number].pos[0];\n            out[1] = this.pos[1] + this.inputs[slot_number].pos[1];\n            return out;\n        }\n        if (\n            !is_input\n            && num_slots > slot_number\n            && this.outputs[slot_number].pos\n        ) {\n            out[0] = this.pos[0] + this.outputs[slot_number].pos[0];\n            out[1] = this.pos[1] + this.outputs[slot_number].pos[1];\n            return out;\n        }\n\n        // horizontal distributed slots\n        if (this.horizontal) {\n            out[0] = this.pos[0] + (slot_number + 0.5) * (this.size[0] / num_slots);\n            if (is_input) {\n                out[1] = this.pos[1] - defaultConfig.NODE_TITLE_HEIGHT;\n            } else {\n                out[1] = this.pos[1] + this.size[1];\n            }\n            return out;\n        }\n\n        // default vertical slots\n        if (is_input) {\n            out[0] = this.pos[0] + offset;\n        } else {\n            out[0] = this.pos[0] + this.size[0] + 1 - offset;\n        }\n        out[1] = this.pos[1]\n            + (slot_number + 0.7) * defaultConfig.NODE_SLOT_HEIGHT\n            + (this.constructor.slot_start_y || 0);\n        return out;\n    }\n\n    /* Force align to grid */\n    alignToGrid() {\n        this.pos[0] = defaultConfig.CANVAS_GRID_SIZE\n            * Math.round(this.pos[0] / defaultConfig.CANVAS_GRID_SIZE);\n        this.pos[1] = defaultConfig.CANVAS_GRID_SIZE\n            * Math.round(this.pos[1] / defaultConfig.CANVAS_GRID_SIZE);\n    }\n\n    /* Console output */\n    trace(msg) {\n        if (!this.console) {\n            this.console = [];\n        }\n\n        this.console.push(msg);\n        if (this.console.length > LGraphNode.MAX_CONSOLE) {\n            this.console.shift();\n        }\n\n        if (this.graph.onNodeTrace) this.graph.onNodeTrace(this, msg);\n    }\n\n    /* Forces to redraw or the main canvas (LGraphNode) or the bg canvas (links) */\n    setDirtyCanvas(\n        dirty_foreground,\n        dirty_background,\n    ) {\n        if (!this.graph) {\n            return;\n        }\n        this.graph.sendActionToCanvas(\"setDirty\", [\n            dirty_foreground,\n            dirty_background,\n        ]);\n    }\n\n    loadImage(url) {\n        const img = new Image();\n        img.src = defaultConfig.node_images_path + url;\n        img.ready = false;\n\n        img.onload = () => {\n            img.ready = true;\n            this.setDirtyCanvas(true);\n        };\n        return img;\n    }\n\n    // safe LGraphNode action execution (not sure if safe)\n    /*\n    executeAction = function(action)\n    {\n    if(action == \"\") return false;\n\n    if( action.indexOf(\";\") != -1 || action.indexOf(\"}\") != -1)\n    {\n    this.trace(\"Error: Action contains unsafe characters\");\n    return false;\n    }\n\n    var tokens = action.split(\"(\");\n    var func_name = tokens[0];\n    if( typeof(this[func_name]) != \"function\")\n    {\n    this.trace(\"Error: Action not found on node: \" + func_name);\n    return false;\n    }\n\n    var code = action;\n\n    try\n    {\n    var _foo = eval;\n    eval = null;\n    (new Function(\"with(this) { \" + code + \"}\")).call(this);\n    eval = _foo;\n    }\n    catch (err)\n    {\n    this.trace(\"Error executing action {\" + action + \"} :\" + err);\n    return false;\n    }\n\n    return true;\n    }\n    */\n\n    /* Allows to get onMouseMove and onMouseUp events even if the mouse is out of focus */\n    captureInput(v) {\n        if (!this.graph || !this.graph.list_of_graphcanvas) {\n            return;\n        }\n\n        const list = this.graph.list_of_graphcanvas;\n\n        for (let i = 0; i < list.length; ++i) {\n            const c = list[i];\n            // releasing somebody elses capture?!\n            if (!v && c.node_capturing_input != this) {\n                continue;\n            }\n\n            // change\n            c.node_capturing_input = v ? this : null;\n        }\n    }\n\n    /**\n     * Collapse the node to make it smaller on the canvas\n     * @method collapse\n     * @memberOf LGraphNode\n     * */\n    collapse(force) {\n        this.graph._version++;\n        if (this.constructor.collapsable === false && !force) {\n            return;\n        }\n        this.flags.collapsed = !this.flags.collapsed;\n        this.setDirtyCanvas(true, true);\n    }\n\n    /**\n     * Forces the node to do not move or realign on Z\n     * @method pin\n     * @memberOf LGraphNode\n     * */\n\n    pin(v) {\n        this.graph._version++;\n        if (v === undefined) {\n            this.flags.pinned = !this.flags.pinned;\n        } else {\n            this.flags.pinned = v;\n        }\n    }\n\n    localToScreen(x, y, graphcanvas) {\n        return [\n            (x + this.pos[0]) * graphcanvas.scale + graphcanvas.offset[0],\n            (y + this.pos[1]) * graphcanvas.scale + graphcanvas.offset[1],\n        ];\n    }\n\n    /**\n     * Create a node of a given type with a name. The node is not attached to any graph yet.\n     * @method createNode\n     * @param {String} type full name of the node class. p.e. \"math/sin\"\n     * @param {String} name a name to distinguish from other nodes\n     * @param {Object} options to set options\n     * @memberOf LGraphNode\n     */\n    static createNode(type, title, options) {\n        const baseClass = defaultConfig.registered_node_types[type];\n        if (!baseClass) {\n            if (defaultConfig.debug) console.log(`GraphNode type \"${type}\" not registered.`);\n            return null;\n        }\n\n        const prototype = baseClass.prototype || baseClass;\n\n        title = title || baseClass.title || type;\n\n        let node = null;\n\n        if (defaultConfig.catch_exceptions) {\n            try {\n                node = new baseClass(title);\n            } catch (err) {\n                console.error(err);\n                return null;\n            }\n        } else {\n            node = new baseClass(title);\n        }\n\n        node.type = type;\n\n        if (!node.title && title) {\n            node.title = title;\n        }\n        if (!node.properties) {\n            node.properties = {};\n        }\n        if (!node.properties_info) {\n            node.properties_info = [];\n        }\n        if (!node.flags) {\n            node.flags = {};\n        }\n        if (!node.size) {\n            node.size = node.computeSize();\n            // call onresize?\n        }\n        if (!node.pos) {\n            node.pos = defaultConfig.DEFAULT_POSITION.concat();\n        }\n        if (!node.mode) {\n            node.mode = defaultConfig.ALWAYS;\n        }\n\n        // extra options\n        if (options) {\n            // eslint-disable-next-line\n            for (const i in options) node[i] = options[i];\n        }\n\n        return node;\n    }\n\n    // debug purposes: reloads all the js scripts that matches a wildcard\n    static reloadNodes(folderWildcard) {\n        const tmp = document.getElementsByTagName(\"script\");\n        // weird, this array changes by its own, so we use a copy\n        const scriptFiles = [];\n        for (const t of tmp) scriptFiles.push(t);\n\n        const docHeadObj = document.getElementsByTagName(\"head\")[0];\n        folderWildcard = document.location.href + folderWildcard;\n\n        for (const script of scriptFiles) {\n            const { src } = script;\n            if (\n                !src\n                || src.substr(0, folderWildcard.length) !== folderWildcard\n            ) continue;\n\n            try {\n                if (defaultConfig.debug) {\n                    console.log(`Reloading: ${src}`);\n                }\n                const dynamicScript = document.createElement(\"script\");\n                dynamicScript.type = \"text/javascript\";\n                dynamicScript.src = src;\n                docHeadObj.appendChild(dynamicScript);\n                docHeadObj.removeChild(scriptFiles[i]);\n            } catch (err) {\n                if (defaultConfig.throw_errors) {\n                    throw err;\n                }\n                if (defaultConfig.debug) console.log(`Error while reloading ${src}`);\n            }\n        }\n\n        if (defaultConfig.debug) {\n            console.log(\"Nodes reloaded\");\n        }\n    }\n\n    /**\n     * Adds this method to all nodetypes, existing and to be created\n     * (You can add it to LGraphNode.prototype but then existing node types wont have it)\n     * @method addNodeMethod\n     * @param {Function} func\n     * @memberOf LGraphNode\n     */\n    static addNodeMethod(name, func) {\n        LGraphNode.prototype[name] = func;\n        for (const i in defaultConfig.registered_node_types) {\n            const type = defaultConfig.registered_node_types[i];\n            if (type.prototype[name]) type.prototype[`_${name}`] = type.prototype[name];\n            type.prototype[name] = func;\n        }\n    }\n\n    static extendNode(object) {\n        for (const i of Object.getOwnPropertyNames(LGraphNode.prototype)) {\n            if (!object.prototype[i]) {\n                object.prototype[i] = LGraphNode.prototype[i];\n            }\n        }\n    }\n\n}\n","import LGraphNode from \"./LGraphNode\";\nimport { overlapBounding } from \"./utils/math\";\n\n/**\n * @class LGraphGroup\n * @param title\n */\nexport default class LGraphGroup {\n    constructor(title) {\n        this._ctor(title);\n    }\n\n    _ctor(title) {\n        this.title = title || \"Group\";\n        this.font_size = 24;\n        this.color = \"#AAA\";\n        this._bounding = new Float32Array([10, 10, 140, 80]);\n        this._pos = this._bounding.subarray(0, 2);\n        this._size = this._bounding.subarray(2, 4);\n        this._nodes = [];\n        this.graph = null;\n\n        Object.defineProperty(this, \"pos\", {\n            set(v) {\n                if (!v || v.length < 2) {\n                    return;\n                }\n                this._pos[0] = v[0];\n                this._pos[1] = v[1];\n            },\n            get() {\n                return this._pos;\n            },\n            enumerable: true,\n        });\n\n        Object.defineProperty(this, \"size\", {\n            set(v) {\n                if (!v || v.length < 2) {\n                    return;\n                }\n                this._size[0] = Math.max(140, v[0]);\n                this._size[1] = Math.max(80, v[1]);\n            },\n            get() {\n                return this._size;\n            },\n            enumerable: true,\n        });\n    }\n\n    recomputeInsideNodes() {\n        this._nodes.length = 0;\n        const nodes = this.graph._nodes;\n        const node_bounding = new Float32Array(4);\n\n        for (let i = 0; i < nodes.length; ++i) {\n            const node = nodes[i];\n            node.getBounding(node_bounding);\n            if (!overlapBounding(this._bounding, node_bounding)) {\n                continue;\n            } // out of the visible area\n            this._nodes.push(node);\n        }\n    }\n\n    move(deltax, deltay, ignore_nodes) {\n        this._pos[0] += deltax;\n        this._pos[1] += deltay;\n        if (ignore_nodes) {\n            return;\n        }\n        for (let i = 0; i < this._nodes.length; ++i) {\n            const node = this._nodes[i];\n            node.pos[0] += deltax;\n            node.pos[1] += deltay;\n        }\n    }\n\n    serialize() {\n        const b = this._bounding;\n        return {\n            title: this.title,\n            bounding: [\n                Math.round(b[0]),\n                Math.round(b[1]),\n                Math.round(b[2]),\n                Math.round(b[3]),\n            ],\n            color: this.color,\n            font: this.font,\n        };\n    }\n\n    configure(o) {\n        this.title = o.title;\n        this._bounding.set(o.bounding);\n        this.color = o.color;\n        this.font = o.font;\n    }\n\n    isPointInside = LGraphNode.prototype.isPointInside\n\n    setDirtyCanvas = LGraphNode.prototype.setDirtyCanvas\n}\n","/**\n * @class DragAndScale\n * @param element\n * @param skipEvents\n */\nexport default class DragAndScale {\n    constructor(element, skipEvents) {\n        this.offset = new Float32Array([0, 0]);\n        this.scale = 1;\n        this.max_scale = 10;\n        this.min_scale = 0.1;\n        this.onredraw = null;\n        this.enabled = true;\n        this.last_mouse = [0, 0];\n        this.element = null;\n        this.visible_area = new Float32Array(4);\n\n        if (element) {\n            this.element = element;\n            if (!skipEvents) {\n                this.bindEvents(element);\n            }\n        }\n    }\n\n    bindEvents(element) {\n        this.last_mouse = new Float32Array(2);\n\n        this._binded_mouse_callback = this.onMouse.bind(this);\n\n        element.addEventListener(\"mousedown\", this._binded_mouse_callback);\n        element.addEventListener(\"mousemove\", this._binded_mouse_callback);\n\n        element.addEventListener(\n            \"mousewheel\",\n            this._binded_mouse_callback,\n            false,\n        );\n        element.addEventListener(\"wheel\", this._binded_mouse_callback, false);\n    }\n\n    computeVisibleArea() {\n        if (!this.element) {\n            // eslint-disable-next-line\n            this.visible_area[0] = this.visible_area[1] = this.visible_area[2] = this.visible_area[3] = 0;\n            return;\n        }\n        const { width } = this.element;\n        const { height } = this.element;\n        const startx = -this.offset[0];\n        const starty = -this.offset[1];\n        const endx = startx + width / this.scale;\n        const endy = starty + height / this.scale;\n        this.visible_area[0] = startx;\n        this.visible_area[1] = starty;\n        this.visible_area[2] = endx - startx;\n        this.visible_area[3] = endy - starty;\n    }\n\n    onMouse(e) {\n        if (!this.enabled) {\n            return;\n        }\n\n        const canvas = this.element;\n        const rect = canvas.getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        const y = e.clientY - rect.top;\n        e.canvasx = x;\n        e.canvasy = y;\n        e.dragging = this.dragging;\n\n        let ignore = false;\n        if (this.onmouse) {\n            ignore = this.onmouse(e);\n        }\n\n        if (e.type === \"mousedown\") {\n            this.dragging = true;\n            canvas.removeEventListener(\n                \"mousemove\",\n                this._binded_mouse_callback,\n            );\n            document.body.addEventListener(\n                \"mousemove\",\n                this._binded_mouse_callback,\n            );\n            document.body.addEventListener(\n                \"mouseup\",\n                this._binded_mouse_callback,\n            );\n        } else if (e.type === \"mousemove\") {\n            if (!ignore) {\n                const deltax = x - this.last_mouse[0];\n                const deltay = y - this.last_mouse[1];\n                if (this.dragging) {\n                    this.mouseDrag(deltax, deltay);\n                }\n            }\n        } else if (e.type === \"mouseup\") {\n            this.dragging = false;\n            document.body.removeEventListener(\n                \"mousemove\",\n                this._binded_mouse_callback,\n            );\n            document.body.removeEventListener(\n                \"mouseup\",\n                this._binded_mouse_callback,\n            );\n            canvas.addEventListener(\"mousemove\", this._binded_mouse_callback);\n        } else if (\n            e.type === \"mousewheel\"\n            || e.type === \"wheel\"\n            || e.type === \"DOMMouseScroll\"\n        ) {\n            e.eventType = \"mousewheel\";\n            if (e.type === \"wheel\") {\n                e.wheel = -e.deltaY;\n            } else {\n                e.wheel = e.wheelDeltaY != null ? e.wheelDeltaY : e.detail * -60;\n            }\n\n            // from stack overflow\n            if (e.wheelDelta) {\n                e.delta = e.wheelDelta / 40;\n            } else if (e.deltaY) {\n                e.delta = -e.deltaY / 3;\n            } else {\n                e.delta = 0;\n            }\n            this.changeDeltaScale(1.0 + e.delta * 0.05);\n        }\n\n        this.last_mouse[0] = x;\n        this.last_mouse[1] = y;\n\n        e.preventDefault();\n        e.stopPropagation();\n        return false;\n    }\n\n    toCanvasContext(ctx) {\n        ctx.scale(this.scale, this.scale);\n        ctx.translate(this.offset[0], this.offset[1]);\n    }\n\n    convertOffsetToCanvas(pos) {\n        // return [pos[0] / this.scale - this.offset[0], pos[1] / this.scale - this.offset[1]];\n        return [\n            (pos[0] + this.offset[0]) * this.scale,\n            (pos[1] + this.offset[1]) * this.scale,\n        ];\n    }\n\n    convertCanvasToOffset(pos, out) {\n        out = out || [0, 0];\n        out[0] = pos[0] / this.scale - this.offset[0];\n        out[1] = pos[1] / this.scale - this.offset[1];\n        return out;\n    }\n\n    mouseDrag(x, y) {\n        this.offset[0] += x / this.scale;\n        this.offset[1] += y / this.scale;\n\n        if (this.onredraw) {\n            this.onredraw(this);\n        }\n    }\n\n    changeScale(value, zoomingCenter) {\n        if (value < this.min_scale) {\n            value = this.min_scale;\n        } else if (value > this.max_scale) {\n            value = this.max_scale;\n        }\n\n        if (value === this.scale) {\n            return;\n        }\n\n        if (!this.element) {\n            return;\n        }\n\n        const rect = this.element.getBoundingClientRect();\n        if (!rect) {\n            return;\n        }\n\n        zoomingCenter = zoomingCenter || [\n            rect.width * 0.5,\n            rect.height * 0.5,\n        ];\n        const center = this.convertCanvasToOffset(zoomingCenter);\n        this.scale = value;\n        if (Math.abs(this.scale - 1) < 0.01) {\n            this.scale = 1;\n        }\n\n        const newCenter = this.convertCanvasToOffset(zoomingCenter);\n        const deltaOffset = [\n            newCenter[0] - center[0],\n            newCenter[1] - center[1],\n        ];\n\n        this.offset[0] += deltaOffset[0];\n        this.offset[1] += deltaOffset[1];\n\n        if (this.onredraw) {\n            this.onredraw(this);\n        }\n    }\n\n    changeDeltaScale(value, zoomingCenter) {\n        this.changeScale(this.scale * value, zoomingCenter);\n    }\n\n    reset() {\n        this.scale = 1;\n        this.offset[0] = 0;\n        this.offset[1] = 0;\n    }\n}\n","/**\n * ContextMenu from LiteGUI\n * @class ContextMenu\n * @constructor\n * @param {Array} values (allows object { title: \"Nice text\", callback: function ... })\n * @param {Object} options [optional] Some options:\\\n * - title: title to show on top of the menu\n * - callback: function to call when an option is clicked, it receives the item information\n * - ignore_item_callbacks: ignores the callback inside the item, it just calls the\n *     options.callback\n * - event: you can pass a MouseEvent, this way the ContextMenu appears in that position\n */\nexport default class ContextMenu {\n    constructor(values, options = {}) {\n        this.options = options;\n        const that = this;\n\n        // to link a menu with its parent\n        if (options.parentMenu) {\n            if (options.parentMenu.constructor !== this.constructor) {\n                console.error(\"parentMenu must be of class ContextMenu, ignoring it\");\n                options.parentMenu = null;\n            } else {\n                this.parentMenu = options.parentMenu;\n                this.parentMenu.lock = true;\n                this.parentMenu.current_submenu = this;\n            }\n        }\n\n        let eventClass = null;\n        if (options.event) eventClass = options.event.constructor.name;\n        if (eventClass !== \"MouseEvent\"\n            && eventClass !== \"CustomEvent\"\n            && eventClass !== \"PointerEvent\"\n        ) {\n            console.error(\n                \"Event passed to ContextMenu is not of type MouseEvent or CustomEvent. Ignoring it.\",\n            );\n            options.event = null;\n        }\n\n        const root = document.createElement(\"div\");\n        root.className = \"litegraph litecontextmenu litemenubar-panel\";\n        if (options.className) root.className += ` ${options.className}`;\n        root.style.minWidth = 100;\n        root.style.minHeight = 100;\n        root.style.pointerEvents = \"none\";\n        setTimeout(() => {\n            root.style.pointerEvents = \"auto\";\n        }, 100); // delay so the mouse up event is not caught by this element\n\n        // this prevents the default context browser menu to open in case this menu was created\n        // when pressing right button\n        root.addEventListener(\"mouseup\", (e) => {\n            e.preventDefault();\n            return true;\n        },\n        true);\n        root.addEventListener(\n            \"contextmenu\",\n            (e) => {\n                if (e.button !== 2) {\n                    // right button\n                    return false;\n                }\n                e.preventDefault();\n                return false;\n            },\n            true,\n        );\n\n        root.addEventListener(\n            \"mousedown\",\n            (e) => {\n                if (e.button === 2) {\n                    that.close();\n                    e.preventDefault();\n                    return true;\n                }\n            },\n            true,\n        );\n\n        function on_mouse_wheel(e) {\n            const pos = parseInt(root.style.top, 10);\n            root.style.top = `${(pos + e.deltaY * options.scroll_speed).toFixed()}px`;\n            e.preventDefault();\n            return true;\n        }\n\n        if (!options.scroll_speed) options.scroll_speed = 0.1;\n\n        root.addEventListener(\"wheel\", on_mouse_wheel, true);\n        root.addEventListener(\"mousewheel\", on_mouse_wheel, true);\n\n        this.root = root;\n\n        // title\n        if (options.title) {\n            const element = document.createElement(\"div\");\n            element.className = \"litemenu-title\";\n            element.innerHTML = options.title;\n            root.appendChild(element);\n        }\n\n        // entries\n        for (let i = 0; i < values.length; i++) {\n            let name = values.constructor === Array ? values[i] : i;\n            if (name && name.constructor !== String) {\n                name = name.content === undefined ? String(name) : name.content;\n            }\n            const value = values[i];\n            this.addItem(name, value, options);\n        }\n\n        // close on leave\n        root.addEventListener(\"mouseleave\", (e) => {\n            if (that.lock) return;\n            if (root.closing_timer) clearTimeout(root.closing_timer);\n            root.closing_timer = setTimeout(that.close.bind(that, e), 500);\n            // that.close(e);\n        });\n\n        root.addEventListener(\"mouseenter\", (e) => {\n            if (root.closing_timer) clearTimeout(root.closing_timer);\n        });\n\n        // insert before checking position\n        let rootDocument = document;\n        if (options.event) {\n            rootDocument = options.event.target.ownerDocument;\n        }\n\n        if (!rootDocument) {\n            rootDocument = document;\n        }\n\n        if (rootDocument.fullscreenElement) {\n            rootDocument.fullscreenElement.appendChild(root);\n        } else {\n            rootDocument.body.appendChild(root);\n        }\n\n        // compute best position\n        let left = options.left || 0;\n        let top = options.top || 0;\n        if (options.event) {\n            left = options.event.clientX - 10;\n            top = options.event.clientY - 10;\n            if (options.title) top -= 20;\n\n            if (options.parentMenu) {\n                const rect = options.parentMenu.root.getBoundingClientRect();\n                left = rect.left + rect.width;\n            }\n\n            const bodyRect = document.body.getBoundingClientRect();\n            const rootRect = root.getBoundingClientRect();\n            if (bodyRect.height === 0) console.error(\"document.body height is 0. That is dangerous, set html,body { height: 100%; }\");\n\n            if (bodyRect.width && left > bodyRect.width - rootRect.width - 10) {\n                left = bodyRect.width - rootRect.width - 10;\n            }\n            if (bodyRect.height && top > bodyRect.height - rootRect.height - 10) {\n                top = bodyRect.height - rootRect.height - 10;\n            }\n        }\n\n        root.style.left = `${left}px`;\n        root.style.top = `${top}px`;\n\n        if (options.scale) root.style.transform = `scale(${options.scale})`;\n    }\n\n    addItem(name, value, options = {}) {\n        const that = this;\n\n        const element = document.createElement(\"div\");\n        element.className = \"litemenu-entry submenu\";\n\n        let disabled = false;\n\n        if (value === null) element.classList.add(\"separator\");\n        else {\n            element.innerHTML = value && value.title ? value.title : name;\n            element.value = value;\n\n            if (value) {\n                if (value.disabled) {\n                    disabled = true;\n                    element.classList.add(\"disabled\");\n                }\n                if (value.submenu || value.has_submenu) element.classList.add(\"has_submenu\");\n            }\n\n            if (typeof value === \"function\") {\n                element.dataset.value = name;\n                element.onclick_callback = value;\n            } else element.dataset.value = value;\n\n            if (value.className) element.className += ` ${value.className}`;\n        }\n\n        this.root.appendChild(element);\n        if (!disabled) element.addEventListener(\"click\", inner_onclick);\n        if (options.autoopen) element.addEventListener(\"mouseenter\", inner_over);\n\n        function inner_over(e) {\n            const { value } = this;\n            if (!value || !value.has_submenu) return;\n            // if it is a submenu, autoopen like the item was clicked\n            inner_onclick.call(this, e);\n        }\n\n        // menu option clicked\n        function inner_onclick(e) {\n            const { value } = this;\n            let closeParent = true;\n\n            if (that.current_submenu) that.current_submenu.close(e);\n\n            // global callback\n            if (options.callback) {\n                const r = options.callback.call(\n                    this,\n                    value,\n                    options,\n                    e,\n                    that,\n                    options.node,\n                );\n                if (r === true) closeParent = false;\n            }\n\n            // special cases\n            if (value) {\n                if (\n                    value.callback\n                    && !options.ignore_item_callbacks\n                    && value.disabled !== true\n                ) {\n                    // item callback\n                    const r = value.callback.call(\n                        this,\n                        value,\n                        options,\n                        e,\n                        that,\n                        options.extra,\n                    );\n                    if (r === true) closeParent = false;\n                }\n                if (value.submenu) {\n                    if (!value.submenu.options) {\n                        throw new Error(\"ContextMenu submenu needs options\");\n                    }\n                    const submenu = new that.constructor(value.submenu.options, {\n                        callback: value.submenu.callback,\n                        event: e,\n                        parentMenu: that,\n                        ignore_item_callbacks:\n                        value.submenu.ignore_item_callbacks,\n                        title: value.submenu.title,\n                        extra: value.submenu.extra,\n                        autoopen: options.autoopen,\n                    });\n                    closeParent = false;\n                }\n            }\n\n            if (closeParent && !that.lock) that.close();\n        }\n\n        return element;\n    }\n\n    close(e, ignoreParentMenu) {\n        if (this.root.parentNode) {\n            this.root.remove()\n        }\n        if (this.parentMenu && !ignoreParentMenu) {\n            this.parentMenu.lock = false;\n            this.parentMenu.current_submenu = null;\n            if (e === undefined) this.parentMenu.close();\n            else if (e && !ContextMenu.isCursorOverElement(e, this.parentMenu.root)) {\n                ContextMenu.trigger(this.parentMenu.root, \"mouseleave\", e);\n            }\n        }\n        if (this.current_submenu) this.current_submenu.close(e, true);\n\n        if (this.root.closing_timer) clearTimeout(this.root.closing_timer);\n    }\n\n    // this code is used to trigger events easily (used in the context menu mouseleave\n    static trigger(element, eventName, params) {\n        const evt = document.createEvent(\"CustomEvent\");\n        evt.initCustomEvent(eventName, true, true, params); // canBubble, cancelable, detail\n        if (element.dispatchEvent) element.dispatchEvent(evt);\n        else if (element.__events) element.__events.dispatchEvent(evt);\n        // else nothing seems binded here so nothing to do\n        return evt;\n    }\n\n    // returns the top most menu\n    getTopMenu() {\n        if (this.options.parentMenu) return this.options.parentMenu.getTopMenu();\n        return this;\n    }\n\n    getFirstEvent() {\n        if (this.options.parentMenu) return this.options.parentMenu.getFirstEvent();\n        return this.options.event;\n    }\n\n    static closeAllContextMenus(ref_window = window) {\n        const elements = ref_window.document.querySelectorAll(\".litecontextmenu\");\n        if (!elements.length) {\n            return;\n        }\n\n        const result = [];\n        for (const el of elements) result.push(el);\n        for (const re of result) {\n            if (re.close) re.close();\n            else if (re.parentNode) re.remove();\n        }\n    }\n\n    static isCursorOverElement(event, element) {\n        const left = event.clientX;\n        const top = event.clientY;\n        const rect = element.getBoundingClientRect();\n        if (!rect) return false;\n        return top > rect.top\n            && top < rect.top + rect.height\n            && left > rect.left\n            && left < rect.left + rect.width;\n    }\n}\n","import DragAndScale from \"./DragAndScale\";\nimport { getFileExtension } from \"./utils/file\";\nimport ContextMenu from \"./ContextMenu\";\nimport { isValidConnection } from \"./utils/function\";\nimport LGraphNode from \"./LGraphNode\";\nimport { distance, isInsideRectangle, overlapBounding, clamp } from \"./utils/math\";\nimport LGraphGroup from \"./LGraphGroup\";\nimport * as registry from \"./utils/registry\";\nimport defaultConfig from \"./utils/defaultConfig\";\nimport getTime from \"./utils/time\";\n\nconst temp = new Float32Array(4);\nconst tempVC2 = new Float32Array(2);\nconst tempArea = new Float32Array(4);\nconst marginArea = new Float32Array(4);\nconst linkBounding = new Float32Array(4);\nconst tempA = new Float32Array(2);\nconst tempB = new Float32Array(2);\n\n/**\n * This class is in charge of rendering one graph inside a canvas. And provides all the\n * interaction required. Valid callbacks are: onNodeSelected, onNodeDeselected,\n * onShowNodePanel, onNodeDblClicked\n * @class LGraphCanvas\n * @constructor\n * @param {HTMLCanvasElement} canvas the canvas where you want to render\n *  (it accepts a selector in string format or the canvas element itself)\n * @param {LGraph} graph [optional]\n * @param {Object} options [optional] { skip_rendering, autoresize }\n */\nexport default class LGraphCanvas {\n    constructor(canvas, graph, options = {}) {\n        // if(graph === undefined)\n        // throw (\"No graph assigned\");\n        this.background_image = LGraphCanvas.DEFAULT_BACKGROUND_IMAGE;\n\n        if (canvas && canvas.constructor === String) {\n            canvas = document.querySelector(canvas);\n        }\n\n        this.ds = new DragAndScale();\n        this.zoom_modify_alpha = true; // otherwise it generates ugly patterns when scaling down\n        // too much\n\n        this.title_text_font = `${defaultConfig.NODE_TEXT_SIZE}px Arial`;\n        this.inner_text_font = `normal ${defaultConfig.NODE_SUBTEXT_SIZE}px Arial`;\n        this.node_title_color = defaultConfig.NODE_TITLE_COLOR;\n        this.default_link_color = defaultConfig.LINK_COLOR;\n        this.default_connection_color = {\n            input_off: \"#778\",\n            input_on: \"#7F7\",\n            output_off: \"#778\",\n            output_on: \"#7F7\",\n        };\n\n        this.highquality_render = true;\n        this.use_gradients = false; // set to true to render titlebar with gradients\n        this.editor_alpha = 1; // used for transition\n        this.pause_rendering = false;\n        this.clear_background = true;\n\n        this.read_only = false; // if set to true users cannot modify the graph\n        this.render_only_selected = true;\n        this.live_mode = false;\n        this.show_info = true;\n        this.allow_dragcanvas = true;\n        this.allow_dragnodes = true;\n        this.allow_interaction = true; // allow to control widgets, buttons, collapse, etc\n        this.allow_searchbox = true;\n        this.allow_reconnect_links = false; // allows to change a connection with having to redo it\n        // again\n\n        this.drag_mode = false;\n        this.dragging_rectangle = null;\n\n        this.filter = null; // allows to filter to only accept some type of nodes in a graph\n\n        this.set_canvas_dirty_on_mouse_event = true; // forces to redraw the canvas if the mouse\n        // does anything\n        this.always_render_background = false;\n        this.render_shadows = true;\n        this.render_canvas_border = true;\n        this.render_connections_shadows = false; // too much cpu\n        this.render_connections_border = true;\n        this.render_curved_connections = false;\n        this.render_connection_arrows = false;\n        this.render_collapsed_slots = true;\n        this.render_execution_order = false;\n        this.render_title_colored = true;\n        this.render_link_tooltip = true;\n\n        this.links_render_mode = defaultConfig.SPLINE_LINK;\n\n        this.mouse = [0, 0]; // mouse in canvas coordinates, where 0,0 is the top-left corner of\n        // the blue rectangle\n        this.graph_mouse = [0, 0]; // mouse in graph coordinates, where 0,0 is the top-left corner\n        // of the blue rectangle\n        this.canvas_mouse = this.graph_mouse; // LEGACY: REMOVE THIS, USE GRAPH_MOUSE INSTEAD\n\n        // to personalize the search box\n        this.onSearchBox = null;\n        this.onSearchBoxSelection = null;\n\n        // callbacks\n        this.onMouse = null;\n        this.onDrawBackground = null; // to render background objects (behind nodes and\n        // connections) in the canvas affected by transform\n        this.onDrawForeground = null; // to render foreground objects (above nodes and connections)\n        // in the canvas affected by transform\n        this.onDrawOverlay = null; // to render foreground objects not affected by transform (for\n        // GUIs)\n        this.onDrawLinkTooltip = null; // called when rendering a tooltip\n        this.onNodeMoved = null; // called after moving a node\n        this.onSelectionChange = null; // called if the selection changes\n        this.onConnectingChange = null; // called before any link changes\n        this.onBeforeChange = null; // called before modifying the graph\n        this.onAfterChange = null; // called after modifying the graph\n\n        this.connections_width = 3;\n        this.round_radius = 8;\n\n        this.current_node = null;\n        this.node_widget = null; // used for widgets\n        this.over_link_center = null;\n        this.last_mouse_position = [0, 0];\n        this.visible_area = this.ds.visible_area;\n        this.visible_links = [];\n\n        // link canvas and graph\n        if (graph) {\n            graph.attachCanvas(this);\n        }\n\n        this.setCanvas(canvas);\n        this.clear();\n\n        if (!options.skip_render) {\n            this.startRendering();\n        }\n\n        this.autoresize = options.autoresize;\n    }\n\n    static DEFAULT_BACKGROUND_IMAGE = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQBJREFUeNrs1rEKwjAUhlETUkj3vP9rdmr1Ysammk2w5wdxuLgcMHyptfawuZX4pJSWZTnfnu/lnIe/jNNxHHGNn//HNbbv+4dr6V+11uF527arU7+u63qfa/bnmh8sWLBgwYJlqRf8MEptXPBXJXa37BSl3ixYsGDBMliwFLyCV/DeLIMFCxYsWLBMwSt4Be/NggXLYMGCBUvBK3iNruC9WbBgwYJlsGApeAWv4L1ZBgsWLFiwYJmCV/AK3psFC5bBggULloJX8BpdwXuzYMGCBctgwVLwCl7Be7MMFixYsGDBsu8FH1FaSmExVfAxBa/gvVmwYMGCZbBg/W4vAQYA5tRF9QYlv/QAAAAASUVORK5CYII=\";\n\n    static link_type_colors = {\n        \"-1\": defaultConfig.EVENT_LINK_COLOR,\n        number: \"#AAA\",\n        node: \"#DCA\",\n    }\n\n    static gradients = {}\n\n    /**\n     * clears all the data inside\n     *\n     * @method clear\n     * @memberOf LGraphCanvas\n     */\n    clear() {\n        this.frame = 0;\n        this.last_draw_time = 0;\n        this.render_time = 0;\n        this.fps = 0;\n\n        // this.scale = 1;\n        // this.offset = [0,0];\n\n        this.dragging_rectangle = null;\n\n        this.selected_nodes = {};\n        this.selected_group = null;\n\n        this.visible_nodes = [];\n        this.node_dragged = null;\n        this.node_over = null;\n        this.node_capturing_input = null;\n        this.connecting_node = null;\n        this.highlighted_links = {};\n\n        this.dragging_canvas = false;\n\n        this.dirty_canvas = true;\n        this.dirty_bgcanvas = true;\n        this.dirty_area = null;\n\n        this.node_in_panel = null;\n        this.node_widget = null;\n\n        this.last_mouse = [0, 0];\n        this.last_mouseclick = 0;\n        this.visible_area.set([0, 0, 0, 0]);\n\n        if (this.onClear) this.onClear();\n    }\n\n    /**\n     * assigns a graph, you can reassign graphs to the same canvas\n     *\n     * @method setGraph\n     * @param {LGraph} graph\n     * @param {boolean=} skipClear\n     * @memberOf LGraphCanvas\n     */\n    setGraph(graph, skipClear) {\n        if (this.graph === graph) {\n            return;\n        }\n\n        if (!skipClear) this.clear();\n\n        if (!graph && this.graph) {\n            this.graph.detachCanvas(this);\n            return;\n        }\n\n        graph.attachCanvas(this);\n\n        // remove the graph stack in case a subgraph was open\n        if (this._graph_stack) this._graph_stack = null;\n\n        this.setDirty(true, true);\n    }\n\n    /**\n     * returns the top level graph (in case there are subgraphs open on the canvas)\n     *\n     * @method getTopGraph\n     * @return {LGraph} graph\n     * @memberOf LGraphCanvas\n     */\n    getTopGraph() {\n        if (this._graph_stack.length) return this._graph_stack[0];\n        return this.graph;\n    }\n\n    /**\n     * opens a graph contained inside a node in the current graph\n     *\n     * @method openSubgraph\n     * @param {LGraph} graph\n     * @memberOf LGraphCanvas\n     */\n    openSubgraph(graph) {\n        if (!graph) {\n            throw new Error(\"graph cannot be null\");\n        }\n\n        if (this.graph === graph) {\n            throw new Error(\"graph cannot be the same\");\n        }\n\n        this.clear();\n\n        if (this.graph) {\n            if (!this._graph_stack) {\n                this._graph_stack = [];\n            }\n            this._graph_stack.push(this.graph);\n        }\n\n        graph.attachCanvas(this);\n        this.checkPanels();\n        this.setDirty(true, true);\n    }\n\n    /**\n     * closes a subgraph contained inside a node\n     *\n     * @method closeSubgraph\n     * @memberOf LGraphCanvas\n     */\n    closeSubgraph() {\n        if (!this._graph_stack || this._graph_stack.length === 0) {\n            return;\n        }\n        const subgraphNode = this.graph._subgraph_node;\n        const graph = this._graph_stack.pop();\n        this.selected_nodes = {};\n        this.highlighted_links = {};\n        graph.attachCanvas(this);\n        this.setDirty(true, true);\n        if (subgraphNode) {\n            this.centerOnNode(subgraphNode);\n            this.selectNodes([subgraphNode]);\n        }\n    }\n\n    /**\n     * returns the visualy active graph (in case there are more in the stack)\n     * @method getCurrentGraph\n     * @return {LGraph} the active graph\n     * @memberOf LGraphCanvas\n     */\n    getCurrentGraph() {\n        return this.graph;\n    }\n\n    /**\n     * assigns a canvas\n     *\n     * @method setCanvas\n     * @param {HTMLCanvasElement | string | HTMLElement} canvas assigns a canvas\n     *  (also accepts the ID of the element (not a selector))\n     * @param {boolean} skipEvents\n     * @memberOf LGraphCanvas\n     */\n    setCanvas(canvas, skipEvents) {\n        if (canvas?.constructor === String) {\n            canvas = document.getElementById(canvas);\n            if (!canvas) {\n                throw new Error(\"Error creating LiteGraph canvas: Canvas not found\");\n            }\n        }\n\n        if (canvas === this.canvas) {\n            return;\n        }\n\n        if (!canvas && this.canvas) {\n            // maybe detach events from old_canvas\n            if (!skipEvents) {\n                this.unbindEvents();\n            }\n        }\n\n        this.canvas = canvas;\n        this.ds.element = canvas;\n\n        if (!canvas) return;\n\n        // this.canvas.tabindex = \"1000\";\n        canvas.className += \" lgraphcanvas\";\n        canvas.data = this;\n        canvas.tabindex = \"1\"; // to allow key events\n\n        // bg canvas: used for non changing stuff\n        this.bgcanvas = null;\n        this.bgcanvas = document.createElement(\"canvas\");\n        this.bgcanvas.width = this.canvas.width;\n        this.bgcanvas.height = this.canvas.height;\n\n        if (canvas.getContext === null) {\n            if (canvas.localName !== \"canvas\") {\n                throw new Error(`Element supplied for LGraphCanvas must be a <canvas> element, you passed a ${\n                    canvas.localName}`);\n            }\n            throw new Error(\"This browser doesn't support Canvas\");\n        }\n\n        this.ctx = canvas.getContext(\"2d\");\n        if (this.ctx == null) {\n            if (!canvas.webgl_enabled) {\n                console.warn(\n                    \"This canvas seems to be WebGL, enabling WebGL renderer\",\n                );\n            }\n            this.enableWebGL();\n        }\n\n        // input:  (move and up could be unbinded)\n        this._mousemove_callback = this.processMouseMove.bind(this);\n        this._mouseup_callback = this.processMouseUp.bind(this);\n\n        if (!skipEvents) this.bindEvents();\n    }\n\n    _doNothing(e) {\n        e.preventDefault();\n        return false;\n    }\n\n    _doReturnTrue(e) {\n        e.preventDefault();\n        return true;\n    }\n\n    /**\n     * binds mouse, keyboard, touch and drag events to the canvas\n     * @method bindEvents\n     * @memberOf LGraphCanvas\n     * */\n    bindEvents() {\n        if (this._events_binded) {\n            console.warn(\"LGraphCanvas: events already binded\");\n            return;\n        }\n\n        const { canvas } = this;\n\n        const refWindow = this.getCanvasWindow();\n        const { document } = refWindow; // hack used when moving canvas between windows\n\n        this._mousedown_callback = this.processMouseDown.bind(this);\n        this._mousewheel_callback = this.processMouseWheel.bind(this);\n\n        canvas.addEventListener(\"mousedown\", this._mousedown_callback, true); // down do not need\n        // to store the binded\n        canvas.addEventListener(\"mousemove\", this._mousemove_callback);\n        canvas.addEventListener(\"mousewheel\", this._mousewheel_callback);\n\n        canvas.addEventListener(\"contextmenu\", this._doNothing);\n        canvas.addEventListener(\"DOMMouseScroll\", this._mousewheel_callback);\n\n        canvas.addEventListener(\"touchstart\", this.touchHandler, true);\n        canvas.addEventListener(\"touchmove\", this.touchHandler, true);\n        canvas.addEventListener(\"touchend\", this.touchHandler, true);\n        canvas.addEventListener(\"touchcancel\", this.touchHandler, true);\n\n        // Keyboard ******************\n        this._key_callback = this.processKey.bind(this);\n\n        canvas.addEventListener(\"keydown\", this._key_callback, true);\n        document.addEventListener(\"keyup\", this._key_callback, true); // in document, otherwise it\n        // doesn't fire keyup\n\n        // Dropping Stuff over nodes ************************************\n        this._ondrop_callback = this.processDrop.bind(this);\n\n        canvas.addEventListener(\"dragover\", this._doNothing, false);\n        canvas.addEventListener(\"dragend\", this._doNothing, false);\n        canvas.addEventListener(\"drop\", this._ondrop_callback, false);\n        canvas.addEventListener(\"dragenter\", this._doReturnTrue, false);\n\n        this._events_binded = true;\n    }\n\n    /**\n     * unbinds mouse events from the canvas\n     * @method unbindEvents\n     * @memberOf LGraphCanvas\n     * */\n    unbindEvents() {\n        if (!this._events_binded) {\n            console.warn(\"LGraphCanvas: no events binded\");\n            return;\n        }\n\n        const refWindow = this.getCanvasWindow();\n        const { document } = refWindow;\n\n        this.canvas.removeEventListener(\"mousedown\", this._mousedown_callback);\n        this.canvas.removeEventListener(\n            \"mousewheel\",\n            this._mousewheel_callback,\n        );\n        this.canvas.removeEventListener(\n            \"DOMMouseScroll\",\n            this._mousewheel_callback,\n        );\n        this.canvas.removeEventListener(\"keydown\", this._key_callback);\n        document.removeEventListener(\"keyup\", this._key_callback);\n        this.canvas.removeEventListener(\"contextmenu\", this._doNothing);\n        this.canvas.removeEventListener(\"drop\", this._ondrop_callback);\n        this.canvas.removeEventListener(\"dragenter\", this._doReturnTrue);\n\n        this.canvas.removeEventListener(\"touchstart\", this.touchHandler);\n        this.canvas.removeEventListener(\"touchmove\", this.touchHandler);\n        this.canvas.removeEventListener(\"touchend\", this.touchHandler);\n        this.canvas.removeEventListener(\"touchcancel\", this.touchHandler);\n\n        this._mousedown_callback = null;\n        this._mousewheel_callback = null;\n        this._key_callback = null;\n        this._ondrop_callback = null;\n\n        this._events_binded = false;\n    }\n\n    /**\n     * this function allows to render the canvas using WebGL instead of Canvas2D\n     * this is useful if you plant to render 3D objects inside your nodes, it uses litegl.js for\n     * webgl and canvas2DtoWebGL to emulate the Canvas2D calls in webGL\n     * @method enableWebGL\n     * @memberOf LGraphCanvas\n     * */\n    enableWebGL() {\n        if (!GL) throw new Error(\"litegl.js must be included to use a WebGL canvas\");\n        if (!enableWebGLCanvas) throw new Error(\"webglCanvas.js must be included to use this feature\");\n\n        this.ctx = enableWebGLCanvas(this.canvas);\n        this.gl = this.ctx;\n        this.ctx.webgl = true;\n        this.bgcanvas = this.canvas;\n        this.bgctx = this.gl;\n        this.canvas.webgl_enabled = true;\n    }\n\n    /**\n     * marks as dirty the canvas, this way it will be rendered again\n     *\n     * @class LGraphCanvas\n     * @method setDirty\n     * @param {boolean} [fgcanvas] if the foreground canvas is dirty (the one containing the nodes)\n     * @param {boolean} [bgcanvas] if the background canvas is dirty (the one containing the wires)\n     * @memberOf LGraphCanvas\n     */\n    setDirty(fgcanvas, bgcanvas) {\n        if (fgcanvas) this.dirty_canvas = true;\n        if (bgcanvas) this.dirty_bgcanvas = true;\n    }\n\n    /**\n     * Used to attach the canvas in a popup\n     *\n     * @method getCanvasWindow\n     * @return {Window} returns the window where the canvas is attached (the DOM root node)\n     * @memberOf LGraphCanvas\n     */\n    getCanvasWindow() {\n        if (!this.canvas) return window;\n        const doc = this.canvas.ownerDocument;\n        return doc.defaultView;\n    }\n\n    /**\n     * starts rendering the content of the canvas when needed\n     *\n     * @method startRendering\n     * @memberOf LGraphCanvas\n     */\n    startRendering() {\n        if (this.is_rendering) return;\n\n        this.is_rendering = true;\n        this.renderFrame();\n    }\n\n    /**\n     * render a frame\n     *\n     * @method renderFrame\n     * @memberOf LGraphCanvas\n     */\n    renderFrame() {\n        if (!this.pause_rendering) this.draw();\n\n        const window = this.getCanvasWindow();\n        if (this.is_rendering) window.requestAnimationFrame(() => this.renderFrame());\n    }\n\n    /**\n     * stops rendering the content of the canvas (to save resources)\n     *\n     * @method stopRendering\n     * @memberOf LGraphCanvas\n     */\n    stopRendering() {\n        this.is_rendering = false;\n    }\n\n    /* LiteGraphCanvas input */\n\n    /**\n     * used to block future mouse events (because of im gui)\n     *\n     * @method blockClick\n     * @memberOf LGraphCanvas\n     */\n    blockClick() {\n        this.block_click = true;\n        this.last_mouseclick = 0;\n    }\n\n    processMouseDown(e) {\n        if (this.set_canvas_dirty_on_mouse_event) this.dirty_canvas = true;\n\n        if (!this.graph) return;\n\n        this.adjustMouseEvent(e);\n\n        const refWindow = this.getCanvasWindow();\n        LGraphCanvas.active_canvas = this;\n\n        // move mouse move event to the window in case it drags outside of the canvas\n        this.canvas.removeEventListener(\"mousemove\", this._mousemove_callback);\n        refWindow.document.addEventListener(\"mousemove\", this._mousemove_callback, true); // catch for the entire window\n        refWindow.document.addEventListener(\"mouseup\", this._mouseup_callback, true);\n\n        const node = this.graph.getNodeOnPos(e.canvasX, e.canvasY, this.visible_nodes, 5);\n        let skipAction = false;\n        const now = getTime();\n        const isDoubleClick = now - this.last_mouseclick < 300;\n        this.mouse[0] = e.localX;\n        this.mouse[1] = e.localY;\n        this.graph_mouse[0] = e.canvasX;\n        this.graph_mouse[1] = e.canvasY;\n        this.last_click_position = [this.mouse[0], this.mouse[1]];\n\n        this.canvas.focus();\n\n        ContextMenu.closeAllContextMenus(refWindow);\n\n        if (this.onMouse) {\n            if (this.onMouse(e)) return;\n        }\n\n        // left button mouse\n        if (e.which === 1) {\n            if (e.ctrlKey) {\n                this.dragging_rectangle = new Float32Array(4);\n                this.dragging_rectangle[0] = e.canvasX;\n                this.dragging_rectangle[1] = e.canvasY;\n                this.dragging_rectangle[2] = 1;\n                this.dragging_rectangle[3] = 1;\n                skipAction = true;\n            }\n\n            let clickingCanvasBg = false;\n\n            // when clicked on top of a node\n            // and it is not interactive\n            if (node && this.allow_interaction && !skipAction && !this.read_only) {\n                if (!this.live_mode && !node.flags.pinned) {\n                    this.bringToFront(node);\n                } // if it wasn't selected?\n\n                // not dragging mouse to connect two slots\n                if (!this.connecting_node && !node.flags.collapsed && !this.live_mode) {\n                // Search for corner for resize\n                    if (!skipAction\n                    && node.resizable\n                    && isInsideRectangle(\n                        e.canvasX,\n                        e.canvasY,\n                        node.pos[0] + node.size[0] - 5,\n                        node.pos[1] + node.size[1] - 5,\n                        1010,\n                    )\n                    ) {\n                        this.graph.beforeChange();\n                        this.resizing_node = node;\n                        this.canvas.style.cursor = \"se-resize\";\n                        skipAction = true;\n                    } else {\n                    // search for outputs\n                        if (node.outputs) {\n                            for (let i = 0, l = node.outputs.length; i < l; i++) {\n                                const output = node.outputs[i];\n                                const linkPos = node.getConnectionPos(false, i);\n                                if (isInsideRectangle(\n                                    e.canvasX,\n                                    e.canvasY,\n                                    linkPos[0] - 15,\n                                    linkPos[1] - 10,\n                                    30,\n                                    20,\n                                )) {\n                                    this.connecting_node = node;\n                                    this.connecting_output = output;\n                                    this.connecting_pos = node.getConnectionPos(false, i);\n                                    this.connecting_slot = i;\n                                    if (e.shiftKey) {\n                                        node.disconnectOutput(i);\n                                    }\n\n                                    if (isDoubleClick) {\n                                        if (node.onOutputDblClick) {\n                                            node.onOutputDblClick(i, e);\n                                        }\n                                    } else if (node.onOutputClick) {\n                                        node.onOutputClick(i, e);\n                                    }\n\n                                    skipAction = true;\n                                    break;\n                                }\n                            }\n                        }\n\n                        // search for inputs\n                        if (node.inputs) {\n                            for (let i = 0, l = node.inputs.length; i < l; i++) {\n                                const input = node.inputs[i];\n                                const linkPos = node.getConnectionPos(true, i);\n                                if (isInsideRectangle(\n                                    e.canvasX,\n                                    e.canvasY,\n                                    linkPos[0] - 15,\n                                    linkPos[1] - 10,\n                                    30, 20,\n                                )) {\n                                    if (isDoubleClick) {\n                                        if (node.onInputDblClick) {\n                                            node.onInputDblClick(i, e);\n                                        }\n                                    } else if (node.onInputClick) {\n                                        node.onInputClick(i, e);\n                                    }\n\n                                    if (input.link) {\n                                        const linkInfo = this.graph.links[\n                                            input.link\n                                        ]; // before disconnecting\n                                        node.disconnectInput(i);\n\n                                        if (\n                                            this.allow_reconnect_links\n                                            || e.shiftKey\n                                        ) {\n                                            this.connecting_node = this.graph._nodes_by_id[\n                                                linkInfo.origin_id\n                                            ];\n                                            this.connecting_slot = linkInfo.origin_slot;\n                                            this.connecting_output = this.connecting_node.outputs[\n                                                this.connecting_slot\n                                            ];\n\n                                            this.connecting_pos = this.connecting_node\n                                                .getConnectionPos(false, this.connecting_slot);\n                                        }\n\n                                        this.dirty_bgcanvas = true;\n                                        skipAction = true;\n                                    }\n                                }\n                            }\n                        }\n                    } // not resizing\n                }\n\n                // it wasn't clicked on the links boxes\n                if (!skipAction) {\n                    let blockDragNote = false;\n                    const pos = [e.canvasX - node.pos[0], e.canvasY - node.pos[1]];\n\n                    // widgets\n                    const widget = this.processNodeWidgets(node, this.graph_mouse, e);\n                    if (widget) {\n                        blockDragNote = true;\n                        this.node_widget = [node, widget];\n                    }\n\n                    // double clicking\n                    if (isDoubleClick && this.selected_nodes[node.id]) {\n                        // double click node\n                        if (node.onDblClick) {\n                            node.onDblClick(e, pos, this);\n                        }\n                        this.processNodeDblClicked(node);\n                        blockDragNote = true;\n                    }\n\n                    // if do not capture mouse\n                    if (node.onMouseDown && node.onMouseDown(e, pos, this)) {\n                        blockDragNote = true;\n                    } else {\n                        // open subgraph button\n                        if (node.subgraph && !node.skip_subgraph_button) {\n                            if (!node.flags.collapsed && pos[0]\n                                > node.size[0] - defaultConfig.NODE_TITLE_HEIGHT\n                                && pos[1] < 0) {\n                                setTimeout(() => {\n                                    this.openSubgraph(node.subgraph);\n                                }, 10);\n                            }\n                        }\n\n                        if (this.live_mode) {\n                            clickingCanvasBg = true;\n                            blockDragNote = true;\n                        }\n                    }\n\n                    if (!blockDragNote) {\n                        if (this.allow_dragnodes) {\n                            this.graph.beforeChange();\n                            this.node_dragged = node;\n                        }\n                        if (!this.selected_nodes[node.id]) {\n                            this.processNodeSelected(node, e);\n                        }\n                    }\n\n                    this.dirty_canvas = true;\n                }\n            } else {\n                // search for link connector\n                if (!this.read_only) {\n                    for (const link of this.visible_links) {\n                        const center = link._pos;\n                        if (\n                            !center\n                            || e.canvasX < center[0] - 4\n                            || e.canvasX > center[0] + 4\n                            || e.canvasY < center[1] - 4\n                            || e.canvasY > center[1] + 4\n                        ) {\n                            continue;\n                        }\n                        // link clicked\n                        this.showLinkMenu(link, e);\n                        this.over_link_center = null; // clear tooltip\n                        break;\n                    }\n                }\n\n                this.selected_group = this.graph.getGroupOnPos(e.canvasX, e.canvasY);\n                this.selected_group_resizing = false;\n                if (this.selected_group && !this.read_only) {\n                    if (e.ctrlKey) this.dragging_rectangle = null;\n\n                    const dist = distance([e.canvasX, e.canvasY],\n                        [this.selected_group.pos[0] + this.selected_group.size[0],\n                            this.selected_group.pos[1] + this.selected_group.size[1]]);\n                    if (dist * this.ds.scale < 10) {\n                        this.selected_group_resizing = true;\n                    } else {\n                        this.selected_group.recomputeInsideNodes();\n                    }\n                }\n\n                if (isDoubleClick && !this.read_only && this.allow_searchbox) {\n                    this.showSearchBox(e);\n                }\n\n                clickingCanvasBg = true;\n            }\n\n            if (!skipAction && clickingCanvasBg && this.allow_dragcanvas) {\n                this.dragging_canvas = true;\n            }\n        } else if (e.which === 2) {\n            // middle button\n        } else if (e.which === 3) {\n            // right button\n            if (!this.read_only) this.processContextMenu(node, e);\n        }\n\n        // TODO\n        // if(this.node_selected != prev_selected)\n        //\tthis.onNodeSelectionChange(this.node_selected);\n\n        this.last_mouse[0] = e.localX;\n        this.last_mouse[1] = e.localY;\n        this.last_mouseclick = getTime();\n        this.last_mouse_dragging = true;\n\n        /*\n    if( (this.dirty_canvas || this.dirty_bgcanvas) && this.rendering_timer_id == null)\n    this.draw();\n    */\n\n        this.graph.change();\n\n        // this is to ensure to defocus(blur) if a text input element is on focus\n        if (\n            !refWindow.document.activeElement\n            || (refWindow.document.activeElement.nodeName.toLowerCase()\n            !== \"input\"\n            && refWindow.document.activeElement.nodeName.toLowerCase()\n            !== \"textarea\")) {\n            e.preventDefault();\n        }\n        e.stopPropagation();\n\n        if (this.onMouseDown) {\n            this.onMouseDown(e);\n        }\n\n        return false;\n    }\n\n    /**\n     * Called when a mouse move event has to be processed\n     * @method processMouseMove\n     * @memberOf LGraphCanvas\n     * */\n    processMouseMove(e) {\n        if (this.autoresize) this.resize();\n\n        if (this.set_canvas_dirty_on_mouse_event) this.dirty_canvas = true;\n\n        if (!this.graph) return;\n\n        LGraphCanvas.active_canvas = this;\n        this.adjustMouseEvent(e);\n        const mouse = [e.localX, e.localY];\n        this.mouse[0] = mouse[0];\n        this.mouse[1] = mouse[1];\n        const delta = [\n            mouse[0] - this.last_mouse[0],\n            mouse[1] - this.last_mouse[1],\n        ];\n        this.last_mouse = mouse;\n        this.graph_mouse[0] = e.canvasX;\n        this.graph_mouse[1] = e.canvasY;\n\n        if (this.block_click) {\n            e.preventDefault();\n            return false;\n        }\n\n        e.dragging = this.last_mouse_dragging;\n\n        if (this.node_widget) {\n            this.processNodeWidgets(this.node_widget[0], this.graph_mouse, e, this.node_widget[1]);\n            this.dirty_canvas = true;\n        }\n\n        if (this.dragging_rectangle) {\n            this.dragging_rectangle[2] = e.canvasX - this.dragging_rectangle[0];\n            this.dragging_rectangle[3] = e.canvasY - this.dragging_rectangle[1];\n            this.dirty_canvas = true;\n        } else if (this.selected_group && !this.read_only) {\n            // moving/resizing a group\n            if (this.selected_group_resizing) {\n                this.selected_group.size = [\n                    e.canvasX - this.selected_group.pos[0],\n                    e.canvasY - this.selected_group.pos[1],\n                ];\n            } else {\n                const deltax = delta[0] / this.ds.scale;\n                const deltay = delta[1] / this.ds.scale;\n                this.selected_group.move(deltax, deltay, e.ctrlKey);\n                if (this.selected_group._nodes.length) this.dirty_canvas = true;\n            }\n            this.dirty_bgcanvas = true;\n        } else if (this.dragging_canvas) {\n            this.ds.offset[0] += delta[0] / this.ds.scale;\n            this.ds.offset[1] += delta[1] / this.ds.scale;\n            this.dirty_canvas = true;\n            this.dirty_bgcanvas = true;\n        } else if (this.allow_interaction && !this.read_only) {\n            if (this.connecting_node) this.dirty_canvas = true;\n\n            // get node over\n            const node = this.graph.getNodeOnPos(e.canvasX, e.canvasY, this.visible_nodes);\n\n            // remove mouseover flag\n            for (const _node of this.graph._nodes) {\n                if (_node.mouseOver && node !== _node) {\n                    // mouse leave\n                    _node.mouseOver = false;\n                    if (this.node_over && this.node_over.onMouseLeave) {\n                        this.node_over.onMouseLeave(e);\n                    }\n                    this.node_over = null;\n                    this.dirty_canvas = true;\n                }\n            }\n\n            // mouse over a node\n            if (node) {\n                if (node.redraw_on_mouse) this.dirty_canvas = true;\n\n                // this.canvas.style.cursor = \"move\";\n                if (!node.mouseOver) {\n                    // mouse enter\n                    node.mouseOver = true;\n                    this.node_over = node;\n                    this.dirty_canvas = true;\n\n                    if (node.onMouseEnter) node.onMouseEnter(e);\n                }\n\n                // in case the node wants to do something\n                if (node.onMouseMove) {\n                    node.onMouseMove(e, [e.canvasX - node.pos[0], e.canvasY - node.pos[1]], this);\n                }\n\n                // if dragging a link\n                if (this.connecting_node) {\n                    const pos = this._highlight_input || [0, 0];\n\n                    // on top of input\n                    if (this.isOverNodeBox(node, e.canvasX, e.canvasY)) {\n                        // mouse on top of the corner box, don't know what to do\n                    } else {\n                        // check if I have a slot below de mouse\n                        const slot = this.isOverNodeInput(node, e.canvasX, e.canvasY, pos);\n                        if (slot !== -1 && node.inputs[slot]) {\n                            const slotType = node.inputs[slot].type;\n                            if (isValidConnection(this.connecting_output.type, slotType)) {\n                                this._highlight_input = pos;\n                            }\n                        } else this._highlight_input = null;\n                    }\n                }\n\n                // Search for corner\n                if (this.canvas) {\n                    if (isInsideRectangle(\n                        e.canvasX,\n                        e.canvasY,\n                        node.pos[0] + node.size[0] - 5,\n                        node.pos[1] + node.size[1] - 5,\n                        5,\n                        5,\n                    )) {\n                        this.canvas.style.cursor = \"se-resize\";\n                    } else this.canvas.style.cursor = \"crosshair\";\n                }\n            } else { // not over a node\n                // search for link connector\n                let overLink = null;\n                for (const link of this.visible_links) {\n                    const center = link._pos;\n                    if (!center\n                        || e.canvasX < center[0] - 4\n                        || e.canvasX > center[0] + 4\n                        || e.canvasY < center[1] - 4\n                        || e.canvasY > center[1] + 4) {\n                        continue;\n                    }\n                    overLink = link;\n                    break;\n                }\n                if (overLink !== this.over_link_center) {\n                    this.over_link_center = overLink;\n                    this.dirty_canvas = true;\n                }\n\n                if (this.canvas) this.canvas.style.cursor = \"\";\n            } // end\n\n            // send event to node if capturing input (used with widgets that allow drag outside of\n            // the area of the node)\n            if (this.node_capturing_input && this.node_capturing_input !== node && this.node_capturing_input.onMouseMove) {\n                this.node_capturing_input.onMouseMove(e, [e.canvasX - this.node_capturing_input.pos[0], e.canvasY - this.node_capturing_input.pos[1]], this);\n            }\n\n            // node being dragged\n            if (this.node_dragged && !this.live_mode) {\n                for (const nKeys of Object.keys(this.selected_nodes)) {\n                    const n = this.selected_nodes[nKeys];\n                    n.pos[0] += delta[0] / this.ds.scale;\n                    n.pos[1] += delta[1] / this.ds.scale;\n                }\n\n                this.dirty_canvas = true;\n                this.dirty_bgcanvas = true;\n            }\n\n            if (this.resizing_node && !this.live_mode) {\n                // convert mouse to node space\n                const desiredSize = [\n                    e.canvasX - this.resizing_node.pos[0],\n                    e.canvasY - this.resizing_node.pos[1],\n                ];\n                const minSize = this.resizing_node.computeSize();\n                desiredSize[0] = Math.max(minSize[0], desiredSize[0]);\n                desiredSize[1] = Math.max(minSize[1], desiredSize[1]);\n                this.resizing_node.setSize(desiredSize);\n\n                this.canvas.style.cursor = \"se-resize\";\n                this.dirty_canvas = true;\n                this.dirty_bgcanvas = true;\n            }\n        }\n\n        e.preventDefault();\n        return false;\n    }\n\n    /**\n     * Called when a mouse up event has to be processed\n     * @method processMouseUp\n     * @memberOf LGraphCanvas\n     * */\n    processMouseUp(e) {\n        if (this.set_canvas_dirty_on_mouse_event) this.dirty_canvas = true;\n\n        if (!this.graph) return;\n\n        const window = this.getCanvasWindow();\n        const { document } = window;\n        LGraphCanvas.active_canvas = this;\n\n        // restore the mousemove event back to the canvas\n        document.removeEventListener(\"mousemove\", this._mousemove_callback, true);\n        this.canvas.addEventListener(\"mousemove\", this._mousemove_callback, true);\n        document.removeEventListener(\"mouseup\", this._mouseup_callback, true);\n\n        this.adjustMouseEvent(e);\n        const now = getTime();\n        e.click_time = now - this.last_mouseclick;\n        this.last_mouse_dragging = false;\n        this.last_click_position = null;\n\n        if (this.block_click) this.block_click = false;\n        // used to avoid sending twice a click in a immediate button\n\n        if (e.which === 1) {\n            if (this.node_widget) this.processNodeWidgets(this.node_widget[0], this.graph_mouse, e);\n\n            // left button\n            this.node_widget = null;\n\n            if (this.selected_group) {\n                const diffx = this.selected_group.pos[0]\n                    - Math.round(this.selected_group.pos[0]);\n                const diffy = this.selected_group.pos[1]\n                    - Math.round(this.selected_group.pos[1]);\n\n                this.selected_group.move(diffx, diffy, e.ctrlKey);\n\n                this.selected_group.pos[0] = Math.round(this.selected_group.pos[0]);\n                this.selected_group.pos[1] = Math.round(this.selected_group.pos[1]);\n\n                if (this.selected_group._nodes.length) this.dirty_canvas = true;\n                this.selected_group = null;\n            }\n            this.selected_group_resizing = false;\n\n            if (this.dragging_rectangle) {\n                if (this.graph) {\n                    const nodes = this.graph._nodes;\n                    const nodeBounding = new Float32Array(4);\n                    this.deselectAllNodes();\n                    // compute bounding and flip if left to right\n                    const w = Math.abs(this.dragging_rectangle[2]);\n                    const h = Math.abs(this.dragging_rectangle[3]);\n                    const startx = this.dragging_rectangle[2] < 0\n                        ? this.dragging_rectangle[0] - w\n                        : this.dragging_rectangle[0];\n                    const starty = this.dragging_rectangle[3] < 0\n                        ? this.dragging_rectangle[1] - h\n                        : this.dragging_rectangle[1];\n                    this.dragging_rectangle[0] = startx;\n                    this.dragging_rectangle[1] = starty;\n                    this.dragging_rectangle[2] = w;\n                    this.dragging_rectangle[3] = h;\n\n                    // test against all nodes (not visible because the rectangle maybe start outside\n                    const toSelect = [];\n\n                    for (const node of nodes) {\n                        node.getBounding(nodeBounding);\n                        if (\n                            !overlapBounding(\n                                this.dragging_rectangle,\n                                nodeBounding,\n                            )\n                        ) {\n                            continue;\n                        } // out of the visible area\n                        toSelect.push(node);\n                    }\n                    if (toSelect.length) {\n                        this.selectNodes(toSelect);\n                    }\n                }\n                this.dragging_rectangle = null;\n            } else if (this.connecting_node) {\n                // dragging a connection\n                this.dirty_canvas = true;\n                this.dirty_bgcanvas = true;\n\n                const node = this.graph.getNodeOnPos(\n                    e.canvasX,\n                    e.canvasY,\n                    this.visible_nodes,\n                );\n\n                // node below mouse\n                if (node) {\n                    if (\n                        this.connecting_output.type === defaultConfig.EVENT\n                        && this.isOverNodeBox(node, e.canvasX, e.canvasY)\n                    ) {\n                        this.connecting_node.connect(this.connecting_slot, node, defaultConfig.EVENT);\n                    } else {\n                        // slot below mouse? connect\n                        const slot = this.isOverNodeInput(node, e.canvasX, e.canvasY);\n                        if (slot !== -1) {\n                            this.connecting_node.connect(this.connecting_slot, node, slot);\n                        } else {\n                            // not on top of an input\n                            const input = node.getInputInfo(0);\n                            // auto connect\n                            if (this.connecting_output.type === defaultConfig.EVENT) {\n                                this.connecting_node.connect(\n                                    this.connecting_slot, node,\n                                    defaultConfig.EVENT,\n                                );\n                            } else if (\n                                input\n                                && !input.link\n                                && isValidConnection(\n                                    input.type && this.connecting_output.type,\n                                )\n                            ) {\n                                this.connecting_node.connect(this.connecting_slot, node, 0);\n                            }\n                        }\n                    }\n                }\n\n                this.connecting_output = null;\n                this.connecting_pos = null;\n                this.connecting_node = null;\n                this.connecting_slot = -1;\n            } else if (this.resizing_node) {\n                this.dirty_canvas = true;\n                this.dirty_bgcanvas = true;\n                this.graph.afterChange(this.resizing_node);\n                this.resizing_node = null;\n            } else if (this.node_dragged) {\n                // node being dragged?\n                const node = this.node_dragged;\n                if (\n                    node\n                    && e.click_time < 300\n                    && isInsideRectangle(\n                        e.canvasX,\n                        e.canvasY,\n                        node.pos[0],\n                        node.pos[1] - defaultConfig.NODE_TITLE_HEIGHT,\n                        defaultConfig.NODE_TITLE_HEIGHT,\n                        defaultConfig.NODE_TITLE_HEIGHT,\n                    )\n                ) {\n                    node.collapse();\n                }\n\n                this.dirty_canvas = true;\n                this.dirty_bgcanvas = true;\n                this.node_dragged.pos[0] = Math.round(this.node_dragged.pos[0]);\n                this.node_dragged.pos[1] = Math.round(this.node_dragged.pos[1]);\n                if (this.graph.config.align_to_grid) {\n                    this.node_dragged.alignToGrid();\n                }\n                if (this.onNodeMoved) this.onNodeMoved(this.node_dragged);\n                this.graph.afterChange(this.node_dragged);\n                this.node_dragged = null;\n            } else {\n                // get node over\n                const node = this.graph.getNodeOnPos(\n                    e.canvasX,\n                    e.canvasY,\n                    this.visible_nodes,\n                );\n\n                if (!node && e.click_time < 300) {\n                    this.deselectAllNodes();\n                }\n\n                this.dirty_canvas = true;\n                this.dragging_canvas = false;\n\n                if (this.node_over && this.node_over.onMouseUp) {\n                    this.node_over.onMouseUp(e, [e.canvasX - this.node_over.pos[0], e.canvasY - this.node_over.pos[1]], this);\n                }\n                if (\n                    this.node_capturing_input\n                    && this.node_capturing_input.onMouseUp\n                ) {\n                    this.node_capturing_input.onMouseUp(e, [\n                        e.canvasX - this.node_capturing_input.pos[0],\n                        e.canvasY - this.node_capturing_input.pos[1],\n                    ]);\n                }\n            }\n        } else if (e.which === 2) {\n            // middle button\n            // trace(\"middle\");\n            this.dirty_canvas = true;\n            this.dragging_canvas = false;\n        } else if (e.which === 3) {\n            // right button\n            // trace(\"right\");\n            this.dirty_canvas = true;\n            this.dragging_canvas = false;\n        }\n\n        this.graph.change();\n\n        e.stopPropagation();\n        e.preventDefault();\n        return false;\n    }\n\n    /**\n     * Called when a mouse wheel event has to be processed\n     * @method processMouseWheel\n     * @memberOf LGraphCanvas\n     * */\n    processMouseWheel(e) {\n        if (!this.graph || !this.allow_dragcanvas) {\n            return;\n        }\n\n        const delta = e.wheelDeltaY ?? e.detail * -60;\n\n        this.adjustMouseEvent(e);\n\n        let { scale } = this.ds;\n\n        if (delta > 0) {\n            scale *= 1.1;\n        } else if (delta < 0) {\n            scale *= 1 / 1.1;\n        }\n\n        // this.setZoom( scale, [ e.localX, e.localY ] );\n        this.ds.changeScale(scale, [e.localX, e.localY]);\n\n        this.graph.change();\n\n        e.preventDefault();\n        return false; // prevent default\n    }\n\n    /**\n     * returns true if a position (in graph space) is on top of a node little corner box\n     * @method isOverNodeBox\n     * @memberOf LGraphCanvas\n     * */\n    isOverNodeBox(node, canvasx, canvasy) {\n        const titleHeight = defaultConfig.NODE_TITLE_HEIGHT;\n        return !!isInsideRectangle(\n            canvasx,\n            canvasy,\n            node.pos[0] + 2,\n            node.pos[1] + 2 - titleHeight,\n            titleHeight - 4,\n            titleHeight - 4,\n        );\n    }\n\n    /**\n     * returns true if a position (in graph space) is on top of a node input slot\n     * @method isOverNodeInput\n     * @memberOf LGraphCanvas\n     * */\n    isOverNodeInput(\n        node,\n        canvasx,\n        canvasy,\n        slotPos,\n    ) {\n        if (node.inputs) {\n            for (let i = 0, l = node.inputs.length; i < l; ++i) {\n                const linkPos = node.getConnectionPos(true, i);\n                let isInside = false;\n                if (node.horizontal) {\n                    isInside = isInsideRectangle(\n                        canvasx,\n                        canvasy,\n                        linkPos[0] - 5,\n                        linkPos[1] - 10,\n                        10,\n                        20,\n                    );\n                } else {\n                    isInside = isInsideRectangle(\n                        canvasx,\n                        canvasy,\n                        linkPos[0] - 10,\n                        linkPos[1] - 5,\n                        40,\n                        10,\n                    );\n                }\n                if (isInside) {\n                    if (slotPos) {\n                        slotPos[0] = linkPos[0];\n                        slotPos[1] = linkPos[1];\n                    }\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * process a key event\n     * @method processKey\n     * @memberOf LGraphCanvas\n     * */\n    processKey(e) {\n        if (!this.graph) return;\n\n        let blockDefault = false;\n\n        if (e.target.localName === \"input\") {\n            return;\n        }\n\n        if (e.type === \"keydown\") {\n            if (e.keyCode === 32) {\n                // esc\n                this.dragging_canvas = true;\n                blockDefault = true;\n            }\n\n            // select all Control A\n            if (e.keyCode === 65 && e.ctrlKey) {\n                this.selectNodes();\n                blockDefault = true;\n            }\n\n            if (e.code === \"KeyC\" && (e.metaKey || e.ctrlKey) && !e.shiftKey) {\n                // copy\n                if (this.selected_nodes) {\n                    this.copyToClipboard();\n                    blockDefault = true;\n                }\n            }\n\n            if (e.code === \"KeyV\" && (e.metaKey || e.ctrlKey) && !e.shiftKey) {\n                // paste\n                this.pasteFromClipboard();\n            }\n\n            // delete or backspace\n            if ((e.keyCode === 46 || e.keyCode === 8)\n                && (e.target.localName !== \"input\" && e.target.localName !== \"textarea\")) {\n                this.deleteSelectedNodes();\n                blockDefault = true;\n            }\n\n            // collapse\n            // ...\n\n            // TODO\n            if (this.selected_nodes) {\n                for (var i in this.selected_nodes) {\n                    if (this.selected_nodes[i].onKeyDown) {\n                        this.selected_nodes[i].onKeyDown(e);\n                    }\n                }\n            }\n        } else if (e.type == \"keyup\") {\n            if (e.keyCode == 32) {\n                this.dragging_canvas = false;\n            }\n\n            if (this.selected_nodes) {\n                for (var i in this.selected_nodes) {\n                    if (this.selected_nodes[i].onKeyUp) {\n                        this.selected_nodes[i].onKeyUp(e);\n                    }\n                }\n            }\n        }\n\n        this.graph.change();\n\n        if (blockDefault) {\n            e.preventDefault();\n            e.stopImmediatePropagation();\n            return false;\n        }\n    }\n\n    pasteFromClipboard() {\n        const data = localStorage.getItem(\"litegrapheditor_clipboard\");\n        if (!data) return;\n\n        this.graph.beforeChange();\n\n        // create nodes\n        const clipboardInfo = JSON.parse(data);\n        const nodes = [];\n        for (const node_data of clipboardInfo.nodes) {\n            const node = LGraphNode.createNode(node_data.type);\n            if (node) {\n                node.configure(node_data);\n                node.pos[0] += 5;\n                node.pos[1] += 5;\n                this.graph.add(node);\n                nodes.push(node);\n            }\n        }\n\n        for (const link_info of clipboardInfo.links) {\n            const origin_node = nodes[link_info[0]];\n            const target_node = nodes[link_info[2]];\n            if (origin_node && target_node) origin_node.connect(link_info[1], target_node, link_info[3]);\n            else console.warn(\"Warning, nodes missing on pasting\");\n        }\n\n        this.selectNodes(nodes);\n\n        this.graph.afterChange();\n    }\n\n    copyToClipboard() {\n        const clipboardInfo = {\n            nodes: [],\n            links: [],\n        };\n        let index = 0;\n        const selectedNodesArray = [];\n\n        // eslint-disable-next-line guard-for-in, no-restricted-syntax\n        for (const i in this.selected_nodes) {\n            const node = this.selected_nodes[i];\n            node.relative_id = index;\n            selectedNodesArray.push(node);\n            index += 1;\n        }\n\n        for (const node of selectedNodesArray) {\n            const cloned = node.clone();\n            if (!cloned) {\n                console.warn(`node type not found: ${node.type}`);\n                continue;\n            }\n            clipboardInfo.nodes.push(cloned.serialize());\n            if (node.inputs && node.inputs.length) {\n                for (let j = 0; j < node.inputs.length; ++j) {\n                    const input = node.inputs[j];\n                    if (!input || input.link == null) {\n                        continue;\n                    }\n                    const link_info = this.graph.links[input.link];\n                    if (!link_info) {\n                        continue;\n                    }\n                    const target_node = this.graph.getNodeById(\n                        link_info.origin_id,\n                    );\n                    if (!target_node || !this.selected_nodes[target_node.id]) {\n                        // improve this by allowing connections to non-selected nodes\n                        continue;\n                    } // not selected\n                    clipboardInfo.links.push([\n                        target_node._relative_id,\n                        link_info.origin_slot, // j,\n                        node._relative_id,\n                        link_info.target_slot,\n                    ]);\n                }\n            }\n        }\n\n        localStorage.setItem(\"litegrapheditor_clipboard\", JSON.stringify(clipboardInfo));\n    }\n\n    /**\n     * process a item drop event on top the canvas\n     * @method processDrop\n     * @memberOf LGraphCanvas\n     * */\n    processDrop(e) {\n        e.preventDefault();\n        this.adjustMouseEvent(e);\n\n        const pos = [e.canvasX, e.canvasY];\n        const node = this.graph ? this.graph.getNodeOnPos(pos[0], pos[1]) : null;\n\n        if (!node) {\n            let r = null;\n            if (this.onDropItem) r = this.onDropItem(e);\n            if (!r) {\n                this.checkDropItem(e);\n            }\n            return;\n        }\n\n        if (node.onDropFile || node.onDropData) {\n            const { files } = e.dataTransfer;\n            if (files && files.length) {\n                for (const file of files) {\n                    const filename = file.name;\n                    // console.log(file);\n\n                    if (node.onDropFile) {\n                        node.onDropFile(file);\n                    }\n\n                    if (node.onDropData) {\n                        // prepare reader\n                        const reader = new FileReader();\n                        reader.onload = (event) => {\n                            // console.log(event.target);\n                            const data = event.target.result;\n                            node.onDropData(data, filename, file);\n                        };\n\n                        // read data\n                        const type = file.type.split(\"/\")[0];\n                        if (type === \"text\" || type === \"\") {\n                            reader.readAsText(file);\n                        } else if (type === \"image\") {\n                            reader.readAsDataURL(file);\n                        } else {\n                            reader.readAsArrayBuffer(file);\n                        }\n                    }\n                }\n            }\n        }\n\n        if (node.onDropItem) {\n            if (node.onDropItem(e)) {\n                return true;\n            }\n        }\n\n        if (this.onDropItem) {\n            return this.onDropItem(e);\n        }\n\n        return false;\n    }\n\n    checkDropItem(e) {\n        if (e.dataTransfer.files.length) {\n            const file = e.dataTransfer.files[0];\n            const ext = getFileExtension(file.name).toLowerCase();\n            const nodetype = defaultConfig.node_types_by_file_extension[ext];\n            if (nodetype) {\n                this.graph.beforeChange();\n                const node = LGraphNode.createNode(nodetype.type);\n                node.pos = [e.canvasX, e.canvasY];\n                this.graph.add(node);\n                if (node.onDropFile) {\n                    node.onDropFile(file);\n                }\n                this.graph.afterChange();\n            }\n        }\n    }\n\n    processNodeDblClicked(n) {\n        if (this.onShowNodePanel) this.onShowNodePanel(n);\n        else this.showShowNodePanel(n);\n\n        if (this.onNodeDblClicked) this.onNodeDblClicked(n);\n\n        this.setDirty(true);\n    }\n\n    processNodeSelected(node, e) {\n        this.selectNode(node, e && e.shiftKey);\n        if (this.onNodeSelected) {\n            this.onNodeSelected(node);\n        }\n    }\n\n    /**\n     * selects a given node (or adds it to the current selection)\n     * @method selectNode\n     * @param {LGraphNode} node\n     * @param {boolean} addToCurrentSelection\n     * @memberOf LGraphCanvas\n     * */\n    selectNode(node, addToCurrentSelection) {\n        if (node == null) {\n            this.deselectAllNodes();\n        } else {\n            this.selectNodes([node], addToCurrentSelection);\n        }\n    }\n\n    /**\n     * selects several nodes (or adds them to the current selection)\n     * @method selectNodes\n     * @memberOf LGraphCanvas\n     * */\n    selectNodes(nodes = this.graph._nodes, addToCurrentSelection) {\n        if (!addToCurrentSelection) this.deselectAllNodes();\n\n        for (const node of nodes) {\n            if (node.is_selected) continue;\n\n            if (!node.is_selected && node.onSelected) node.onSelected();\n            node.is_selected = true;\n            this.selected_nodes[node.id] = node;\n\n            if (node.inputs) {\n                for (const input of node.inputs) this.highlighted_links[input.link] = true;\n            }\n\n            if (node.outputs) {\n                for (const out of node.outputs) {\n                    if (out.links) {\n                        for (const link of out.links) this.highlighted_links[link] = true;\n                    }\n                }\n            }\n        }\n\n        if (this.onSelectionChange) this.onSelectionChange(this.selected_nodes);\n\n        this.setDirty(true);\n    }\n\n    /**\n     * removes a node from the current selection\n     * @method deselectNode\n     * @memberOf LGraphCanvas\n     * */\n    deselectNode(node) {\n        if (!node.is_selected) return;\n        if (node.onDeselected) {\n            node.onDeselected();\n        }\n        node.is_selected = false;\n\n        if (this.onNodeDeselected) {\n            this.onNodeDeselected(node);\n        }\n\n        // remove highlighted\n        if (node.inputs) {\n            for (const input of node.inputs) delete this.highlighted_links[input.link];\n        }\n        if (node.outputs) {\n            for (const out of node.outputs) {\n                if (out.links) {\n                    for (const link of out.links) delete this.highlighted_links[link];\n                }\n            }\n        }\n    }\n\n    /**\n     * removes all nodes from the current selection\n     * @method deselectAllNodes\n     * @memberOf LGraphCanvas\n     * */\n    deselectAllNodes() {\n        if (!this.graph) return;\n        for (const node of this.graph._nodes) {\n            if (!node.is_selected) {\n                continue;\n            }\n            if (node.onDeselected) {\n                node.onDeselected();\n            }\n            node.is_selected = false;\n            if (this.onNodeDeselected) {\n                this.onNodeDeselected(node);\n            }\n        }\n        this.selected_nodes = {};\n        this.current_node = null;\n        this.highlighted_links = {};\n        if (this.onSelectionChange) this.onSelectionChange(this.selected_nodes);\n        this.setDirty(true);\n    }\n\n    /**\n     * deletes all nodes in the current selection from the graph\n     * @method deleteSelectedNodes\n     * @memberOf LGraphCanvas\n     * */\n    deleteSelectedNodes() {\n        this.graph.beforeChange();\n\n        // eslint-disable-next-line guard-for-in, no-restricted-syntax\n        for (const i in this.selected_nodes) {\n            const node = this.selected_nodes[i];\n\n            if (node.block_delete) continue;\n\n            // autoconnect when possible (very basic, only takes into account first input-output)\n            if (node.inputs\n                && node.inputs.length\n                && node.outputs\n                && node.outputs.length\n                && isValidConnection(node.inputs[0].type, node.outputs[0].type)\n                && node.inputs[0].link\n                && node.outputs[0].links\n                && node.outputs[0].links.length) {\n                const inputLink = node.graph.links[node.inputs[0].link];\n                const outputLink = node.graph.links[node.outputs[0].links[0]];\n                const inputNode = node.getInputNode(0);\n                const outputNode = node.getOutputNodes(0)[0];\n                if (inputNode && outputNode) {\n                    inputNode.connect(inputLink.origin_slot, outputNode, outputLink.target_slot);\n                }\n            }\n            this.graph.remove(node);\n            if (this.onNodeDeselected) this.onNodeDeselected(node);\n        }\n\n        this.selected_nodes = {};\n        this.current_node = null;\n        this.highlighted_links = {};\n        this.setDirty(true);\n        this.graph.afterChange();\n    }\n\n    /**\n     * centers the camera on a given node\n     * @method centerOnNode\n     * @memberOf LGraphCanvas\n     * */\n    centerOnNode(node) {\n        this.ds.offset[0] = -node.pos[0]\n            - node.size[0] * 0.5\n            + (this.canvas.width * 0.5) / this.ds.scale;\n        this.ds.offset[1] = -node.pos[1]\n            - node.size[1] * 0.5\n            + (this.canvas.height * 0.5) / this.ds.scale;\n        this.setDirty(true, true);\n    }\n\n    /**\n     * adds some useful properties to a mouse event, like the position in graph coordinates\n     * @method adjustMouseEvent\n     * @memberOf LGraphCanvas\n     * */\n    adjustMouseEvent(e) {\n        if (this.canvas) {\n            const b = this.canvas.getBoundingClientRect();\n            e.localX = e.clientX - b.left;\n            e.localY = e.clientY - b.top;\n        } else {\n            e.localX = e.clientX;\n            e.localY = e.clientY;\n        }\n\n        e.deltaX = e.localX - this.last_mouse_position[0];\n        e.deltaY = e.localY - this.last_mouse_position[1];\n\n        this.last_mouse_position[0] = e.localX;\n        this.last_mouse_position[1] = e.localY;\n\n        e.canvasX = e.localX / this.ds.scale - this.ds.offset[0];\n        e.canvasY = e.localY / this.ds.scale - this.ds.offset[1];\n    }\n\n    /**\n     * changes the zoom level of the graph (default is 1), you can pass also a place used to pivot\n     * the zoom\n     * @method setZoom\n     * @memberOf LGraphCanvas\n     * */\n    setZoom(value, zoomingCenter) {\n        this.ds.changeScale(value, zoomingCenter);\n        this.dirty_canvas = true;\n        this.dirty_bgcanvas = true;\n    }\n\n    /**\n     * converts a coordinate from graph coordinates to canvas2D coordinates\n     * @method convertOffsetToCanvas\n     * @memberOf LGraphCanvas\n     * */\n    convertOffsetToCanvas(pos) {\n        return this.ds.convertOffsetToCanvas(pos);\n    }\n\n    /**\n     * converts a coordinate from Canvas2D coordinates to graph space\n     * @method convertCanvasToOffset\n     * @memberOf LGraphCanvas\n     * */\n    convertCanvasToOffset(pos, out) {\n        return this.ds.convertCanvasToOffset(pos, out);\n    }\n\n    /**\n     * converts event coordinates from canvas2D to graph coordinates\n     * @method convertEventToCanvasOffset\n     * @param e\n     * @returns {Array}\n     * @memberOf LGraphCanvas\n     */\n    convertEventToCanvasOffset(e) {\n        const rect = this.canvas.getBoundingClientRect();\n        return this.convertCanvasToOffset([e.clientX - rect.left, e.clientY - rect.top]);\n    }\n\n    /**\n     * brings a node to front (above all other nodes)\n     * @method bringToFront\n     * @param {LGraphNode} node\n     * @memberOf LGraphCanvas\n     * */\n    bringToFront(node) {\n        const i = this.graph._nodes.indexOf(node);\n        if (i === -1) {\n            return;\n        }\n\n        this.graph._nodes.splice(i, 1);\n        this.graph._nodes.push(node);\n    }\n\n    /**\n     * sends a node to the back (below all other nodes)\n     * @method sendToBack\n     * @param {LGraphNode} node\n     * @memberOf LGraphCanvas\n     * */\n    sendToBack(node) {\n        const i = this.graph._nodes.indexOf(node);\n        if (i === -1) {\n            return;\n        }\n\n        this.graph._nodes.splice(i, 1);\n        this.graph._nodes.unshift(node);\n    }\n\n    /**\n     * checks which nodes are visible (inside the camera area)\n     * @method computeVisibleNodes\n     * @param {LGraphNode[]} [nodes]\n     * @param {LGraphNode[]} [out]\n     * @return {LGraphNode[]}\n     * @memberOf LGraphCanvas\n     * */\n    computeVisibleNodes(nodes, out = []) {\n        const visibleNodes = out;\n        nodes = this.graph._nodes;\n        visibleNodes.length = 0;\n        for (const n of nodes) {\n            // skip rendering nodes in live mode\n            if (this.live_mode && !n.onDrawBackground && !n.onDrawForeground) {\n                continue;\n            }\n\n            if (!overlapBounding(this.visible_area, n.getBounding(temp))) {\n                continue;\n            } // out of the visible area\n\n            visibleNodes.push(n);\n        }\n        return visibleNodes;\n    }\n\n    /**\n     * renders the whole canvas content, by rendering in two separated canvas, one containing the\n     * background grid and the connections, and one containing the nodes)\n     * @method draw\n     * @param {boolean} [force_canvas]\n     * @param {boolean} [force_bgcanvas]\n     * @memberOf LGraphCanvas\n     * */\n    draw(force_canvas, force_bgcanvas) {\n        if (!this.canvas || this.canvas.width === 0 || this.canvas.height === 0) return;\n\n        // fps counting\n        const now = getTime();\n        this.render_time = (now - this.last_draw_time) * 0.001;\n        this.last_draw_time = now;\n\n        if (this.graph) this.ds.computeVisibleArea();\n\n        if (\n            this.dirty_bgcanvas\n            || force_bgcanvas\n            || this.always_render_background\n            || (this.graph\n            && this.graph._last_trigger_time\n            && now - this.graph._last_trigger_time < 1000)\n        ) this.drawBackCanvas();\n\n        if (this.dirty_canvas || force_canvas) this.drawFrontCanvas();\n\n        this.fps = this.render_time ? 1.0 / this.render_time : 0;\n        this.frame += 1;\n    }\n\n    /**\n     * draws the front canvas (the one containing all the nodes)\n     * @method drawFrontCanvas\n     * @memberOf LGraphCanvas\n     * */\n    drawFrontCanvas() {\n        this.dirty_canvas = false;\n\n        if (!this.ctx) this.ctx = this.bgcanvas.getContext(\"2d\");\n        const { ctx } = this;\n        if (!ctx) return;\n\n        if (ctx.start2D) {\n            ctx.start2D();\n        }\n\n        const { canvas } = this;\n\n        // reset in case of error\n        ctx.restore();\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n\n        // clip dirty area if there is one, otherwise work in full canvas\n        if (this.dirty_area) {\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect(\n                this.dirty_area[0],\n                this.dirty_area[1],\n                this.dirty_area[2],\n                this.dirty_area[3],\n            );\n            ctx.clip();\n        }\n\n        if (this.clear_background) ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n        // draw bg canvas\n        if (this.bgcanvas === this.canvas) {\n            this.drawBackCanvas();\n        } else {\n            ctx.drawImage(this.bgcanvas, 0, 0);\n        }\n\n        // rendering\n        if (this.onRender) this.onRender(canvas, ctx);\n\n        // info widget\n        if (this.show_info) this.renderInfo(ctx);\n\n        if (this.graph) {\n            // apply transformations\n            ctx.save();\n            this.ds.toCanvasContext(ctx);\n\n            // draw nodes\n            let drawnNodes = 0;\n            const visibleNodes = this.computeVisibleNodes(null, this.visible_nodes);\n\n            for (const node of visibleNodes) {\n                // transform coords system\n                ctx.save();\n                ctx.translate(node.pos[0], node.pos[1]);\n\n                // Draw\n                this.drawNode(node, ctx);\n                drawnNodes += 1;\n\n                // Restore\n                ctx.restore();\n            }\n\n            // on top (debug)\n            if (this.render_execution_order) this.drawExecutionOrder(ctx);\n\n            // connections ontop?\n            if (this.graph.config.links_ontop && !this.live_mode) this.drawConnections(ctx);\n\n            // current connection (the one being dragged by the mouse)\n            if (this.connecting_pos) {\n                ctx.lineWidth = this.connections_width;\n                let linkColor = null;\n                switch (this.connecting_output.type) {\n                    case defaultConfig.EVENT:\n                        linkColor = defaultConfig.EVENT_LINK_COLOR;\n                        break;\n                    default:\n                        linkColor = defaultConfig.CONNECTING_LINK_COLOR;\n                }\n\n                // the connection being dragged by the mouse\n                this.renderLink(\n                    ctx,\n                    this.connecting_pos,\n                    [this.graph_mouse[0], this.graph_mouse[1]],\n                    null,\n                    false,\n                    null,\n                    linkColor,\n                    this.connecting_output.dir\n                    || (this.connecting_node.horizontal ? defaultConfig.DOWN : defaultConfig.RIGHT),\n                    defaultConfig.CENTER,\n                );\n\n                ctx.beginPath();\n                if (\n                    this.connecting_output.type === defaultConfig.EVENT\n                    || this.connecting_output.shape === defaultConfig.BOX_SHAPE\n                ) {\n                    ctx.rect(\n                        this.connecting_pos[0] - 6 + 0.5,\n                        this.connecting_pos[1] - 5 + 0.5,\n                        14,\n                        10,\n                    );\n                } else {\n                    ctx.arc(\n                        this.connecting_pos[0],\n                        this.connecting_pos[1],\n                        4,\n                        0,\n                        Math.PI * 2,\n                    );\n                }\n                ctx.fill();\n\n                ctx.fillStyle = \"#ffcc00\";\n                if (this._highlight_input) {\n                    ctx.beginPath();\n                    ctx.arc(\n                        this._highlight_input[0],\n                        this._highlight_input[1],\n                        6,\n                        0,\n                        Math.PI * 2,\n                    );\n                    ctx.fill();\n                }\n            }\n\n            // the selection rectangle\n            if (this.dragging_rectangle) {\n                ctx.strokeStyle = \"#FFF\";\n                ctx.strokeRect(\n                    this.dragging_rectangle[0],\n                    this.dragging_rectangle[1],\n                    this.dragging_rectangle[2],\n                    this.dragging_rectangle[3],\n                );\n            }\n\n            // on top of link center\n            if (this.over_link_center && this.render_link_tooltip) {\n                this.drawLinkTooltip(ctx, this.over_link_center);\n            } else if (this.onDrawLinkTooltip) {\n                this.onDrawLinkTooltip(ctx, null);\n            }\n\n            // custom info\n            if (this.onDrawForeground) {\n                this.onDrawForeground(ctx, this.visible_rect);\n            }\n\n            ctx.restore();\n        }\n\n        // draws panel in the corner\n        if (this._graph_stack && this._graph_stack.length) this.drawSubgraphPanel(ctx);\n\n        if (this.onDrawOverlay) this.onDrawOverlay(ctx);\n\n        if (this.dirty_area) ctx.restore();\n\n        if (ctx.finish2D) ctx.finish2D();\n    }\n\n    /**\n     * draws the panel in the corner that shows subgraph properties\n     * @method drawSubgraphPanel\n     * @memberOf LGraphCanvas\n     * */\n    drawSubgraphPanel(ctx) {\n        const subgraph = this.graph;\n        const subnode = subgraph._subgraph_node;\n        if (!subnode) {\n            console.warn(\"subgraph without subnode\");\n            return;\n        }\n\n        const num = subnode.inputs ? subnode.inputs.length : 0;\n        const w = 300;\n        const h = Math.floor(defaultConfig.NODE_SLOT_HEIGHT * 1.6);\n\n        ctx.fillStyle = \"#111\";\n        ctx.globalAlpha = 0.8;\n        ctx.beginPath();\n        ctx.roundRect(10, 10, w, (num + 1) * h + 50, 8);\n        ctx.fill();\n        ctx.globalAlpha = 1;\n\n        ctx.fillStyle = \"#888\";\n        ctx.font = \"14px Arial\";\n        ctx.textAlign = \"left\";\n        ctx.fillText(\"Graph Inputs\", 20, 34);\n\n        if (this.drawButton(w - 20, 20, 20, 20, \"X\", \"#151515\")) {\n            this.closeSubgraph();\n            return;\n        }\n\n        let y = 50;\n        ctx.font = \"20px Arial\";\n        if (subnode.inputs) {\n            for (const input of subnode.inputs) {\n                if (input.not_subgraph_input) continue;\n\n                // input button clicked\n                if (this.drawButton(20, y + 2, w - 20, h - 2)) {\n                    const type = subnode.constructor.input_node_type || \"graph/input\";\n                    this.graph.beforeChange();\n                    const newnode = createNode(type);\n                    if (newnode) {\n                        subgraph.add(newnode);\n                        this.block_click = false;\n                        this.last_click_position = null;\n                        this.selectNodes([newnode]);\n                        this.node_dragged = newnode;\n                        this.dragging_canvas = false;\n                        newnode.setProperty(\"name\", input.name);\n                        newnode.setProperty(\"type\", input.type);\n                        this.node_dragged.pos[0] = this.graph_mouse[0] - 5;\n                        this.node_dragged.pos[1] = this.graph_mouse[1] - 5;\n                        this.graph.afterChange();\n                    } else {\n                        console.error(\"graph input node not found:\", type);\n                    }\n                }\n\n                ctx.fillStyle = \"#9C9\";\n                ctx.beginPath();\n                ctx.arc(w - 16, y + h * 0.5, 5, 0, 2 * Math.PI);\n                ctx.fill();\n\n                ctx.fillStyle = \"#AAA\";\n                ctx.fillText(input.name, 50, y + h * 0.75);\n                const tw = ctx.measureText(input.name);\n                ctx.fillStyle = \"#777\";\n                ctx.fillText(input.type, 50 + tw.width + 10, y + h * 0.75);\n\n                y += h;\n            }\n        }\n\n        // add + button\n        if (this.drawButton(20, y + 2, w - 20, h - 2, \"+\", \"#151515\", \"#222\")) {\n            this.showSubgraphPropertiesDialog(subnode);\n        }\n    }\n\n    /**\n     * Draws a button into the canvas overlay and computes if it was clicked using the immediate\n     * gui paradigm\n     * @method drawButton\n     * @param x\n     * @param y\n     * @param w\n     * @param h\n     * @param text\n     * @param [bgcolor]\n     * @param [hovercolor]\n     * @param [textcolor]\n     * @returns {*|boolean}\n     * @memberOf LGraphCanvas\n     */\n    drawButton(x, y, w, h, text, bgcolor = defaultConfig.NODE_DEFAULT_COLOR, hovercolor = \"#555\", textcolor = defaultConfig.NODE_TEXT_COLOR) {\n        const { ctx } = this;\n\n        let pos = this.mouse;\n        const hover = isInsideRectangle(pos[0], pos[1], x, y, w, h);\n        pos = this.last_click_position;\n        const clicked = pos && isInsideRectangle(pos[0], pos[1], x, y, w, h);\n\n        ctx.fillStyle = hover ? hovercolor : bgcolor;\n        if (clicked) ctx.fillStyle = \"#AAA\";\n        ctx.beginPath();\n        ctx.roundRect(x, y, w, h, 4);\n        ctx.fill();\n\n        if (text) {\n            if (text.constructor === String) {\n                ctx.fillStyle = textcolor;\n                ctx.textAlign = \"center\";\n                // eslint-disable-next-line\n                ctx.font = `${(h * 0.65) | 0}px Arial`;\n                ctx.fillText(text, x + w * 0.5, y + h * 0.75);\n                ctx.textAlign = \"left\";\n            }\n        }\n\n        if (clicked) this.blockClick();\n        return clicked && !this.block_click;\n    }\n\n    isAreaClicked(x, y, w, h, holdClick) {\n        const pos = this.last_click_position;\n        const clicked = pos && isInsideRectangle(pos[0], pos[1], x, y, w, h);\n        if (clicked && holdClick) this.blockClick();\n        return clicked && !this.block_click;\n    }\n\n    /**\n     * draws some useful stats in the corner of the canvas\n     * @method renderInfo\n     * @memberOf LGraphCanvas\n     * */\n    renderInfo(ctx, x = 10, y = this.canvas.height - 80) {\n        ctx.save();\n        ctx.translate(x, y);\n\n        ctx.font = \"10px Arial\";\n        ctx.fillStyle = \"#888\";\n        if (this.graph) {\n            ctx.fillText(`T: ${this.graph.globaltime.toFixed(2)}s`, 5, 13);\n            ctx.fillText(`I: ${this.graph.iteration}`, 5, 13 * 2);\n            ctx.fillText(`N: ${this.graph._nodes.length} [${this.visible_nodes.length}]`, 5, 13 * 3);\n            ctx.fillText(`V: ${this.graph._version}`, 5, 13 * 4);\n            ctx.fillText(`FPS:${this.fps.toFixed(2)}`, 5, 13 * 5);\n        } else {\n            ctx.fillText(\"No graph selected\", 5, 13);\n        }\n        ctx.restore();\n    }\n\n    /**\n     * draws the back canvas (the one containing the background and the connections)\n     * @method drawBackCanvas\n     * @memberOf LGraphCanvas\n     * */\n    drawBackCanvas() {\n        const canvas = this.bgcanvas;\n        if (canvas.width !== this.canvas.width || canvas.height !== this.canvas.height) {\n            canvas.width = this.canvas.width;\n            canvas.height = this.canvas.height;\n        }\n\n        if (!this.bgctx) this.bgctx = this.bgcanvas.getContext(\"2d\");\n        const ctx = this.bgctx;\n        if (ctx.start) ctx.start();\n\n        // clear\n        if (this.clear_background) ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n        if (this._graph_stack && this._graph_stack.length) {\n            ctx.save();\n            const subgraphNode = this.graph._subgraph_node;\n            ctx.strokeStyle = subgraphNode.bgcolor;\n            ctx.lineWidth = 10;\n            ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);\n            ctx.lineWidth = 1;\n            ctx.font = \"40px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.fillStyle = subgraphNode.bgcolor || \"#AAA\";\n            let title = \"\";\n\n            for (const g of this._graph_stack) {\n                title += `${g._subgraph_node.getTitle()} >> `;\n            }\n\n            ctx.fillText(\n                title + subgraphNode.getTitle(),\n                canvas.width * 0.5,\n                40,\n            );\n            ctx.restore();\n        }\n\n        let bgAlreadyPainted = false;\n        if (this.onRenderBackground) {\n            bgAlreadyPainted = this.onRenderBackground(canvas, ctx);\n        }\n\n        // reset in case of error\n        ctx.restore();\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        this.visible_links.length = 0;\n\n        if (this.graph) {\n            // apply transformations\n            ctx.save();\n            this.ds.toCanvasContext(ctx);\n\n            // render BG\n            if (this.background_image && this.ds.scale > 0.5 && !bgAlreadyPainted) {\n                ctx.globalAlpha = this.zoom_modify_alpha\n                    ? (1.0 - 0.5 / this.ds.scale) * this.editor_alpha\n                    : this.editor_alpha;\n\n                ctx.imageSmoothingEnabled = false;\n                ctx.mozImageSmoothingEnabled = false;\n                ctx.imageSmoothingEnabled = false;\n                if (\n                    !this._bg_img\n                    || this._bg_img.id !== this.background_image\n                ) {\n                    this._bg_img = new Image();\n                    this._bg_img.id = this.background_image;\n                    this._bg_img.src = this.background_image;\n                    this._bg_img.onload = () => this.draw(true, true);\n                }\n\n                let pattern = null;\n                if (this._pattern == null && this._bg_img.width > 0) {\n                    pattern = ctx.createPattern(this._bg_img, \"repeat\");\n                    this._pattern_img = this._bg_img;\n                    this._pattern = pattern;\n                } else {\n                    pattern = this._pattern;\n                }\n                if (pattern) {\n                    ctx.fillStyle = pattern;\n                    ctx.fillRect(\n                        this.visible_area[0],\n                        this.visible_area[1],\n                        this.visible_area[2],\n                        this.visible_area[3],\n                    );\n                    ctx.fillStyle = \"transparent\";\n                }\n\n                ctx.globalAlpha = 1.0;\n                ctx.imageSmoothingEnabled = true;\n                ctx.mozImageSmoothingEnabled = true;\n                ctx.imageSmoothingEnabled = true;\n            }\n\n            // groups\n            if (this.graph._groups.length && !this.live_mode) this.drawGroups(canvas, ctx);\n\n            if (this.onDrawBackground) this.onDrawBackground(ctx, this.visible_area);\n\n            // bg\n            if (this.render_canvas_border) {\n                ctx.strokeStyle = \"#235\";\n                ctx.strokeRect(0, 0, canvas.width, canvas.height);\n            }\n\n            if (this.render_connections_shadows) {\n                ctx.shadowColor = \"#000\";\n                ctx.shadowOffsetX = 0;\n                ctx.shadowOffsetY = 0;\n                ctx.shadowBlur = 6;\n            } else {\n                ctx.shadowColor = \"rgba(0,0,0,0)\";\n            }\n\n            // draw connections\n            if (!this.live_mode) this.drawConnections(ctx);\n\n            ctx.shadowColor = \"rgba(0,0,0,0)\";\n\n            ctx.restore();\n        }\n\n        if (ctx.finish) ctx.finish();\n\n        this.dirty_bgcanvas = false;\n        this.dirty_canvas = true; // to force to repaint the front canvas with the bgcanvas\n    }\n\n    /**\n     * draws the given node inside the canvas\n     * @method drawNode\n     * @memberOf LGraphCanvas\n     * */\n    drawNode(node, ctx) {\n        let glow = false;\n        this.current_node = node;\n\n        const color = node.color || node.constructor.color || defaultConfig.NODE_DEFAULT_COLOR;\n        let bgcolor = node.bgcolor || node.constructor.bgcolor || defaultConfig.NODE_DEFAULT_BGCOLOR;\n\n        // shadow and glow\n        if (node.mouseOver) glow = true;\n\n        const lowQuality = this.ds.scale < 0.6; // zoomed out\n\n        // only render if it forces it to do it\n        if (this.live_mode) {\n            if (!node.flags.collapsed) {\n                ctx.shadowColor = \"transparent\";\n                if (node.onDrawForeground) {\n                    node.onDrawForeground(ctx, this, this.canvas);\n                }\n            }\n            return;\n        }\n\n        ctx.globalAlpha = this.editor_alpha;\n\n        if (this.render_shadows && !lowQuality) {\n            ctx.shadowColor = defaultConfig.DEFAULT_SHADOW_COLOR;\n            ctx.shadowOffsetX = 2 * this.ds.scale;\n            ctx.shadowOffsetY = 2 * this.ds.scale;\n            ctx.shadowBlur = 3 * this.ds.scale;\n        } else {\n            ctx.shadowColor = \"transparent\";\n        }\n\n        // custom draw collapsed method (draw after shadows because they are affected)\n        if (node.flags.collapsed\n            && node.onDrawCollapsed\n            && node.onDrawCollapsed(ctx, this) == true\n        ) {\n            return;\n        }\n\n        // clip if required (mask)\n        const shape = node._shape || defaultConfig.BOX_SHAPE;\n        const size = tempVC2;\n        tempVC2.set(node.size);\n        const { horizontal } = node; // || node.flags.horizontal;\n\n        if (node.flags.collapsed) {\n            ctx.font = this.inner_text_font;\n            const title = node.getTitle ? node.getTitle() : node.title;\n            if (title) {\n                node._collapsed_width = Math.min(\n                    node.size[0],\n                    ctx.measureText(title).width\n                    + defaultConfig.NODE_TITLE_HEIGHT * 2,\n                ); // LiteGraph.NODE_COLLAPSED_WIDTH;\n                size[0] = node._collapsed_width;\n                size[1] = 0;\n            }\n        }\n\n        if (node.clip_area) {\n            // Start clipping\n            ctx.save();\n            ctx.beginPath();\n            if (shape === defaultConfig.BOX_SHAPE) ctx.rect(0, 0, size[0], size[1]);\n            else if (shape === defaultConfig.ROUND_SHAPE) ctx.roundRect(0, 0, size[0], size[1], 10);\n            else if (shape === defaultConfig.CIRCLE_SHAPE) {\n                ctx.arc(\n                    size[0] * 0.5,\n                    size[1] * 0.5,\n                    size[0] * 0.5,\n                    0,\n                    Math.PI * 2,\n                );\n            }\n            ctx.clip();\n        }\n\n        // draw shape\n        if (node.has_errors) bgcolor = \"red\";\n        this.drawNodeShape(\n            node,\n            ctx,\n            size,\n            color,\n            bgcolor,\n            node.is_selected,\n            node.mouseOver,\n        );\n        ctx.shadowColor = \"transparent\";\n\n        // draw foreground\n        if (node.onDrawForeground) {\n            node.onDrawForeground(ctx, this, this.canvas);\n        }\n\n        // connection slots\n        ctx.textAlign = horizontal ? \"center\" : \"left\";\n        ctx.font = this.inner_text_font;\n\n        const renderText = !lowQuality;\n\n        const outSlot = this.connecting_output;\n        ctx.lineWidth = 1;\n\n        let maxY = 0;\n        const slotPos = new Float32Array(2); // to reuse\n\n        // render inputs and outputs\n        if (!node.flags.collapsed) {\n            // input connection slots\n            if (node.inputs) {\n                for (let i = 0; i < node.inputs.length; i++) {\n                    const slot = node.inputs[i];\n\n                    ctx.globalAlpha = this.editor_alpha;\n                    // change opacity of incompatible slots when dragging a connection\n                    if (this.connecting_node\n                        && !isValidConnection(slot.type, outSlot.type)) {\n                        ctx.globalAlpha = 0.4 * this.editor_alpha;\n                    }\n\n                    ctx.fillStyle = slot.link\n                        ? slot.color_on\n                        || this.default_connection_color.input_on\n                        : slot.color_off\n                        || this.default_connection_color.input_off;\n\n                    const pos = node.getConnectionPos(true, i, slotPos);\n                    pos[0] -= node.pos[0];\n                    pos[1] -= node.pos[1];\n                    if (maxY < pos[1] + defaultConfig.NODE_SLOT_HEIGHT * 0.5) {\n                        maxY = pos[1] + defaultConfig.NODE_SLOT_HEIGHT * 0.5;\n                    }\n\n                    ctx.beginPath();\n\n                    if (slot.type === defaultConfig.EVENT || slot.shape === defaultConfig.BOX_SHAPE) {\n                        if (horizontal) ctx.rect(pos[0] - 5 + 0.5, pos[1] - 8 + 0.5, 10, 14);\n                        else ctx.rect(pos[0] - 6 + 0.5, pos[1] - 5 + 0.5, 14, 10);\n                    } else if (slot.shape === defaultConfig.ARROW_SHAPE) {\n                        ctx.moveTo(pos[0] + 8, pos[1] + 0.5);\n                        ctx.lineTo(pos[0] - 4, pos[1] + 6 + 0.5);\n                        ctx.lineTo(pos[0] - 4, pos[1] - 6 + 0.5);\n                        ctx.closePath();\n                    } else if (lowQuality) {\n                        ctx.rect(pos[0] - 4, pos[1] - 4, 8, 8);\n                    } else {\n                        ctx.arc(pos[0], pos[1], 4, 0, Math.PI * 2);\n                    }\n                    ctx.fill();\n\n                    // render name\n                    if (renderText) {\n                        const text = slot.label ? slot.label : slot.name;\n                        if (text) {\n                            ctx.fillStyle = defaultConfig.NODE_TEXT_COLOR;\n                            if (horizontal || slot.dir === defaultConfig.UP) {\n                                ctx.fillText(text, pos[0], pos[1] - 10);\n                            } else {\n                                ctx.fillText(text, pos[0] + 10, pos[1] + 5);\n                            }\n                        }\n                    }\n                }\n            }\n\n            // output connection slots\n            if (this.connecting_node) {\n                ctx.globalAlpha = 0.4 * this.editor_alpha;\n            }\n\n            ctx.textAlign = horizontal ? \"center\" : \"right\";\n            ctx.strokeStyle = \"black\";\n            if (node.outputs) {\n                for (let i = 0; i < node.outputs.length; i++) {\n                    const slot = node.outputs[i];\n\n                    const pos = node.getConnectionPos(false, i, slotPos);\n                    pos[0] -= node.pos[0];\n                    pos[1] -= node.pos[1];\n                    if (maxY < pos[1] + defaultConfig.NODE_SLOT_HEIGHT * 0.5) {\n                        maxY = pos[1] + defaultConfig.NODE_SLOT_HEIGHT * 0.5;\n                    }\n\n                    ctx.fillStyle = slot.links && slot.links.length\n                        ? slot.color_on\n                        || this.default_connection_color.output_on\n                        : slot.color_off\n                        || this.default_connection_color.output_off;\n                    ctx.beginPath();\n                    // ctx.rect( node.size[0] - 14,i*14,10,10);\n\n                    if (\n                        slot.type === defaultConfig.EVENT\n                        || slot.shape === defaultConfig.BOX_SHAPE\n                    ) {\n                        if (horizontal) {\n                            ctx.rect(\n                                pos[0] - 5 + 0.5,\n                                pos[1] - 8 + 0.5,\n                                10,\n                                14,\n                            );\n                        } else {\n                            ctx.rect(\n                                pos[0] - 6 + 0.5,\n                                pos[1] - 5 + 0.5,\n                                14,\n                                10,\n                            );\n                        }\n                    } else if (slot.shape === defaultConfig.ARROW_SHAPE) {\n                        ctx.moveTo(pos[0] + 8, pos[1] + 0.5);\n                        ctx.lineTo(pos[0] - 4, pos[1] + 6 + 0.5);\n                        ctx.lineTo(pos[0] - 4, pos[1] - 6 + 0.5);\n                        ctx.closePath();\n                    } else if (lowQuality) {\n                        ctx.rect(pos[0] - 4, pos[1] - 4, 8, 8);\n                    } else {\n                        ctx.arc(pos[0], pos[1], 4, 0, Math.PI * 2);\n                    }\n\n                    ctx.fill();\n                    if (!lowQuality) ctx.stroke();\n\n                    // render output name\n                    if (renderText) {\n                        const text = slot.label != null ? slot.label : slot.name;\n                        if (text) {\n                            ctx.fillStyle = defaultConfig.NODE_TEXT_COLOR;\n                            if (horizontal || slot.dir === defaultConfig.DOWN) {\n                                ctx.fillText(text, pos[0], pos[1] - 8);\n                            } else {\n                                ctx.fillText(text, pos[0] - 10, pos[1] + 5);\n                            }\n                        }\n                    }\n                }\n            }\n\n            ctx.textAlign = \"left\";\n            ctx.globalAlpha = 1;\n\n            if (node.widgets) {\n                let widgetsY = maxY;\n                if (horizontal || node.widgets_up) widgetsY = 2;\n                if (node.widgets_start_y) widgetsY = node.widgets_start_y;\n                this.drawNodeWidgets(\n                    node,\n                    widgetsY,\n                    ctx,\n                    this.node_widget && this.node_widget[0] === node ? this.node_widget[1] : null,\n                );\n            }\n        } else if (this.render_collapsed_slots) {\n            // if collapsed\n            let inputSlot = null;\n            let outputSlot = null;\n            let storedSlot;\n\n            // get first connected slot to render\n            if (node.inputs) {\n                for (const slot of node.inputs) {\n                    if (slot.link == null) continue;\n                    inputSlot = slot;\n                    storedSlot = slot;\n                    break;\n                }\n            }\n            if (node.outputs) {\n                for (const slot of node.outputs) {\n                    if (!slot.links || !slot.links.length) continue;\n                    outputSlot = slot;\n                    storedSlot = slot;\n                }\n            }\n\n            if (inputSlot) {\n                let x = 0;\n                let y = defaultConfig.NODE_TITLE_HEIGHT * -0.5; // center\n                if (horizontal) {\n                    x = node._collapsed_width * 0.5;\n                    y = -defaultConfig.NODE_TITLE_HEIGHT;\n                }\n                ctx.fillStyle = \"#686\";\n                ctx.beginPath();\n                if (storedSlot.type === defaultConfig.EVENT\n                    || storedSlot.shape === defaultConfig.BOX_SHAPE) {\n                    ctx.rect(x - 7 + 0.5, y - 4, 14, 8);\n                } else if (storedSlot.shape === defaultConfig.ARROW_SHAPE) {\n                    ctx.moveTo(x + 8, y);\n                    ctx.lineTo(x + -4, y - 4);\n                    ctx.lineTo(x + -4, y + 4);\n                    ctx.closePath();\n                } else ctx.arc(x, y, 4, 0, Math.PI * 2);\n                ctx.fill();\n            }\n\n            if (outputSlot) {\n                let x = node._collapsed_width;\n                let y = defaultConfig.NODE_TITLE_HEIGHT * -0.5; // center\n                if (horizontal) {\n                    x = node._collapsed_width * 0.5;\n                    y = 0;\n                }\n                ctx.fillStyle = \"#686\";\n                ctx.strokeStyle = \"black\";\n                ctx.beginPath();\n                if (\n                    storedSlot.type === defaultConfig.EVENT\n                    || storedSlot.shape === defaultConfig.BOX_SHAPE\n                ) {\n                    ctx.rect(x - 7 + 0.5, y - 4, 14, 8);\n                } else if (slot.shape === defaultConfig.ARROW_SHAPE) {\n                    ctx.moveTo(x + 6, y);\n                    ctx.lineTo(x - 6, y - 4);\n                    ctx.lineTo(x - 6, y + 4);\n                    ctx.closePath();\n                } else ctx.arc(x, y, 4, 0, Math.PI * 2);\n                ctx.fill();\n                // ctx.stroke();\n            }\n        }\n\n        if (node.clip_area) ctx.restore();\n\n        ctx.globalAlpha = 1.0;\n    }\n\n    // used by this.over_link_center\n    drawLinkTooltip(ctx, link) {\n        const pos = link._pos;\n        ctx.fillStyle = \"black\";\n        ctx.beginPath();\n        ctx.arc(pos[0], pos[1], 3, 0, Math.PI * 2);\n        ctx.fill();\n\n        if (link.data == null) return;\n\n        if (this.onDrawLinkTooltip && this.onDrawLinkTooltip(ctx, link, this)) return;\n\n        const { data } = link;\n        let text;\n\n        if (data.constructor === Number) text = data.toFixed(2);\n        else if (data.constructor === String) text = `\"${data}\"`;\n        else if (data.constructor === Boolean) text = String(data);\n        else if (data.toToolTip) text = data.toToolTip();\n        else text = `[${data.constructor.name}]`;\n\n        if (!text) return;\n        text = text.substr(0, 30); // avoid weird\n\n        ctx.font = \"14px Courier New\";\n        const info = ctx.measureText(text);\n        const w = info.width + 20;\n        const h = 24;\n        ctx.shadowColor = \"black\";\n        ctx.shadowOffsetX = 2;\n        ctx.shadowOffsetY = 2;\n        ctx.shadowBlur = 3;\n        ctx.fillStyle = \"#454\";\n        ctx.beginPath();\n        ctx.roundRect(pos[0] - w * 0.5, pos[1] - 15 - h, w, h, 3, 3);\n        ctx.moveTo(pos[0] - 10, pos[1] - 15);\n        ctx.lineTo(pos[0] + 10, pos[1] - 15);\n        ctx.lineTo(pos[0], pos[1] - 5);\n        ctx.fill();\n        ctx.shadowColor = \"transparent\";\n        ctx.textAlign = \"center\";\n        ctx.fillStyle = \"#CEC\";\n        ctx.fillText(text, pos[0], pos[1] - 15 - h * 0.3);\n    }\n\n    /**\n     * draws the shape of the given node in the canvas\n     * @method drawNodeShape\n     * @memberOf LGraphCanvas\n     * */\n    drawNodeShape(\n        node,\n        ctx,\n        size,\n        fgcolor,\n        bgcolor,\n        selected,\n        mouseHover,\n    ) {\n        // bg rect\n        ctx.strokeStyle = fgcolor;\n        ctx.fillStyle = bgcolor;\n\n        const titleHeight = defaultConfig.NODE_TITLE_HEIGHT;\n        const lowQuality = this.ds.scale < 0.5;\n\n        // render node area depending on shape\n        const shape = node._shape || node.constructor.shape || defaultConfig.ROUND_SHAPE;\n\n        const { title_mode } = node.constructor;\n\n        let renderTitle = true;\n        if (title_mode === defaultConfig.TRANSPARENT_TITLE) renderTitle = false;\n        else if (title_mode === defaultConfig.AUTOHIDE_TITLE && mouseHover) renderTitle = true;\n\n        const area = tempArea;\n        area[0] = 0; // x\n        area[1] = renderTitle ? -titleHeight : 0; // y\n        area[2] = size[0] + 1; // w\n        area[3] = renderTitle ? size[1] + titleHeight : size[1]; // h\n\n        const oldAlpha = ctx.globalAlpha;\n\n        ctx.beginPath();\n        if (shape === defaultConfig.BOX_SHAPE || lowQuality) {\n            ctx.fillRect(area[0], area[1], area[2], area[3]);\n        } else if (shape === defaultConfig.ROUND_SHAPE || shape === defaultConfig.CARD_SHAPE) {\n            ctx.roundRect(\n                area[0],\n                area[1],\n                area[2],\n                area[3],\n                this.round_radius,\n                shape === defaultConfig.CARD_SHAPE ? 0 : this.round_radius,\n            );\n        } else if (shape === defaultConfig.CIRCLE_SHAPE) {\n            ctx.arc(\n                size[0] * 0.5,\n                size[1] * 0.5,\n                size[0] * 0.5,\n                0,\n                Math.PI * 2,\n            );\n        }\n        ctx.fill();\n\n        // separator\n        if (!node.flags.collapsed) {\n            ctx.shadowColor = \"transparent\";\n            ctx.fillStyle = \"rgba(0,0,0,0.2)\";\n            ctx.fillRect(0, -1, area[2], 2);\n        }\n        ctx.shadowColor = \"transparent\";\n\n        if (node.onDrawBackground) node.onDrawBackground(ctx, this, this.canvas, this.graph_mouse);\n\n        // title bg (remember, it is rendered ABOVE the node)\n        if (renderTitle || title_mode === defaultConfig.TRANSPARENT_TITLE) {\n            // title bar\n            if (node.onDrawTitleBar) {\n                node.onDrawTitleBar(ctx, titleHeight, size, this.ds.scale, fgcolor);\n            } else if (\n                title_mode !== defaultConfig.TRANSPARENT_TITLE\n                && (node.constructor.title_color || this.render_title_colored)\n            ) {\n                const titleColor = node.constructor.title_color || fgcolor;\n\n                if (node.flags.collapsed) {\n                    ctx.shadowColor = defaultConfig.DEFAULT_SHADOW_COLOR;\n                }\n\n                //* gradient test\n                if (this.use_gradients) {\n                    let grad = LGraphCanvas.gradients[titleColor];\n                    if (!grad) {\n                        grad = ctx.createLinearGradient(0, 0, 400, 0);\n                        LGraphCanvas.gradients[titleColor] = grad;\n                        grad.addColorStop(0, titleColor);\n                        grad.addColorStop(1, \"#000\");\n                    }\n                    ctx.fillStyle = grad;\n                } else {\n                    ctx.fillStyle = titleColor;\n                }\n\n                // ctx.globalAlpha = 0.5 * old_alpha;\n                ctx.beginPath();\n                if (shape === defaultConfig.BOX_SHAPE || lowQuality) {\n                    ctx.rect(0, -titleHeight, size[0] + 1, titleHeight);\n                } else if (shape === defaultConfig.ROUND_SHAPE || shape === defaultConfig.CARD_SHAPE) {\n                    ctx.roundRect(\n                        0,\n                        -titleHeight,\n                        size[0] + 1,\n                        titleHeight,\n                        this.round_radius,\n                        node.flags.collapsed ? this.round_radius : 0,\n                    );\n                }\n                ctx.fill();\n                ctx.shadowColor = \"transparent\";\n            }\n\n            // title box\n            const boxSize = 10;\n            if (node.onDrawTitleBox) {\n                node.onDrawTitleBox(ctx, titleHeight, size, this.ds.scale);\n            } else if ([defaultConfig.ROUND_SHAPE, defaultConfig.CIRCLE_SHAPE, defaultConfig.CARD_SHAPE].includes(shape)) {\n                if (lowQuality) {\n                    ctx.fillStyle = \"black\";\n                    ctx.beginPath();\n                    ctx.arc(\n                        titleHeight * 0.5,\n                        titleHeight * -0.5,\n                        boxSize * 0.5 + 1,\n                        0,\n                        Math.PI * 2,\n                    );\n                    ctx.fill();\n                }\n\n                ctx.fillStyle = node.boxcolor || defaultConfig.NODE_DEFAULT_BOXCOLOR;\n                if (lowQuality) ctx.fillRect(titleHeight * 0.5 - boxSize * 0.5, titleHeight * -0.5 - boxSize * 0.5, boxSize, boxSize);\n                else {\n                    ctx.beginPath();\n                    ctx.arc(\n                        titleHeight * 0.5,\n                        titleHeight * -0.5,\n                        boxSize * 0.5,\n                        0,\n                        Math.PI * 2,\n                    );\n                    ctx.fill();\n                }\n            } else {\n                if (lowQuality) {\n                    ctx.fillStyle = \"black\";\n                    ctx.fillRect(\n                        (titleHeight - boxSize) * 0.5 - 1,\n                        (titleHeight + boxSize) * -0.5 - 1,\n                        boxSize + 2,\n                        boxSize + 2,\n                    );\n                }\n                ctx.fillStyle = node.boxcolor || defaultConfig.NODE_DEFAULT_BOXCOLOR;\n                ctx.fillRect(\n                    (titleHeight - boxSize) * 0.5,\n                    (titleHeight + boxSize) * -0.5,\n                    boxSize,\n                    boxSize,\n                );\n            }\n            ctx.globalAlpha = oldAlpha;\n\n            // title text\n            if (node.onDrawTitleText) {\n                node.onDrawTitleText(\n                    ctx,\n                    titleHeight,\n                    size,\n                    this.ds.scale,\n                    this.title_text_font,\n                    selected,\n                );\n            }\n            if (!lowQuality) {\n                ctx.font = this.title_text_font;\n                const title = String(node.getTitle());\n                if (title) {\n                    if (selected) ctx.fillStyle = defaultConfig.NODE_SELECTED_TITLE_COLOR;\n                    else ctx.fillStyle = node.constructor.title_text_color || this.node_title_color;\n                    if (node.flags.collapsed) {\n                        ctx.textAlign = \"left\";\n                        const measure = ctx.measureText(title);\n                        ctx.fillText(\n                            title.substr(0, 20), // avoid urls too long\n                            titleHeight, // + measure.width * 0.5,\n                            defaultConfig.NODE_TITLE_TEXT_Y - titleHeight,\n                        );\n                        ctx.textAlign = \"left\";\n                    } else {\n                        ctx.textAlign = \"left\";\n                        ctx.fillText(\n                            title,\n                            titleHeight,\n                            defaultConfig.NODE_TITLE_TEXT_Y - titleHeight,\n                        );\n                    }\n                }\n            }\n\n            // subgraph box\n            if (!node.flags.collapsed && node.subgraph && !node.skip_subgraph_button) {\n                const w = defaultConfig.NODE_TITLE_HEIGHT;\n                const x = node.size[0] - w;\n                const over = isInsideRectangle(\n                    this.graph_mouse[0] - node.pos[0],\n                    this.graph_mouse[1] - node.pos[1],\n                    x + 2,\n                    -w + 2,\n                    w - 4,\n                    w - 4,\n                );\n                ctx.fillStyle = over ? \"#888\" : \"#555\";\n                if (shape === defaultConfig.BOX_SHAPE || lowQuality) {\n                    ctx.fillRect(x + 2, -w + 2, w - 4, w - 4);\n                } else {\n                    ctx.beginPath();\n                    ctx.roundRect(x + 2, -w + 2, w - 4, w - 4, 4);\n                    ctx.fill();\n                }\n                ctx.fillStyle = \"#333\";\n                ctx.beginPath();\n                ctx.moveTo(x + w * 0.2, -w * 0.6);\n                ctx.lineTo(x + w * 0.8, -w * 0.6);\n                ctx.lineTo(x + w * 0.5, -w * 0.3);\n                ctx.fill();\n            }\n\n            // custom title render\n            if (node.onDrawTitle) node.onDrawTitle(ctx);\n        }\n\n        // render selection marker\n        if (selected) {\n            if (node.onBounding) node.onBounding(area);\n\n            if (title_mode === defaultConfig.TRANSPARENT_TITLE) {\n                area[1] -= titleHeight;\n                area[3] += titleHeight;\n            }\n            ctx.lineWidth = 1;\n            ctx.globalAlpha = 0.8;\n            ctx.beginPath();\n            if (shape === defaultConfig.BOX_SHAPE) {\n                ctx.rect(\n                    -6 + area[0],\n                    -6 + area[1],\n                    12 + area[2],\n                    12 + area[3],\n                );\n            } else if (\n                shape === defaultConfig.ROUND_SHAPE\n                || (shape === defaultConfig.CARD_SHAPE && node.flags.collapsed)\n            ) {\n                ctx.roundRect(\n                    -6 + area[0],\n                    -6 + area[1],\n                    12 + area[2],\n                    12 + area[3],\n                    this.round_radius * 2,\n                );\n            } else if (shape === defaultConfig.CARD_SHAPE) {\n                ctx.roundRect(\n                    -6 + area[0],\n                    -6 + area[1],\n                    12 + area[2],\n                    12 + area[3],\n                    this.round_radius * 2,\n                    2,\n                );\n            } else if (shape === defaultConfig.CIRCLE_SHAPE) {\n                ctx.arc(\n                    size[0] * 0.5,\n                    size[1] * 0.5,\n                    size[0] * 0.5 + 6,\n                    0,\n                    Math.PI * 2,\n                );\n            }\n            ctx.strokeStyle = defaultConfig.NODE_BOX_OUTLINE_COLOR;\n            ctx.stroke();\n            ctx.strokeStyle = fgcolor;\n            ctx.globalAlpha = 1;\n        }\n    }\n\n    /**\n     * draws every connection visible in the canvas\n     * OPTIMIZE THIS: pre-catch connections position instead of recomputing them every time\n     * @method drawConnections\n     * @memberOf LGraphCanvas\n     * */\n    drawConnections(ctx) {\n        const now = getTime();\n        const { visible_area } = this;\n        marginArea[0] = visible_area[0] - 20;\n        marginArea[1] = visible_area[1] - 20;\n        marginArea[2] = visible_area[2] + 40;\n        marginArea[3] = visible_area[3] + 40;\n\n        // draw connections\n        ctx.lineWidth = this.connections_width;\n\n        ctx.fillStyle = \"#AAA\";\n        ctx.strokeStyle = \"#AAA\";\n        ctx.globalAlpha = this.editor_alpha;\n        // for every node\n        const nodes = this.graph._nodes;\n        for (const node of nodes) {\n            // for every input (we render just inputs because it is easier as every slot can only\n            // have one input)\n            if (!node.inputs || !node.inputs.length) {\n                continue;\n            }\n\n            for (let i = 0; i < node.inputs.length; ++i) {\n                const input = node.inputs[i];\n                if (!input || input.link == null) continue;\n\n                const linkId = input.link;\n                const link = this.graph.links[linkId];\n                if (!link) continue;\n\n                // find link info\n                const startNode = this.graph.getNodeById(link.origin_id);\n                if (!startNode) continue;\n\n                const startNodeSlot = link.origin_slot;\n                let startNodeSlotPos = null;\n                if (startNodeSlot === -1) {\n                    startNodeSlotPos = [\n                        startNode.pos[0] + 10,\n                        startNode.pos[1] + 10,\n                    ];\n                } else {\n                    startNodeSlotPos = startNode.getConnectionPos(\n                        false,\n                        startNodeSlot,\n                        tempA,\n                    );\n                }\n\n                const endNodeSlotPos = node.getConnectionPos(true, i, tempB);\n\n                // compute link bounding\n                linkBounding[0] = startNodeSlotPos[0];\n                linkBounding[1] = startNodeSlotPos[1];\n                linkBounding[2] = endNodeSlotPos[0] - startNodeSlotPos[0];\n                linkBounding[3] = endNodeSlotPos[1] - startNodeSlotPos[1];\n\n                if (linkBounding[2] < 0) {\n                    linkBounding[0] += linkBounding[2];\n                    linkBounding[2] = Math.abs(linkBounding[2]);\n                }\n                if (linkBounding[3] < 0) {\n                    linkBounding[1] += linkBounding[3];\n                    linkBounding[3] = Math.abs(linkBounding[3]);\n                }\n\n                // skip links outside of the visible area of the canvas\n                if (!overlapBounding(linkBounding, marginArea)) {\n                    continue;\n                }\n\n                const startSlot = startNode.outputs[startNodeSlot];\n                const endSlot = node.inputs[i];\n                if (!startSlot || !endSlot) continue;\n                const startDir = startSlot.dir\n                    || (startNode.horizontal ? defaultConfig.DOWN : defaultConfig.RIGHT);\n                const endDir = endSlot.dir\n                    || (node.horizontal ? defaultConfig.UP : defaultConfig.LEFT);\n\n                this.renderLink(\n                    ctx,\n                    startNodeSlotPos,\n                    endNodeSlotPos,\n                    link,\n                    false,\n                    0,\n                    null,\n                    startDir,\n                    endDir,\n                );\n\n                // event triggered rendered on top\n                if (link && link._last_time && now - link._last_time < 1000) {\n                    const f = 2.0 - (now - link._last_time) * 0.002;\n                    const tmp = ctx.globalAlpha;\n                    ctx.globalAlpha = tmp * f;\n                    this.renderLink(\n                        ctx,\n                        startNodeSlotPos,\n                        endNodeSlotPos,\n                        link,\n                        true,\n                        f,\n                        \"white\",\n                        startDir,\n                        endDir,\n                    );\n                    ctx.globalAlpha = tmp;\n                }\n            }\n        }\n        ctx.globalAlpha = 1;\n    }\n\n    /**\n     * draws a link between two points\n     * @method renderLink\n     * @param {vec2} a start pos\n     * @param {vec2} b end pos\n     * @param {Object} link the link object with all the link info\n     * @param {boolean} skipBorder ignore the shadow of the link\n     * @param {boolean} flow show flow animation (for events)\n     * @param {string} color the color for the link\n     * @param {number} startDir the direction enum\n     * @param {number} endDir the direction enum\n     * @param {number} numSubline number of sublines (useful to represent vec3 or rgb)\n     * @memberOf LGraphCanvas\n     * */\n    renderLink(\n        ctx,\n        a,\n        b,\n        link,\n        skipBorder,\n        flow,\n        color,\n        startDir,\n        endDir,\n        numSubline,\n    ) {\n        if (link) this.visible_links.push(link);\n\n        // choose color\n        if (!color && link) color = link.color || LGraphCanvas.link_type_colors[link.type];\n        if (!color) color = this.default_link_color;\n        if (link != null && this.highlighted_links[link.id]) color = \"#FFF\";\n\n        startDir = startDir || defaultConfig.RIGHT;\n        endDir = endDir || defaultConfig.LEFT;\n\n        const dist = distance(a, b);\n\n        if (this.render_connections_border && this.ds.scale > 0.6) {\n            ctx.lineWidth = this.connections_width + 4;\n        }\n        ctx.lineJoin = \"round\";\n        numSubline = numSubline || 1;\n        if (numSubline > 1) ctx.lineWidth = 0.5;\n\n        // begin line shape\n        ctx.beginPath();\n        for (let i = 0; i < numSubline; i += 1) {\n            const offsety = (i - (numSubline - 1) * 0.5) * 5;\n\n            if (this.links_render_mode === defaultConfig.SPLINE_LINK) {\n                ctx.moveTo(a[0], a[1] + offsety);\n                let startOffsetX = 0;\n                let startOffsetY = 0;\n                let endOffsetX = 0;\n                let endOffsetY = 0;\n                switch (startDir) {\n                    case defaultConfig.LEFT:\n                        startOffsetX = dist * -0.25;\n                        break;\n                    case defaultConfig.RIGHT:\n                        startOffsetX = dist * 0.25;\n                        break;\n                    case defaultConfig.UP:\n                        startOffsetY = dist * -0.25;\n                        break;\n                    case defaultConfig.DOWN:\n                        startOffsetY = dist * 0.25;\n                        break;\n                    default:\n                        break;\n                }\n                switch (endDir) {\n                    case defaultConfig.LEFT:\n                        endOffsetX = dist * -0.25;\n                        break;\n                    case defaultConfig.RIGHT:\n                        endOffsetX = dist * 0.25;\n                        break;\n                    case defaultConfig.UP:\n                        endOffsetY = dist * -0.25;\n                        break;\n                    case defaultConfig.DOWN:\n                        endOffsetY = dist * 0.25;\n                        break;\n                    default:\n                        break;\n                }\n                ctx.bezierCurveTo(\n                    a[0] + startOffsetX,\n                    a[1] + startOffsetY + offsety,\n                    b[0] + endOffsetX,\n                    b[1] + endOffsetY + offsety,\n                    b[0],\n                    b[1] + offsety,\n                );\n            } else if (this.links_render_mode === defaultConfig.LINEAR_LINK) {\n                ctx.moveTo(a[0], a[1] + offsety);\n                let startOffsetX = 0;\n                let startOffsetY = 0;\n                let endOffsetX = 0;\n                let endOffsetY = 0;\n                switch (startDir) {\n                    case defaultConfig.LEFT:\n                        startOffsetX = -1;\n                        break;\n                    case defaultConfig.RIGHT:\n                        startOffsetX = 1;\n                        break;\n                    case defaultConfig.UP:\n                        startOffsetY = -1;\n                        break;\n                    case defaultConfig.DOWN:\n                        startOffsetY = 1;\n                        break;\n                    default:\n                        break;\n                }\n                switch (endDir) {\n                    case defaultConfig.LEFT:\n                        endOffsetX = -1;\n                        break;\n                    case defaultConfig.RIGHT:\n                        endOffsetX = 1;\n                        break;\n                    case defaultConfig.UP:\n                        endOffsetY = -1;\n                        break;\n                    case defaultConfig.DOWN:\n                        endOffsetY = 1;\n                        break;\n                    default:\n                        break;\n                }\n                const l = 15;\n                ctx.lineTo(\n                    a[0] + startOffsetX * l,\n                    a[1] + startOffsetY * l + offsety,\n                );\n                ctx.lineTo(\n                    b[0] + endOffsetX * l,\n                    b[1] + endOffsetY * l + offsety,\n                );\n                ctx.lineTo(b[0], b[1] + offsety);\n            } else if (this.links_render_mode === defaultConfig.STRAIGHT_LINK) {\n                ctx.moveTo(a[0], a[1]);\n                let startX = a[0];\n                let startY = a[1];\n                let endX = b[0];\n                let endY = b[1];\n\n                if (startDir === defaultConfig.RIGHT) startX += 10;\n                else startY += 10;\n                if (endDir === defaultConfig.LEFT) endX -= 10;\n                else endY -= 10;\n\n                ctx.lineTo(startX, startY);\n                ctx.lineTo((startX + endX) * 0.5, startY);\n                ctx.lineTo((startX + endX) * 0.5, endY);\n                ctx.lineTo(endX, endY);\n                ctx.lineTo(b[0], b[1]);\n            } else return;\n        }\n\n        // rendering the outline of the connection can be a little bit slow\n        if (this.render_connections_border && this.ds.scale > 0.6 && !skipBorder) {\n            ctx.strokeStyle = \"rgba(0,0,0,0.5)\";\n            ctx.stroke();\n        }\n\n        ctx.lineWidth = this.connections_width;\n        ctx.fillStyle = color;\n        ctx.strokeStyle = color;\n        ctx.stroke();\n        // end line shape\n\n        const posConnectionPoint = this.computeConnectionPoint(a, b, 0.5, startDir, endDir);\n        if (link && link._pos) {\n            link._pos[0] = posConnectionPoint[0];\n            link._pos[1] = posConnectionPoint[1];\n        }\n\n        // render arrow in the middle\n        if (this.ds.scale >= 0.6 && this.highquality_render && endDir !== defaultConfig.CENTER) {\n            // render arrow\n            if (this.render_connection_arrows) {\n                // compute two points in the connection\n                const posA = this.computeConnectionPoint(a, b, 0.25, startDir, endDir);\n                const posB = this.computeConnectionPoint(a, b, 0.26, startDir, endDir);\n                const posC = this.computeConnectionPoint(a, b, 0.75, startDir, endDir);\n                const posD = this.computeConnectionPoint(a, b, 0.76, startDir, endDir);\n\n                // compute the angle between them so the arrow points in the right direction\n                let angleA = 0;\n                let angleB = 0;\n                if (this.render_curved_connections) {\n                    angleA = -Math.atan2(posB[0] - posA[0], posB[1] - posA[1]);\n                    angleB = -Math.atan2(posD[0] - posC[0], posD[1] - posC[1]);\n                } else angleB = angleA = b[1] > a[1] ? 0 : Math.PI;\n\n                // render arrow\n                ctx.save();\n                ctx.translate(posA[0], posA[1]);\n                ctx.rotate(angleA);\n                ctx.beginPath();\n                ctx.moveTo(-5, -3);\n                ctx.lineTo(0, 7);\n                ctx.lineTo(5, -3);\n                ctx.fill();\n                ctx.restore();\n                ctx.save();\n                ctx.translate(posC[0], posC[1]);\n                ctx.rotate(angleB);\n                ctx.beginPath();\n                ctx.moveTo(-5, -3);\n                ctx.lineTo(0, 7);\n                ctx.lineTo(5, -3);\n                ctx.fill();\n                ctx.restore();\n            }\n\n            // circle\n            ctx.beginPath();\n            ctx.arc(posConnectionPoint[0], posConnectionPoint[1], 5, 0, Math.PI * 2);\n            ctx.fill();\n        }\n\n        // render flowing points\n        if (flow) {\n            ctx.fillStyle = color;\n            for (let i = 0; i < 5; ++i) {\n                const f = (getTime() * 0.001 + i * 0.2) % 1;\n                const pos = this.computeConnectionPoint(a, b, f, startDir, endDir);\n                ctx.beginPath();\n                ctx.arc(pos[0], pos[1], 5, 0, 2 * Math.PI);\n                ctx.fill();\n            }\n        }\n    }\n\n    /**\n     * returns the link center point based on curvature\n     * @method computeConnectionPoint\n     * @param a\n     * @param b\n     * @param t\n     * @param [startDir]\n     * @param [endDir]\n     * @returns {number[]}\n     * @memberOf LGraphCanvas\n     */\n    computeConnectionPoint(a, b, t, startDir = defaultConfig.RIGHT, endDir = defaultConfig.LEFT) {\n        const dist = distance(a, b);\n        const p0 = a;\n        const p1 = [a[0], a[1]];\n        const p2 = [b[0], b[1]];\n        const p3 = b;\n\n        switch (startDir) {\n            case defaultConfig.LEFT:\n                p1[0] += dist * -0.25;\n                break;\n            case defaultConfig.RIGHT:\n                p1[0] += dist * 0.25;\n                break;\n            case defaultConfig.UP:\n                p1[1] += dist * -0.25;\n                break;\n            case defaultConfig.DOWN:\n                p1[1] += dist * 0.25;\n                break;\n            default:\n                break;\n        }\n        switch (endDir) {\n            case defaultConfig.LEFT:\n                p2[0] += dist * -0.25;\n                break;\n            case defaultConfig.RIGHT:\n                p2[0] += dist * 0.25;\n                break;\n            case defaultConfig.UP:\n                p2[1] += dist * -0.25;\n                break;\n            case defaultConfig.DOWN:\n                p2[1] += dist * 0.25;\n                break;\n            default:\n                break;\n        }\n\n        const c1 = (1 - t) * (1 - t) * (1 - t);\n        const c2 = 3 * ((1 - t) * (1 - t)) * t;\n        const c3 = 3 * (1 - t) * (t * t);\n        const c4 = t * t * t;\n\n        const x = c1 * p0[0] + c2 * p1[0] + c3 * p2[0] + c4 * p3[0];\n        const y = c1 * p0[1] + c2 * p1[1] + c3 * p2[1] + c4 * p3[1];\n        return [x, y];\n    }\n\n    drawExecutionOrder(ctx) {\n        ctx.shadowColor = \"transparent\";\n        ctx.globalAlpha = 0.25;\n\n        ctx.textAlign = \"center\";\n        ctx.strokeStyle = \"white\";\n        ctx.globalAlpha = 0.75;\n\n        const { visible_nodes } = this;\n        for (const node of visible_nodes) {\n            ctx.fillStyle = \"black\";\n            ctx.fillRect(\n                node.pos[0] - defaultConfig.NODE_TITLE_HEIGHT,\n                node.pos[1] - defaultConfig.NODE_TITLE_HEIGHT,\n                defaultConfig.NODE_TITLE_HEIGHT,\n                defaultConfig.NODE_TITLE_HEIGHT,\n            );\n            if (node.order === 0) {\n                ctx.strokeRect(\n                    node.pos[0] - defaultConfig.NODE_TITLE_HEIGHT + 0.5,\n                    node.pos[1] - defaultConfig.NODE_TITLE_HEIGHT + 0.5,\n                    defaultConfig.NODE_TITLE_HEIGHT,\n                    defaultConfig.NODE_TITLE_HEIGHT,\n                );\n            }\n            ctx.fillStyle = \"#FFF\";\n            ctx.fillText(\n                node.order,\n                node.pos[0] + defaultConfig.NODE_TITLE_HEIGHT * -0.5,\n                node.pos[1] - 6,\n            );\n        }\n        ctx.globalAlpha = 1;\n    }\n\n    /**\n     * draws the widgets stored inside a node\n     * @method drawNodeWidgets\n     * @memberOf LGraphCanvas\n     * */\n    drawNodeWidgets(node, posY, ctx, active_widget) {\n        if (!node.widgets || !node.widgets.length) return 0;\n        const width = node.size[0];\n        const { widgets } = node;\n        posY += 2;\n        const H = defaultConfig.NODE_WIDGET_HEIGHT;\n        const showText = this.ds.scale > 0.5;\n        ctx.save();\n        ctx.globalAlpha = this.editor_alpha;\n        const outlineColor = defaultConfig.WIDGET_OUTLINE_COLOR;\n        const backgroundColor = defaultConfig.WIDGET_BGCOLOR;\n        const textColor = defaultConfig.WIDGET_TEXT_COLOR;\n        const secondaryTextColor = defaultConfig.WIDGET_SECONDARY_TEXT_COLOR;\n        const margin = 15;\n\n        for (const w of widgets) {\n            let y = posY;\n            if (w.y) y = w.y;\n            w.last_y = y;\n            ctx.strokeStyle = outlineColor;\n            ctx.fillStyle = \"#222\";\n            ctx.textAlign = \"left\";\n            // ctx.lineWidth = 2;\n            if (w.disabled) ctx.globalAlpha *= 0.5;\n            const widgetWidth = w.width || width;\n\n            switch (w.type) {\n                case \"button\":\n                    if (w.clicked) {\n                        ctx.fillStyle = \"#AAA\";\n                        w.clicked = false;\n                        this.dirty_canvas = true;\n                    }\n                    ctx.fillRect(margin, y, widgetWidth - margin * 2, H);\n                    if (showText && !w.disabled) ctx.strokeRect(margin, y, widgetWidth - margin * 2, H);\n                    if (showText) {\n                        ctx.textAlign = \"center\";\n                        ctx.fillStyle = textColor;\n                        ctx.fillText(w.name, widgetWidth * 0.5, y + H * 0.7);\n                    }\n                    break;\n                case \"toggle\":\n                    ctx.textAlign = \"left\";\n                    ctx.strokeStyle = outlineColor;\n                    ctx.fillStyle = backgroundColor;\n                    ctx.beginPath();\n\n                    if (showText) ctx.roundRect(margin, posY, widgetWidth - margin * 2, H, H * 0.5);\n                    else ctx.rect(margin, posY, widgetWidth - margin * 2, H);\n\n                    ctx.fill();\n                    if (showText && !w.disabled) ctx.stroke();\n                    ctx.fillStyle = w.value ? \"#89A\" : \"#333\";\n                    ctx.beginPath();\n                    ctx.arc(widgetWidth - margin * 2, y + H * 0.5, H * 0.36, 0, Math.PI * 2);\n                    ctx.fill();\n                    if (showText) {\n                        ctx.fillStyle = secondaryTextColor;\n                        if (w.name) ctx.fillText(w.name, margin * 2, y + H * 0.7);\n                        ctx.fillStyle = w.value ? textColor : secondaryTextColor;\n                        ctx.textAlign = \"right\";\n                        ctx.fillText(\n                            w.value\n                                ? w.options.on || \"true\"\n                                : w.options.off || \"false\",\n                            widgetWidth - 40,\n                            y + H * 0.7,\n                        );\n                    }\n                    break;\n                case \"slider\":\n                    ctx.fillStyle = backgroundColor;\n                    ctx.fillRect(margin, y, widgetWidth - margin * 2, H);\n                    var range = w.options.max - w.options.min;\n                    var nvalue = (w.value - w.options.min) / range;\n                    ctx.fillStyle = active_widget === w ? \"#89A\" : \"#678\";\n                    ctx.fillRect(margin, y, nvalue * (widgetWidth - margin * 2), H);\n                    if (showText && !w.disabled) ctx.strokeRect(margin, y, widgetWidth - margin * 2, H);\n                    if (w.marker) {\n                        const marker_nvalue = (w.marker - w.options.min) / range;\n                        ctx.fillStyle = \"#AA9\";\n                        ctx.fillRect(margin + marker_nvalue * (widgetWidth - margin * 2), y, 2, H);\n                    }\n                    if (showText) {\n                        ctx.textAlign = \"center\";\n                        ctx.fillStyle = textColor;\n                        ctx.fillText(\n                            `${w.name}  ${Number(w.value)\n                                .toFixed(3)}`,\n                            widgetWidth * 0.5,\n                            y + H * 0.7,\n                        );\n                    }\n                    break;\n                case \"number\":\n                case \"combo\":\n                    ctx.textAlign = \"left\";\n                    ctx.strokeStyle = outlineColor;\n                    ctx.fillStyle = backgroundColor;\n                    ctx.beginPath();\n                    if (showText) ctx.roundRect(margin, posY, widgetWidth - margin * 2, H, H * 0.5);\n                    else ctx.rect(margin, posY, widgetWidth - margin * 2, H);\n                    ctx.fill();\n                    if (showText) {\n                        if (!w.disabled) ctx.stroke();\n                        ctx.fillStyle = textColor;\n                        if (!w.disabled) {\n                            ctx.beginPath();\n                            ctx.moveTo(margin + 16, posY + 5);\n                            ctx.lineTo(margin + 6, posY + H * 0.5);\n                            ctx.lineTo(margin + 16, posY + H - 5);\n                            ctx.fill();\n                            ctx.beginPath();\n                            ctx.moveTo(widgetWidth - margin - 16, posY + 5);\n                            ctx.lineTo(widgetWidth - margin - 6, posY + H * 0.5);\n                            ctx.lineTo(widgetWidth - margin - 16, posY + H - 5);\n                            ctx.fill();\n                        }\n                        ctx.fillStyle = secondaryTextColor;\n                        ctx.fillText(w.name, margin * 2 + 5, y + H * 0.7);\n                        ctx.fillStyle = textColor;\n                        ctx.textAlign = \"right\";\n                        if (w.type === \"number\") {\n                            ctx.fillText(\n                                Number(w.value)\n                                    .toFixed(\n                                        w.options.precision\n                                            ? w.options.precision\n                                            : 3,\n                                    ),\n                                widgetWidth - margin * 2 - 20,\n                                y + H * 0.7,\n                            );\n                        } else {\n                            let v = w.value;\n                            if (w.options.values) {\n                                let { values } = w.options;\n                                if (values.constructor === Function) values = values();\n                                if (values && values.constructor !== Array) v = values[w.value];\n                            }\n                            ctx.fillText(\n                                v,\n                                widgetWidth - margin * 2 - 20,\n                                y + H * 0.7,\n                            );\n                        }\n                    }\n                    break;\n                case \"string\":\n                case \"text\":\n                    ctx.textAlign = \"left\";\n                    ctx.strokeStyle = outlineColor;\n                    ctx.fillStyle = backgroundColor;\n                    ctx.beginPath();\n\n                    if (showText) ctx.roundRect(margin, posY, widgetWidth - margin * 2, H, H * 0.5);\n                    else ctx.rect(margin, posY, widgetWidth - margin * 2, H);\n\n                    ctx.fill();\n                    if (showText) {\n                        if (!w.disabled) ctx.stroke();\n                        ctx.save();\n                        ctx.beginPath();\n                        ctx.rect(margin, posY, widgetWidth - margin * 2, H);\n                        ctx.clip();\n\n                        // ctx.stroke();\n                        ctx.fillStyle = secondaryTextColor;\n                        if (w.name) ctx.fillText(w.name, margin * 2, y + H * 0.7);\n                        ctx.fillStyle = textColor;\n                        ctx.textAlign = \"right\";\n                        ctx.fillText(String(w.value)\n                            .substr(0, 30), widgetWidth - margin * 2, y + H * 0.7); // 30 chars max\n                        ctx.restore();\n                    }\n                    break;\n                default:\n                    if (w.draw) w.draw(ctx, node, widgetWidth, y, H);\n                    break;\n            }\n            posY += (w.computeSize ? w.computeSize(widgetWidth)[1] : H) + 4;\n            ctx.globalAlpha = this.editor_alpha;\n        }\n        ctx.restore();\n        ctx.textAlign = \"left\";\n    }\n\n    /**\n     * process an event on widgets\n     * @method processNodeWidgets\n     * @memberOf LGraphCanvas\n     * */\n    processNodeWidgets(node, pos, event, activeWidget) {\n        if (!node.widgets || !node.widgets.length) return null;\n\n        const x = pos[0] - node.pos[0];\n        const y = pos[1] - node.pos[1];\n        const width = node.size[0];\n        const refWindow = this.getCanvasWindow();\n\n        for (const w of node.widgets) {\n            if (!w || w.disabled) continue;\n            const widgetHeight = w.computeSize ? w.computeSize(width)[1] : defaultConfig.NODE_WIDGET_HEIGHT;\n            const widgetWidth = w.width || width;\n            // outside\n            if (w !== activeWidget\n                && (x < 6 || x > widgetWidth - 12 || y < w.last_y || y > w.last_y + widgetHeight)) {\n                continue;\n            }\n\n            const oldValue = w.value;\n\n            // if ( w == active_widget || (x > 6 && x < widget_width - 12 && y > w.last_y && y <\n            // w.last_y + widget_height) ) { inside widget\n            switch (w.type) {\n                case \"button\":\n                    if (event.type === \"mousemove\") {\n                        break;\n                    }\n                    if (w.callback) {\n                        setTimeout(() => w.callback(w, this, node, pos, event), 20);\n                    }\n                    w.clicked = true;\n                    this.dirty_canvas = true;\n                    break;\n                case \"slider\":\n                    const range = w.options.max - w.options.min;\n                    const nvalue = clamp((x - 15) / (widgetWidth - 30), 0, 1);\n                    w.value = w.options.min + (w.options.max - w.options.min) * nvalue;\n                    if (w.callback) {\n                        setTimeout(() => innerValueChange(w, w.value), 20);\n                    }\n                    this.dirty_canvas = true;\n                    break;\n                case \"number\":\n                case \"combo\":\n                    const oldValue = w.value;\n                    if (event.type === \"mousemove\" && w.type === \"number\") {\n                        w.value += event.deltaX * 0.1 * (w.options.step || 1);\n                        if (w.options.min && w.value < w.options.min) w.value = w.options.min;\n                        if (w.options.max && w.value > w.options.max) w.value = w.options.max;\n                    } else if (event.type === \"mousedown\") {\n                        let { values } = w.options;\n                        if (values && values.constructor === Function) {\n                            values = w.options.values(w, node);\n                        }\n                        let valuesList = [];\n\n                        if (w.type !== \"number\") valuesList = values.constructor === Array ? values : Object.keys(values);\n\n                        const delta = x < 40 ? -1 : x > widgetWidth - 40 ? 1 : 0;\n                        if (w.type === \"number\") {\n                            w.value += delta * 0.1 * (w.options.step || 1);\n                            if (w.options.min != null && w.value < w.options.min) {\n                                w.value = w.options.min;\n                            }\n                            if (w.options.max != null && w.value > w.options.max) {\n                                w.value = w.options.max;\n                            }\n                        } else if (delta) { // clicked in arrow, used for combos\n                            let index = -1;\n                            this.last_mouseclick = 0; // avoids dobl click event\n                            if (values.constructor === Object) {\n                                index = valuesList.indexOf(String(w.value)) + delta;\n                            } else {\n                                index = valuesList.indexOf(w.value) + delta;\n                            }\n                            if (index >= valuesList.length) {\n                                index = valuesList.length - 1;\n                            }\n                            if (index < 0) {\n                                index = 0;\n                            }\n                            if (values.constructor === Array) {\n                                w.value = values[index];\n                            } else {\n                                w.value = index;\n                            }\n                        } else { // combo clicked\n                            const textValues = values !== valuesList\n                                ? Object.values(values)\n                                : values;\n                            const menu = new ContextMenu(textValues, {\n                                scale: Math.max(1, this.ds.scale),\n                                event,\n                                className: \"dark\",\n                                callback: innerClicked.bind(w),\n                            },\n                            refWindow);\n\n                            function innerClicked(v, option, event) {\n                                if (values != valuesList) v = textValues.indexOf(v);\n                                this.value = v;\n                                innerValueChange(this, v);\n                                that.dirty_canvas = true;\n                                return false;\n                            }\n                        }\n                    } else if (event.type === \"mouseup\" && w.type === \"number\") {\n                        const delta = x < 40 ? -1 : x > widgetWidth - 40 ? 1 : 0;\n                        if (event.click_time < 200 && delta == 0) {\n                            this.prompt(\"Value\", w.value, (v) => {\n                                w.value = Number(v);\n                                innerValueChange(w, w.value);\n                            }, event);\n                        }\n                    }\n\n                    if (oldValue !== w.value) {\n                        setTimeout(\n                            () => {\n                                innerValueChange(this, this.value);\n                            },\n                            20,\n                        );\n                    }\n                    this.dirty_canvas = true;\n                    break;\n                case \"toggle\":\n                    if (event.type === \"mousedown\") {\n                        w.value = !w.value;\n                        setTimeout(() => {\n                            innerValueChange(w, w.value);\n                        }, 20);\n                    }\n                    break;\n                case \"string\":\n                case \"text\":\n                    if (event.type === \"mousedown\") {\n                        this.prompt(\"Value\", w.value, (v) => {\n                            w.value = v;\n                            innerValueChange(w, v);\n                        }, event, w.options ? w.options.multiline : false);\n                    }\n                    break;\n                default:\n                    if (w.mouse) {\n                        this.dirty_canvas = w.mouse(event, [x, y], node);\n                    }\n                    break;\n            } // end switch\n\n            // value changed\n            if (oldValue !== w.value) {\n                if (node.onWidgetChanged) node.onWidgetChanged(w.name, w.value, oldValue, w);\n                node.graph._version++;\n            }\n\n            return w;\n        }\n\n        const that = this;\n        function innerValueChange(widget, value) {\n            widget.value = value;\n            if (widget.options && widget.options.property && node.properties[widget.options.property]) {\n                node.setProperty(widget.options.property, value);\n            }\n            if (widget.callback) {\n                widget.callback(widget.value, that, node, pos, event);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * draws every group area in the background\n     * @method drawGroups\n     * @memberOf LGraphCanvas\n     * */\n    drawGroups(canvas, ctx) {\n        if (!this.graph) return;\n\n        const groups = this.graph._groups;\n\n        ctx.save();\n        ctx.globalAlpha = 0.5 * this.editor_alpha;\n\n        for (const group of groups) {\n            if (!overlapBounding(this.visible_area, group._bounding)) {\n                continue;\n            } // out of the visible area\n\n            ctx.fillStyle = group.color || \"#335\";\n            ctx.strokeStyle = group.color || \"#335\";\n            const pos = group._pos;\n            const size = group._size;\n            ctx.globalAlpha = 0.25 * this.editor_alpha;\n            ctx.beginPath();\n            ctx.rect(pos[0] + 0.5, pos[1] + 0.5, size[0], size[1]);\n            ctx.fill();\n            ctx.globalAlpha = this.editor_alpha;\n            ctx.stroke();\n\n            ctx.beginPath();\n            ctx.moveTo(pos[0] + size[0], pos[1] + size[1]);\n            ctx.lineTo(pos[0] + size[0] - 10, pos[1] + size[1]);\n            ctx.lineTo(pos[0] + size[0], pos[1] + size[1] - 10);\n            ctx.fill();\n\n            const fontSize = group.font_size || defaultConfig.DEFAULT_GROUP_FONT_SIZE;\n            ctx.font = `${fontSize}px Arial`;\n            ctx.fillText(group.title, pos[0] + 4, pos[1] + fontSize);\n        }\n\n        ctx.restore();\n    }\n\n    adjustNodesSize() {\n        const nodes = this.graph._nodes;\n        for (const node of nodes) node.size = node.computeSize();\n        this.setDirty(true, true);\n    }\n\n    /**\n     * resizes the canvas to a given size, if no size is passed, then it tries to fill the\n     * parentNode\n     * @method resize\n     * @memberOf LGraphCanvas\n     * */\n    resize(width, height) {\n        if (!width && !height) {\n            const parent = this.canvas.parentNode;\n            width = parent.offsetWidth;\n            height = parent.offsetHeight;\n        }\n\n        if (this.canvas.width === width && this.canvas.height === height) {\n            return;\n        }\n\n        this.canvas.width = width;\n        this.canvas.height = height;\n        this.bgcanvas.width = this.canvas.width;\n        this.bgcanvas.height = this.canvas.height;\n        this.setDirty(true, true);\n    }\n\n    /**\n     * switches to live mode (node shapes are not rendered, only the content)\n     * this feature was designed when graphs where meant to create user interfaces\n     * @method switchLiveMode\n     * @memberOf LGraphCanvas\n     * */\n    switchLiveMode(transition) {\n        if (!transition) {\n            this.live_mode = !this.live_mode;\n            this.dirty_canvas = true;\n            this.dirty_bgcanvas = true;\n            return;\n        }\n\n        const delta = this.live_mode ? 1.1 : 0.9;\n        if (this.live_mode) {\n            this.live_mode = false;\n            this.editor_alpha = 0.1;\n        }\n\n        const t = setInterval(() => {\n            this.editor_alpha *= delta;\n            this.dirty_canvas = true;\n            this.dirty_bgcanvas = true;\n\n            if (delta < 1 && this.editor_alpha < 0.01) {\n                clearInterval(t);\n                if (delta < 1) {\n                    this.live_mode = true;\n                }\n            }\n            if (delta > 1 && this.editor_alpha > 0.99) {\n                clearInterval(t);\n                this.editor_alpha = 1;\n            }\n        }, 1);\n    }\n\n    /**\n     * @method onNodeSelectionChange\n     * @param node\n     * @todo Need create event\n     * @memberOf LGraphCanvas\n     */\n    onNodeSelectionChange(node) {\n        // disabled\n    }\n\n    /**\n     * @method touchHandler\n     * @param {TouchEvent} event\n     * @memberOf LGraphCanvas\n     */\n    touchHandler(event) {\n        // alert(\"foo\");\n        const touches = event.changedTouches;\n        const first = touches[0];\n        let type = \"\";\n\n        switch (event.type) {\n            case \"touchstart\":\n                type = \"mousedown\";\n                break;\n            case \"touchmove\":\n                type = \"mousemove\";\n                break;\n            case \"touchend\":\n                type = \"mouseup\";\n                break;\n            default:\n                return;\n        }\n\n        // initMouseEvent(type, canBubble, cancelable, view, clickCount,\n        //           screenX, screenY, clientX, clientY, ctrlKey,\n        //           altKey, shiftKey, metaKey, button, relatedTarget);\n\n        const window = this.getCanvasWindow();\n        const { document } = window;\n\n        const simulatedEvent = document.createEvent(\"MouseEvent\");\n        simulatedEvent.initMouseEvent(\n            type,\n            true,\n            true,\n            window,\n            1,\n            first.screenX,\n            first.screenY,\n            first.clientX,\n            first.clientY,\n            false,\n            false,\n            false,\n            false,\n            0 /* left */,\n            null,\n        );\n        first.target.dispatchEvent(simulatedEvent);\n        event.preventDefault();\n    }\n\n    /**\n     * @method onGroupAdd\n     * @param info\n     * @param entry\n     * @param {MouseEvent} mouseEvent\n     * @memberOf LGraphCanvas\n     */\n    static onGroupAdd(info, entry, mouseEvent) {\n        const canvas = LGraphCanvas.active_canvas;\n\n        const group = new LGraphGroup();\n        group.pos = canvas.convertEventToCanvasOffset(mouseEvent);\n        canvas.graph.add(group);\n    }\n\n    static onMenuAdd(node, options, e, previousMenu, callback) {\n        const canvas = LGraphCanvas.active_canvas;\n        const refWindow = canvas.getCanvasWindow();\n        const { graph } = canvas;\n        if (!graph) return;\n\n        function inner_onMenuAdded(base_category, prev_menu) {\n            const categories = registry.getNodeTypesCategories(canvas.filter || graph.filter)\n                .filter((category) => category.startsWith(base_category));\n            const entries = [];\n\n            categories.forEach((category) => {\n                if (!category) {\n                    return;\n                }\n\n                const base_category_regex = new RegExp(`^(${base_category})`);\n                const category_name = category.replace(base_category_regex, \"\").split(\"/\")[0];\n                const category_path = base_category === \"\" ? `${category_name}/` : `${base_category + category_name}/`;\n\n                let name = category_name;\n                if (name.indexOf(\"::\") != -1) {\n                    name = name.split(\"::\")[1];\n                }\n\n                const index = entries.findIndex((entry) => entry.value === category_path);\n                if (index === -1) {\n                    entries.push({\n                        value: category_path,\n                        content: name,\n                        has_submenu: true,\n                        callback(value, event, mouseEvent, contextMenu) {\n                            inner_onMenuAdded(value.value, contextMenu);\n                        },\n                    });\n                }\n            });\n\n            const nodes = registry.getNodeTypesInCategory(base_category.slice(0, -1), canvas.filter || graph.filter);\n            nodes.forEach((node) => {\n                if (node.skip_list) return;\n\n                const entry = {\n                    value: node.type,\n                    content: node.title,\n                    has_submenu: false,\n                    callback(value, event, mouseEvent, contextMenu) {\n                        const first_event = contextMenu.getFirstEvent();\n                        canvas.graph.beforeChange();\n                        const node = LGraphNode.createNode(value.value);\n                        if (node) {\n                            node.pos = canvas.convertEventToCanvasOffset(first_event);\n                            canvas.graph.add(node);\n                        }\n                        if (callback) callback(node);\n                        canvas.graph.afterChange();\n                    },\n                };\n\n                entries.push(entry);\n            });\n\n            new ContextMenu(entries, {\n                event: e,\n                parentMenu: prev_menu,\n            }, refWindow);\n        }\n\n        inner_onMenuAdded(\"\", previousMenu);\n        return false;\n    }\n\n    /**\n     * @method onMenuCollapseAll\n     * @todo Need create event\n     * @memberOf LGraphCanvas\n     */\n    static onMenuCollapseAll() {\n    }\n\n    /**\n     * @method onMenuNodeEdit\n     * @todo Need create event\n     * @memberOf LGraphCanvas\n     */\n    static onMenuNodeEdit() {\n    }\n\n    static showMenuNodeOptionalInputs(v, optionsParam, e, previousMenu, node) {\n        if (!node) return;\n\n        const that = this;\n        const canvas = LGraphCanvas.active_canvas;\n        const refWindow = canvas.getCanvasWindow();\n\n        let options = node.optional_inputs;\n        if (node.onGetInputs) options = node.onGetInputs();\n\n        let entries = [];\n        if (options) {\n            for (const entry of options) {\n                if (!entry) {\n                    entries.push(null);\n                    continue;\n                }\n                let label = entry[0];\n                if (entry[2] && entry[2].label) {\n                    label = entry[2].label;\n                }\n                const data = {\n                    content: label,\n                    value: entry,\n                };\n                if (entry[1] === defaultConfig.ACTION) {\n                    data.className = \"event\";\n                }\n                entries.push(data);\n            }\n        }\n\n        if (this.onMenuNodeInputs) entries = this.onMenuNodeInputs(entries);\n\n        if (!entries.length) {\n            console.log(\"no input entries\");\n            return;\n        }\n\n        const menu = new ContextMenu(\n            entries,\n            {\n                event: e,\n                callback: innerClicked,\n                parentMenu: previousMenu,\n                node,\n            },\n            refWindow,\n        );\n\n        function innerClicked(v, e, prev) {\n            if (!node) {\n                return;\n            }\n\n            if (v.callback) {\n                v.callback.call(that, node, v, e, prev);\n            }\n\n            if (v.value) {\n                node.graph.beforeChange();\n                node.addInput(v.value[0], v.value[1], v.value[2]);\n                node.setDirtyCanvas(true, true);\n                node.graph.afterChange();\n            }\n        }\n\n        return false;\n    }\n\n    static showMenuNodeOptionalOutputs(v, optionsParam, e, previousMenu, node) {\n        if (!node) return;\n\n        const that = this;\n        const canvas = LGraphCanvas.active_canvas;\n        const refWindow = canvas.getCanvasWindow();\n\n        let options = node.optional_outputs;\n        if (node.onGetOutputs) {\n            options = node.onGetOutputs();\n        }\n\n        let entries = [];\n        if (options) {\n            for (const entry of options) {\n                if (!entry) {\n                    // separator?\n                    entries.push(null);\n                    continue;\n                }\n\n                if (node.flags\n                    && node.flags.skip_repeated_outputs\n                    && node.findOutputSlot(entry[0]) !== -1) {\n                    continue;\n                } // skip the ones already on\n                let label = entry[0];\n                if (entry[2] && entry[2].label) label = entry[2].label;\n                const data = {\n                    content: label,\n                    value: entry,\n                };\n                if (entry[1] === defaultConfig.EVENT) data.className = \"event\";\n                entries.push(data);\n            }\n        }\n\n        if (this.onMenuNodeOutputs) entries = this.onMenuNodeOutputs(entries);\n\n        if (!entries.length) return;\n\n        const menu = new ContextMenu(\n            entries,\n            {\n                event: e,\n                callback: innerClicked,\n                parentMenu: previousMenu,\n                node,\n            },\n            refWindow,\n        );\n\n        function innerClicked(v, e, prev) {\n            if (!node) return;\n\n            if (v.callback) v.callback.call(that, node, v, e, prev);\n\n            if (!v.value) {\n                return;\n            }\n\n            const value = v.value[1];\n\n            if (\n                value\n                && (value.constructor === Object || value.constructor === Array)\n            ) {\n                // submenu why?\n                const entries = [];\n                for (const i in value) {\n                    entries.push({\n                        content: i,\n                        value: value[i],\n                    });\n                }\n                new ContextMenu(entries, {\n                    event: e,\n                    callback: innerClicked,\n                    parentMenu: previousMenu,\n                    node,\n                });\n                return false;\n            }\n            node.graph.beforeChange();\n            node.addOutput(v.value[0], v.value[1], v.value[2]);\n            node.setDirtyCanvas(true, true);\n            node.graph.afterChange();\n        }\n\n        return false;\n    }\n\n    static onShowMenuNodeProperties(value, options, e, previousMenu, node) {\n        if (!node || !node.properties) {\n            return;\n        }\n\n        const canvas = LGraphCanvas.active_canvas;\n        const refWindow = canvas.getCanvasWindow();\n\n        const entries = [];\n        // eslint-disable-next-line\n        for (const i in node.properties) {\n            let value = node.properties[i] ? node.properties[i] : \" \";\n            if (typeof value === \"object\") value = JSON.stringify(value);\n            const info = node.getPropertyInfo(i);\n            if (info.type == \"enum\" || info.type == \"combo\") value = LGraphCanvas.getPropertyPrintableValue(value, info.values);\n\n            // value could contain invalid html characters, clean that\n            value = LGraphCanvas.decodeHTML(value);\n            entries.push({\n                content:\n                    `<span class=\"property_name\">${\n                        info.label ? info.label : i\n                    }</span>`\n                    + `<span class=\"property_value\">${\n                        value\n                    }</span>`,\n                value: i,\n            });\n        }\n        if (!entries.length) {\n            return;\n        }\n\n        const menu = new ContextMenu(\n            entries,\n            {\n                event: e,\n                callback: innerClicked,\n                parentMenu: previousMenu,\n                allow_html: true,\n                node,\n            },\n            refWindow,\n        );\n\n        function innerClicked(v) {\n            if (!node) {\n                return;\n            }\n            const rect = this.getBoundingClientRect();\n            canvas.showEditPropertyValue(node, v.value, {\n                position: [rect.left, rect.top],\n            });\n        }\n\n        return false;\n    }\n\n    static decodeHTML(str) {\n        const e = document.createElement(\"div\");\n        e.innerText = str;\n        return e.innerHTML;\n    }\n\n    static onResizeNode(value, options, e, menu, node) {\n        if (!node) return;\n        node.size = node.computeSize();\n        if (node.onResize) node.onResize(node.size);\n        node.setDirtyCanvas(true, true);\n    }\n\n    showLinkMenu(link, e) {\n        const that = this;\n        const options = [\"Add Node\", null, \"Delete\"];\n        const menu = new ContextMenu(options, {\n            event: e,\n            title: link.data != null ? link.data.constructor.name : null,\n            callback: innerClicked,\n        });\n\n        function innerClicked(v, options, e) {\n            switch (v) {\n                case \"Add Node\":\n                    LGraphCanvas.onMenuAdd(null, null, e, menu, (node) => {\n                        console.log(\"node autoconnect\");\n                        const nodeLeft = that.graph.getNodeById(link.origin_id);\n                        const nodeRight = that.graph.getNodeById(link.target_id);\n                        if (!node.inputs\n                            || !node.inputs.length\n                            || !node.outputs\n                            || !node.outputs.length) return;\n                        if (nodeLeft.outputs[link.origin_slot].type === node.inputs[0].type && node.outputs[0].type === nodeRight.inputs[0].type) {\n                            nodeLeft.connect(link.origin_slot, node, 0);\n                            node.connect(0, nodeRight, link.target_slot);\n                            node.pos[0] -= node.size[0] * 0.5;\n                        }\n                    });\n                    break;\n                case \"Delete\":\n                    that.graph.removeLink(link.id);\n                    break;\n                default:\n            }\n        }\n\n        return false;\n    }\n\n    static onShowPropertyEditor(item, options, e, menu, node) {\n        const property = item.property || \"title\";\n        const value = node[property];\n\n        const dialog = document.createElement(\"div\");\n        dialog.className = \"graphdialog\";\n        dialog.innerHTML = \"<span class='name'></span><input autofocus type='text' class='value'/><button>OK</button>\";\n\n        const title = dialog.querySelector(\".name\");\n        title.innerText = property;\n\n        const input = dialog.querySelector(\".value\");\n        if (input) {\n            input.value = value;\n            input.addEventListener(\"blur\", (e) => {\n                input.focus();\n            });\n            input.addEventListener(\"keydown\", (e) => {\n                if (e.keyCode !== 13 && e.target.localName !== \"textarea\") return;\n                setValue(input.value);\n                e.preventDefault();\n                e.stopPropagation();\n            });\n        }\n\n        const graphcanvas = LGraphCanvas.active_canvas;\n        const { canvas } = graphcanvas;\n\n        const rect = canvas.getBoundingClientRect();\n        let offsetx = -20;\n        let offsety = -20;\n        if (rect) {\n            offsetx -= rect.left;\n            offsety -= rect.top;\n        }\n\n        if (e) {\n            dialog.style.left = `${e.clientX + offsetx}px`;\n            dialog.style.top = `${e.clientY + offsety}px`;\n        } else {\n            dialog.style.left = `${canvas.width * 0.5 + offsetx}px`;\n            dialog.style.top = `${canvas.height * 0.5 + offsety}px`;\n        }\n\n        const button = dialog.querySelector(\"button\");\n        button.addEventListener(\"click\", () => setValue(input.value));\n        canvas.parentNode.appendChild(dialog);\n\n        function setValue(value) {\n            if (item.type === \"Number\") {\n                value = Number(value);\n            } else if (item.type === \"Boolean\") {\n                value = Boolean(value);\n            }\n            node[property] = value;\n            if (dialog.parentNode) {\n                dialog.remove();\n            }\n            node.setDirtyCanvas(true, true);\n        }\n    }\n\n    prompt(title = \"\", value, callback, event, multiline) {\n        const that = this;\n\n        let modified = false;\n\n        const dialog = document.createElement(\"div\");\n        dialog.className = \"graphdialog rounded\";\n        if (multiline) {\n            dialog.innerHTML = \"<span class='name'></span> <textarea autofocus class='value'></textarea><button class='rounded'>OK</button>\";\n        } else {\n            dialog.innerHTML = \"<span class='name'></span> <input autofocus type='text' class='value'/><button class='rounded'>OK</button>\";\n        }\n        dialog.close = () => {\n            this.prompt_box = null;\n            if (dialog.parentNode) dialog.remove();\n        };\n\n        if (this.ds.scale > 1) {\n            dialog.style.transform = `scale(${this.ds.scale})`;\n        }\n\n        dialog.addEventListener(\"mouseleave\", (e) => {\n            if (!modified) dialog.close();\n        });\n\n        if (this.prompt_box) {\n            this.prompt_box.close();\n        }\n        this.prompt_box = dialog;\n\n        const first = null;\n        const timeout = null;\n        const selected = null;\n\n        const nameElement = dialog.querySelector(\".name\");\n        nameElement.innerText = title;\n        const valueElement = dialog.querySelector(\".value\");\n        valueElement.value = value;\n\n        const input = valueElement;\n        input.addEventListener(\"keydown\", (e) => {\n            modified = true;\n            if (e.keyCode === 27) dialog.close();\n            else if (e.keyCode === 13 && e.target.localName !== \"textarea\") {\n                if (callback) {\n                    callback(input.value);\n                }\n                dialog.close();\n            } else {\n                return;\n            }\n            e.preventDefault();\n            e.stopPropagation();\n        });\n\n        const button = dialog.querySelector(\"button\");\n        button.addEventListener(\"click\", () => {\n            if (callback) callback(input.value);\n            this.setDirty(true);\n            dialog.close();\n        });\n\n        const graphcanvas = LGraphCanvas.active_canvas;\n        const { canvas } = graphcanvas;\n\n        const rect = canvas.getBoundingClientRect();\n        let offsetx = -20;\n        let offsety = -20;\n        if (rect) {\n            offsetx -= rect.left;\n            offsety -= rect.top;\n        }\n\n        if (event) {\n            dialog.style.left = `${event.clientX + offsetx}px`;\n            dialog.style.top = `${event.clientY + offsety}px`;\n        } else {\n            dialog.style.left = `${canvas.width * 0.5 + offsetx}px`;\n            dialog.style.top = `${canvas.height * 0.5 + offsety}px`;\n        }\n\n        canvas.parentNode.appendChild(dialog);\n        setTimeout(() => input.focus(), 10);\n\n        return dialog;\n    }\n\n    static search_limit = -1\n\n    showSearchBox = function (event) {\n        const that = this;\n        const graphcanvas = LGraphCanvas.active_canvas;\n        const { canvas } = graphcanvas;\n        const rootDocument = canvas.ownerDocument || document;\n\n        const dialog = document.createElement(\"div\");\n        dialog.className = \"litegraph litesearchbox graphdialog rounded\";\n        dialog.innerHTML = \"<span class='name'>Search</span> <input autofocus type='text' class='value rounded'/><div class='helper'></div>\";\n        dialog.close = () => {\n            this.search_box = null;\n            rootDocument.body.focus();\n            rootDocument.body.style.overflow = \"\";\n\n            setTimeout(() => {\n                this.canvas.focus();\n            }, 20); // important, if canvas loses focus keys wont be captured\n            if (dialog.parentNode) {\n                dialog.remove();\n            }\n        };\n\n        let timeoutClose = null;\n\n        if (this.ds.scale > 1) dialog.style.transform = `scale(${this.ds.scale})`;\n\n        dialog.addEventListener(\"mouseenter\", () => {\n            if (timeoutClose) {\n                clearTimeout(timeoutClose);\n                timeoutClose = null;\n            }\n        });\n\n        dialog.addEventListener(\"mouseleave\", () => {\n            // dialog.close();\n            timeoutClose = setTimeout(() => dialog.close(), 500);\n        });\n\n        if (this.search_box) this.search_box.close();\n        this.search_box = dialog;\n\n        const helper = dialog.querySelector(\".helper\");\n\n        let first = null;\n        let timeout = null;\n        let selected = null;\n\n        const input = dialog.querySelector(\"input\");\n        if (input) {\n            input.addEventListener(\"blur\", () => input.focus());\n            input.addEventListener(\"keydown\", (e) => {\n                if (e.keyCode === 38) {\n                    // UP\n                    changeSelection(false);\n                } else if (e.keyCode === 40) {\n                    // DOWN\n                    changeSelection(true);\n                } else if (e.keyCode === 27) {\n                    // ESC\n                    dialog.close();\n                } else if (e.keyCode === 13) {\n                    if (selected) {\n                        select(selected.innerHTML);\n                    } else if (first) {\n                        select(first);\n                    } else {\n                        dialog.close();\n                    }\n                } else {\n                    if (timeout) {\n                        clearInterval(timeout);\n                    }\n                    timeout = setTimeout(refreshHelper, 10);\n                    return;\n                }\n                e.preventDefault();\n                e.stopPropagation();\n                e.stopImmediatePropagation();\n                return true;\n            });\n        }\n\n        if (rootDocument.fullscreenElement) rootDocument.fullscreenElement.appendChild(dialog);\n        else {\n            rootDocument.body.appendChild(dialog);\n            rootDocument.body.style.overflow = \"hidden\";\n        }\n\n        // compute best position\n        const rect = canvas.getBoundingClientRect();\n\n        const left = (event ? event.clientX : (rect.left + rect.width * 0.5)) - 80;\n        const top = (event ? event.clientY : (rect.top + rect.height * 0.5)) - 20;\n        dialog.style.left = `${left}px`;\n        dialog.style.top = `${top}px`;\n\n        // To avoid out of screen problems\n        if (event.layerY > (rect.height - 200)) {\n            helper.style.maxHeight = `${rect.height - event.layerY - 20}px`;\n        }\n\n        input.focus();\n\n        function select(name) {\n            if (name) {\n                if (that.onSearchBoxSelection) {\n                    that.onSearchBoxSelection(name, event, graphcanvas);\n                } else {\n                    const extra = defaultConfig.searchbox_extras[name.toLowerCase()];\n                    if (extra) {\n                        name = extra.type;\n                    }\n\n                    graphcanvas.graph.beforeChange();\n                    const node = LGraphNode.createNode(name);\n                    if (node) {\n                        node.pos = graphcanvas.convertEventToCanvasOffset(\n                            event,\n                        );\n                        graphcanvas.graph.add(node);\n                    }\n\n                    if (extra && extra.data) {\n                        if (extra.data.properties) {\n                            // eslint-disable-next-line\n                            for (const i in extra.data.properties) {\n                                node.addProperty(i, extra.data.properties[i]);\n                            }\n                        }\n                        if (extra.data.inputs) {\n                            node.inputs = [];\n                            // eslint-disable-next-line\n                            for (const i in extra.data.inputs) {\n                                node.addOutput(\n                                    extra.data.inputs[i][0],\n                                    extra.data.inputs[i][1],\n                                );\n                            }\n                        }\n                        if (extra.data.outputs) {\n                            node.outputs = [];\n                            // eslint-disable-next-line\n                            for (const i in extra.data.outputs) {\n                                node.addOutput(\n                                    extra.data.outputs[i][0],\n                                    extra.data.outputs[i][1],\n                                );\n                            }\n                        }\n                        if (extra.data.title) node.title = extra.data.title;\n                        if (extra.data.json) node.configure(extra.data.json);\n\n                        graphcanvas.graph.afterChange();\n                    }\n                }\n            }\n\n            dialog.close();\n        }\n\n        function changeSelection(forward) {\n            const prev = selected;\n            if (selected) selected.classList.remove(\"selected\");\n            if (!selected) {\n                selected = forward\n                    ? helper.childNodes[0]\n                    : helper.childNodes[helper.childNodes.length];\n            } else {\n                selected = forward\n                    ? selected.nextSibling\n                    : selected.previousSibling;\n                if (!selected) selected = prev;\n            }\n            if (!selected) return;\n            selected.classList.add(\"selected\");\n            selected.scrollIntoView({\n                block: \"end\",\n                behavior: \"smooth\",\n            });\n        }\n\n        function refreshHelper() {\n            timeout = null;\n            let str = input.value;\n            first = null;\n            helper.innerHTML = \"\";\n            if (!str) return;\n\n            if (that.onSearchBox) {\n                const list = that.onSearchBox(helper, str, graphcanvas);\n                if (list) {\n                    for (const l of list) addResult(l);\n                }\n            } else {\n                let c = 0;\n                str = str.toLowerCase();\n                const filter = graphcanvas.filter || graphcanvas.graph.filter;\n\n                // extras\n                // eslint-disable-next-line\n                for (const i in defaultConfig.searchbox_extras) {\n                    const extra = defaultConfig.searchbox_extras[i];\n                    if (extra.desc.toLowerCase().indexOf(str) === -1) {\n                        continue;\n                    }\n                    const ctor = defaultConfig.registered_node_types[extra.type];\n                    if (ctor && ctor.filter !== filter) continue;\n                    addResult(extra.desc, \"searchbox_extra\");\n                    if (LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit) {\n                        break;\n                    }\n                }\n\n                const keys = Object.keys(defaultConfig.registered_node_types); // types\n                const filtered = keys.filter((type) => {\n                    const ctor = defaultConfig.registered_node_types[type];\n                    if (filter && ctor.filter !== filter) return false;\n                    return type.toLowerCase().indexOf(str) !== -1;\n                });\n\n                for (const filteredItem of filtered) {\n                    addResult(filteredItem);\n                    if (LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit) {\n                        break;\n                    }\n                }\n            }\n\n            function addResult(type, className) {\n                const help = document.createElement(\"div\");\n                if (!first) first = type;\n                help.innerText = type;\n                help.dataset.type = escape(type);\n                help.className = \"litegraph lite-search-item\";\n                if (className) help.className += ` ${className}`;\n                help.addEventListener(\"click\", () => {\n                    select(unescape(help.dataset.type));\n                });\n                helper.appendChild(help);\n            }\n        }\n\n        return dialog;\n    }\n\n    showEditPropertyValue(node, property, options = {}) {\n        if (!node || node.properties[property] === undefined) return;\n\n        const info = node.getPropertyInfo(property);\n        const { type } = info;\n\n        let inputHTML = \"\";\n\n        if ([\"sring\", \"number\", \"array\", \"object\"].includes(type)) {\n            inputHTML = \"<input autofocus type='text' class='value'/>\";\n        } else if ([\"enum\", \"combo\"].includes(type) && info.values) {\n            inputHTML = \"<select autofocus type='text' class='value'>\";\n            // eslint-disable-next-line\n            for (const i in info.values) {\n                let value = i;\n                if (info.values.constructor === Array) value = info.values[i];\n\n                inputHTML += `<option value=\"${value}\" ${value == node.properties[property] ? \"selected\" : \"\"}>${info.values[i]}</option>`;\n            }\n            inputHTML += \"</select>\";\n        } else if (type === \"boolean\") {\n            inputHTML = `<input autofocus type=\"checkbox\" class=\"value\" ${\n                node.properties[property] ? \"checked\" : \"\"\n            }/>`;\n        } else {\n            console.warn(`unknown type: ${type}`);\n            return;\n        }\n\n        const dialog = this.createDialog(\n            `<span class=\"name\">${\n                info.label ? info.label : property\n            }</span>${\n                inputHTML\n            }<button>OK</button>`,\n            options,\n        );\n\n        if ([\"enum\", \"combo\"].includes(type) && info.values) {\n            const input = dialog.querySelector(\"select\");\n            input.addEventListener(\"change\", (e) => {\n                setValue(e.target.value);\n            });\n        } else if (type === \"boolean\") {\n            const input = dialog.querySelector(\"input\");\n            if (input) {\n                input.addEventListener(\"click\", () => setValue(!!input.checked));\n            }\n        } else {\n            const input = dialog.querySelector(\"input\");\n            if (input) {\n                input.addEventListener(\"blur\", () => { input.focus(); });\n\n                let v = node.properties[property] ? node.properties[property] : \"\";\n                if (type !== \"string\") {\n                    v = JSON.stringify(v);\n                }\n\n                input.value = v;\n                input.addEventListener(\"keydown\", (e) => {\n                    if (e.keyCode != 13) return;\n                    setValue(input.value);\n                    e.preventDefault();\n                    e.stopPropagation();\n                });\n            }\n        }\n\n        const button = dialog.querySelector(\"button\");\n        button.addEventListener(\"click\", () => setValue(input.value));\n        function setValue(value) {\n            if (info\n                && info.values\n                && info.values.constructor === Object\n                && info.values[value]) value = info.values[value];\n\n            if (typeof node.properties[property] === \"number\") {\n                value = Number(value);\n            }\n            if ([\"array\", \"object\"].includes(type)) {\n                value = JSON.parse(value);\n            }\n            node.properties[property] = value;\n            if (node.graph) {\n                node.graph._version++;\n            }\n            if (node.onPropertyChanged) {\n                node.onPropertyChanged(property, value);\n            }\n            if (options.onclose) options.onclose();\n            dialog.close();\n            node.setDirtyCanvas(true, true);\n        }\n\n        return dialog;\n    }\n\n    createDialog(html, options = {}) {\n        const dialog = document.createElement(\"div\");\n        dialog.className = \"graphdialog\";\n        dialog.innerHTML = html;\n\n        const rect = this.canvas.getBoundingClientRect();\n        let offsetx = -20;\n        let offsety = -20;\n        if (rect) {\n            offsetx -= rect.left;\n            offsety -= rect.top;\n        }\n\n        if (options.position) {\n            offsetx += options.position[0];\n            offsety += options.position[1];\n        } else if (options.event) {\n            offsetx += options.event.clientX;\n            offsety += options.event.clientY;\n        } // centered\n        else {\n            offsetx += this.canvas.width * 0.5;\n            offsety += this.canvas.height * 0.5;\n        }\n\n        dialog.style.left = `${offsetx}px`;\n        dialog.style.top = `${offsety}px`;\n\n        this.canvas.parentNode.appendChild(dialog);\n\n        dialog.close = () => {\n            if (dialog.parentNode) dialog.remove();\n        };\n\n        return dialog;\n    }\n\n    createPanel(title, options = {}) {\n        const refWindow = options.window || window;\n\n        const root = document.createElement(\"div\");\n        root.className = \"litegraph dialog\";\n        root.innerHTML = \"<div class='dialog-header'><span class='dialog-title'></span></div><div class='dialog-content'></div><div class='dialog-footer'></div>\";\n        root.header = root.querySelector(\".dialog-header\");\n\n        if (options.width) root.style.width = options.width + (options.width.constructor === Number ? \"px\" : \"\");\n        if (options.height) root.style.height = options.height + (options.height.constructor === Number ? \"px\" : \"\");\n        if (options.closable) {\n            const close = document.createElement(\"span\");\n            close.innerHTML = \"&#10005;\";\n            close.classList.add(\"close\");\n            close.addEventListener(\"click\", () => root.close());\n            root.header.appendChild(close);\n        }\n        root.title_element = root.querySelector(\".dialog-title\");\n        root.title_element.innerText = title;\n        root.content = root.querySelector(\".dialog-content\");\n        root.footer = root.querySelector(\".dialog-footer\");\n\n        root.close = () => root.remove();\n\n        root.clear = () => root.content.innerHTML = \"\";\n\n        root.addHTML = (code, classname, onFooter) => {\n            const elem = document.createElement(\"div\");\n            if (classname) elem.className = classname;\n            elem.innerHTML = code;\n            if (onFooter) root.footer.appendChild(elem);\n            else root.content.appendChild(elem);\n            return elem;\n        };\n\n        root.addButton = (name, callback, options) => {\n            const elem = document.createElement(\"button\");\n            elem.innerText = name;\n            elem.options = options;\n            elem.classList.add(\"btn\");\n            elem.addEventListener(\"click\", callback);\n            root.footer.appendChild(elem);\n            return elem;\n        };\n\n        root.addSeparator = () => {\n            const elem = document.createElement(\"div\");\n            elem.className = \"separator\";\n            root.content.appendChild(elem);\n        };\n\n        root.addWidget = (type, name, value, options = {}, callback) => {\n            type = type.toLowerCase();\n            value = String(value);\n            let strValue = type === \"number\" ? new Number(value).toFixed(3) : value.toString();\n            const elem = document.createElement(\"div\");\n            elem.className = \"property\";\n            elem.innerHTML = \"<span class='property_name'></span><span class='property_value'></span>\";\n            elem.querySelector(\".property_name\").innerText = name;\n            const valueElement = elem.querySelector(\".property_value\");\n            valueElement.innerText = strValue;\n            elem.dataset.property = name;\n            elem.dataset.type = options.type || type;\n            elem.options = options;\n            elem.value = strValue;\n\n            if (type === \"boolean\") {\n                elem.classList.add(\"boolean\");\n                if (value) elem.classList.add(\"bool-on\");\n                elem.addEventListener(\"click\", () => {\n                    // var v = node.properties[this.dataset[\"property\"]];\n                    // node.setProperty(this.dataset[\"property\"],!v); this.innerText = v ? \"true\" :\n                    // \"false\";\n                    const propname = elem.dataset.property;\n                    this.value = !elem.value;\n                    this.classList.toggle(\"bool-on\");\n                    this.querySelector(\".property_value\").innerText = elem.value ? \"true\" : \"false\";\n                    innerChange(propname, elem.value);\n                });\n            } else if ([\"string\", \"number\"].includes(type)) {\n                valueElement.setAttribute(\"contenteditable\", true);\n                valueElement.addEventListener(\"keydown\", (e) => {\n                    if (e.code === \"Enter\") {\n                        e.preventDefault();\n                        valueElement.blur();\n                    }\n                });\n                valueElement.addEventListener(\"blur\", () => {\n                    let v = valueElement.innerText;\n                    const propname = valueElement.parentNode.dataset.property;\n                    const proptype = valueElement.parentNode.dataset.type;\n                    if (proptype === \"number\") v = Number(v);\n                    innerChange(propname, v);\n                });\n            } else if ([\"enum\", \"combo\"].includes(type)) strValue = LGraphCanvas.getPropertyPrintableValue(value, options.values);\n            valueElement.innerText = strValue;\n\n            valueElement.addEventListener(\"click\", (event) => {\n                const values = options.values || [];\n                const propname = valueElement.parentNode.dataset.property;\n                const menu = new ContextMenu(values, {\n                    event,\n                    className: \"dark\",\n                    callback: (v, option, event) => {\n                        this.innerText = v;\n                        innerChange(propname, v);\n                        return false;\n                    },\n                },\n                refWindow);\n            });\n\n            root.content.appendChild(elem);\n\n            function innerChange(name, value) {\n                console.log(\"change\", name, value);\n                // that.dirty_canvas = true;\n                if (options.callback) options.callback(name, value);\n                if (callback) callback(name, value);\n            }\n\n            return elem;\n        };\n\n        return root;\n    }\n\n    static getPropertyPrintableValue(value, values) {\n        if (!values) return String(value);\n        if (values.constructor === Array) return String(value);\n\n        if (values.constructor === Object) {\n            let desc_value = \"\";\n            for (const k in values) {\n                if (values[k] !== value) continue;\n                desc_value = k;\n                break;\n            }\n            return `${String(value)} (${desc_value})`;\n        }\n    }\n\n    showShowNodePanel = function (node) {\n        window.SELECTED_NODE = node;\n        let panel = document.querySelector(\"#node-panel\");\n        if (panel) panel.close();\n        const refWindow = this.getCanvasWindow();\n        panel = this.createPanel(node.title || \"\", {\n            closable: true,\n            window: refWindow,\n        });\n        panel.id = \"node-panel\";\n        panel.node = node;\n        panel.classList.add(\"settings\");\n        const that = this;\n        const graphcanvas = this;\n\n        const inner_refresh = () => {\n            panel.content.innerHTML = \"\"; // clear\n            panel.addHTML(`<span class=\"node_type\">${node.type}</span><span class=\"node_desc\">${node.constructor.desc || \"\"}</span><span class=\"separator\"></span>`);\n\n            panel.addHTML(\"<h3>Properties</h3>\");\n\n            for (const i in node.properties) {\n                const value = node.properties[i];\n                const info = node.getPropertyInfo(i);\n\n                if (node.onAddPropertyToPanel && node.onAddPropertyToPanel(i, panel)) continue;\n\n                panel.addWidget(info.widget || info.type, i, value, info, (name, value) => {\n                    graphcanvas.graph.beforeChange(node);\n                    node.setProperty(name, value);\n                    graphcanvas.graph.afterChange();\n                    graphcanvas.dirty_canvas = true;\n                });\n            }\n\n            panel.addSeparator();\n\n            if (node.onShowCustomPanelInfo) node.onShowCustomPanelInfo(panel);\n            panel.addButton(\"Delete\", () => {\n                if (node.block_delete) return;\n                node.graph.remove(node);\n                panel.close();\n            })\n                .classList\n                .add(\"delete\");\n        };\n\n        function inner_showCodePad(node, propname) {\n            panel.style.top = \"calc( 50% - 250px)\";\n            panel.style.left = \"calc( 50% - 400px)\";\n            panel.style.width = \"800px\";\n            panel.style.height = \"500px\";\n\n            panel.content.innerHTML = \"<textarea class='code'></textarea>\";\n            const textarea = panel.content.querySelector(\"textarea\");\n            textarea.value = node.properties[propname];\n            textarea.addEventListener(\"keydown\", (e) => {\n                if (e.code === \"Enter\" && e.ctrlKey) {\n                    console.log(\"Assigned\");\n                    node.setProperty(propname, textarea.value);\n                }\n            });\n            textarea.style.height = \"calc(100% - 40px)\";\n\n            const assign = that.createButton(\"Assign\", null, () => {\n                node.setProperty(propname, textarea.value);\n            });\n            panel.content.appendChild(assign);\n            const button = that.createButton(\"Close\", null, () => {\n                panel.style.height = \"\";\n                inner_refresh();\n            });\n            button.style.float = \"right\";\n            panel.content.appendChild(button);\n        }\n\n        inner_refresh();\n\n        this.canvas.parentNode.appendChild(panel);\n    }\n\n    showSubgraphPropertiesDialog(node) {\n        console.log(\"showing subgraph properties dialog\");\n\n        const old_panel = this.canvas.parentNode.querySelector(\".subgraph_dialog\");\n        if (old_panel) old_panel.close();\n\n        const panel = this.createPanel(\"Subgraph Inputs\", {\n            closable: true,\n            width: 500,\n        });\n        panel.node = node;\n        panel.classList.add(\"subgraph_dialog\");\n\n        function inner_refresh() {\n            panel.clear();\n\n            // show currents\n            if (node.inputs) {\n                for (const input of node.inputs) {\n                    if (input.not_subgraph_input) continue;\n                    const html = \"<button>&#10005;</button> <span class='bullet_icon'></span><span class='name'></span><span class='type'></span>\";\n                    const elem = panel.addHTML(html, \"subgraph_property\");\n                    elem.dataset.name = input.name;\n                    elem.dataset.slot = i;\n                    elem.querySelector(\".name\").innerText = input.name;\n                    elem.querySelector(\".type\").innerText = input.type;\n                    elem.querySelector(\"button\")\n                        .addEventListener(\"click\", () => {\n                            node.removeInput(Number(elem.parentNode.dataset.slot));\n                            inner_refresh();\n                        });\n                }\n            }\n        }\n\n        // add extra\n        const html = \" + <span class='label'>Name</span><input class='name'/><span class='label'>Type</span><input class='type'/><button>+</button>\";\n        const elem = panel.addHTML(html, \"subgraph_property extra\", true);\n        elem.querySelector(\"button\")\n            .addEventListener(\"click\", function (e) {\n                const elem = this.parentNode;\n                const name = elem.querySelector(\".name\").value;\n                const type = elem.querySelector(\".type\").value;\n                if (!name || node.findInputSlot(name) !== -1) return;\n                node.addInput(name, type);\n                elem.querySelector(\".name\").value = \"\";\n                elem.querySelector(\".type\").value = \"\";\n                inner_refresh();\n            });\n\n        inner_refresh();\n        this.canvas.parentNode.appendChild(panel);\n        return panel;\n    }\n\n    checkPanels() {\n        if (!this.canvas) return;\n        const panels = this.canvas.parentNode.querySelectorAll(\".litegraph.dialog\");\n        for (const panel of panels) {\n            if (!panel.node) continue;\n            if (!panel.node.graph || panel.graph !== this.graph) panel.close();\n        }\n    }\n\n    static onMenuNodeCollapse(value, options, e, menu, node) {\n        node.graph.beforeChange(node);\n        node.collapse();\n        node.graph.afterChange(node);\n    }\n\n    static onMenuNodePin(value, options, e, menu, node) {\n        node.pin();\n    }\n\n    static onMenuNodeMode = function (value, options, e, menu, node) {\n        new ContextMenu(\n            [\"Always\", \"On Event\", \"On Trigger\", \"Never\"],\n            {\n                event: e,\n                callback: (v) => {\n                    if (!node) {\n                        return;\n                    }\n                    switch (v) {\n                        case \"On Event\":\n                            node.mode = defaultConfig.ON_EVENT;\n                            break;\n                        case \"On Trigger\":\n                            node.mode = defaultConfig.ON_TRIGGER;\n                            break;\n                        case \"Never\":\n                            node.mode = defaultConfig.NEVER;\n                            break;\n                        case \"Always\":\n                        default:\n                            node.mode = defaultConfig.ALWAYS;\n                            break;\n                    }\n                },\n                parentMenu: menu,\n                node,\n            },\n        );\n        return false;\n    }\n\n    static onMenuNodeColors(value, options, e, menu, node) {\n        if (!node) throw new Error(\"no node for color\");\n        const values = [];\n        values.push({\n            value: null,\n            content:\n                \"<span style='display: block; padding-left: 4px;'>No color</span>\",\n        });\n\n        // eslint-disable-next-line\n        for (const i in LGraphCanvas.node_colors) {\n            const color = LGraphCanvas.node_colors[i];\n            values.push({\n                value: i,\n                content: `<span style=\"display: block; color: #999; padding-left: 4px; border-left: 8px solid ${color.color}; background-color:${color.bgcolor}\">${i}</span>`,\n            });\n        }\n        new ContextMenu(values, {\n            event: e,\n            callback: (v) => {\n                if (!node) {\n                    return;\n                }\n\n                const color = v.value ? LGraphCanvas.node_colors[v.value] : null;\n                if (color) {\n                    if (node.constructor.name === \"LGraphGroup\") {\n                        node.color = color.groupcolor;\n                    } else {\n                        node.color = color.color;\n                        node.bgcolor = color.bgcolor;\n                    }\n                } else {\n                    delete node.color;\n                    delete node.bgcolor;\n                }\n                node.setDirtyCanvas(true, true);\n            },\n            parentMenu: menu,\n            node,\n        });\n\n        return false;\n    }\n\n    static onMenuNodeShapes(value, options, e, menu, node) {\n        if (!node) {\n            throw new Error(\"no node passed\");\n        }\n\n        new ContextMenu(defaultConfig.VALID_SHAPES, {\n            event: e,\n            callback: (v) => {\n                if (!node) return;\n                node.graph.beforeChange(node);\n                node.shape = v;\n                node.graph.afterChange(node);\n                node.setDirtyCanvas(true);\n            },\n        }, {\n            parentMenu: menu,\n            node,\n        });\n\n        return false;\n    }\n\n    static onMenuNodeRemove(value, options, e, menu, node) {\n        if (!node) throw new Error(\"no node passed\");\n        if (node.removable === false) return;\n\n        const { graph } = node;\n        graph.beforeChange();\n        graph.remove(node);\n        graph.afterChange();\n        node.setDirtyCanvas(true, true);\n    }\n\n    static onMenuNodeToSubgraph(value, options, e, menu, node) {\n        const { graph } = node;\n        const graphcanvas = LGraphCanvas.active_canvas;\n        if (!graphcanvas) return;\n\n        let nodesList = Object.values(graphcanvas.selected_nodes || {});\n        if (!nodesList.length) nodesList = [node];\n\n        const subgraphNode = LGraphNode.createNode(\"graph/subgraph\");\n        subgraphNode.pos = node.pos.concat();\n        graph.add(subgraphNode);\n\n        subgraphNode.buildFromNodes(nodesList);\n\n        graphcanvas.deselectAllNodes();\n        node.setDirtyCanvas(true, true);\n    }\n\n    static onMenuNodeClone(value, options, e, menu, node) {\n        if (node.clonable === false) return;\n        const newnode = node.clone();\n        if (!newnode) return;\n        newnode.pos = [node.pos[0] + 5, node.pos[1] + 5];\n\n        node.graph.beforeChange();\n        node.graph.add(newnode);\n        node.graph.afterChange();\n\n        node.setDirtyCanvas(true, true);\n    }\n\n    static node_colors = {\n        red: {\n            color: \"#322\",\n            bgcolor: \"#533\",\n            groupcolor: \"#A88\",\n        },\n        brown: {\n            color: \"#332922\",\n            bgcolor: \"#593930\",\n            groupcolor: \"#b06634\",\n        },\n        green: {\n            color: \"#232\",\n            bgcolor: \"#353\",\n            groupcolor: \"#8A8\",\n        },\n        blue: {\n            color: \"#223\",\n            bgcolor: \"#335\",\n            groupcolor: \"#88A\",\n        },\n        pale_blue: {\n            color: \"#2a363b\",\n            bgcolor: \"#3f5159\",\n            groupcolor: \"#3f789e\",\n        },\n        cyan: {\n            color: \"#233\",\n            bgcolor: \"#355\",\n            groupcolor: \"#8AA\",\n        },\n        purple: {\n            color: \"#323\",\n            bgcolor: \"#535\",\n            groupcolor: \"#a1309b\",\n        },\n        yellow: {\n            color: \"#432\",\n            bgcolor: \"#653\",\n            groupcolor: \"#b58b2a\",\n        },\n        black: {\n            color: \"#222\",\n            bgcolor: \"#000\",\n            groupcolor: \"#444\",\n        },\n    }\n\n    getCanvasMenuOptions() {\n        let options = null;\n        if (this.getMenuOptions) {\n            options = this.getMenuOptions();\n        } else {\n            options = [\n                {\n                    content: \"Add Node\",\n                    has_submenu: true,\n                    callback: LGraphCanvas.onMenuAdd,\n                },\n                {\n                    content: \"Add Group\",\n                    callback: LGraphCanvas.onGroupAdd,\n                },\n                // {content:\"Collapse All\", callback: LGraphCanvas.onMenuCollapseAll }\n            ];\n\n            if (this._graph_stack && this._graph_stack.length > 0) {\n                options.push(null, {\n                    content: \"Close subgraph\",\n                    callback: this.closeSubgraph.bind(this),\n                });\n            }\n        }\n\n        if (this.getExtraMenuOptions) {\n            const extra = this.getExtraMenuOptions(this, options);\n            if (extra) options = options.concat(extra);\n        }\n\n        return options;\n    }\n\n    getNodeMenuOptions(node) {\n        let options = null;\n\n        if (node.getMenuOptions) options = node.getMenuOptions(this);\n        else {\n            options = [\n                {\n                    content: \"Inputs\",\n                    has_submenu: true,\n                    disabled: true,\n                    callback: LGraphCanvas.showMenuNodeOptionalInputs,\n                },\n                {\n                    content: \"Outputs\",\n                    has_submenu: true,\n                    disabled: true,\n                    callback: LGraphCanvas.showMenuNodeOptionalOutputs,\n                },\n                null,\n                {\n                    content: \"Properties\",\n                    has_submenu: true,\n                    callback: LGraphCanvas.onShowMenuNodeProperties,\n                },\n                null,\n                {\n                    content: \"Title\",\n                    callback: LGraphCanvas.onShowPropertyEditor,\n                },\n                {\n                    content: \"Mode\",\n                    has_submenu: true,\n                    callback: LGraphCanvas.onMenuNodeMode,\n                },\n                {\n                    content: \"Resize\",\n                    callback() {\n                        if (node.resizable) {\n                            return LGraphCanvas.onResizeNode;\n                        }\n                    },\n                },\n                {\n                    content: \"Collapse\",\n                    callback: LGraphCanvas.onMenuNodeCollapse,\n                },\n                {\n                    content: \"Pin\",\n                    callback: LGraphCanvas.onMenuNodePin,\n                },\n                {\n                    content: \"Colors\",\n                    has_submenu: true,\n                    callback: LGraphCanvas.onMenuNodeColors,\n                },\n                {\n                    content: \"Shapes\",\n                    has_submenu: true,\n                    callback: LGraphCanvas.onMenuNodeShapes,\n                },\n                null,\n            ];\n        }\n\n        if (node.onGetInputs) {\n            const inputs = node.onGetInputs();\n            if (inputs && inputs.length) options[0].disabled = false;\n        }\n\n        if (node.onGetOutputs) {\n            const outputs = node.onGetOutputs();\n            if (outputs && outputs.length) options[1].disabled = false;\n        }\n\n        if (node.getExtraMenuOptions) {\n            const extra = node.getExtraMenuOptions(this, options);\n            if (extra) {\n                extra.push(null);\n                options = extra.concat(options);\n            }\n        }\n\n        if (node.clonable) {\n            options.push({\n                content: \"Clone\",\n                callback: LGraphCanvas.onMenuNodeClone,\n            });\n        }\n\n        options.push(null, {\n            content: \"Remove\",\n            disabled: !(node.removable !== false && !node.block_delete),\n            callback: LGraphCanvas.onMenuNodeRemove,\n        });\n\n        if (node.graph && node.graph.onGetNodeMenuOptions) {\n            node.graph.onGetNodeMenuOptions(options, node);\n        }\n\n        return options;\n    }\n\n    getGroupMenuOptions() {\n        return [\n            {\n                content: \"Title\",\n                callback: LGraphCanvas.onShowPropertyEditor,\n            },\n            {\n                content: \"Color\",\n                has_submenu: true,\n                callback: LGraphCanvas.onMenuNodeColors,\n            },\n            {\n                content: \"Font size\",\n                property: \"font_size\",\n                type: \"Number\",\n                callback: LGraphCanvas.onShowPropertyEditor,\n            },\n            null,\n            {\n                content: \"Remove\",\n                callback: LGraphCanvas.onMenuNodeRemove,\n            },\n        ];\n    }\n\n    processContextMenu(node, event) {\n        const that = this;\n        const canvas = LGraphCanvas.active_canvas;\n        const refWindow = canvas.getCanvasWindow();\n\n        let menuInfo = null;\n        const options = {\n            event,\n            callback: inner_option_clicked,\n            extra: node,\n        };\n\n        if (node) options.title = node.type;\n\n        // check if mouse is in input\n        let slot = null;\n        if (node) {\n            slot = node.getSlotInPosition(event.canvasX, event.canvasY);\n            LGraphCanvas.active_node = node;\n        }\n\n        if (slot) {\n            // on slot\n            menuInfo = [];\n            if (node.getSlotMenuOptions) menuInfo = node.getSlotMenuOptions(slot);\n            else {\n                if (slot && slot.output && slot.output.links && slot.output.links.length) {\n                    menuInfo.push({\n                        content: \"Disconnect Links\",\n                        slot,\n                    });\n                }\n                const _slot = slot.input || slot.output;\n                menuInfo.push(_slot.locked ? \"Cannot remove\" : { content: \"Remove Slot\", slot });\n                menuInfo.push(_slot.nameLocked ? \"Cannot rename\" : { content: \"Rename Slot\", slot });\n            }\n            options.title = (slot.input ? slot.input.type : slot.output.type) || \"*\";\n            if (slot.input && slot.input.type === defaultConfig.ACTION) options.title = \"Action\";\n            if (slot.output && slot.output.type === defaultConfig.EVENT) options.title = \"Event\";\n        } else if (node) {\n            menuInfo = this.getNodeMenuOptions(node);\n        } else {\n            menuInfo = this.getCanvasMenuOptions();\n            const group = this.graph.getGroupOnPos(event.canvasX, event.canvasY);\n            if (group) {\n                // on group\n                menuInfo.push(null, {\n                    content: \"Edit Group\",\n                    has_submenu: true,\n                    submenu: {\n                        title: \"Group\",\n                        extra: group,\n                        options: this.getGroupMenuOptions(group),\n                    },\n                });\n            }\n        }\n\n        // show menu\n        if (!menuInfo) return;\n\n        const menu = new ContextMenu(menuInfo, options, refWindow);\n\n        function inner_option_clicked(v, options, e) {\n            if (!v) {\n                return;\n            }\n\n            if (v.content === \"Remove Slot\") {\n                const info = v.slot;\n                if (info.input) node.removeInput(info.slot);\n                else if (info.output) node.removeOutput(info.slot);\n            } else if (v.content === \"Disconnect Links\") {\n                const info = v.slot;\n                if (info.output) node.disconnectOutput(info.slot);\n                else if (info.input) node.disconnectInput(info.slot);\n            } else if (v.content === \"Rename Slot\") {\n                const info = v.slot;\n                const slotInfo = info.input\n                    ? node.getInputInfo(info.slot) : node.getOutputInfo(info.slot);\n                const dialog = that.createDialog(\n                    \"<span class='name'>Name</span><input autofocus type='text'/><button>OK</button>\",\n                    options,\n                );\n                const input = dialog.querySelector(\"input\");\n                if (input && slotInfo) input.value = slotInfo.label || \"\";\n                dialog.querySelector(\"button\")\n                    .addEventListener(\"click\", () => {\n                        if (input.value) {\n                            if (slotInfo) slotInfo.label = input.value;\n                            that.setDirty(true);\n                        }\n                        dialog.close();\n                    });\n            }\n        }\n    }\n}\n","/**\n * @module File Utils\n */\nimport defaultConfig from \"./defaultConfig\";\n\nexport function getFileExtension(url) {\n    const question = url.indexOf(\"?\");\n    if (question !== -1) {\n        url = url.substr(0, question);\n    }\n    const point = url.lastIndexOf(\".\");\n    if (point === -1) {\n        return \"\";\n    }\n    return url.substr(point + 1).toLowerCase();\n}\n\n/**\n * Wrapper to load files (from url using fetch or from file using FileReader)\n * @method fetchFile\n * @param {String|File|Blob} url the url of the file (or the file itself)\n * @param {String} type an string to know how to fetch it:\n *     \"text\",\"arraybuffer\",\"json\",\"blob\"\n * @param {Function} onComplete callback(data)\n * @param {Function} onError in case of an error\n * @return {FileReader|Promise|void} returns the object used to\n */\nexport function fetchFile(url, type = \"text\", onComplete, onError) {\n    if (!url) return null;\n\n    if (url.constructor === String) {\n        if (url.substr(0, 4) === \"http\" && defaultConfig.proxy) {\n            url = defaultConfig.proxy + url.substr(url.indexOf(\":\") + 3);\n        }\n        return fetch(url)\n            .then((response) => {\n                if (!response.ok) throw new Error(\"File not found\"); // it will be catch\n                // below\n                if (type === \"arraybuffer\") return response.arrayBuffer();\n                if ([\"string\", \"text\"].includes(type)) return response.text();\n                if (type === \"json\") return response.json();\n                if (type === \"blob\") return response.blob();\n            })\n            .then((data) => {\n                if (onComplete) onComplete(data);\n            })\n            .catch((error) => {\n                console.error(\"error fetching file:\", url);\n                if (onError) onError(error);\n            });\n    }\n    if (url.constructor === File || url.constructor === Blob) {\n        const reader = new FileReader();\n        reader.onload = (e) => {\n            let v = e.target.result;\n            if (type === \"json\") v = JSON.parse(v);\n            if (onComplete) onComplete(v);\n        };\n        if (type === \"arraybuffer\") return reader.readAsArrayBuffer(url);\n        if ([\"string\", \"text\"].includes(type)) return reader.readAsText(url);\n        if (type === \"blob\") return reader.readAsBinaryString(url);\n    }\n    return null;\n}\n","import defaultConfig from \"./utils/defaultConfig\";\nimport getTime from \"./utils/time\";\nimport LGraphNode from \"./LGraphNode\";\nimport LGraphGroup from \"./LGraphGroup\";\nimport LGraphCanvas from \"./LGraphCanvas\";\nimport LLink from \"./LLink\";\n\n/**\n * LGraph is the class that contain a full graph.\n * We instantiate one and add nodes to it, and then we can run the execution loop.\n * supported callbacks:\n + onNodeAdded: when a new node is added to the graph\n + onNodeRemoved: when a node inside this graph is removed\n + onNodeConnectionChange: some connection has changed in the graph (connected or disconnected)\n *\n * @class LGraph\n * @constructor\n * @param {Object} o data from previous serialization [optional]\n */\nexport default class LGraph {\n    constructor(o) {\n        if (defaultConfig.debug) {\n            console.log(\"Graph created\");\n        }\n        this.list_of_graphcanvas = null;\n        this.clear();\n\n        if (o) {\n            this.configure(o);\n        }\n    }\n\n    getSupportedTypes() {\n        return this.supportedTypes || LGraph.supportedTypes;\n    }\n\n    STATUS_STOPPED = 1;\n\n    STATUS_RUNNING = 2;\n\n    supportedTypes = [\"number\", \"string\", \"boolean\"];\n\n    static supportedTypes = [\"number\", \"string\", \"boolean\"];\n    // used to know which types of connections support this graph (some graphs do not allow certain\n    // types)\n\n    /**\n     * Removes all nodes from this graph\n     * @method clear\n     * @memberOf LGraph\n     */\n    clear() {\n        this.stop();\n        this.status = this.STATUS_STOPPED;\n\n        this.last_node_id = 0;\n        this.last_link_id = 0;\n\n        this._version = -1; // used to detect changes\n\n        // safe clear\n        if (this._nodes) {\n            for (const node of this._nodes) {\n                if (node.onRemoved) node.onRemoved();\n            }\n        }\n\n        // nodes\n        this._nodes = [];\n        this._nodes_by_id = {};\n        this._nodes_in_order = []; // nodes sorted in execution order\n        this._nodes_executable = null; // nodes that contain onExecute sorted in execution order\n\n        // other scene stuff\n        this._groups = [];\n\n        // links\n        this.links = {}; // container with all the links\n\n        // iterations\n        this.iteration = 0;\n\n        // custom data\n        this.config = {};\n        this.vars = {};\n        this.extra = {}; // to store custom data\n\n        // timing\n        this.globaltime = 0;\n        this.runningtime = 0;\n        this.fixedtime = 0;\n        this.fixedtime_lapse = 0.01;\n        this.elapsed_time = 0.01;\n        this.last_update_time = 0;\n        this.starttime = 0;\n\n        this.catch_errors = true;\n\n        // subgraph_data\n        this.inputs = {};\n        this.outputs = {};\n\n        // notify canvas to redraw\n        this.change();\n\n        this.sendActionToCanvas(\"clear\");\n    }\n\n    /**\n     * Attach Canvas to this graph\n     * @method attachCanvas\n     * @param {GraphCanvas} graphcanvas\n     * @memberOf LGraph\n     */\n    attachCanvas(graphcanvas) {\n        if (graphcanvas.constructor !== LGraphCanvas) {\n            throw new Error(\"attachCanvas expects a LGraphCanvas instance\");\n        }\n        if (graphcanvas.graph && graphcanvas.graph !== this) {\n            graphcanvas.graph.detachCanvas(graphcanvas);\n        }\n\n        graphcanvas.graph = this;\n\n        if (!this.list_of_graphcanvas) this.list_of_graphcanvas = [];\n        this.list_of_graphcanvas.push(graphcanvas);\n    }\n\n    /**\n     * Detach Canvas from this graph\n     * @method detachCanvas\n     * @param {GraphCanvas} graphcanvas\n     * @memberOf LGraph\n     */\n    detachCanvas(graphcanvas) {\n        if (!this.list_of_graphcanvas) {\n            return;\n        }\n\n        const pos = this.list_of_graphcanvas.indexOf(graphcanvas);\n        if (pos === -1) {\n            return;\n        }\n        graphcanvas.graph = null;\n        this.list_of_graphcanvas.splice(pos, 1);\n    }\n\n    /**\n     * Starts running this graph every interval milliseconds.\n     * @method start\n     * @param {number} interval amount of milliseconds between executions, if 0 then it renders to\n     *     the monitor refresh rate\n     * @memberOf LGraph\n     */\n    start(interval) {\n        if (this.status === LGraph.STATUS_RUNNING) {\n            return;\n        }\n        this.status = LGraph.STATUS_RUNNING;\n\n        if (this.onPlayEvent) {\n            this.onPlayEvent();\n        }\n\n        this.sendEventToAllNodes(\"onStart\");\n\n        // launch\n        this.starttime = getTime();\n        this.last_update_time = this.starttime;\n        interval = interval || 0;\n        const that = this;\n\n        // execute once per frame\n        if (interval === 0 && typeof window !== \"undefined\" && window.requestAnimationFrame) {\n            // eslint-disable-next-line no-inner-declarations\n            function onFrame() {\n                if (that.execution_timer_id !== -1) {\n                    return;\n                }\n                window.requestAnimationFrame(onFrame);\n                if (that.onBeforeStep) that.onBeforeStep();\n                that.runStep(1, !that.catch_errors);\n                if (that.onAfterStep) that.onAfterStep();\n            }\n\n            this.execution_timer_id = -1;\n            onFrame();\n        } else { // execute every 'interval' ms\n            this.execution_timer_id = setInterval(() => {\n                // execute\n                if (that.onBeforeStep) that.onBeforeStep();\n                that.runStep(1, !that.catch_errors);\n                if (that.onAfterStep) that.onAfterStep();\n            }, interval);\n        }\n    }\n\n    /**\n     * Stops the execution loop of the graph\n     * @method stop execution\n     * @memberOf LGraph\n     */\n    stop() {\n        if (this.status === LGraph.STATUS_STOPPED) {\n            return;\n        }\n\n        this.status = LGraph.STATUS_STOPPED;\n\n        if (this.onStopEvent) {\n            this.onStopEvent();\n        }\n\n        if (this.execution_timer_id) {\n            if (this.execution_timer_id !== -1) {\n                clearInterval(this.execution_timer_id);\n            }\n            this.execution_timer_id = null;\n        }\n\n        this.sendEventToAllNodes(\"onStop\");\n    }\n\n    /**\n     * Run N steps (cycles) of the graph\n     * @method runStep\n     * @param {number} num number of steps to run, default is 1\n     * @param {Boolean} doNotCatchError [optional] if you want to try/catch errors\n     * @param {number} limit max number of nodes to execute (used to execute from start to a node)\n     * @memberOf LGraph\n     */\n    runStep(num, doNotCatchError, limit) {\n        num = num || 1;\n\n        const start = getTime();\n        this.globaltime = 0.001 * (start - this.starttime);\n\n        const nodes = this._nodes_executable\n            ? this._nodes_executable\n            : this._nodes;\n        if (!nodes) {\n            return;\n        }\n\n        limit = limit || nodes.length;\n\n        if (doNotCatchError) {\n            // iterations\n            for (let i = 0; i < num; i++) {\n                for (let j = 0; j < limit; j++) {\n                    const node = nodes[j];\n                    if (node.mode === defaultConfig.ALWAYS && node.onExecute) {\n                        node.onExecute(); // hard to send elapsed time\n                    }\n                }\n\n                this.fixedtime += this.fixedtime_lapse;\n                if (this.onExecuteStep) {\n                    this.onExecuteStep();\n                }\n            }\n\n            if (this.onAfterExecute) {\n                this.onAfterExecute();\n            }\n        } else {\n            try {\n                // iterations\n                for (let i = 0; i < num; i++) {\n                    for (let j = 0; j < limit; ++j) {\n                        const node = nodes[j];\n                        if (node.mode === defaultConfig.ALWAYS && node.onExecute) {\n                            node.onExecute();\n                        }\n                    }\n\n                    this.fixedtime += this.fixedtime_lapse;\n                    if (this.onExecuteStep) {\n                        this.onExecuteStep();\n                    }\n                }\n\n                if (this.onAfterExecute) {\n                    this.onAfterExecute();\n                }\n                this.errors_in_execution = false;\n            } catch (err) {\n                this.errors_in_execution = true;\n                if (defaultConfig.throw_errors) {\n                    throw err;\n                }\n                if (defaultConfig.debug) {\n                    console.log(`Error during execution: ${err}`);\n                }\n                this.stop();\n            }\n        }\n\n        const now = getTime();\n        let elapsed = now - start;\n        if (elapsed === 0) {\n            elapsed = 1;\n        }\n        this.execution_time = 0.001 * elapsed;\n        this.globaltime += 0.001 * elapsed;\n        this.iteration += 1;\n        this.elapsed_time = (now - this.last_update_time) * 0.001;\n        this.last_update_time = now;\n    }\n\n    /**\n     * Updates the graph execution order according to relevance of the nodes (nodes with only\n     * outputs have more relevance than nodes with only inputs.\n     * @method updateExecutionOrder\n     * @memberOf LGraph\n     */\n    updateExecutionOrder() {\n        this._nodes_in_order = this.computeExecutionOrder(false);\n        this._nodes_executable = [];\n        for (const node of this._nodes_in_order) {\n            if (node.onExecute) {\n                this._nodes_executable.push(node);\n            }\n        }\n    }\n\n    /**\n     * It computes the executable nodes in order and returns it\n     * @param onlyOnExecute\n     * @param setLevel\n     * @returns {this}\n     * @internal\n     * @memberOf LGraph\n     */\n    computeExecutionOrder(onlyOnExecute, setLevel) {\n        let L = [];\n        const S = [];\n        const M = {};\n        const visitedLinks = {}; // to avoid repeating links\n        const remainingLinks = {}; // to a\n\n        // search for the nodes without inputs (starting nodes)\n        for (const node of this._nodes) {\n            if (onlyOnExecute && !node.onExecute) {\n                continue;\n            }\n\n            M[node.id] = node; // add to pending nodes\n\n            let num = 0; // num of input connections\n            if (node.inputs) {\n                for (let j = 0, l2 = node.inputs.length; j < l2; j++) {\n                    if (node.inputs[j] && node.inputs[j].link != null) {\n                        num += 1;\n                    }\n                }\n            }\n\n            if (num === 0) {\n                // is a starting node\n                S.push(node);\n                if (setLevel) {\n                    node._level = 1;\n                }\n            } else {\n                if (setLevel) {\n                    node._level = 0;\n                }\n                remainingLinks[node.id] = num;\n            }\n        }\n\n        while (true) {\n            if (S.length === 0) {\n                break;\n            }\n\n            // get an starting node\n            const node = S.shift();\n            L.push(node); // add to ordered list\n            delete M[node.id]; // remove from the pending nodes\n\n            if (!node.outputs) {\n                continue;\n            }\n\n            // for every output\n            for (const output of node.outputs) {\n                if (\n                    output == null\n                    || output.links == null\n                    || output.links.length === 0\n                ) {\n                    continue;\n                }\n\n                // for every connection\n                for (const linkId of output.links) {\n                    const link = this.links[linkId];\n                    if (!link) {\n                        continue;\n                    }\n\n                    // already visited link (ignore it)\n                    if (visitedLinks[link.id]) {\n                        continue;\n                    }\n\n                    const targetNode = this.getNodeById(link.target_id);\n                    if (targetNode == null) {\n                        visitedLinks[link.id] = true;\n                        continue;\n                    }\n\n                    if (\n                        setLevel\n                        && (!targetNode._level\n                        || targetNode._level <= node._level)\n                    ) {\n                        targetNode._level = node._level + 1;\n                    }\n\n                    visitedLinks[link.id] = true; // mark as visited\n                    remainingLinks[targetNode.id] -= 1; // reduce the number of links remaining\n                    if (remainingLinks[targetNode.id] === 0) {\n                        S.push(targetNode);\n                    } // if no more links, then add to starters array\n                }\n            }\n        }\n\n        // the remaining ones (loops)\n        // eslint-disable-next-line guard-for-in,no-restricted-syntax\n        for (const i in M) L.push(M[i]);\n\n        if (L.length !== this._nodes.length && defaultConfig.debug) {\n            console.warn(\"something went wrong, nodes missing\");\n        }\n\n        const l = L.length;\n\n        // save order number in the node\n        for (let i = 0; i < l; i++) L[i].order = i;\n\n        // sort now by priority\n        L = L.sort((A, B) => {\n            const Ap = A.constructor.priority || A.priority || 0;\n            const Bp = B.constructor.priority || B.priority || 0;\n            if (Ap === Bp) {\n                // if same priority, sort by order\n                return A.order - B.order;\n            }\n            return Ap - Bp; // sort by priority\n        });\n\n        // save order number in the node, again...\n        for (let i = 0; i < l; ++i) L[i].order = i;\n\n        return L;\n    }\n\n    /**\n     * Returns all the nodes that could affect this one (ancestors) by crawling all the inputs\n     * recursively. It doesn't include the node itself\n     * @method getAncestors\n     * @memberOf LGraph\n     * @return {Array} an array with all the LGraphNodes that affect this node, in order of\n     *     execution\n     */\n    // eslint-disable-next-line class-methods-use-this\n    getAncestors(node) {\n        const ancestors = [];\n        const pending = [node];\n        const visited = {};\n\n        while (pending.length) {\n            const current = pending.shift();\n            if (!current.inputs) {\n                continue;\n            }\n            if (!visited[current.id] && current !== node) {\n                visited[current.id] = true;\n                ancestors.push(current);\n            }\n\n            for (let i = 0; i < current.inputs.length; ++i) {\n                const input = current.getInputNode(i);\n                if (input && ancestors.indexOf(input) === -1) {\n                    pending.push(input);\n                }\n            }\n        }\n\n        ancestors.sort((a, b) => a.order - b.order);\n        return ancestors;\n    }\n\n    /**\n     * Positions every node in a more readable manner\n     * @method arrange\n     * @memberOf LGraph\n     */\n    arrange(margin) {\n        margin = margin || 100;\n\n        const nodes = this.computeExecutionOrder(false, true);\n        const columns = [];\n        for (const node of nodes) {\n            const col = node._level || 1;\n            if (!columns[col]) {\n                columns[col] = [];\n            }\n            columns[col].push(node);\n        }\n\n        let x = margin;\n\n        for (const column of columns) {\n            if (!column) {\n                continue;\n            }\n            let maxSize = 100;\n            let y = margin + defaultConfig.NODE_TITLE_HEIGHT;\n            for (const node of column) {\n                node.pos[0] = x;\n                node.pos[1] = y;\n                if (node.size[0] > maxSize) maxSize = node.size[0];\n                y += node.size[1] + margin + defaultConfig.NODE_TITLE_HEIGHT;\n            }\n            x += maxSize + margin;\n        }\n\n        this.setDirtyCanvas(true, true);\n    }\n\n    /**\n     * Returns the amount of time the graph has been running in milliseconds\n     * @method getTime\n     * @return {number} number of milliseconds the graph has been running\n     * @memberOf LGraph\n     */\n    getTime() {\n        return this.globaltime;\n    }\n\n    /**\n     * Returns the amount of time accumulated using the fixedtime_lapse var. This is used in\n     * context where the time increments should be constant\n     * @method getFixedTime\n     * @return {number} number of milliseconds the graph has been running\n     * @memberOf LGraph\n     */\n\n    getFixedTime() {\n        return this.fixedtime;\n    }\n\n    /**\n     * Returns the amount of time it took to compute the latest iteration. Take into account that\n     * this number could be not correct if the nodes are using graphical actions\n     * @method getElapsedTime\n     * @return {number} number of milliseconds it took the last cycle\n     * @memberOf LGraph\n     */\n\n    getElapsedTime() {\n        return this.elapsed_time;\n    }\n\n    /**\n     * Sends an event to all the nodes, useful to trigger stuff\n     * @method sendEventToAllNodes\n     * @param {String} eventname the name of the event (function to be called)\n     * @param {Array} params parameters in array format\n     * @memberOf LGraph\n     */\n    sendEventToAllNodes(eventname, params, mode) {\n        mode = mode || defaultConfig.ALWAYS;\n\n        const nodes = this._nodes_in_order ? this._nodes_in_order : this._nodes;\n        if (!nodes) {\n            return;\n        }\n\n        for (let j = 0, l = nodes.length; j < l; ++j) {\n            const node = nodes[j];\n\n            if (\n                node.constructor.name === \"Subgraph\"\n                && eventname !== \"onExecute\"\n            ) {\n                if (node.mode === mode) {\n                    node.sendEventToAllNodes(eventname, params, mode);\n                }\n                continue;\n            }\n\n            if (!node[eventname] || node.mode !== mode) {\n                continue;\n            }\n            if (params === undefined) {\n                node[eventname]();\n            } else if (params && params.constructor === Array) {\n                node[eventname](...params);\n            } else {\n                node[eventname](params);\n            }\n        }\n    }\n\n    sendActionToCanvas(action, params = []) {\n        if (!this.list_of_graphcanvas) {\n            return;\n        }\n\n        for (const c of this.list_of_graphcanvas) {\n            if (c[action]) {\n                c[action](...params);\n            }\n        }\n    }\n\n    /**\n     * Adds a new node instance to this graph\n     * @method add\n     * @param {LGraphNode} node the instance of the node\n     * @param {boolean} skipComputeOrder\n     * @memberOf LGraph\n     */\n\n    add(node, skipComputeOrder) {\n        if (!node) {\n            return;\n        }\n\n        // groups\n        if (node.constructor === LGraphGroup) {\n            this._groups.push(node);\n            this.setDirtyCanvas(true);\n            this.change();\n            node.graph = this;\n            this._version++;\n            return;\n        }\n\n        // nodes\n        if (node.id !== -1 && this._nodes_by_id[node.id]) {\n            console.warn(\n                \"LiteGraph: there is already a node with this ID, changing it\",\n            );\n            node.id = ++this.last_node_id;\n        }\n\n        if (this._nodes.length >= defaultConfig.MAX_NUMBER_OF_NODES) {\n            throw new Error(\"LiteGraph: max number of nodes in a graph reached\");\n        }\n\n        // give him an id\n        if (!node.id || node.id === -1) {\n            node.id = ++this.last_node_id;\n        } else if (this.last_node_id < node.id) {\n            this.last_node_id = node.id;\n        }\n\n        node.graph = this;\n        this._version++;\n\n        this._nodes.push(node);\n        this._nodes_by_id[node.id] = node;\n\n        if (node.onAdded) node.onAdded(this);\n\n        if (this.config.align_to_grid) node.alignToGrid();\n\n        if (!skipComputeOrder) this.updateExecutionOrder();\n\n        if (this.onNodeAdded) this.onNodeAdded(node);\n\n        this.setDirtyCanvas(true);\n        this.change();\n\n        return node; // to chain actions\n    }\n\n    /**\n     * Removes a node from the graph\n     * @method remove\n     * @param {LGraphNode} node the instance of the node\n     * @memberOf LGraph\n     */\n\n    remove(node) {\n        if (node.constructor.name === \"LGraphGroup\") {\n            const index = this._groups.indexOf(node);\n            if (index !== -1) {\n                this._groups.splice(index, 1);\n            }\n            node.graph = null;\n            this._version++;\n            this.setDirtyCanvas(true, true);\n            this.change();\n            return;\n        }\n\n        if (this._nodes_by_id[node.id] == null) {\n            return;\n        } // not found\n\n        if (node.ignore_remove) {\n            return;\n        } // cannot be removed\n\n        this.beforeChange(); // sure?\n\n        // disconnect inputs\n        if (node.inputs) {\n            for (let i = 0; i < node.inputs.length; i++) {\n                const slot = node.inputs[i];\n                if (slot.link != null) {\n                    node.disconnectInput(i);\n                }\n            }\n        }\n\n        // disconnect outputs\n        if (node.outputs) {\n            for (let i = 0; i < node.outputs.length; i++) {\n                const slot = node.outputs[i];\n                if (slot.links != null && slot.links.length) {\n                    node.disconnectOutput(i);\n                }\n            }\n        }\n\n        // node.id = -1; //why?\n\n        // callback\n        if (node.onRemoved) {\n            node.onRemoved();\n        }\n\n        node.graph = null;\n        this._version++;\n\n        // remove from canvas render\n        if (this.list_of_graphcanvas) {\n            for (const canvas of this.list_of_graphcanvas) {\n                if (canvas.selected_nodes[node.id]) {\n                    delete canvas.selected_nodes[node.id];\n                }\n                if (canvas.node_dragged === node) {\n                    canvas.node_dragged = null;\n                }\n            }\n        }\n\n        // remove from containers\n        if (this._nodes.includes(node)) {\n            this._nodes = this._nodes.filter(n => n !== node);\n        }\n        delete this._nodes_by_id[node.id];\n\n        if (this.onNodeRemoved) {\n            this.onNodeRemoved(node);\n        }\n\n        // close panels\n        this.sendActionToCanvas(\"checkPanels\");\n\n        this.setDirtyCanvas(true, true);\n        this.afterChange(); // sure?\n        this.change();\n\n        this.updateExecutionOrder();\n    }\n\n    /**\n     * Returns a node by its id.\n     * @method getNodeById\n     * @param {Number} id\n     * @memberOf LGraph\n     */\n\n    getNodeById(id) {\n        if (id == null) {\n            return null;\n        }\n        return this._nodes_by_id[id];\n    }\n\n    /**\n     * Returns a list of nodes that matches a class\n     * @method findNodesByClass\n     * @param {Class} classObject the class itself (not an string)\n     * @param {Array} result\n     * @return {Array} a list with all the nodes of this type\n     * @memberOf LGraph\n     */\n    findNodesByClass(classObject, result = []) {\n        result.length = 0;\n        for (const node of this._nodes) {\n            if (node.constructor === classObject) result.push(node);\n        }\n        return result;\n    }\n\n    /**\n     * Returns a list of nodes that matches a type\n     * @method findNodesByType\n     * @param {String} type the name of the node type\n     * @param {Array} result\n     * @return {Array} a list with all the nodes of this type\n     * @memberOf LGraph\n     */\n    findNodesByType(type, result = []) {\n        type = type.toLowerCase();\n        result = result || [];\n        result.length = 0;\n        for (const node of this._nodes) {\n            if (node.type.toLowerCase() === type) result.push(node);\n        }\n        return result;\n    }\n\n    /**\n     * Returns the first node that matches a name in its title\n     * @method findNodeByTitle\n     * @param {String} title the name of the node to search\n     * @return {Node} the node or null\n     * @memberOf LGraph\n     */\n    findNodeByTitle(title) {\n        for (const node of this._nodes) {\n            if (node.title === title) return node;\n        }\n        return null;\n    }\n\n    /**\n     * Returns a list of nodes that matches a name\n     * @method findNodesByTitle\n     * @param {String} title the name of the node to search\n     * @return {Array} a list with all the nodes with this name\n     * @memberOf LGraph\n     */\n    findNodesByTitle(title) {\n        const result = [];\n        for (const node of this._nodes) {\n            if (node.title === title) result.push(node);\n        }\n        return result;\n    }\n\n    /**\n     * Returns the top-most node in this position of the canvas\n     * @method getNodeOnPos\n     * @param {number} x the x coordinate in canvas space\n     * @param {number} y the y coordinate in canvas space\n     * @param {Array} nodesList a list with all the nodes to search from, by default is all the\n     *     nodes in the graph\n     * @param {number} margin\n     * @return {LGraphNode} the node at this position or null\n     * @memberOf LGraph\n     */\n    getNodeOnPos(x, y, nodesList = this._nodes, margin) {\n        for (const n of nodesList) {\n            if (n.isPointInside(x, y, margin)) return n;\n        }\n        return null;\n    }\n\n    /**\n     * Returns the top-most group in that position\n     * @method getGroupOnPos\n     * @param {number} x the x coordinate in canvas space\n     * @param {number} y the y coordinate in canvas space\n     * @return {LGraphGroup} the group or null\n     * @memberOf LGraph\n     */\n    getGroupOnPos(x, y) {\n        for (const g of this._groups) {\n            if (g.isPointInside(x, y, 2, true)) return g;\n        }\n        return null;\n    }\n\n    /**\n     * Checks that the node type matches the node type registered, used when replacing a nodetype\n     * by a newer version during execution this replaces the ones using the old version with the\n     * new version\n     * @method checkNodeTypes\n     * @memberOf LGraph\n     */\n    checkNodeTypes() {\n        for (let node of this._nodes) {\n            const ctor = defaultConfig.registered_node_types[node.type];\n            if (node.constructor === ctor) {\n                continue;\n            }\n            console.log(`node being replaced by newer version: ${node.type}`);\n            const newnode = LGraphNode.createNode(node.type);\n            node = newnode;\n            newnode.configure(node.serialize());\n            newnode.graph = this;\n            this._nodes_by_id[newnode.id] = newnode;\n            if (node.inputs) {\n                newnode.inputs = node.inputs.concat();\n            }\n            if (node.outputs) {\n                newnode.outputs = node.outputs.concat();\n            }\n        }\n        this.updateExecutionOrder();\n    }\n\n    onAction(action, param) {\n        this._input_nodes = this.findNodesByClass(\n            LiteGraph.GraphInput,\n            this._input_nodes,\n        );\n        for (const node of this._input_nodes) {\n            if (node.properties.name !== action) {\n                continue;\n            }\n            node.onAction(action, param);\n            break;\n        }\n    }\n\n    trigger(action, param) {\n        if (this.onTrigger) {\n            this.onTrigger(action, param);\n        }\n    }\n\n    /**\n     * Tell this graph it has a global graph input of this type\n     * @method addGlobalInput\n     * @param {String} name\n     * @param {String} type\n     * @param {*} value [optional]\n     * @memberOf LGraph\n     */\n    addInput(name, type, value) {\n        const input = this.inputs[name];\n        if (input) {\n            // already exist\n            return;\n        }\n\n        this.beforeChange();\n        this.inputs[name] = {\n            name,\n            type,\n            value,\n        };\n        this._version++;\n        this.afterChange();\n\n        if (this.onInputAdded) {\n            this.onInputAdded(name, type);\n        }\n\n        if (this.onInputsOutputsChange) {\n            this.onInputsOutputsChange();\n        }\n    }\n\n    /**\n     * Assign a data to the global graph input\n     * @method setGlobalInputData\n     * @param {String} name\n     * @param {*} data\n     * @memberOf LGraph\n     */\n    setInputData(name, data) {\n        const input = this.inputs[name];\n        if (!input) {\n            return;\n        }\n        input.value = data;\n    }\n\n    /**\n     * Returns the current value of a global graph input\n     * @method getInputData\n     * @param {String} name\n     * @return {*} the data\n     * @memberOf LGraph\n     */\n    getInputData(name) {\n        const input = this.inputs[name];\n        if (!input) {\n            return null;\n        }\n        return input.value;\n    }\n\n    /**\n     * Changes the newName of a global graph input\n     * @method renameInput\n     * @param {String} oldName\n     * @param {String} new_name\n     * @memberOf LGraph\n     */\n    renameInput(oldName, newName) {\n        if (newName === oldName) {\n            return;\n        }\n\n        if (!this.inputs[oldName]) {\n            return false;\n        }\n\n        if (this.inputs[newName]) {\n            console.error(\"there is already one input with that newName\");\n            return false;\n        }\n\n        this.inputs[newName] = this.inputs[oldName];\n        delete this.inputs[oldName];\n        this._version++;\n\n        if (this.onInputRenamed) {\n            this.onInputRenamed(oldName, newName);\n        }\n\n        if (this.onInputsOutputsChange) {\n            this.onInputsOutputsChange();\n        }\n    }\n\n    /**\n     * Changes the type of a global graph input\n     * @method changeInputType\n     * @param {String} name\n     * @param {String} type\n     * @memberOf LGraph\n     */\n    changeInputType(name, type) {\n        if (!this.inputs[name]) {\n            return false;\n        }\n\n        if (\n            this.inputs[name].type\n            && String(this.inputs[name].type).toLowerCase()\n            === String(type).toLowerCase()\n        ) {\n            return;\n        }\n\n        this.inputs[name].type = type;\n        this._version++;\n        if (this.onInputTypeChanged) {\n            this.onInputTypeChanged(name, type);\n        }\n    }\n\n    /**\n     * Removes a global graph input\n     * @method removeInput\n     * @param {String} name\n     * @memberOf LGraph\n     */\n    removeInput(name) {\n        if (!this.inputs[name]) {\n            return false;\n        }\n\n        delete this.inputs[name];\n        this._version++;\n\n        if (this.onInputRemoved) {\n            this.onInputRemoved(name);\n        }\n\n        if (this.onInputsOutputsChange) {\n            this.onInputsOutputsChange();\n        }\n        return true;\n    }\n\n    /**\n     * Creates a global graph output\n     * @method addOutput\n     * @param {String} name\n     * @param {String} type\n     * @param {*} value\n     * @memberOf LGraph\n     */\n    addOutput(name, type, value) {\n        this.outputs[name] = {\n            name,\n            type,\n            value,\n        };\n        this._version++;\n\n        if (this.onOutputAdded) {\n            this.onOutputAdded(name, type);\n        }\n\n        if (this.onInputsOutputsChange) {\n            this.onInputsOutputsChange();\n        }\n    }\n\n    /**\n     * Assign a data to the global output\n     * @method setOutputData\n     * @param {String} name\n     * @param {String} value\n     * @memberOf LGraph\n     */\n    setOutputData(name, value) {\n        const output = this.outputs[name];\n        if (!output) {\n            return;\n        }\n        output.value = value;\n    }\n\n    /**\n     * Returns the current value of a global graph output\n     * @method getOutputData\n     * @param {String} name\n     * @return {*} the data\n     * @memberOf LGraph\n     */\n    getOutputData(name) {\n        const output = this.outputs[name];\n        if (!output) {\n            return null;\n        }\n        return output.value;\n    }\n\n    /**\n     * Renames a global graph output\n     * @method renameOutput\n     * @param {String} oldName\n     * @param {String} newName\n     * @memberOf LGraph\n     */\n    renameOutput(oldName, newName) {\n        if (!this.outputs[oldName]) {\n            return false;\n        }\n\n        if (this.outputs[newName]) {\n            console.error(\"there is already one output with that newName\");\n            return false;\n        }\n\n        this.outputs[newName] = this.outputs[oldName];\n        delete this.outputs[oldName];\n        this._version++;\n\n        if (this.onOutputRenamed) {\n            this.onOutputRenamed(oldName, newName);\n        }\n\n        if (this.onInputsOutputsChange) {\n            this.onInputsOutputsChange();\n        }\n    }\n\n    /**\n     * Changes the type of a global graph output\n     * @method changeOutputType\n     * @param {String} name\n     * @param {String} type\n     * @memberOf LGraph\n     */\n    changeOutputType(name, type) {\n        if (!this.outputs[name]) {\n            return false;\n        }\n\n        if (\n            this.outputs[name].type\n            && String(this.outputs[name].type).toLowerCase()\n            === String(type).toLowerCase()\n        ) {\n            return;\n        }\n\n        this.outputs[name].type = type;\n        this._version++;\n        if (this.onOutputTypeChanged) {\n            this.onOutputTypeChanged(name, type);\n        }\n    }\n\n    /**\n     * Removes a global graph output\n     * @method removeOutput\n     * @param {String} name\n     * @memberOf LGraph\n     */\n    removeOutput(name) {\n        if (!this.outputs[name]) {\n            return false;\n        }\n        delete this.outputs[name];\n        this._version++;\n\n        if (this.onOutputRemoved) {\n            this.onOutputRemoved(name);\n        }\n\n        if (this.onInputsOutputsChange) {\n            this.onInputsOutputsChange();\n        }\n        return true;\n    }\n\n    triggerInput(name, value) {\n        const nodes = this.findNodesByTitle(name);\n        for (let i = 0; i < nodes.length; ++i) {\n            nodes[i].onTrigger(value);\n        }\n    }\n\n    setCallback(name, func) {\n        const nodes = this.findNodesByTitle(name);\n        for (let i = 0; i < nodes.length; ++i) {\n            nodes[i].setTrigger(func);\n        }\n    }\n\n    // used for undo, called before any change is made to the graph\n    beforeChange(info) {\n        if (this.onBeforeChange) {\n            this.onBeforeChange(this, info);\n        }\n        this.sendActionToCanvas(\"onBeforeChange\", this);\n    }\n\n    // used to resend actions, called after any change is made to the graph\n    afterChange(info) {\n        if (this.onAfterChange) {\n            this.onAfterChange(this, info);\n        }\n        this.sendActionToCanvas(\"onAfterChange\", this);\n    }\n\n    connectionChange(node) {\n        this.updateExecutionOrder();\n        if (this.onConnectionChange) {\n            this.onConnectionChange(node);\n        }\n        this._version++;\n        this.sendActionToCanvas(\"onConnectionChange\");\n    }\n\n    /**\n     * returns if the graph is in live mode\n     * @method isLive\n     * @memberOf LGraph\n     */\n\n    isLive() {\n        if (!this.list_of_graphcanvas) {\n            return false;\n        }\n\n        for (let i = 0; i < this.list_of_graphcanvas.length; ++i) {\n            const c = this.list_of_graphcanvas[i];\n            if (c.live_mode) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * clears the triggered slot animation in all links (stop visual animation)\n     * @method clearTriggeredSlots\n     * @memberOf LGraph\n     */\n    clearTriggeredSlots() {\n        // eslint-disable-next-line guard-for-in,no-restricted-syntax\n        for (const i in this.links) {\n            const linkInfo = this.links[i];\n            if (!linkInfo) {\n                continue;\n            }\n            if (linkInfo._last_time) {\n                linkInfo._last_time = 0;\n            }\n        }\n    }\n\n    /* Called when something visually changed (not the graph!) */\n    change() {\n        if (defaultConfig.debug) {\n            console.log(\"Graph changed\");\n        }\n        this.sendActionToCanvas(\"setDirty\", [true, true]);\n        if (this.on_change) this.on_change(this);\n    }\n\n    setDirtyCanvas(fg, bg) {\n        this.sendActionToCanvas(\"setDirty\", [fg, bg]);\n    }\n\n    /**\n     * Destroys a link\n     * @method removeLink\n     * @param {Number} linkId\n     * @memberOf LGraph\n     */\n    removeLink(linkId) {\n        const link = this.links[linkId];\n        if (!link) {\n            return;\n        }\n        const node = this.getNodeById(link.target_id);\n        if (node) {\n            node.disconnectInput(link.target_slot);\n        }\n    }\n\n    // save and recover app state ***************************************\n    /**\n     * Creates a Object containing all the info about this graph, it can be serialized\n     * @method serialize\n     * @return {Object} value of the node\n     * @memberOf LGraph\n     */\n    serialize() {\n        const nodesInfo = [];\n        for (const node of this._nodes) {\n            nodesInfo.push(node.serialize());\n        }\n\n        // pack link info into a non-verbose format\n        const links = [];\n        // eslint-disable-next-line guard-for-in,no-restricted-syntax\n        for (const i in this.links) {\n            // links is an OBJECT\n            let link = this.links[i];\n            if (!link.serialize) {\n                // weird bug I havent solved yet\n                console.warn(\n                    \"weird LLink bug, link info is not a LLink but a regular object\",\n                );\n                const link2 = new LLink();\n                // eslint-disable-next-line guard-for-in,no-restricted-syntax\n                for (const j in link) {\n                    link2[j] = link[j];\n                }\n                this.links[i] = link2;\n                link = link2;\n            }\n\n            links.push(link.serialize());\n        }\n\n        const groupsInfo = [];\n        for (const group of this._groups) groupsInfo.push(group.serialize());\n\n        const data = {\n            last_node_id: this.last_node_id,\n            last_link_id: this.last_link_id,\n            nodes: nodesInfo,\n            links,\n            groups: groupsInfo,\n            config: this.config,\n            extra: this.extra,\n            version: defaultConfig.VERSION,\n        };\n\n        if (this.onSerialize) this.onSerialize(data);\n\n        return data;\n    }\n\n    /**\n     * Configure a graph from a JSON string\n     * @method configure\n     * @param {String} str configure a graph from a JSON string\n     * @param {Boolean} returns if there was any error parsing\n     * @memberOf LGraph\n     */\n    configure(data, keepOld) {\n        if (!data) {\n            return;\n        }\n\n        if (!keepOld) this.clear();\n\n        const { nodes } = data;\n\n        // decode links info (they are very verbose)\n        if (data.links && data.links.constructor === Array) {\n            const links = [];\n            for (const linkData of data.links) {\n                if (!linkData) {\n                    console.warn(\"serialized graph link data contains errors, skipping.\");\n                    continue;\n                }\n                const link = new LLink();\n                link.configure(linkData);\n                links[link.id] = link;\n            }\n            data.links = links;\n        }\n\n        // copy all stored fields\n        // eslint-disable-next-line guard-for-in,no-restricted-syntax\n        for (const i in data) {\n            if (i === \"nodes\" || i === \"groups\") {\n                continue;\n            }\n            this[i] = data[i];\n        }\n\n        let error = false;\n\n        // create nodes\n        this._nodes = [];\n        if (nodes) {\n            for (const nInfo of nodes) {\n                let node = LGraphNode.createNode(nInfo.type, nInfo.title);\n                if (!node) {\n                    if (defaultConfig.debug) {\n                        console.log(\n                            `Node not found or has errors: ${nInfo.type}`,\n                        );\n                    }\n\n                    // in case of error we create a replacement node to avoid losing info\n                    node = new LGraphNode();\n                    node.last_serialization = nInfo;\n                    node.has_errors = true;\n                    error = true;\n                    // continue;\n                }\n\n                node.id = nInfo.id; // id it or it will create a new id\n                this.add(node, true); // add before configure, otherwise configure cannot create\n                // links\n            }\n\n            // configure nodes afterwards so they can reach each other\n            for (const nInfo of nodes) {\n                const node = this.getNodeById(nInfo.id);\n                if (node) {\n                    node.configure(nInfo);\n                }\n            }\n        }\n\n        // groups\n        this._groups.length = 0;\n        if (data.groups) {\n            for (const dataGroup of data.groups) {\n                const group = new LGraphGroup();\n                group.configure(dataGroup);\n                this.add(group);\n            }\n        }\n\n        this.updateExecutionOrder();\n\n        this.extra = data.extra || {};\n\n        if (this.onConfigure) this.onConfigure(data);\n\n        this._version++;\n        this.setDirtyCanvas(true, true);\n        return error;\n    }\n\n    load(url, callback) {\n        const that = this;\n\n        // from file\n        if (url.constructor === File || url.constructor === Blob) {\n            const reader = new FileReader();\n            reader.addEventListener(\"load\", (event) => {\n                const data = JSON.parse(event.target.result);\n                that.configure(data);\n                if (callback) callback();\n            });\n\n            reader.readAsText(url);\n            return;\n        }\n\n        // is a string, then an URL\n        const req = new XMLHttpRequest();\n        req.open(\"GET\", url, true);\n        req.send(null);\n        req.onload(() => {\n            if (req.status !== 200) {\n                console.error(\"Error loading graph:\", req.status, req.response);\n                return;\n            }\n            const data = JSON.parse(req.response);\n            that.configure(data);\n            if (callback) callback();\n        });\n        req.onerror((err) => {\n            console.error(\"Error loading graph:\", err);\n        });\n    }\n\n    /**\n     * Node event manager\n     * @todo Need create event\n     * @param node\n     * @param msg\n     * @param color\n     * @memberOf LGraph\n     */\n    onNodeTrace(node, msg, color) {\n        // TODO\n    }\n}\n","import { clamp } from \"./utils/math\";\n/**\n * @class CurveEditor\n * @param points\n */\nexport default class CurveEditor {\n    constructor(points) {\n        this.points = points;\n        this.selected = -1;\n        this.nearest = -1;\n        this.size = null; // stores last size used\n        this.must_update = true;\n        this.margin = 5;\n    }\n\n    sampleCurve(f, points) {\n        if (!points) return;\n        for (let i = 0; i < points.length - 1; ++i) {\n            const p = points[i];\n            const pn = points[i + 1];\n            if (pn[0] < f) continue;\n            const r = (pn[0] - p[0]);\n            if (Math.abs(r) < 0.00001) return p[1];\n            const localF = (f - p[0]) / r;\n            return p[1] * (1.0 - localF) + pn[1] * localF;\n        }\n        return 0;\n    }\n\n    draw(ctx, size, graphcanvas, backgroundColor, lineColor = \"#666\", inactive) {\n        const { points } = this;\n        if (!points) return;\n        this.size = size;\n        const w = size[0] - this.margin * 2;\n        const h = size[1] - this.margin * 2;\n\n        ctx.save();\n        ctx.translate(this.margin, this.margin);\n\n        if (backgroundColor) {\n            ctx.fillStyle = \"#111\";\n            ctx.fillRect(0, 0, w, h);\n            ctx.fillStyle = \"#222\";\n            ctx.fillRect(w * 0.5, 0, 1, h);\n            ctx.strokeStyle = \"#333\";\n            ctx.strokeRect(0, 0, w, h);\n        }\n        ctx.strokeStyle = lineColor;\n        if (inactive) ctx.globalAlpha = 0.5;\n        ctx.beginPath();\n        for (const point of points) {\n            ctx.lineTo(point[0] * w, (1.0 - point[1]) * h);\n        }\n        ctx.stroke();\n        ctx.globalAlpha = 1;\n        if (!inactive) {\n            for (let i = 0; i < points.length; ++i) {\n                const p = points[i];\n                if (this.selected === i) ctx.fillStyle = \"#FFF\";\n                else if (this.nearest === i) ctx.fillStyle = \"#DDD\";\n                else ctx.fillStyle = \"#AAA\";\n                ctx.beginPath();\n                ctx.arc(p[0] * w, (1.0 - p[1]) * h, 2, 0, Math.PI * 2);\n                ctx.fill();\n            }\n        }\n        ctx.restore();\n    }\n\n    onMouseDown(localpos, graphcanvas) {\n        const { points } = this;\n        if (!points) return;\n        if (localpos[1] < 0) return;\n\n        // this.captureInput(true);\n        const w = this.size[0] - this.margin * 2;\n        const h = this.size[1] - this.margin * 2;\n        const x = localpos[0] - this.margin;\n        const y = localpos[1] - this.margin;\n        const pos = [x, y];\n        const maxDist = 30 / graphcanvas.ds.scale;\n        // search closer one\n        this.selected = this.getCloserPoint(pos, maxDist);\n        // create one\n        if (this.selected === -1) {\n            const point = [x / w, 1 - y / h];\n            points.push(point);\n            points.sort((a, b) => a[0] - b[0]);\n            this.selected = points.indexOf(point);\n            this.must_update = true;\n        }\n        if (this.selected !== -1) return true;\n    }\n\n    onMouseMove(localpos, graphcanvas) {\n        const { points } = this;\n        if (!points) return;\n        const s = this.selected;\n        if (s < 0) return;\n        const x = (localpos[0] - this.margin) / (this.size[0] - this.margin * 2);\n        const y = (localpos[1] - this.margin) / (this.size[1] - this.margin * 2);\n        const curvepos = [(localpos[0] - this.margin), (localpos[1] - this.margin)];\n        const maxDist = 30 / graphcanvas.ds.scale;\n        this._nearest = this.getCloserPoint(curvepos, maxDist);\n        const point = points[s];\n        if (point) {\n            const isEdgePoint = s === 0 || s === points.length - 1;\n            if (!isEdgePoint\n                && (localpos[0] < -10\n                    || localpos[0] > this.size[0] + 10\n                    || localpos[1] < -10\n                    || localpos[1] > this.size[1] + 10)) {\n                points.splice(s, 1);\n                this.selected = -1;\n                return;\n            }\n            if (!isEdgePoint) {\n                point[0] = clamp(x, 0, 1);\n            } else {\n                point[0] = s === 0 ? 0 : 1;\n            }\n            point[1] = 1.0 - clamp(y, 0, 1);\n            points.sort((a, b) => a[0] - b[0]);\n            this.selected = points.indexOf(point);\n            this.must_update = true;\n        }\n    }\n\n    onMouseUp() {\n        this.selected = -1;\n        return false;\n    }\n\n    getCloserPoint(pos, maxDist = 30) {\n        const { points } = this;\n        if (!points) return -1;\n        const w = (this.size[0] - this.margin * 2);\n        const h = (this.size[1] - this.margin * 2);\n        const num = points.length;\n        const p2 = [0, 0];\n        let minDist = 1000000;\n        let closest = -1;\n        let lastValid = -1;\n        for (let i = 0; i < num; ++i) {\n            const p = points[i];\n            p2[0] = p[0] * w;\n            p2[1] = (1.0 - p[1]) * h;\n            // eslint-disable-next-line no-unused-vars\n            if (p2[0] < pos[0]) lastValid = i;\n            const dist = vec2.distance(pos, p2);\n            if (dist > minDist || dist > maxDist) continue;\n            closest = i;\n            minDist = dist;\n        }\n        return closest;\n    }\n}\n","// Creates an interface to access extra features from a graph (like play, stop, live, etc)\nimport LGraph from \"./LGraph\";\nimport LGraphCanvas from \"./LGraphCanvas\";\n\n/**\n * @class Editor\n * @param containerId\n * @param options\n */\nexport default class Editor {\n    constructor(containerId, options) {\n        options = options || {};\n\n        // fill container\n        const html = \"<div class='content'><div class='editor-area'><canvas class='graphcanvas' width='1000' height='500' tabindex=10></canvas></div></div>\";\n\n        const root = document.createElement(\"div\");\n        this.root = root;\n        root.className = \"litegraph litegraph-editor\";\n        root.innerHTML = html;\n\n        this.content = root.querySelector(\".content\");\n        this.footer = root.querySelector(\".footer\");\n\n        const canvas = root.querySelector(\".graphcanvas\");\n\n        // create graph\n        const graph = (this.graph = new LGraph());\n        const graphcanvas = (this.graphcanvas = new LGraphCanvas(canvas, graph));\n        graphcanvas.background_image = \"imgs/grid.png\";\n        graph.onAfterExecute = function () {\n            graphcanvas.draw(true);\n        };\n\n        graphcanvas.onDropItem = this.onDropItem.bind(this);\n\n        if (options.miniwindow) {\n            this.addMiniWindow(300, 200);\n        }\n\n        // append to DOM\n        const parent = document.getElementById(containerId);\n        if (parent) {\n            parent.appendChild(root);\n        }\n\n        graphcanvas.resize();\n        // graphcanvas.draw(true,true);\n    }\n\n    onDropItem(e) {\n        for (const file of e.dataTransfer.files) {\n            const ext = LGraphCanvas.getFileExtension(file.name);\n            const reader = new FileReader();\n            if (ext === \"json\") {\n                reader.onload = (event) => {\n                    this.graph.configure(JSON.parse(event.target.result));\n                };\n                reader.readAsText(file);\n            }\n        }\n    }\n\n    addMiniWindow(w, h) {\n        const miniwindow = document.createElement(\"div\");\n        miniwindow.className = \"litegraph miniwindow\";\n        miniwindow.innerHTML = `<canvas class='graphcanvas' width='${\n            w\n        }' height='${\n            h\n        }' tabindex=10></canvas>`;\n        const canvas = miniwindow.querySelector(\"canvas\");\n        const that = this;\n\n        const graphcanvas = new LGraphCanvas(canvas, this.graph);\n        graphcanvas.show_info = false;\n        graphcanvas.background_image = \"imgs/grid.png\";\n        graphcanvas.scale = 0.25;\n        graphcanvas.allow_dragnodes = false;\n        graphcanvas.allow_interaction = false;\n        graphcanvas.render_shadows = false;\n        graphcanvas.max_zoom = 0.25;\n        this.miniwindow_graphcanvas = graphcanvas;\n        graphcanvas.onClear = function () {\n            graphcanvas.scale = 0.25;\n            graphcanvas.allow_dragnodes = false;\n            graphcanvas.allow_interaction = false;\n        };\n        graphcanvas.onRenderBackground = function (canvas, ctx) {\n            ctx.strokeStyle = \"#567\";\n            let tl = that.graphcanvas.convertOffsetToCanvas([0, 0]);\n            let br = that.graphcanvas.convertOffsetToCanvas([\n                that.graphcanvas.canvas.width,\n                that.graphcanvas.canvas.height,\n            ]);\n            tl = this.convertCanvasToOffset(tl);\n            br = this.convertCanvasToOffset(br);\n            ctx.lineWidth = 1;\n            ctx.strokeRect(\n                Math.floor(tl[0]) + 0.5,\n                Math.floor(tl[1]) + 0.5,\n                Math.floor(br[0] - tl[0]),\n                Math.floor(br[1] - tl[1]),\n            );\n        };\n\n        miniwindow.style.position = \"absolute\";\n        miniwindow.style.top = \"4px\";\n        miniwindow.style.right = \"4px\";\n\n        const closeBouton = document.createElement(\"div\");\n        closeBouton.className = \"corner-button\";\n        closeBouton.innerHTML = \"&#10060;\";\n        closeBouton.addEventListener(\"click\", (e) => {\n            graphcanvas.setGraph(null);\n            miniwindow.remove();\n        });\n        miniwindow.appendChild(closeBouton);\n\n        this.root.querySelector(\".content\").appendChild(miniwindow);\n    }\n}\n","import \"../css/litegraph.css\";\nimport \"../css/litegraph-editor.css\";\n\nexport { default as LGraph } from \"./LGraph\";\nexport { default as LLink } from \"./LLink\";\nexport { default as LGraphNode } from \"./LGraphNode\";\nexport { default as LGraphGroup } from \"./LGraphGroup\";\nexport { default as DragAndScale } from \"./DragAndScale\";\nexport { default as CurveEditor } from \"./CurveEditor\";\nexport { default as LGraphCanvas } from \"./LGraphCanvas\";\nexport { default as ContextMenu } from \"./ContextMenu\";\nexport { default as Editor } from \"./litegraph-editor\";\n\nexport { default as defaultConfig } from \"./utils/defaultConfig\";\nexport * from \"./utils/registry\";\nexport * from \"./utils/math\";\nexport * from \"./utils/function\";\n\nif (typeof CanvasRenderingContext2D !== \"undefined\") {\n    CanvasRenderingContext2D.prototype.roundRect = function roundRect(\n        x,\n        y,\n        width,\n        height,\n        radius = 5,\n        radiusLow = radius,\n    ) {\n        this.moveTo(x + radius, y);\n        this.lineTo(x + width - radius, y);\n        this.quadraticCurveTo(x + width, y, x + width, y + radius);\n\n        this.lineTo(x + width, y + height - radiusLow);\n        this.quadraticCurveTo(\n            x + width,\n            y + height,\n            x + width - radiusLow,\n            y + height,\n        );\n        this.lineTo(x + radiusLow, y + height);\n        this.quadraticCurveTo(x, y + height, x, y + height - radiusLow);\n        this.lineTo(x, y + radius);\n        this.quadraticCurveTo(x, y, x + radius, y);\n    };\n}\n"],"names":["styleInject","css","ref","insertAt","document","head","getElementsByTagName","style","createElement","type","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","VERSION","CANVAS_GRID_SIZE","NODE_TITLE_HEIGHT","NODE_TITLE_TEXT_Y","NODE_SLOT_HEIGHT","NODE_WIDGET_HEIGHT","NODE_WIDTH","NODE_MIN_WIDTH","NODE_COLLAPSED_RADIUS","NODE_COLLAPSED_WIDTH","NODE_TITLE_COLOR","NODE_SELECTED_TITLE_COLOR","NODE_TEXT_SIZE","NODE_TEXT_COLOR","NODE_SUBTEXT_SIZE","NODE_DEFAULT_COLOR","NODE_DEFAULT_BGCOLOR","NODE_DEFAULT_BOXCOLOR","NODE_DEFAULT_SHAPE","NODE_BOX_OUTLINE_COLOR","DEFAULT_SHADOW_COLOR","DEFAULT_GROUP_FONT","WIDGET_BGCOLOR","WIDGET_OUTLINE_COLOR","WIDGET_TEXT_COLOR","WIDGET_SECONDARY_TEXT_COLOR","LINK_COLOR","EVENT_LINK_COLOR","CONNECTING_LINK_COLOR","MAX_NUMBER_OF_NODES","DEFAULT_POSITION","VALID_SHAPES","BOX_SHAPE","ROUND_SHAPE","CIRCLE_SHAPE","CARD_SHAPE","ARROW_SHAPE","INPUT","OUTPUT","EVENT","ACTION","ALWAYS","ON_EVENT","NEVER","ON_TRIGGER","UP","DOWN","LEFT","RIGHT","CENTER","STRAIGHT_LINK","LINEAR_LINK","SPLINE_LINK","NORMAL_TITLE","NO_TITLE","TRANSPARENT_TITLE","AUTOHIDE_TITLE","proxy","node_images_path","debug","catch_exceptions","throw_errors","allow_scripts","registered_node_types","node_types_by_file_extension","Nodes","Globals","searchbox_extras","auto_sort_node_types","getTime","performance","now","Date","process","t","hrtime","cloneObject","obj","target","r","JSON","parse","stringify","i","registerNodeType","baseClass","prototype","TypeError","defaultConfig","console","log","classname","name","pos","lastIndexOf","category","substr","title","prev","Object","hasOwnProperty","call","defineProperty","set","v","this","_shape","get","enumerable","configurable","onPropertyChange","warn","supported_extensions","ext","constructor","String","toLowerCase","onNodeTypeRegistered","onNodeTypeReplaced","getNodeTypesInCategory","filter","push","sort","getNodeTypesCategories","categories","id","skip_list","result","getParameterNames","func","replace","split","Boolean","isValidConnection","typeA","typeB","indexOf","supportedTypesA","supportedTypesB","length","j","LLink","origin_id","origin_slot","target_id","target_slot","_data","_pos","Float32Array","o","Array","distance","a","b","Math","sqrt","isInsideRectangle","x","y","left","top","width","height","overlapBounding","AEndX","AEndY","BEndX","BEndY","clamp","LGraphNode","size","graph","inputs","outputs","connections","properties","properties_info","flags","info","_version","_typeof","configure","k","onPropertyChanged","onConnectionsChange","input","linkInfo","links","link","output","widgets","widget","options","property","value","widgets_values","onConfigure","order","mode","last_serialization","serialize_widgets","color","bgcolor","boxcolor","shape","onSerialize","node","createNode","data","serialize","prevValue","w","slot","output_info","link_id","forceUpdate","linkId","getNodeById","updateOutputData","onExecute","slot_name","force_update","findInputSlot","getInputData","slot_info","link_info","l","input_info","target_node","action","param","_last_trigger_time","triggerSlot","_last_time","target_connection","onAction","onResize","default_value","extra_info","onOutputAdded","setSize","computeSize","setDirtyCanvas","array","disconnectOutput","splice","onOutputRemoved","onInputAdded","disconnectInput","onInputRemoved","direction","out","concat","rows","max","font_size","title_width","compute_text_size","input_width","output_width","text_width","label","slot_start_y","widgets_height","text","widgets_up","widgets_start_y","min_height","widgets_info","onGetPropertyInfo","callback","Function","values","custom_widget","onBounding","margin","skip_title","margin_top","isLive","collapsed","_collapsed_width","link_pos","getConnectionPos","findOutputSlot","Number","changed","beforeChange","onConnectInput","last_link_id","onNodeConnectionChange","afterChange","connectionChange","is_input","slot_number","num_slots","offset","horizontal","round","msg","MAX_CONSOLE","shift","onNodeTrace","dirty_foreground","dirty_background","sendActionToCanvas","url","img","Image","src","ready","onload","_this","list_of_graphcanvas","list","c","node_capturing_input","force","collapsable","pinned","undefined","graphcanvas","scale","err","error","folderWildcard","scriptFiles","docHeadObj","location","href","dynamicScript","removeChild","object","getOwnPropertyNames","LGraphGroup","isPointInside","_ctor","_bounding","subarray","_size","_nodes","nodes","node_bounding","getBounding","deltax","deltay","ignore_nodes","bounding","font","DragAndScale","element","skipEvents","max_scale","min_scale","onredraw","enabled","last_mouse","visible_area","bindEvents","_binded_mouse_callback","onMouse","bind","addEventListener","startx","starty","endx","endy","e","canvas","rect","getBoundingClientRect","clientX","clientY","canvasx","canvasy","dragging","ignore","onmouse","removeEventListener","body","mouseDrag","eventType","wheel","deltaY","wheelDeltaY","detail","wheelDelta","delta","changeDeltaScale","preventDefault","stopPropagation","ctx","translate","zoomingCenter","center","convertCanvasToOffset","abs","newCenter","deltaOffset","changeScale","ContextMenu","that","parentMenu","lock","current_submenu","eventClass","event","root","on_mouse_wheel","parseInt","scroll_speed","toFixed","className","minWidth","minHeight","pointerEvents","setTimeout","button","close","innerHTML","content","addItem","closing_timer","clearTimeout","rootDocument","ownerDocument","fullscreenElement","bodyRect","rootRect","transform","disabled","inner_over","has_submenu","inner_onclick","closeParent","ignore_item_callbacks","extra","submenu","Error","autoopen","classList","add","dataset","onclick_callback","ignoreParentMenu","parentNode","remove","isCursorOverElement","trigger","getTopMenu","getFirstEvent","eventName","params","evt","createEvent","initCustomEvent","dispatchEvent","__events","ref_window","window","elements","querySelectorAll","el","re","temp","tempVC2","tempArea","marginArea","linkBounding","tempA","tempB","LGraphCanvas","active_canvas","dialog","search_box","focus","overflow","timeoutClose","ds","helper","querySelector","first","timeout","selected","keyCode","changeSelection","clearInterval","refreshHelper","select","stopImmediatePropagation","onSearchBoxSelection","convertEventToCanvasOffset","addProperty","addOutput","json","forward","nextSibling","previousSibling","childNodes","scrollIntoView","block","behavior","str","onSearchBox","addResult","desc","ctor","search_limit","keys","help","innerText","escape","unescape","layerY","maxHeight","SELECTED_NODE","panel","refWindow","getCanvasWindow","createPanel","closable","addHTML","getPropertyInfo","onAddPropertyToPanel","addWidget","setProperty","dirty_canvas","addSeparator","onShowCustomPanelInfo","addButton","block_delete","inner_refresh","background_image","DEFAULT_BACKGROUND_IMAGE","zoom_modify_alpha","title_text_font","inner_text_font","node_title_color","default_link_color","default_connection_color","input_off","input_on","output_off","output_on","highquality_render","use_gradients","editor_alpha","pause_rendering","clear_background","read_only","render_only_selected","live_mode","show_info","allow_dragcanvas","allow_dragnodes","allow_interaction","allow_searchbox","allow_reconnect_links","drag_mode","dragging_rectangle","set_canvas_dirty_on_mouse_event","always_render_background","render_shadows","render_canvas_border","render_connections_shadows","render_connections_border","render_curved_connections","render_connection_arrows","render_collapsed_slots","render_execution_order","render_title_colored","render_link_tooltip","links_render_mode","mouse","graph_mouse","canvas_mouse","onDrawBackground","onDrawForeground","onDrawOverlay","onDrawLinkTooltip","onNodeMoved","onSelectionChange","onConnectingChange","onBeforeChange","onAfterChange","connections_width","round_radius","current_node","node_widget","over_link_center","last_mouse_position","visible_links","attachCanvas","setCanvas","clear","skip_render","startRendering","autoresize","frame","last_draw_time","render_time","fps","selected_nodes","selected_group","visible_nodes","node_dragged","node_over","connecting_node","highlighted_links","dragging_canvas","dirty_bgcanvas","dirty_area","node_in_panel","last_mouseclick","onClear","skipClear","_graph_stack","setDirty","detachCanvas","checkPanels","subgraphNode","_subgraph_node","pop","centerOnNode","selectNodes","getElementById","unbindEvents","tabindex","bgcanvas","getContext","localName","webgl_enabled","enableWebGL","_mousemove_callback","processMouseMove","_mouseup_callback","processMouseUp","_events_binded","_mousedown_callback","processMouseDown","_mousewheel_callback","processMouseWheel","_doNothing","touchHandler","_key_callback","processKey","_ondrop_callback","processDrop","_doReturnTrue","GL","enableWebGLCanvas","gl","webgl","bgctx","fgcanvas","defaultView","is_rendering","renderFrame","draw","requestAnimationFrame","_this2","block_click","adjustMouseEvent","getNodeOnPos","canvasX","canvasY","skipAction","isDoubleClick","localX","localY","last_click_position","closeAllContextMenus","which","ctrlKey","clickingCanvasBg","bringToFront","resizable","resizing_node","cursor","linkPos","connecting_output","connecting_pos","connecting_slot","shiftKey","onOutputDblClick","onOutputClick","onInputDblClick","onInputClick","_nodes_by_id","blockDragNote","processNodeWidgets","onDblClick","processNodeDblClicked","onMouseDown","subgraph","skip_subgraph_button","_this3","openSubgraph","processNodeSelected","showLinkMenu","getGroupOnPos","selected_group_resizing","recomputeInsideNodes","showSearchBox","processContextMenu","last_mouse_dragging","change","activeElement","nodeName","resize","move","_node","mouseOver","onMouseLeave","redraw_on_mouse","onMouseEnter","onMouseMove","_highlight_input","isOverNodeBox","isOverNodeInput","slotType","overLink","nKeys","n","desiredSize","minSize","click_time","diffx","diffy","nodeBounding","deselectAllNodes","h","toSelect","connect","getInputInfo","collapse","config","align_to_grid","alignToGrid","onMouseUp","titleHeight","slotPos","blockDefault","code","metaKey","copyToClipboard","pasteFromClipboard","deleteSelectedNodes","onKeyDown","onKeyUp","localStorage","getItem","clipboardInfo","node_data","origin_node","index","selectedNodesArray","relative_id","cloned","clone","_relative_id","setItem","onDropItem","checkDropItem","onDropFile","onDropData","files","dataTransfer","file","filename","reader","FileReader","readAsText","readAsDataURL","readAsArrayBuffer","question","point","getFileExtension","nodetype","onShowNodePanel","showShowNodePanel","onNodeDblClicked","selectNode","onNodeSelected","addToCurrentSelection","is_selected","onSelected","onDeselected","onNodeDeselected","inputLink","outputLink","inputNode","getInputNode","outputNode","getOutputNodes","deltaX","convertOffsetToCanvas","unshift","visibleNodes","force_canvas","force_bgcanvas","computeVisibleArea","drawBackCanvas","drawFrontCanvas","start2D","restore","setTransform","save","beginPath","clip","clearRect","drawImage","onRender","renderInfo","toCanvasContext","computeVisibleNodes","drawNode","drawExecutionOrder","links_ontop","drawConnections","lineWidth","linkColor","renderLink","dir","arc","PI","fill","fillStyle","strokeStyle","strokeRect","drawLinkTooltip","visible_rect","drawSubgraphPanel","finish2D","subnode","num","floor","globalAlpha","roundRect","textAlign","fillText","drawButton","closeSubgraph","not_subgraph_input","input_node_type","newnode","tw","measureText","showSubgraphPropertiesDialog","hovercolor","textcolor","hover","clicked","blockClick","holdClick","globaltime","iteration","start","g","getTitle","bgAlreadyPainted","onRenderBackground","imageSmoothingEnabled","mozImageSmoothingEnabled","_bg_img","_this4","pattern","_pattern","createPattern","_pattern_img","fillRect","_groups","drawGroups","shadowColor","shadowOffsetX","shadowOffsetY","shadowBlur","finish","lowQuality","onDrawCollapsed","min","clip_area","has_errors","drawNodeShape","renderText","outSlot","maxY","storedSlot","inputSlot","outputSlot","moveTo","lineTo","closePath","color_on","color_off","stroke","widgetsY","drawNodeWidgets","toToolTip","fgcolor","mouseHover","title_mode","renderTitle","area","oldAlpha","onDrawTitleBar","title_color","titleColor","grad","gradients","createLinearGradient","addColorStop","boxSize","onDrawTitleBox","includes","onDrawTitleText","title_text_color","over","onDrawTitle","startNode","startNodeSlot","startNodeSlotPos","endNodeSlotPos","startSlot","endSlot","startDir","endDir","f","tmp","skipBorder","flow","numSubline","link_type_colors","dist","lineJoin","offsety","startOffsetX","startOffsetY","endOffsetX","endOffsetY","bezierCurveTo","startX","startY","endX","endY","posConnectionPoint","computeConnectionPoint","posA","posB","posC","posD","angleA","angleB","atan2","rotate","p0","p1","p2","p3","c1","c2","c3","c4","posY","active_widget","H","showText","outlineColor","backgroundColor","textColor","secondaryTextColor","last_y","widgetWidth","on","off","range","nvalue","marker","marker_nvalue","precision","activeWidget","widgetHeight","oldValue","_this5","innerValueChange","step","valuesList","textValues","option","prompt","multiline","onWidgetChanged","groups","group","fontSize","DEFAULT_GROUP_FONT_SIZE","parent","offsetWidth","offsetHeight","transition","setInterval","_this6","changedTouches","simulatedEvent","initMouseEvent","screenX","screenY","menu","onMenuAdd","nodeLeft","nodeRight","removeLink","modified","_this7","prompt_box","nameElement","valueElement","offsetx","inputHTML","createDialog","setValue","checked","onclose","html","position","header","title_element","footer","onFooter","elem","strValue","toString","innerChange","propname","_this8","toggle","setAttribute","blur","getPropertyPrintableValue","old_panel","removeInput","addInput","getMenuOptions","onGroupAdd","getExtraMenuOptions","showMenuNodeOptionalInputs","showMenuNodeOptionalOutputs","onShowMenuNodeProperties","onShowPropertyEditor","onMenuNodeMode","onResizeNode","onMenuNodeCollapse","onMenuNodePin","onMenuNodeColors","onMenuNodeShapes","onGetInputs","onGetOutputs","clonable","onMenuNodeClone","removable","onMenuNodeRemove","onGetNodeMenuOptions","menuInfo","removeOutput","slotInfo","getOutputInfo","getSlotInPosition","active_node","getSlotMenuOptions","_slot","locked","nameLocked","getNodeMenuOptions","getCanvasMenuOptions","getGroupMenuOptions","entry","mouseEvent","previousMenu","inner_onMenuAdded","base_category","prev_menu","registry","startsWith","entries","forEach","base_category_regex","RegExp","category_name","category_path","findIndex","contextMenu","slice","first_event","optionsParam","optional_inputs","onMenuNodeInputs","optional_outputs","skip_repeated_outputs","onMenuNodeOutputs","innerClicked","decodeHTML","showEditPropertyValue","allow_html","item","desc_value","pin","node_colors","groupcolor","nodesList","buildFromNodes","number","red","brown","green","blue","pale_blue","cyan","purple","yellow","black","LGraph","supportedTypes","stop","status","STATUS_STOPPED","last_node_id","onRemoved","_nodes_in_order","_nodes_executable","vars","runningtime","fixedtime","fixedtime_lapse","elapsed_time","last_update_time","starttime","catch_errors","interval","STATUS_RUNNING","onPlayEvent","sendEventToAllNodes","execution_timer_id","onFrame","onBeforeStep","runStep","onAfterStep","onStopEvent","doNotCatchError","limit","onExecuteStep","onAfterExecute","errors_in_execution","elapsed","execution_time","computeExecutionOrder","onlyOnExecute","setLevel","L","S","M","visitedLinks","remainingLinks","l2","_level","targetNode","A","B","Ap","priority","Bp","ancestors","pending","visited","current","columns","col","column","maxSize","eventname","skipComputeOrder","onAdded","updateExecutionOrder","onNodeAdded","ignore_remove","onNodeRemoved","classObject","_input_nodes","findNodesByClass","LiteGraph","GraphInput","onTrigger","onInputsOutputsChange","oldName","newName","onInputRenamed","onInputTypeChanged","onOutputRenamed","onOutputTypeChanged","findNodesByTitle","setTrigger","onConnectionChange","on_change","fg","bg","nodesInfo","link2","groupsInfo","version","keepOld","linkData","nInfo","dataGroup","File","Blob","req","XMLHttpRequest","open","send","response","onerror","CurveEditor","points","nearest","must_update","p","pn","localF","lineColor","inactive","localpos","maxDist","getCloserPoint","s","curvepos","_nearest","isEdgePoint","minDist","closest","vec2","Editor","containerId","miniwindow","addMiniWindow","max_zoom","miniwindow_graphcanvas","tl","br","right","closeBouton","setGraph","CanvasRenderingContext2D","radius","radiusLow","quadraticCurveTo","nodeType","description","paramType","returnType","names","classobj","apply","setOutputData"],"mappings":"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"}
{"version":3,"file":"litegraph.min.js","sources":["../node_modules/style-inject/dist/style-inject.es.js","../src/utils/defaultConfig.js","../src/utils/time.js","../src/utils/object.js","../src/utils/registry.js","../src/utils/function.js","../src/LLink.js","../src/utils/math.js","../src/LGraphNode.js","../src/LGraphGroup.js","../src/DragAndScale.js","../src/ContextMenu.js","../src/LGraphCanvas.js","../src/utils/file.js","../src/LGraph.js","../src/CurveEditor.js","../src/litegraph-editor.js","../src/index.js"],"sourcesContent":["function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","export default {\n    VERSION: 0.4,\n\n    CANVAS_GRID_SIZE: 10,\n\n    NODE_TITLE_HEIGHT: 30,\n    NODE_TITLE_TEXT_Y: 20,\n    NODE_SLOT_HEIGHT: 20,\n    NODE_WIDGET_HEIGHT: 20,\n    NODE_WIDTH: 140,\n    NODE_MIN_WIDTH: 50,\n    NODE_COLLAPSED_RADIUS: 10,\n    NODE_COLLAPSED_WIDTH: 80,\n    NODE_TITLE_COLOR: \"#999\",\n    NODE_SELECTED_TITLE_COLOR: \"#FFF\",\n    NODE_TEXT_SIZE: 14,\n    NODE_TEXT_COLOR: \"#AAA\",\n    NODE_SUBTEXT_SIZE: 12,\n    NODE_DEFAULT_COLOR: \"#333\",\n    NODE_DEFAULT_BGCOLOR: \"#353535\",\n    NODE_DEFAULT_BOXCOLOR: \"#666\",\n    NODE_DEFAULT_SHAPE: \"box\",\n    NODE_BOX_OUTLINE_COLOR: \"#FFF\",\n    DEFAULT_SHADOW_COLOR: \"rgba(0,0,0,0.5)\",\n    DEFAULT_GROUP_FONT: 24,\n\n    WIDGET_BGCOLOR: \"#222\",\n    WIDGET_OUTLINE_COLOR: \"#666\",\n    WIDGET_TEXT_COLOR: \"#DDD\",\n    WIDGET_SECONDARY_TEXT_COLOR: \"#999\",\n\n    LINK_COLOR: \"#9A9\",\n    EVENT_LINK_COLOR: \"#A86\",\n    CONNECTING_LINK_COLOR: \"#AFA\",\n\n    MAX_NUMBER_OF_NODES: 1000, // avoid infinite loops\n    DEFAULT_POSITION: [100, 100], // default node position\n    VALID_SHAPES: [\"default\", \"box\", \"round\", \"card\"], // ,\"circle\"\n\n    // shapes are used for nodes but also for slots\n    BOX_SHAPE: 1,\n    ROUND_SHAPE: 2,\n    CIRCLE_SHAPE: 3,\n    CARD_SHAPE: 4,\n    ARROW_SHAPE: 5,\n\n    // enums\n    INPUT: 1,\n    OUTPUT: 2,\n\n    EVENT: -1, // for outputs\n    ACTION: -1, // for inputs\n\n    ALWAYS: 0,\n    ON_EVENT: 1,\n    NEVER: 2,\n    ON_TRIGGER: 3,\n\n    UP: 1,\n    DOWN: 2,\n    LEFT: 3,\n    RIGHT: 4,\n    CENTER: 5,\n\n    STRAIGHT_LINK: 0,\n    LINEAR_LINK: 1,\n    SPLINE_LINK: 2,\n\n    NORMAL_TITLE: 0,\n    NO_TITLE: 1,\n    TRANSPARENT_TITLE: 2,\n    AUTOHIDE_TITLE: 3,\n\n    proxy: null, // used to redirect calls\n    node_images_path: \"\",\n\n    debug: true,\n    catch_exceptions: true,\n    throw_errors: true,\n    allow_scripts: false,\n    // if set to true some nodes like Formula would be allowed\n    // to evaluate code that comes from unsafe sources\n    // (like node configuration), which could lead to exploits\n    registered_node_types: {}, // nodetypes by string\n    node_types_by_file_extension: {}, // used for dropping files in the canvas\n    Nodes: {}, // node types by classname\n    Globals: {}, // used to store vars between graphs\n\n    searchbox_extras: {}, // used to add extra features to the search box\n    auto_sort_node_types: false,\n    // If set to true, will automatically sort node types / categories in the context menus\n};\n","/**\n * @module Time Utils\n */\n\nexport default function getTime() {\n    if (performance) return performance.now();\n    if (Date && Date.now) return Date.now;\n    if (process) {\n        const t = process.hrtime();\n        return t[0] * 0.001 + t[1] * 1e-6;\n    }\n    return new Date().getTime();\n}\n","/**\n * @module Object Utils\n */\n\n// separated just to improve if it doesn't work\nexport default function cloneObject(obj, target) {\n    if (obj == null) return null;\n    const r = JSON.parse(JSON.stringify(obj));\n    if (!target) return r;\n\n    // eslint-disable-next-line guard-for-in,no-restricted-syntax\n    for (const i in r) target[i] = r[i];\n    return target;\n}\n","/**\n * @module Registry Manager\n */\n\n/**\n * removes a node type from the system\n * @method unregisterNodeType\n * @param {String|Object} type name of the node or the node constructor itself\n */\nimport defaultConfig from \"./defaultConfig\";\n\nexport function unregisterNodeType(type) {\n    const baseClass = type.constructor === String ? defaultConfig.registered_node_types[type] : type;\n    if (!baseClass) throw new Error(`node type not found: ${type}`);\n    delete defaultConfig.registered_node_types[baseClass.type];\n    if (baseClass.constructor.name) delete defaultConfig.Nodes[baseClass.constructor.name];\n}\n\n/**\n * Register a node class so it can be listed when the user wants to create a new one\n * @method registerNodeType\n * @param {LGraphNode} type name of the node and path\n * @param {Class} baseClass class containing the structure of a node\n */\nexport function registerNodeType(type, baseClass) {\n    if (!baseClass.prototype) {\n        throw new TypeError(\"Cannot register a simple object, it must be a class with a prototype\");\n    }\n    baseClass.type = type;\n\n    if (defaultConfig.debug) {\n        console.log(`Node registered: ${type}`);\n    }\n\n    const classname = baseClass.name;\n\n    const pos = type.lastIndexOf(\"/\");\n    baseClass.category = type.substr(0, pos);\n\n    if (!baseClass.title) {\n        baseClass.title = classname;\n    }\n\n    // info.name = name.substr(pos+1,name.length - pos);\n\n    const prev = defaultConfig.registered_node_types[type];\n    if (prev) {\n        console.log(`replacing node type: ${type}`);\n    } else {\n        if (!Object.hasOwnProperty.call(baseClass.prototype, \"shape\")) {\n            Object.defineProperty(baseClass.prototype, \"shape\", {\n                set(v) {\n                    switch (v) {\n                        case \"default\":\n                            delete this._shape;\n                            break;\n                        case \"box\":\n                            this._shape = defaultConfig.BOX_SHAPE;\n                            break;\n                        case \"round\":\n                            this._shape = defaultConfig.ROUND_SHAPE;\n                            break;\n                        case \"circle\":\n                            this._shape = defaultConfig.CIRCLE_SHAPE;\n                            break;\n                        case \"card\":\n                            this._shape = defaultConfig.CARD_SHAPE;\n                            break;\n                        default:\n                            this._shape = v;\n                    }\n                },\n                get() {\n                    return this._shape;\n                },\n                enumerable: true,\n                configurable: true,\n            });\n        }\n\n        // warnings\n        if (baseClass.prototype.onPropertyChange) {\n            console.warn(\n                `LiteGraph node class ${\n                    type\n                } has onPropertyChange method, it must be called onPropertyChanged with d at the end`,\n            );\n        }\n\n        // used to know which nodes create when dragging files to the canvas\n        if (baseClass.supported_extensions) {\n            for (const ext of baseClass.supported_extensions) {\n                if (ext && ext.constructor === String) {\n                    defaultConfig.node_types_by_file_extension[ext.toLowerCase()] = baseClass;\n                }\n            }\n        }\n    }\n\n    defaultConfig.registered_node_types[type] = baseClass;\n    if (baseClass.constructor.name) defaultConfig.Nodes[classname] = baseClass;\n\n    if (defaultConfig.onNodeTypeRegistered) defaultConfig.onNodeTypeRegistered(type, baseClass);\n    if (prev && defaultConfig.onNodeTypeReplaced) {\n        defaultConfig.onNodeTypeReplaced(type, baseClass, prev);\n    }\n\n    // warnings\n    if (baseClass.prototype.onPropertyChange) {\n        console.warn(\n            `LiteGraph node class ${\n                type\n            } has onPropertyChange method, it must be called onPropertyChanged with d at the end`,\n        );\n    }\n\n    // used to know which nodes create when dragging files to the canvas\n    if (baseClass.supported_extensions) {\n        for (const ext of baseClass.supported_extensions) {\n            if (ext && ext.constructor === String) {\n                defaultConfig.node_types_by_file_extension[ext.toLowerCase()] = baseClass;\n            }\n        }\n    }\n}\n\n/**\n * Removes all previously registered node's types\n */\nexport function clearRegisteredTypes() {\n    defaultConfig.registered_node_types = {};\n    defaultConfig.node_types_by_file_extension = {};\n    defaultConfig.Nodes = {};\n    defaultConfig.searchbox_extras = {};\n}\n\n/**\n * Returns a registered node type with a given name\n * @method getNodeType\n * @param {String} type full name of the node class. p.e. \"math/sin\"\n * @return {Class} the node class\n */\nexport function getNodeType(type) {\n    return defaultConfig.registered_node_types[type];\n}\n\n/**\n * Returns a list of node types matching one category\n * @method getNodeType\n * @param {String} category category name\n * @return {Array} array with all the node classes\n */\nexport function getNodeTypesInCategory(category, filter) {\n    const r = [];\n    // eslint-disable-next-line\n    for (const i in defaultConfig.registered_node_types) {\n        const type = defaultConfig.registered_node_types[i];\n        if (type.filter !== filter) continue;\n\n        if (category === \"\") {\n            if (!type.category) r.push(type);\n        } else if (type.category === category) {\n            r.push(type);\n        }\n    }\n\n    return defaultConfig.auto_sort_node_types ? r.sort() : r;\n}\n\n/**\n * Register a string in the search box so when the user types it it will recommend this node\n * @method registerSearchboxExtra\n * @param {String} nodeType the node recommended\n * @param {String} description text to show next to it\n * @param {Object} data it could contain info of how the node should be configured\n * @return {Boolean} true if they can be connected\n */\nexport function registerSearchboxExtra(nodeType, description, data) {\n    defaultConfig.searchbox_extras[description.toLowerCase()] = {\n        type: nodeType,\n        desc: description,\n        data,\n    };\n}\n/**\n * Returns a list with all the node type categories\n * @method getNodeTypesCategories\n * @param {String} filter only nodes with ctor.filter equal can be shown\n * @return {Array} array with all the names of the categories\n */\nexport function getNodeTypesCategories(filter) {\n    const categories = { \"\": 1 };\n    // eslint-disable-next-line\n    for (const id in defaultConfig.registered_node_types) {\n        const type = defaultConfig.registered_node_types[id];\n        if (type.category && !type.skip_list) {\n            if (type.filter !== filter) continue;\n            categories[type.category] = 1;\n        }\n    }\n    const result = [];\n    // eslint-disable-next-line\n    for (const i in categories) result.push(i);\n    return defaultConfig.auto_sort_node_types ? result.sort() : result;\n}\n","/**\n * @module Function Utils\n */\nimport defaultConfig from \"./defaultConfig\";\nimport { registerNodeType } from \"./registry\";\n\n// used to create nodes from wrapping function\nexport function getParameterNames(func) {\n    return (`${func}`)\n        .replace(/[/][/].*$/gm, \"\") // strip single-line comments\n        .replace(/\\s+/g, \"\") // strip white space\n        .replace(/[/][*][^/*]*[*][/]/g, \"\") // strip multi-line comments  /**/\n        .split(\"){\", 1)[0]\n        .replace(/^[^(]*[(]/, \"\") // extract the parameters\n        .replace(/=[^,]+/g, \"\") // strip any ES6 defaults\n        .split(\",\")\n        .filter(Boolean); // split & filter [\"\"]\n}\n\n/**\n * Create a new nodetype by passing a function, it wraps it with a proper class and\n * generates inputs according to the parameters of the function. Useful to wrap simple\n * methods that do not require properties, and that only process some input to generate an\n * output.\n * @method wrapFunctionAsNode\n * @param {String} name node name with namespace (p.e.: 'math/sum')\n * @param {Function} func\n * @param {Array} paramType [optional] an array containing the type of every parameter,\n *     otherwise parameters will accept any type\n * @param {String} returnType [optional] string with the return type, otherwise it will be\n *     generic\n * @param {Object} properties [optional] properties to be configurable\n */\nexport function wrapFunctionAsNode(\n    name,\n    func,\n    paramType,\n    returnType,\n    properties,\n) {\n    const params = Array(func.length);\n    let code = \"\";\n    const names = getParameterNames(func);\n    for (let i = 0; i < names.length; ++i) {\n        code += `this.addInput('${names[i]}',${paramType && paramType[i] ? `'${paramType[i]}'` : \"0\"});\\n`;\n    }\n    code += `this.addOutput('out',${returnType ? `'${returnType}'` : 0});\\n`;\n    if (properties) code += `this.properties = ${JSON.stringify(properties)};\\n`;\n    const classobj = Function(\"code\");\n    classobj.title = name.split(\"/\").pop();\n    classobj.desc = `Generated from ${func.name}`;\n    classobj.prototype.onExecute = function onExecute() {\n        for (let i = 0; i < params.length; ++i) {\n            params[i] = this.getInputData(i);\n        }\n        const r = func.apply(this, params);\n        this.setOutputData(0, r);\n    };\n    registerNodeType(name, classobj);\n}\n/**\n * Returns if the types of two slots are compatible (taking into account wildcards, etc)\n * @method isValidConnection\n * @param {String} typeA\n * @param {String} typeB\n * @return {Boolean} true if they can be connected\n */\nexport function isValidConnection(typeA, typeB) {\n    if (\n        !typeA\n        || !typeB\n        || typeA === typeB\n        || (typeA === defaultConfig.EVENT && typeB === defaultConfig.ACTION)\n    ) {\n        return true;\n    }\n\n    // Enforce string type to handle toLowerCase call (-1 number not ok)\n    typeA = String(typeA);\n    typeB = String(typeB);\n    typeA = typeA.toLowerCase();\n    typeB = typeB.toLowerCase();\n\n    // For nodes supporting multiple connection types\n    if (typeA.indexOf(\",\") === -1 && typeB.indexOf(\",\") === -1) return typeA === typeB;\n\n    // Check all permutations to see if one is valid\n    const supportedTypesA = typeA.split(\",\");\n    const supportedTypesB = typeB.split(\",\");\n    for (let i = 0; i < supportedTypesA.length; ++i) {\n        for (let j = 0; j < supportedTypesB.length; ++j) {\n            if (supportedTypesA[i] === supportedTypesB[j]) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n","/**\n * @class LLink\n * @param id\n * @param type\n * @param origin_id\n * @param origin_slot\n * @param target_id\n * @param target_slot\n */\nexport default class LLink {\n    constructor(id, type, origin_id, origin_slot, target_id, target_slot) {\n        this.id = id;\n        this.type = type;\n        this.origin_id = origin_id;\n        this.origin_slot = origin_slot;\n        this.target_id = target_id;\n        this.target_slot = target_slot;\n\n        this._data = null;\n        this._pos = new Float32Array(2); // center\n    }\n\n    configure(o) {\n        if (o.constructor === Array) {\n            this.id = o[0];\n            this.origin_id = o[1];\n            this.origin_slot = o[2];\n            this.target_id = o[3];\n            this.target_slot = o[4];\n            this.type = o[5];\n        } else {\n            this.id = o.id;\n            this.type = o.type;\n            this.origin_id = o.origin_id;\n            this.origin_slot = o.origin_slot;\n            this.target_id = o.target_id;\n            this.target_slot = o.target_slot;\n        }\n    }\n\n    serialize() {\n        return [\n            this.id,\n            this.origin_id,\n            this.origin_slot,\n            this.target_id,\n            this.target_slot,\n            this.type,\n        ];\n    }\n}\n","/**\n * @module Math Utils\n */\n\nexport function distance(a, b) {\n    return Math.sqrt(\n        (b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1]),\n    );\n}\n\nexport function isInsideRectangle(x, y, left, top, width, height) {\n    return left < x && left + width > x && top < y && top + height > y;\n}\n\n// bounding overlap, format: [ startx, starty, width, height ]\nexport function overlapBounding(a, b) {\n    const AEndX = a[0] + a[2];\n    const AEndY = a[1] + a[3];\n    const BEndX = b[0] + b[2];\n    const BEndY = b[1] + b[3];\n\n    return !(a[0] > BEndX\n        || a[1] > BEndY\n        || AEndX < b[0]\n        || AEndY < b[1]);\n}\n\nexport function clamp(v, a, b) {\n    // eslint-disable-next-line no-nested-ternary\n    return a > v ? a : b < v ? b : v;\n}\n","import defaultConfig from \"./utils/defaultConfig\";\nimport cloneObject from \"./utils/object\";\nimport getTime from \"./utils/time\";\nimport { isValidConnection } from \"./utils/function\";\nimport LLink from \"./LLink\";\nimport { isInsideRectangle } from \"./utils/math\";\n\n/*\ntitle: string\npos: [x,y]\nsize: [x,y]\n\ninput|output: every connection\n+  { name:string, type:string, pos: [x,y]=Optional, direction: \"input\"|\"output\", links: Array });\n\ngeneral properties:\n+ clip_area: if you render outside the node, it will be clipped\n+ unsafe_execution: not allowed for safe execution\n+ skip_repeated_outputs: when adding new outputs, it wont show if there is one already connected\n+ resizable: if set to false it wont be resizable with the mouse\n+ horizontal: slots are distributed horizontally\n+ widgets_start_y: widgets start at y distance from the top of the node\n\nflags object:\n+ collapsed: if it is collapsed\n\nsupported callbacks:\n+ onAdded: when added to graph (warning: this is called BEFORE the node is configured when loading)\n+ onRemoved: when removed from graph\n+ onStart:\twhen the graph starts playing\n+ onStop:\twhen the graph stops playing\n+ onDrawForeground: render the inside widgets inside the node\n+ onDrawBackground: render the background area inside the node (only in edit mode)\n+ onMouseDown\n+ onMouseMove\n+ onMouseUp\n+ onMouseEnter\n+ onMouseLeave\n+ onExecute: execute the node\n+ onPropertyChanged: when a property is changed in the panel (return true to skip default behaviour)\n+ onGetInputs: returns an array of possible inputs\n+ onGetOutputs: returns an array of possible outputs\n+ onBounding: in case this node has a bigger bounding than the node itself (the callback receives the bounding as [x,y,w,h])\n+ onDblClick: double clicked in the node\n+ onInputDblClick: input slot double clicked (can be used to automatically create a node connected)\n+ onOutputDblClick: output slot double clicked (can be used to automatically create a node connected)\n+ onConfigure: called after the node has been configured\n+ onSerialize: to add extra info when serializing (the callback receives the object that should be filled with the data)\n+ onSelected\n+ onDeselected\n+ onDropItem : DOM item dropped over the node\n+ onDropFile : file dropped over the node\n+ onConnectInput : if returns false the incoming connection will be canceled\n+ onConnectionsChange : a connection changed (new one or removed) (LiteGraph.INPUT or LiteGraph.OUTPUT, slot, true if connected, link_info, input_info )\n+ onAction: action slot triggered\n+ getExtraMenuOptions: to add option to context menu\n*/\n\n/**\n * Base Class for all the node type classes\n * @class LGraphNode\n * @param {String} title a name for the node\n */\nexport default class LGraphNode {\n    constructor(title) {\n        this.title = title || \"Unnamed\";\n        this.size = [defaultConfig.NODE_WIDTH, 60];\n        this.graph = null;\n        this.id = -1; // not know till not added\n        this.type = null;\n        // inputs available: array of inputs\n        this.inputs = [];\n        this.outputs = [];\n        this.connections = [];\n\n        // local data\n        this.properties = {}; // for the values\n        this.properties_info = []; // for the info\n\n        this.flags = {};\n    }\n\n    /**\n     * Internal position array\n     * @internal\n     * @type {Float32Array}\n     * @private\n     * @memberOf LGraphNode\n     */\n    _pos = new Float32Array(10, 10)\n\n    set pos(v) {\n        if (!v || v.length < 2) {\n            return;\n        }\n        this._pos[0] = v[0];\n        this._pos[1] = v[1];\n    }\n\n    get pos() {\n        return this._pos;\n    }\n\n    /**\n     * configure a node from an object containing the serialized info\n     * @method configure\n     * @memberOf LGraphNode\n     */\n    configure(info) {\n        if (this.graph) {\n            this.graph._version++;\n        }\n        // eslint-disable-next-line guard-for-in,no-restricted-syntax\n        for (const j in info) {\n            if (j === \"properties\") {\n                // i don't want to clone properties, I want to reuse the old container\n                // eslint-disable-next-line guard-for-in,no-restricted-syntax\n                for (const k in info.properties) {\n                    this.properties[k] = info.properties[k];\n                    if (this.onPropertyChanged) {\n                        this.onPropertyChanged(k, info.properties[k]);\n                    }\n                }\n                continue;\n            }\n\n            if (info[j] == null) {\n                continue;\n            } else if (typeof info[j] === \"object\") {\n                // object\n                if (this[j] && this[j].configure) {\n                    this[j].configure(info[j]);\n                } else {\n                    this[j] = cloneObject(info[j], this[j]);\n                }\n            } else {\n                this[j] = info[j];\n            }\n        }\n\n        if (!info.title) {\n            this.title = this.constructor.title;\n        }\n\n        if (this.onConnectionsChange) {\n            if (this.inputs) {\n                for (let i = 0; i < this.inputs.length; ++i) {\n                    const input = this.inputs[i];\n                    const linkInfo = this.graph\n                        ? this.graph.links[input.link]\n                        : null;\n                    this.onConnectionsChange(\n                        defaultConfig.INPUT,\n                        i,\n                        true,\n                        linkInfo,\n                        input,\n                    ); // linkInfo has been created now, so its updated\n                }\n            }\n\n            if (this.outputs) {\n                for (let i = 0; i < this.outputs.length; ++i) {\n                    const output = this.outputs[i];\n                    if (!output.links) {\n                        continue;\n                    }\n                    for (let j = 0; j < output.links.length; ++j) {\n                        const linkInfo = this.graph\n                            ? this.graph.links[output.links[j]]\n                            : null;\n                        this.onConnectionsChange(\n                            defaultConfig.OUTPUT,\n                            i,\n                            true,\n                            linkInfo,\n                            output,\n                        ); // link_info has been created now, so its updated\n                    }\n                }\n            }\n        }\n\n        if (this.widgets) {\n            for (const widget of this.widgets) {\n                if (!widget) continue;\n                if (widget.options\n                    && widget.options.property\n                    // eslint-disable-next-line max-len\n                    && this.properties[widget.options.property]) widget.value = JSON.parse(JSON.stringify(this.properties[widget.options.property]));\n            }\n            if (info.widgets_values) {\n                for (let i = 0; i < info.widgets_values.length; ++i) {\n                    if (this.widgets[i]) {\n                        this.widgets[i].value = info.widgets_values[i];\n                    }\n                }\n            }\n        }\n\n        if (this.onConfigure) {\n            this.onConfigure(info);\n        }\n    }\n\n    /**\n     * serialize the content\n     * @method serialize\n     * @memberOf LGraphNode\n     */\n\n    serialize() {\n        // create serialization object\n        const o = {\n            id: this.id,\n            type: this.type,\n            pos: this.pos,\n            size: this.size,\n            flags: cloneObject(this.flags),\n            order: this.order,\n            mode: this.mode,\n        };\n\n        // special case for when there were errors\n        if (this.constructor === LGraphNode && this.last_serialization) {\n            return this.last_serialization;\n        }\n\n        if (this.inputs) {\n            o.inputs = this.inputs;\n        }\n\n        if (this.outputs) {\n            // clear outputs last data (because data in connections is never serialized but stored\n            // inside the outputs info)\n            for (let i = 0; i < this.outputs.length; i++) {\n                delete this.outputs[i]._data;\n            }\n            o.outputs = this.outputs;\n        }\n\n        if (this.title && this.title != this.constructor.title) {\n            o.title = this.title;\n        }\n\n        if (this.properties) {\n            o.properties = cloneObject(this.properties);\n        }\n\n        if (this.widgets && this.serialize_widgets) {\n            o.widgets_values = [];\n            for (let i = 0; i < this.widgets.length; ++i) {\n                if (this.widgets[i]) {\n                    o.widgets_values[i] = this.widgets[i].value;\n                } else {\n                    o.widgets_values[i] = null;\n                }\n            }\n        }\n\n        if (!o.type) o.type = this.constructor.type;\n\n        if (this.color) o.color = this.color;\n        if (this.bgcolor) o.bgcolor = this.bgcolor;\n        if (this.boxcolor) o.boxcolor = this.boxcolor;\n        if (this.shape) o.shape = this.shape;\n\n        if (this.onSerialize) {\n            if (this.onSerialize(o)) {\n                console.warn(\n                    \"node onSerialize shouldnt return anything, data should be stored in the object pass in the first parameter\",\n                );\n            }\n        }\n\n        return o;\n    }\n\n    /* Creates a clone of this node */\n    clone() {\n        const node = LGraphNode.createNode(this.type);\n        if (!node) {\n            return null;\n        }\n\n        // we clone it because serialize returns shared containers\n        const data = LGraphNode.cloneObject(this.serialize());\n\n        // remove links\n        if (data.inputs) {\n            for (let i = 0; i < data.inputs.length; ++i) {\n                data.inputs[i].link = null;\n            }\n        }\n\n        if (data.outputs) {\n            for (let i = 0; i < data.outputs.length; ++i) {\n                if (data.outputs[i].links) {\n                    data.outputs[i].links.length = 0;\n                }\n            }\n        }\n\n        delete data.id;\n        // remove links\n        node.configure(data);\n\n        return node;\n    }\n\n    /**\n     * serialize and stringify\n     * @method toString\n     * @memberOf LGraphNode\n     */\n\n    toString() {\n        return JSON.stringify(this.serialize());\n    }\n\n    // deserialize = function(info) {} //this cannot be done from within, must\n    // be done in LiteGraph\n\n    /**\n     * get the title string\n     * @method getTitle\n     * @memberOf LGraphNode\n     */\n\n    getTitle() {\n        return this.title || this.constructor.title;\n    }\n\n    /**\n     * sets the value of a property\n     * @method setProperty\n     * @param {String} name\n     * @param {*} value\n     * @memberOf LGraphNode\n     */\n    setProperty(name, value) {\n        if (!this.properties) {\n            this.properties = {};\n        }\n        if (value === this.properties[name]) return;\n        const prevValue = this.properties[name];\n        this.properties[name] = value;\n        if (this.onPropertyChanged && this.onPropertyChanged(name, value, prevValue) === false) {\n            this.properties[name] = prevValue;\n        }\n        if (this.widgets) {\n            for (let i = 0; i < this.widgets.length; ++i) {\n                const w = this.widgets[i];\n                if (!w) continue;\n                if (w.options.property == name) {\n                    w.value = value;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Execution *************************\n    /**\n     * sets the output data\n     * @method setOutputData\n     * @param {number} slot\n     * @param {*} data\n     * @memberOf LGraphNode\n     */\n    setOutputData(slot, data) {\n        if (!this.outputs) {\n            return;\n        }\n\n        // this maybe slow and a niche case\n        // if(slot && slot.constructor === String)\n        //\tslot = this.findOutputSlot(slot);\n\n        if (slot == -1 || slot >= this.outputs.length) {\n            return;\n        }\n\n        const output_info = this.outputs[slot];\n        if (!output_info) {\n            return;\n        }\n\n        // store data in the output itself in case we want to debug\n        output_info._data = data;\n\n        // if there are connections, pass the data to the connections\n        if (this.outputs[slot].links) {\n            for (let i = 0; i < this.outputs[slot].links.length; i++) {\n                const link_id = this.outputs[slot].links[i];\n                const link = this.graph.links[link_id];\n                if (link) link.data = data;\n            }\n        }\n    }\n\n    /**\n     * sets the output data type, useful when you want to be able to overwrite the data type\n     * @method setOutputDataType\n     * @param {number} slot\n     * @param {String} datatype\n     * @memberOf LGraphNode\n     */\n    setOutputDataType(slot, type) {\n        if (!this.outputs) {\n            return;\n        }\n        if (slot == -1 || slot >= this.outputs.length) {\n            return;\n        }\n        const output_info = this.outputs[slot];\n        if (!output_info) {\n            return;\n        }\n        // store data in the output itself in case we want to debug\n        output_info.type = type;\n\n        // if there are connections, pass the data to the connections\n        if (this.outputs[slot].links) {\n            for (let i = 0; i < this.outputs[slot].links.length; i++) {\n                const link_id = this.outputs[slot].links[i];\n                this.graph.links[link_id].type = type;\n            }\n        }\n    }\n\n    /**\n     * Retrieves the input data (data traveling through the connection) from one slot\n     * @method getInputData\n     * @param {number} slot\n     * @param {boolean} force_update if set to true it will force the connected node of this slot\n     *     to output data into this link\n     * @return {*} data or if it is not connected returns undefined\n     * @memberOf LGraphNode\n     */\n    getInputData(slot, force_update) {\n        if (!this.inputs) {\n            return;\n        } // undefined;\n\n        if (slot >= this.inputs.length || this.inputs[slot].link == null) {\n            return;\n        }\n\n        const link_id = this.inputs[slot].link;\n        const link = this.graph.links[link_id];\n        if (!link) {\n            // bug: weird case but it happens sometimes\n            return null;\n        }\n\n        if (!force_update) {\n            return link.data;\n        }\n\n        // special case: used to extract data from the incoming connection before the graph has\n        // been executed\n        const node = this.graph.getNodeById(link.origin_id);\n        if (!node) {\n            return link.data;\n        }\n\n        if (node.updateOutputData) {\n            node.updateOutputData(link.origin_slot);\n        } else if (node.onExecute) {\n            node.onExecute();\n        }\n\n        return link.data;\n    }\n\n    /**\n     * Retrieves the input data type (in case this supports multiple input types)\n     * @method getInputDataType\n     * @param {number} slot\n     * @return {String} datatype in string format\n     * @memberOf LGraphNode\n     */\n    getInputDataType(slot) {\n        if (!this.inputs) {\n            return null;\n        } // undefined;\n\n        if (slot >= this.inputs.length || this.inputs[slot].link == null) {\n            return null;\n        }\n        const link_id = this.inputs[slot].link;\n        const link = this.graph.links[link_id];\n        if (!link) {\n            // bug: weird case but it happens sometimes\n            return null;\n        }\n        const node = this.graph.getNodeById(link.origin_id);\n        if (!node) {\n            return link.type;\n        }\n        const output_info = node.outputs[link.origin_slot];\n        if (output_info) {\n            return output_info.type;\n        }\n        return null;\n    }\n\n    /**\n     * Retrieves the input data from one slot using its name instead of slot number\n     * @method getInputDataByName\n     * @param {String} slot_name\n     * @param {boolean} force_update if set to true it will force the connected node of this slot\n     *     to output data into this link\n     * @return {*} data or if it is not connected returns null\n     * @memberOf LGraphNode\n     */\n    getInputDataByName(\n        slot_name,\n        force_update,\n    ) {\n        const slot = this.findInputSlot(slot_name);\n        if (slot == -1) {\n            return null;\n        }\n        return this.getInputData(slot, force_update);\n    }\n\n    /**\n     * tells you if there is a connection in one input slot\n     * @method isInputConnected\n     * @param {number} slot\n     * @return {boolean}\n     * @memberOf LGraphNode\n     */\n    isInputConnected(slot) {\n        if (!this.inputs) {\n            return false;\n        }\n        return slot < this.inputs.length && this.inputs[slot].link != null;\n    }\n\n    /**\n     * tells you info about an input connection (which node, type, etc)\n     * @method getInputInfo\n     * @param {number} slot\n     * @return {Object} object or null { link: id, name: string, type: string or 0 }\n     * @memberOf LGraphNode\n     */\n    getInputInfo(slot) {\n        if (!this.inputs) {\n            return null;\n        }\n        if (slot < this.inputs.length) {\n            return this.inputs[slot];\n        }\n        return null;\n    }\n\n    /**\n     * Returns the link info in the connection of an input slot\n     * @method getInputLink\n     * @param {number} slot\n     * @return {LLink} object or null\n     * @memberOf LGraphNode\n     */\n    getInputLink(slot) {\n        if (!this.inputs) {\n            return null;\n        }\n        if (slot < this.inputs.length) {\n            const slot_info = this.inputs[slot];\n            return this.graph.links[slot_info.link];\n        }\n        return null;\n    }\n\n    /**\n     * returns the node connected in the input slot\n     * @method getInputNode\n     * @param {number} slot\n     * @return {LGraphNode} node or null\n     * @memberOf LGraphNode\n     */\n    getInputNode(slot) {\n        if (!this.inputs) {\n            return null;\n        }\n        if (slot >= this.inputs.length) {\n            return null;\n        }\n        const input = this.inputs[slot];\n        if (!input || input.link === null) {\n            return null;\n        }\n        const link_info = this.graph.links[input.link];\n        if (!link_info) {\n            return null;\n        }\n        return this.graph.getNodeById(link_info.origin_id);\n    }\n\n    /**\n     * returns the value of an input with this name, otherwise checks if there is a property with\n     * that name\n     * @method getInputOrProperty\n     * @param {string} name\n     * @return {*} value\n     * @memberOf LGraphNode\n     */\n    getInputOrProperty(name) {\n        if (!this.inputs || !this.inputs.length) {\n            return this.properties ? this.properties[name] : null;\n        }\n\n        for (let i = 0, l = this.inputs.length; i < l; ++i) {\n            const input_info = this.inputs[i];\n            if (name == input_info.name && input_info.link != null) {\n                const link = this.graph.links[input_info.link];\n                if (link) {\n                    return link.data;\n                }\n            }\n        }\n        return this.properties[name];\n    }\n\n    /**\n     * tells you the last output data that went in that slot\n     * @method getOutputData\n     * @param {number} slot\n     * @return {Object}  object or null\n     * @memberOf LGraphNode\n     */\n    getOutputData(slot) {\n        if (!this.outputs) {\n            return null;\n        }\n        if (slot >= this.outputs.length) {\n            return null;\n        }\n\n        const info = this.outputs[slot];\n        return info._data;\n    }\n\n    /**\n     * tells you info about an output connection (which node, type, etc)\n     * @method getOutputInfo\n     * @param {number} slot\n     * @return {Object}  object or null { name: string, type: string, links: [ ids of links in\n     *     number ] }\n     * @memberOf LGraphNode\n     */\n    getOutputInfo(slot) {\n        if (!this.outputs) {\n            return null;\n        }\n        if (slot < this.outputs.length) {\n            return this.outputs[slot];\n        }\n        return null;\n    }\n\n    /**\n     * tells you if there is a connection in one output slot\n     * @method isOutputConnected\n     * @param {number} slot\n     * @return {boolean}\n     * @memberOf LGraphNode\n     */\n    isOutputConnected(slot) {\n        if (!this.outputs) {\n            return false;\n        }\n        return (\n            slot < this.outputs.length\n            && this.outputs[slot].links\n            && this.outputs[slot].links.length\n        );\n    }\n\n    /**\n     * tells you if there is any connection in the output slots\n     * @method isAnyOutputConnected\n     * @return {boolean}\n     * @memberOf LGraphNode\n     */\n    isAnyOutputConnected() {\n        if (!this.outputs) {\n            return false;\n        }\n        for (let i = 0; i < this.outputs.length; ++i) {\n            if (this.outputs[i].links && this.outputs[i].links.length) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * retrieves all the nodes connected to this output slot\n     * @method getOutputNodes\n     * @param {number} slot\n     * @return {array}\n     * @memberOf LGraphNode\n     */\n    getOutputNodes(slot) {\n        if (!this.outputs || this.outputs.length == 0) {\n            return null;\n        }\n\n        if (slot >= this.outputs.length) {\n            return null;\n        }\n\n        const output = this.outputs[slot];\n        if (!output.links || output.links.length == 0) {\n            return null;\n        }\n\n        const r = [];\n        for (let i = 0; i < output.links.length; i++) {\n            const link_id = output.links[i];\n            const link = this.graph.links[link_id];\n            if (link) {\n                const target_node = this.graph.getNodeById(link.target_id);\n                if (target_node) {\n                    r.push(target_node);\n                }\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Triggers an event in this node, this will trigger any output with the same name\n     * @method trigger\n     * @param {String} event name ( \"on_play\", ... ) if action is equivalent to false then the\n     *     event is send to all\n     * @param {*} param\n     * @memberOf LGraphNode\n     */\n    trigger(action, param) {\n        if (!this.outputs || !this.outputs.length) {\n            return;\n        }\n\n        if (this.graph) this.graph._last_trigger_time = getTime();\n\n        for (let i = 0; i < this.outputs.length; ++i) {\n            const output = this.outputs[i];\n            if (!output || output.type !== defaultConfig.EVENT || (action && output.name != action)) continue;\n            this.triggerSlot(i, param);\n        }\n    }\n\n    /**\n     * Triggers an slot event in this node\n     * @method triggerSlot\n     * @param {Number} slot the index of the output slot\n     * @param {*} param\n     * @param {Number} link_id [optional] in case you want to trigger and specific output link in a\n     *     slot\n     * @memberOf LGraphNode\n     */\n    triggerSlot(slot, param, link_id) {\n        if (!this.outputs) {\n            return;\n        }\n\n        const output = this.outputs[slot];\n        if (!output) {\n            return;\n        }\n\n        const { links } = output;\n        if (!links || !links.length) {\n            return;\n        }\n\n        if (this.graph) {\n            this.graph._last_trigger_time = getTime();\n        }\n\n        // for every link attached here\n        for (let k = 0; k < links.length; ++k) {\n            const id = links[k];\n            if (link_id != null && link_id != id) {\n                // to skip links\n                continue;\n            }\n            const link_info = this.graph.links[links[k]];\n            if (!link_info) {\n                // not connected\n                continue;\n            }\n            link_info._last_time = getTime();\n            const node = this.graph.getNodeById(link_info.target_id);\n            if (!node) {\n                // node not found?\n                continue;\n            }\n\n            // used to mark events in graph\n            const target_connection = node.inputs[link_info.target_slot];\n\n            if (node.mode === defaultConfig.ON_TRIGGER) {\n                if (node.onExecute) {\n                    node.onExecute(param);\n                }\n            } else if (node.onAction) {\n                node.onAction(target_connection.name, param);\n            }\n        }\n    }\n\n    /**\n     * clears the trigger slot animation\n     * @method clearTriggeredSlot\n     * @param {Number} slot the index of the output slot\n     * @param {Number} link_id [optional] in case you want to trigger and specific output link in a\n     *     slot\n     * @memberOf LGraphNode\n     */\n    clearTriggeredSlot(slot, link_id) {\n        if (!this.outputs) {\n            return;\n        }\n\n        const output = this.outputs[slot];\n        if (!output) {\n            return;\n        }\n\n        const { links } = output;\n        if (!links || !links.length) {\n            return;\n        }\n\n        // for every link attached here\n        for (let k = 0; k < links.length; ++k) {\n            const id = links[k];\n            if (link_id != null && link_id != id) {\n                // to skip links\n                continue;\n            }\n            const link_info = this.graph.links[links[k]];\n            if (!link_info) {\n                // not connected\n                continue;\n            }\n            link_info._last_time = 0;\n        }\n    }\n\n    /**\n     * changes node size and triggers callback\n     * @method setSize\n     * @param {vec2} size\n     * @memberOf LGraphNode\n     */\n    setSize(size) {\n        this.size = size;\n        if (this.onResize) this.onResize(this.size);\n    }\n\n    /**\n     * add a new property to this node\n     * @method addProperty\n     * @param {string} name\n     * @param {*} default_value\n     * @param {string} type string defining the output type (\"vec3\",\"number\",...)\n     * @param {Object} extra_info this can be used to have special properties of the property (like\n     *     values, etc)\n     * @memberOf LGraphNode\n     */\n    addProperty(\n        name,\n        default_value,\n        type,\n        extra_info,\n    ) {\n        const o = {\n            name,\n            type,\n            default_value,\n        };\n        if (extra_info) {\n            for (const i in extra_info) {\n                o[i] = extra_info[i];\n            }\n        }\n        if (!this.properties_info) {\n            this.properties_info = [];\n        }\n        this.properties_info.push(o);\n        if (!this.properties) {\n            this.properties = {};\n        }\n        this.properties[name] = default_value;\n        return o;\n    }\n\n    // connections\n\n    /**\n     * add a new output slot to use in this node\n     * @method addOutput\n     * @param {string} name\n     * @param {string} type string defining the output type (\"vec3\",\"number\",...)\n     * @param {Object} extra_info this can be used to have special properties of an output (label,\n     *     special color, position, etc)\n     * @memberOf LGraphNode\n     */\n    addOutput(name, type, extra_info) {\n        const o = {\n            name,\n            type,\n            links: null,\n        };\n        if (extra_info) {\n            for (const i in extra_info) {\n                o[i] = extra_info[i];\n            }\n        }\n\n        if (!this.outputs) {\n            this.outputs = [];\n        }\n        this.outputs.push(o);\n        if (this.onOutputAdded) {\n            this.onOutputAdded(o);\n        }\n        this.setSize(this.computeSize());\n        this.setDirtyCanvas(true, true);\n        return o;\n    }\n\n    /**\n     * add a new output slot to use in this node\n     * @method addOutputs\n     * @param {Array} array of triplets like [[name,type,extra_info],[...]]\n     * @memberOf LGraphNode\n     */\n    addOutputs(array) {\n        for (let i = 0; i < array.length; ++i) {\n            const info = array[i];\n            const o = {\n                name: info[0],\n                type: info[1],\n                link: null,\n            };\n            if (array[2]) {\n                for (const j in info[2]) {\n                    o[j] = info[2][j];\n                }\n            }\n\n            if (!this.outputs) {\n                this.outputs = [];\n            }\n            this.outputs.push(o);\n            if (this.onOutputAdded) {\n                this.onOutputAdded(o);\n            }\n        }\n\n        this.setSize(this.computeSize());\n        this.setDirtyCanvas(true, true);\n    }\n\n    /**\n     * remove an existing output slot\n     * @method removeOutput\n     * @param {number} slot\n     * @memberOf LGraphNode\n     */\n    removeOutput(slot) {\n        this.disconnectOutput(slot);\n        this.outputs.splice(slot, 1);\n        for (let i = slot; i < this.outputs.length; ++i) {\n            if (!this.outputs[i] || !this.outputs[i].links) {\n                continue;\n            }\n            const { links } = this.outputs[i];\n            for (let j = 0; j < links.length; ++j) {\n                const link = this.graph.links[links[j]];\n                if (!link) {\n                    continue;\n                }\n                link.origin_slot -= 1;\n            }\n        }\n\n        this.setSize(this.computeSize());\n        if (this.onOutputRemoved) {\n            this.onOutputRemoved(slot);\n        }\n        this.setDirtyCanvas(true, true);\n    }\n\n    /**\n     * add a new input slot to use in this node\n     * @method addInput\n     * @param {string} name\n     * @param {string} type string defining the input type (\"vec3\",\"number\",...), it its a generic\n     *     one use 0\n     * @param {Object} extra_info this can be used to have special properties of an input (label,\n     *     color, position, etc)\n     * @memberOf LGraphNode\n     */\n    addInput(name, type, extra_info) {\n        type = type || 0;\n        const o = {\n            name,\n            type,\n            link: null,\n        };\n        if (extra_info) {\n            for (const i in extra_info) {\n                o[i] = extra_info[i];\n            }\n        }\n\n        if (!this.inputs) {\n            this.inputs = [];\n        }\n\n        this.inputs.push(o);\n        this.setSize(this.computeSize());\n\n        if (this.onInputAdded) {\n            this.onInputAdded(o);\n        }\n\n        this.setDirtyCanvas(true, true);\n        return o;\n    }\n\n    /**\n     * add several new input slots in this node\n     * @method addInputs\n     * @param {Array} array of triplets like [[name,type,extra_info],[...]]\n     * @memberOf LGraphNode\n     */\n    addInputs(array) {\n        for (let i = 0; i < array.length; ++i) {\n            const info = array[i];\n            const o = {\n                name: info[0],\n                type: info[1],\n                link: null,\n            };\n            if (array[2]) {\n                for (const j in info[2]) {\n                    o[j] = info[2][j];\n                }\n            }\n\n            if (!this.inputs) {\n                this.inputs = [];\n            }\n            this.inputs.push(o);\n            if (this.onInputAdded) {\n                this.onInputAdded(o);\n            }\n        }\n\n        this.setSize(this.computeSize());\n        this.setDirtyCanvas(true, true);\n    }\n\n    /**\n     * remove an existing input slot\n     * @method removeInput\n     * @param {number} slot\n     * @memberOf LGraphNode\n     */\n    removeInput(slot) {\n        this.disconnectInput(slot);\n        const slot_info = this.inputs.splice(slot, 1);\n        for (let i = slot; i < this.inputs.length; ++i) {\n            if (!this.inputs[i]) {\n                continue;\n            }\n            const link = this.graph.links[this.inputs[i].link];\n            if (!link) {\n                continue;\n            }\n            link.target_slot -= 1;\n        }\n        this.setSize(this.computeSize());\n        if (this.onInputRemoved) {\n            this.onInputRemoved(slot, slot_info[0]);\n        }\n        this.setDirtyCanvas(true, true);\n    }\n\n    /**\n     * add an special connection to this node (used for special kinds of graphs)\n     * @method addConnection\n     * @param {string} name\n     * @param {string} type string defining the input type (\"vec3\",\"number\",...)\n     * @param {number[]} pos position of the connection inside the node\n     * @param {string} direction if is input or output\n     * @memberOf LGraphNode\n     */\n    addConnection(name, type, pos, direction) {\n        const o = {\n            name,\n            type,\n            pos,\n            direction,\n            links: null,\n        };\n        this.connections.push(o);\n        return o;\n    }\n\n    /**\n     * computes the minimum size of a node according to its inputs and output slots\n     * @method computeSize\n     * @param {number} minHeight\n     * @return {number} the total size\n     * @memberOf LGraphNode\n     */\n    computeSize(out) {\n        if (this.constructor.size) {\n            return this.constructor.size.concat();\n        }\n\n        let rows = Math.max(\n            this.inputs ? this.inputs.length : 1,\n            this.outputs ? this.outputs.length : 1,\n        );\n        const size = out || new Float32Array([0, 0]);\n        rows = Math.max(rows, 1);\n        var font_size = defaultConfig.NODE_TEXT_SIZE; // although it should be\n        // graphcanvas.inner_text_font size\n\n        var font_size = font_size;\n        const title_width = compute_text_size(this.title);\n        let input_width = 0;\n        let output_width = 0;\n\n        if (this.inputs) {\n            for (var i = 0, l = this.inputs.length; i < l; ++i) {\n                const input = this.inputs[i];\n                var text = input.label || input.name || \"\";\n                var text_width = compute_text_size(text);\n                if (input_width < text_width) {\n                    input_width = text_width;\n                }\n            }\n        }\n\n        if (this.outputs) {\n            for (var i = 0, l = this.outputs.length; i < l; ++i) {\n                const output = this.outputs[i];\n                var text = output.label || output.name || \"\";\n                var text_width = compute_text_size(text);\n                if (output_width < text_width) {\n                    output_width = text_width;\n                }\n            }\n        }\n\n        size[0] = Math.max(input_width + output_width + 10, title_width);\n        size[0] = Math.max(size[0], defaultConfig.NODE_WIDTH);\n        if (this.widgets && this.widgets.length) {\n            size[0] = Math.max(size[0], defaultConfig.NODE_WIDTH * 1.5);\n        }\n\n        size[1] = (this.constructor.slot_start_y || 0) + rows * defaultConfig.NODE_SLOT_HEIGHT;\n\n        let widgets_height = 0;\n        if (this.widgets && this.widgets.length) {\n            for (var i = 0, l = this.widgets.length; i < l; ++i) {\n                if (this.widgets[i].computeSize) {\n                    widgets_height += this.widgets[i].computeSize(size[0])[1] + 4;\n                } else {\n                    widgets_height += defaultConfig.NODE_WIDGET_HEIGHT + 4;\n                }\n            }\n            widgets_height += 8;\n        }\n\n        // compute height using widgets height\n        if (this.widgets_up) {\n            size[1] = Math.max(size[1], widgets_height);\n        } else if (this.widgets_start_y != null) {\n            size[1] = Math.max(size[1], widgets_height + this.widgets_start_y);\n        } else {\n            size[1] += widgets_height;\n        }\n\n        function compute_text_size(text) {\n            if (!text) {\n                return 0;\n            }\n            return font_size * text.length * 0.6;\n        }\n\n        if (\n            this.constructor.min_height\n            && size[1] < this.constructor.min_height\n        ) {\n            size[1] = this.constructor.min_height;\n        }\n\n        size[1] += 6; // margin\n\n        return size;\n    }\n\n    /**\n     * returns all the info available about a property of this node.\n     *\n     * @method getPropertyInfo\n     * @param {String} property name of the property\n     * @return {Object} the object with all the available info\n     * @memberOf LGraphNode\n     */\n    getPropertyInfo(property) {\n        let info = null;\n\n        // there are several ways to define info about a property\n        // legacy mode\n        if (this.properties_info) {\n            for (let i = 0; i < this.properties_info.length; ++i) {\n                if (this.properties_info[i].name == property) {\n                    info = this.properties_info[i];\n                    break;\n                }\n            }\n        }\n        // litescene mode using the constructor\n        if (this.constructor[`@${property}`]) info = this.constructor[`@${property}`];\n\n        if (this.constructor.widgets_info && this.constructor.widgets_info[property]) info = this.constructor.widgets_info[property];\n\n        // litescene mode using the constructor\n        if (!info && this.onGetPropertyInfo) {\n            info = this.onGetPropertyInfo(property);\n        }\n\n        if (!info) info = {};\n        if (!info.type) info.type = typeof this.properties[property];\n        if (info.widget == \"combo\") info.type = \"enum\";\n\n        return info;\n    }\n\n    /**\n     * Defines a widget inside the node, it will be rendered on top of the node, you can control\n     * lots of properties\n     *\n     * @method addWidget\n     * @param {String} type the widget type (could be \"number\",\"string\",\"combo\"\n     * @param {String} name the text to show on the widget\n     * @param {String} value the default value\n     * @param {Function|String} callback function to call when it changes (optionally, it can be\n     *     the name of the property to modify)\n     * @param {Object} options the object that contains special properties of this widget\n     * @return {Object} the created widget object\n     * @memberOf LGraphNode\n     */\n    addWidget(type, name, value, callback, options) {\n        if (!this.widgets) {\n            this.widgets = [];\n        }\n\n        if (!options && callback && callback.constructor === Object) {\n            options = callback;\n            callback = null;\n        }\n\n        if (options && options.constructor === String) // options can be the property name\n        {\n            options = { property: options };\n        }\n\n        if (callback && callback.constructor === String) // callback can be the property name\n        {\n            if (!options) options = {};\n            options.property = callback;\n            callback = null;\n        }\n\n        if (callback && callback.constructor !== Function) {\n            console.warn(\"addWidget: callback must be a function\");\n            callback = null;\n        }\n\n        const w = {\n            type: type.toLowerCase(),\n            name,\n            value,\n            callback,\n            options: options || {},\n        };\n\n        if (w.options.y) {\n            w.y = w.options.y;\n        }\n\n        if (!callback && !w.options.callback && !w.options.property) {\n            console.warn(\"LiteGraph addWidget(...) without a callback or property assigned\");\n        }\n        if (type == \"combo\" && !w.options.values) {\n            throw \"LiteGraph addWidget('combo',...) requires to pass values in options: { values:['red','blue'] }\";\n        }\n        this.widgets.push(w);\n        this.setSize(this.computeSize());\n        return w;\n    }\n\n    addCustomWidget(custom_widget) {\n        if (!this.widgets) {\n            this.widgets = [];\n        }\n        this.widgets.push(custom_widget);\n        return custom_widget;\n    }\n\n    /**\n     * returns the bounding of the object, used for rendering purposes\n     * bounding is: [topleft_cornerx, topleft_cornery, width, height]\n     * @method getBounding\n     * @return {Float32Array} the total size\n     * @memberOf LGraphNode\n     */\n    getBounding(out) {\n        out = out || new Float32Array(4);\n        out[0] = this.pos[0] - 4;\n        out[1] = this.pos[1] - defaultConfig.NODE_TITLE_HEIGHT;\n        out[2] = this.size[0] + 4;\n        out[3] = this.size[1] + defaultConfig.NODE_TITLE_HEIGHT;\n\n        if (this.onBounding) {\n            this.onBounding(out);\n        }\n        return out;\n    }\n\n    /**\n     * checks if a point is inside the shape of a node\n     * @method isPointInside\n     * @param {number} x\n     * @param {number} y\n     * @return {boolean}\n     * @memberOf LGraphNode\n     */\n    isPointInside(x, y, margin, skip_title) {\n        margin = margin || 0;\n\n        let margin_top = this.graph && this.graph.isLive() ? 0 : defaultConfig.NODE_TITLE_HEIGHT;\n        if (skip_title) {\n            margin_top = 0;\n        }\n        if (this.flags && this.flags.collapsed) {\n            // if ( distance([x,y], [this.pos[0] + this.size[0]*0.5, this.pos[1] +\n            // this.size[1]*0.5]) < LiteGraph.NODE_COLLAPSED_RADIUS)\n            if (\n                isInsideRectangle(\n                    x,\n                    y,\n                    this.pos[0] - margin,\n                    this.pos[1] - defaultConfig.NODE_TITLE_HEIGHT - margin,\n                    (this._collapsed_width || defaultConfig.NODE_COLLAPSED_WIDTH)\n                    + 2 * margin,\n                    defaultConfig.NODE_TITLE_HEIGHT + 2 * margin,\n                )\n            ) {\n                return true;\n            }\n        } else if (\n            this.pos[0] - 4 - margin < x\n            && this.pos[0] + this.size[0] + 4 + margin > x\n            && this.pos[1] - margin_top - margin < y\n            && this.pos[1] + this.size[1] + margin > y\n        ) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * checks if a point is inside a node slot, and returns info about which slot\n     * @method getSlotInPosition\n     * @param {number} x\n     * @param {number} y\n     * @return {Object} if found the object contains { input|output: slot object, slot: number,\n     *     link_pos: [x,y] }\n     * @memberOf LGraphNode\n     */\n    getSlotInPosition(x, y) {\n        // search for inputs\n        const link_pos = new Float32Array(2);\n        if (this.inputs) {\n            for (var i = 0, l = this.inputs.length; i < l; ++i) {\n                const input = this.inputs[i];\n                this.getConnectionPos(true, i, link_pos);\n                if (\n                    isInsideRectangle(\n                        x,\n                        y,\n                        link_pos[0] - 10,\n                        link_pos[1] - 5,\n                        20,\n                        10,\n                    )\n                ) {\n                    return {\n                        input,\n                        slot: i,\n                        link_pos,\n                    };\n                }\n            }\n        }\n\n        if (this.outputs) {\n            for (var i = 0, l = this.outputs.length; i < l; ++i) {\n                const output = this.outputs[i];\n                this.getConnectionPos(false, i, link_pos);\n                if (\n                    isInsideRectangle(\n                        x,\n                        y,\n                        link_pos[0] - 10,\n                        link_pos[1] - 5,\n                        20,\n                        10,\n                    )\n                ) {\n                    return {\n                        output,\n                        slot: i,\n                        link_pos,\n                    };\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * returns the input slot with a given name (used for dynamic slots), -1 if not found\n     * @method findInputSlot\n     * @param {string} name the name of the slot\n     * @return {number} the slot (-1 if not found)\n     * @memberOf LGraphNode\n     */\n    findInputSlot(name) {\n        if (!this.inputs) {\n            return -1;\n        }\n        for (let i = 0, l = this.inputs.length; i < l; ++i) {\n            if (name == this.inputs[i].name) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * returns the output slot with a given name (used for dynamic slots), -1 if not found\n     * @method findOutputSlot\n     * @param {string} name the name of the slot\n     * @return {number} the slot (-1 if not found)\n     * @memberOf LGraphNode\n     */\n    findOutputSlot(name) {\n        if (!this.outputs) {\n            return -1;\n        }\n        for (let i = 0, l = this.outputs.length; i < l; ++i) {\n            if (name == this.outputs[i].name) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * connect this node output to the input of another node\n     * @method connect\n     * @param {number_or_string} slot (could be the number of the slot or the string with the name\n     *     of the slot)\n     * @param {LGraphNode} node the target node\n     * @param {number_or_string} target_slot the input slot of the target node (could be the number\n     *     of the slot or the string with the name of the slot, or -1 to connect a trigger)\n     * @return {Object} the link_info is created, otherwise null\n     * @memberOf LGraphNode\n     */\n    connect(slot, target_node, target_slot) {\n        target_slot = target_slot || 0;\n\n        if (!this.graph) {\n            // could be connected before adding it to a graph\n            console.log(\n                \"Connect: Error, node doesn't belong to any graph. Nodes must be added first to a graph before connecting them.\",\n            ); // due to link ids being associated with graphs\n            return null;\n        }\n\n        // seek for the output slot\n        if (slot.constructor === String) {\n            slot = this.findOutputSlot(slot);\n            if (slot == -1) {\n                if (defaultConfig.debug) {\n                    console.log(`Connect: Error, no slot of name ${slot}`);\n                }\n                return null;\n            }\n        } else if (!this.outputs || slot >= this.outputs.length) {\n            if (defaultConfig.debug) {\n                console.log(\"Connect: Error, slot number not found\");\n            }\n            return null;\n        }\n\n        if (target_node && target_node.constructor === Number) {\n            target_node = this.graph.getNodeById(target_node);\n        }\n        if (!target_node) {\n            throw \"target node is null\";\n        }\n\n        // avoid loopback\n        if (target_node == this) {\n            return null;\n        }\n\n        // you can specify the slot by name\n        if (target_slot.constructor === String) {\n            target_slot = target_node.findInputSlot(target_slot);\n            if (target_slot == -1) {\n                if (defaultConfig.debug) {\n                    console.log(\n                        `Connect: Error, no slot of name ${target_slot}`,\n                    );\n                }\n                return null;\n            }\n        } else if (target_slot === defaultConfig.EVENT) {\n            // search for first slot with event?\n            /*\n    //create input for trigger\n    var input = target_node.addInput(\"onTrigger\", LiteGraph.EVENT );\n    target_slot = target_node.inputs.length - 1; //last one is the one created\n    target_node.mode = LiteGraph.ON_TRIGGER;\n    */\n            return null;\n        } else if (\n            !target_node.inputs\n            || target_slot >= target_node.inputs.length\n        ) {\n            if (defaultConfig.debug) {\n                console.log(\"Connect: Error, slot number not found\");\n            }\n            return null;\n        }\n\n        let changed = false;\n\n        // if there is something already plugged there, disconnect\n        if (target_node.inputs[target_slot].link != null) {\n            this.graph.beforeChange();\n            target_node.disconnectInput(target_slot);\n            changed = true;\n        }\n\n        // why here??\n        // this.setDirtyCanvas(false,true);\n        // this.graph.connectionChange( this );\n\n        const output = this.outputs[slot];\n\n        // allows nodes to block connection\n        if (target_node.onConnectInput) {\n            if (target_node.onConnectInput(target_slot, output.type, output, this, slot) === false) {\n                return null;\n            }\n        }\n\n        const input = target_node.inputs[target_slot];\n        let link_info = null;\n\n        // this slots cannot be connected (different types)\n        if (!isValidConnection(output.type, input.type)) {\n            this.setDirtyCanvas(false, true);\n            if (changed) this.graph.connectionChange(this, link_info);\n            return null;\n        }\n\n        if (!changed) this.graph.beforeChange();\n\n        // create link class\n        link_info = new LLink(\n            ++this.graph.last_link_id,\n            input.type,\n            this.id,\n            slot,\n            target_node.id,\n            target_slot,\n        );\n\n        // add to graph links list\n        this.graph.links[link_info.id] = link_info;\n\n        // connect in output\n        if (output.links == null) {\n            output.links = [];\n        }\n        output.links.push(link_info.id);\n        // connect in input\n        target_node.inputs[target_slot].link = link_info.id;\n        if (this.graph) {\n            this.graph._version++;\n        }\n        if (this.onConnectionsChange) {\n            this.onConnectionsChange(\n                defaultConfig.OUTPUT,\n                slot,\n                true,\n                link_info,\n                output,\n            );\n        } // link_info has been created now, so its updated\n        if (target_node.onConnectionsChange) {\n            target_node.onConnectionsChange(\n                defaultConfig.INPUT,\n                target_slot,\n                true,\n                link_info,\n                input,\n            );\n        }\n        if (this.graph && this.graph.onNodeConnectionChange) {\n            this.graph.onNodeConnectionChange(\n                defaultConfig.INPUT,\n                target_node,\n                target_slot,\n                this,\n                slot,\n            );\n            this.graph.onNodeConnectionChange(\n                defaultConfig.OUTPUT,\n                this,\n                slot,\n                target_node,\n                target_slot,\n            );\n        }\n\n        this.setDirtyCanvas(false, true);\n        this.graph.afterChange();\n        this.graph.connectionChange(this, link_info);\n\n        return link_info;\n    }\n\n    /**\n     * disconnect one output to an specific node\n     * @method disconnectOutput\n     * @param {number_or_string} slot (could be the number of the slot or the string with the name\n     *     of the slot)\n     * @param {LGraphNode} target_node the target node to which this slot is connected [Optional,\n     *     if not target_node is specified all nodes will be disconnected]\n     * @return {boolean} if it was disconnected successfully\n     * @memberOf LGraphNode\n     */\n    disconnectOutput(slot, target_node) {\n        if (slot.constructor === String) {\n            slot = this.findOutputSlot(slot);\n            if (slot == -1) {\n                if (defaultConfig.debug) {\n                    console.log(`Connect: Error, no slot of name ${slot}`);\n                }\n                return false;\n            }\n        } else if (!this.outputs || slot >= this.outputs.length) {\n            if (defaultConfig.debug) {\n                console.log(\"Connect: Error, slot number not found\");\n            }\n            return false;\n        }\n\n        // get output slot\n        const output = this.outputs[slot];\n        if (!output || !output.links || output.links.length == 0) {\n            return false;\n        }\n\n        // one of the output links in this slot\n        if (target_node) {\n            if (target_node.constructor === Number) {\n                target_node = this.graph.getNodeById(target_node);\n            }\n            if (!target_node) {\n                throw \"Target Node not found\";\n            }\n\n            for (var i = 0, l = output.links.length; i < l; i++) {\n                var link_id = output.links[i];\n                var link_info = this.graph.links[link_id];\n\n                // is the link we are searching for...\n                if (link_info.target_id == target_node.id) {\n                    output.links.splice(i, 1); // remove here\n                    var input = target_node.inputs[link_info.target_slot];\n                    input.link = null; // remove there\n                    delete this.graph.links[link_id]; // remove the link from the links pool\n                    if (this.graph) {\n                        this.graph._version++;\n                    }\n                    if (target_node.onConnectionsChange) {\n                        target_node.onConnectionsChange(\n                            defaultConfig.INPUT,\n                            link_info.target_slot,\n                            false,\n                            link_info,\n                            input,\n                        );\n                    } // link_info hasn't been modified so its ok\n                    if (this.onConnectionsChange) {\n                        this.onConnectionsChange(\n                            defaultConfig.OUTPUT,\n                            slot,\n                            false,\n                            link_info,\n                            output,\n                        );\n                    }\n                    if (this.graph && this.graph.onNodeConnectionChange) {\n                        this.graph.onNodeConnectionChange(\n                            defaultConfig.OUTPUT,\n                            this,\n                            slot,\n                        );\n                    }\n                    if (this.graph && this.graph.onNodeConnectionChange) {\n                        this.graph.onNodeConnectionChange(\n                            defaultConfig.OUTPUT,\n                            this,\n                            slot,\n                        );\n                        this.graph.onNodeConnectionChange(\n                            defaultConfig.INPUT,\n                            target_node,\n                            link_info.target_slot,\n                        );\n                    }\n                    break;\n                }\n            }\n        } // all the links in this output slot\n        else {\n            for (var i = 0, l = output.links.length; i < l; i++) {\n                var link_id = output.links[i];\n                var link_info = this.graph.links[link_id];\n                if (!link_info) {\n                    // bug: it happens sometimes\n                    continue;\n                }\n\n                var target_node = this.graph.getNodeById(link_info.target_id);\n                var input = null;\n                if (this.graph) {\n                    this.graph._version++;\n                }\n                if (target_node) {\n                    input = target_node.inputs[link_info.target_slot];\n                    input.link = null; // remove other side link\n                    if (target_node.onConnectionsChange) {\n                        target_node.onConnectionsChange(\n                            defaultConfig.INPUT,\n                            link_info.target_slot,\n                            false,\n                            link_info,\n                            input,\n                        );\n                    } // link_info hasn't been modified so its ok\n                    if (this.graph && this.graph.onNodeConnectionChange) {\n                        this.graph.onNodeConnectionChange(\n                            defaultConfig.INPUT,\n                            target_node,\n                            link_info.target_slot,\n                        );\n                    }\n                }\n                delete this.graph.links[link_id]; // remove the link from the links pool\n                if (this.onConnectionsChange) {\n                    this.onConnectionsChange(\n                        defaultConfig.OUTPUT,\n                        slot,\n                        false,\n                        link_info,\n                        output,\n                    );\n                }\n                if (this.graph && this.graph.onNodeConnectionChange) {\n                    this.graph.onNodeConnectionChange(\n                        defaultConfig.OUTPUT,\n                        this,\n                        slot,\n                    );\n                    this.graph.onNodeConnectionChange(\n                        defaultConfig.INPUT,\n                        target_node,\n                        link_info.target_slot,\n                    );\n                }\n            }\n            output.links = null;\n        }\n\n        this.setDirtyCanvas(false, true);\n        this.graph.connectionChange(this);\n        return true;\n    }\n\n    /**\n     * disconnect one input\n     * @method disconnectInput\n     * @param {number_or_string} slot (could be the number of the slot or the string with the name\n     *     of the slot)\n     * @return {boolean} if it was disconnected successfully\n     * @memberOf LGraphNode\n     */\n    disconnectInput(slot) {\n        // seek for the output slot\n        if (slot.constructor === String) {\n            slot = this.findInputSlot(slot);\n            if (slot == -1) {\n                if (defaultConfig.debug) {\n                    console.log(`Connect: Error, no slot of name ${slot}`);\n                }\n                return false;\n            }\n        } else if (!this.inputs || slot >= this.inputs.length) {\n            if (defaultConfig.debug) {\n                console.log(\"Connect: Error, slot number not found\");\n            }\n            return false;\n        }\n\n        const input = this.inputs[slot];\n        if (!input) {\n            return false;\n        }\n\n        const link_id = this.inputs[slot].link;\n        if (link_id != null) {\n            this.inputs[slot].link = null;\n\n            // remove other side\n            const link_info = this.graph.links[link_id];\n            if (link_info) {\n                const target_node = this.graph.getNodeById(link_info.origin_id);\n                if (!target_node) {\n                    return false;\n                }\n\n                const output = target_node.outputs[link_info.origin_slot];\n                if (!output || !output.links || output.links.length == 0) {\n                    return false;\n                }\n\n                // search in the inputs list for this link\n                for (var i = 0, l = output.links.length; i < l; i++) {\n                    if (output.links[i] == link_id) {\n                        output.links.splice(i, 1);\n                        break;\n                    }\n                }\n\n                delete this.graph.links[link_id]; // remove from the pool\n                if (this.graph) {\n                    this.graph._version++;\n                }\n                if (this.onConnectionsChange) {\n                    this.onConnectionsChange(\n                        defaultConfig.INPUT,\n                        slot,\n                        false,\n                        link_info,\n                        input,\n                    );\n                }\n                if (target_node.onConnectionsChange) {\n                    target_node.onConnectionsChange(\n                        defaultConfig.OUTPUT,\n                        i,\n                        false,\n                        link_info,\n                        output,\n                    );\n                }\n                if (this.graph && this.graph.onNodeConnectionChange) {\n                    this.graph.onNodeConnectionChange(\n                        defaultConfig.OUTPUT,\n                        target_node,\n                        i,\n                    );\n                    this.graph.onNodeConnectionChange(defaultConfig.INPUT, this, slot);\n                }\n            }\n        } // link != null\n\n        this.setDirtyCanvas(false, true);\n        if (this.graph) this.graph.connectionChange(this);\n        return true;\n    }\n\n    /**\n     * returns the center of a connection point in canvas coords\n     * @method getConnectionPos\n     * @param {boolean} is_input true if if a input slot, false if it is an output\n     * @param {number_or_string} slot (could be the number of the slot or the string with the name\n     *     of the slot)\n     * @param {vec2} out [optional] a place to store the output, to free garbage\n     * @return {number[]} the position\n     * @memberOf LGraphNode\n     * */\n    getConnectionPos(\n        is_input,\n        slot_number,\n        out,\n    ) {\n        out = out || new Float32Array(2);\n        let num_slots = 0;\n        if (is_input && this.inputs) {\n            num_slots = this.inputs.length;\n        }\n        if (!is_input && this.outputs) {\n            num_slots = this.outputs.length;\n        }\n\n        const offset = defaultConfig.NODE_SLOT_HEIGHT * 0.5;\n\n        if (this.flags.collapsed) {\n            const w = this._collapsed_width || defaultConfig.NODE_COLLAPSED_WIDTH;\n            if (this.horizontal) {\n                out[0] = this.pos[0] + w * 0.5;\n                if (is_input) {\n                    out[1] = this.pos[1] - defaultConfig.NODE_TITLE_HEIGHT;\n                } else {\n                    out[1] = this.pos[1];\n                }\n            } else {\n                if (is_input) {\n                    out[0] = this.pos[0];\n                } else {\n                    out[0] = this.pos[0] + w;\n                }\n                out[1] = this.pos[1] - defaultConfig.NODE_TITLE_HEIGHT * 0.5;\n            }\n            return out;\n        }\n\n        // weird feature that never got finished\n        if (is_input && slot_number == -1) {\n            out[0] = this.pos[0] + defaultConfig.NODE_TITLE_HEIGHT * 0.5;\n            out[1] = this.pos[1] + defaultConfig.NODE_TITLE_HEIGHT * 0.5;\n            return out;\n        }\n\n        // hard-coded pos\n        if (\n            is_input\n            && num_slots > slot_number\n            && this.inputs[slot_number].pos\n        ) {\n            out[0] = this.pos[0] + this.inputs[slot_number].pos[0];\n            out[1] = this.pos[1] + this.inputs[slot_number].pos[1];\n            return out;\n        }\n        if (\n            !is_input\n            && num_slots > slot_number\n            && this.outputs[slot_number].pos\n        ) {\n            out[0] = this.pos[0] + this.outputs[slot_number].pos[0];\n            out[1] = this.pos[1] + this.outputs[slot_number].pos[1];\n            return out;\n        }\n\n        // horizontal distributed slots\n        if (this.horizontal) {\n            out[0] = this.pos[0] + (slot_number + 0.5) * (this.size[0] / num_slots);\n            if (is_input) {\n                out[1] = this.pos[1] - defaultConfig.NODE_TITLE_HEIGHT;\n            } else {\n                out[1] = this.pos[1] + this.size[1];\n            }\n            return out;\n        }\n\n        // default vertical slots\n        if (is_input) {\n            out[0] = this.pos[0] + offset;\n        } else {\n            out[0] = this.pos[0] + this.size[0] + 1 - offset;\n        }\n        out[1] = this.pos[1]\n            + (slot_number + 0.7) * defaultConfig.NODE_SLOT_HEIGHT\n            + (this.constructor.slot_start_y || 0);\n        return out;\n    }\n\n    /* Force align to grid */\n    alignToGrid() {\n        this.pos[0] = defaultConfig.CANVAS_GRID_SIZE\n            * Math.round(this.pos[0] / defaultConfig.CANVAS_GRID_SIZE);\n        this.pos[1] = defaultConfig.CANVAS_GRID_SIZE\n            * Math.round(this.pos[1] / defaultConfig.CANVAS_GRID_SIZE);\n    }\n\n    /* Console output */\n    trace(msg) {\n        if (!this.console) {\n            this.console = [];\n        }\n\n        this.console.push(msg);\n        if (this.console.length > LGraphNode.MAX_CONSOLE) {\n            this.console.shift();\n        }\n\n        if (this.graph.onNodeTrace) this.graph.onNodeTrace(this, msg);\n    }\n\n    /* Forces to redraw or the main canvas (LGraphNode) or the bg canvas (links) */\n    setDirtyCanvas(\n        dirty_foreground,\n        dirty_background,\n    ) {\n        if (!this.graph) {\n            return;\n        }\n        this.graph.sendActionToCanvas(\"setDirty\", [\n            dirty_foreground,\n            dirty_background,\n        ]);\n    }\n\n    loadImage(url) {\n        const img = new Image();\n        img.src = defaultConfig.node_images_path + url;\n        img.ready = false;\n\n        img.onload = () => {\n            img.ready = true;\n            this.setDirtyCanvas(true);\n        };\n        return img;\n    }\n\n    // safe LGraphNode action execution (not sure if safe)\n    /*\n    executeAction = function(action)\n    {\n    if(action == \"\") return false;\n\n    if( action.indexOf(\";\") != -1 || action.indexOf(\"}\") != -1)\n    {\n    this.trace(\"Error: Action contains unsafe characters\");\n    return false;\n    }\n\n    var tokens = action.split(\"(\");\n    var func_name = tokens[0];\n    if( typeof(this[func_name]) != \"function\")\n    {\n    this.trace(\"Error: Action not found on node: \" + func_name);\n    return false;\n    }\n\n    var code = action;\n\n    try\n    {\n    var _foo = eval;\n    eval = null;\n    (new Function(\"with(this) { \" + code + \"}\")).call(this);\n    eval = _foo;\n    }\n    catch (err)\n    {\n    this.trace(\"Error executing action {\" + action + \"} :\" + err);\n    return false;\n    }\n\n    return true;\n    }\n    */\n\n    /* Allows to get onMouseMove and onMouseUp events even if the mouse is out of focus */\n    captureInput(v) {\n        if (!this.graph || !this.graph.list_of_graphcanvas) {\n            return;\n        }\n\n        const list = this.graph.list_of_graphcanvas;\n\n        for (let i = 0; i < list.length; ++i) {\n            const c = list[i];\n            // releasing somebody elses capture?!\n            if (!v && c.node_capturing_input != this) {\n                continue;\n            }\n\n            // change\n            c.node_capturing_input = v ? this : null;\n        }\n    }\n\n    /**\n     * Collapse the node to make it smaller on the canvas\n     * @method collapse\n     * @memberOf LGraphNode\n     * */\n    collapse(force) {\n        this.graph._version++;\n        if (this.constructor.collapsable === false && !force) {\n            return;\n        }\n        this.flags.collapsed = !this.flags.collapsed;\n        this.setDirtyCanvas(true, true);\n    }\n\n    /**\n     * Forces the node to do not move or realign on Z\n     * @method pin\n     * @memberOf LGraphNode\n     * */\n\n    pin(v) {\n        this.graph._version++;\n        if (v === undefined) {\n            this.flags.pinned = !this.flags.pinned;\n        } else {\n            this.flags.pinned = v;\n        }\n    }\n\n    localToScreen(x, y, graphcanvas) {\n        return [\n            (x + this.pos[0]) * graphcanvas.scale + graphcanvas.offset[0],\n            (y + this.pos[1]) * graphcanvas.scale + graphcanvas.offset[1],\n        ];\n    }\n\n    /**\n     * Create a node of a given type with a name. The node is not attached to any graph yet.\n     * @method createNode\n     * @param {String} type full name of the node class. p.e. \"math/sin\"\n     * @param {String} name a name to distinguish from other nodes\n     * @param {Object} options to set options\n     * @memberOf LGraphNode\n     */\n    static createNode(type, title, options) {\n        const baseClass = defaultConfig.registered_node_types[type];\n        if (!baseClass) {\n            if (defaultConfig.debug) console.log(`GraphNode type \"${type}\" not registered.`);\n            return null;\n        }\n\n        const prototype = baseClass.prototype || baseClass;\n\n        title = title || baseClass.title || type;\n\n        let node = null;\n\n        if (defaultConfig.catch_exceptions) {\n            try {\n                node = new baseClass(title);\n            } catch (err) {\n                console.error(err);\n                return null;\n            }\n        } else {\n            node = new baseClass(title);\n        }\n\n        node.type = type;\n\n        if (!node.title && title) {\n            node.title = title;\n        }\n        if (!node.properties) {\n            node.properties = {};\n        }\n        if (!node.properties_info) {\n            node.properties_info = [];\n        }\n        if (!node.flags) {\n            node.flags = {};\n        }\n        if (!node.size) {\n            node.size = node.computeSize();\n            // call onresize?\n        }\n        if (!node.pos) {\n            node.pos = defaultConfig.DEFAULT_POSITION.concat();\n        }\n        if (!node.mode) {\n            node.mode = defaultConfig.ALWAYS;\n        }\n\n        // extra options\n        if (options) {\n            // eslint-disable-next-line\n            for (const i in options) node[i] = options[i];\n        }\n\n        return node;\n    }\n\n    // debug purposes: reloads all the js scripts that matches a wildcard\n    static reloadNodes(folderWildcard) {\n        const tmp = document.getElementsByTagName(\"script\");\n        // weird, this array changes by its own, so we use a copy\n        const scriptFiles = [];\n        for (const t of tmp) scriptFiles.push(t);\n\n        const docHeadObj = document.getElementsByTagName(\"head\")[0];\n        folderWildcard = document.location.href + folderWildcard;\n\n        for (const script of scriptFiles) {\n            const { src } = script;\n            if (\n                !src\n                || src.substr(0, folderWildcard.length) !== folderWildcard\n            ) continue;\n\n            try {\n                if (defaultConfig.debug) {\n                    console.log(`Reloading: ${src}`);\n                }\n                const dynamicScript = document.createElement(\"script\");\n                dynamicScript.type = \"text/javascript\";\n                dynamicScript.src = src;\n                docHeadObj.appendChild(dynamicScript);\n                docHeadObj.removeChild(scriptFiles[i]);\n            } catch (err) {\n                if (defaultConfig.throw_errors) {\n                    throw err;\n                }\n                if (defaultConfig.debug) console.log(`Error while reloading ${src}`);\n            }\n        }\n\n        if (defaultConfig.debug) {\n            console.log(\"Nodes reloaded\");\n        }\n    }\n\n    /**\n     * Adds this method to all nodetypes, existing and to be created\n     * (You can add it to LGraphNode.prototype but then existing node types wont have it)\n     * @method addNodeMethod\n     * @param {Function} func\n     * @memberOf LGraphNode\n     */\n    static addNodeMethod(name, func) {\n        LGraphNode.prototype[name] = func;\n        for (const i in defaultConfig.registered_node_types) {\n            const type = defaultConfig.registered_node_types[i];\n            if (type.prototype[name]) type.prototype[`_${name}`] = type.prototype[name];\n            type.prototype[name] = func;\n        }\n    }\n\n    static extendNode(object) {\n        for (const i of Object.getOwnPropertyNames(LGraphNode.prototype)) {\n            if (!object.prototype[i]) {\n                object.prototype[i] = LGraphNode.prototype[i];\n            }\n        }\n    }\n\n}\n","import LGraphNode from \"./LGraphNode\";\n\n/**\n * @class LGraphGroup\n * @param title\n */\nexport default class LGraphGroup {\n    constructor(title) {\n        this._ctor(title);\n    }\n\n    _ctor(title) {\n        this.title = title || \"Group\";\n        this.font_size = 24;\n        this.color = \"#AAA\";\n        this._bounding = new Float32Array([10, 10, 140, 80]);\n        this._pos = this._bounding.subarray(0, 2);\n        this._size = this._bounding.subarray(2, 4);\n        this._nodes = [];\n        this.graph = null;\n\n        Object.defineProperty(this, \"pos\", {\n            set(v) {\n                if (!v || v.length < 2) {\n                    return;\n                }\n                this._pos[0] = v[0];\n                this._pos[1] = v[1];\n            },\n            get() {\n                return this._pos;\n            },\n            enumerable: true,\n        });\n\n        Object.defineProperty(this, \"size\", {\n            set(v) {\n                if (!v || v.length < 2) {\n                    return;\n                }\n                this._size[0] = Math.max(140, v[0]);\n                this._size[1] = Math.max(80, v[1]);\n            },\n            get() {\n                return this._size;\n            },\n            enumerable: true,\n        });\n    }\n\n    recomputeInsideNodes() {\n        this._nodes.length = 0;\n        const nodes = this.graph._nodes;\n        const node_bounding = new Float32Array(4);\n\n        for (let i = 0; i < nodes.length; ++i) {\n            const node = nodes[i];\n            node.getBounding(node_bounding);\n            if (!overlapBounding(this._bounding, node_bounding)) {\n                continue;\n            } // out of the visible area\n            this._nodes.push(node);\n        }\n    }\n\n    move(deltax, deltay, ignore_nodes) {\n        this._pos[0] += deltax;\n        this._pos[1] += deltay;\n        if (ignore_nodes) {\n            return;\n        }\n        for (let i = 0; i < this._nodes.length; ++i) {\n            const node = this._nodes[i];\n            node.pos[0] += deltax;\n            node.pos[1] += deltay;\n        }\n    }\n\n    serialize() {\n        const b = this._bounding;\n        return {\n            title: this.title,\n            bounding: [\n                Math.round(b[0]),\n                Math.round(b[1]),\n                Math.round(b[2]),\n                Math.round(b[3]),\n            ],\n            color: this.color,\n            font: this.font,\n        };\n    }\n\n    configure(o) {\n        this.title = o.title;\n        this._bounding.set(o.bounding);\n        this.color = o.color;\n        this.font = o.font;\n    }\n\n    isPointInside = LGraphNode.prototype.isPointInside\n\n    setDirtyCanvas = LGraphNode.prototype.setDirtyCanvas\n}\n","/**\n * @class DragAndScale\n * @param element\n * @param skipEvents\n */\nexport default class DragAndScale {\n    constructor(element, skipEvents) {\n        this.offset = new Float32Array([0, 0]);\n        this.scale = 1;\n        this.max_scale = 10;\n        this.min_scale = 0.1;\n        this.onredraw = null;\n        this.enabled = true;\n        this.last_mouse = [0, 0];\n        this.element = null;\n        this.visible_area = new Float32Array(4);\n\n        if (element) {\n            this.element = element;\n            if (!skipEvents) {\n                this.bindEvents(element);\n            }\n        }\n    }\n\n    bindEvents(element) {\n        this.last_mouse = new Float32Array(2);\n\n        this._binded_mouse_callback = this.onMouse.bind(this);\n\n        element.addEventListener(\"mousedown\", this._binded_mouse_callback);\n        element.addEventListener(\"mousemove\", this._binded_mouse_callback);\n\n        element.addEventListener(\n            \"mousewheel\",\n            this._binded_mouse_callback,\n            false,\n        );\n        element.addEventListener(\"wheel\", this._binded_mouse_callback, false);\n    }\n\n    computeVisibleArea() {\n        if (!this.element) {\n            // eslint-disable-next-line\n            this.visible_area[0] = this.visible_area[1] = this.visible_area[2] = this.visible_area[3] = 0;\n            return;\n        }\n        const { width } = this.element;\n        const { height } = this.element;\n        const startx = -this.offset[0];\n        const starty = -this.offset[1];\n        const endx = startx + width / this.scale;\n        const endy = starty + height / this.scale;\n        this.visible_area[0] = startx;\n        this.visible_area[1] = starty;\n        this.visible_area[2] = endx - startx;\n        this.visible_area[3] = endy - starty;\n    }\n\n    onMouse(e) {\n        if (!this.enabled) {\n            return;\n        }\n\n        const canvas = this.element;\n        const rect = canvas.getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        const y = e.clientY - rect.top;\n        e.canvasx = x;\n        e.canvasy = y;\n        e.dragging = this.dragging;\n\n        let ignore = false;\n        if (this.onmouse) {\n            ignore = this.onmouse(e);\n        }\n\n        if (e.type === \"mousedown\") {\n            this.dragging = true;\n            canvas.removeEventListener(\n                \"mousemove\",\n                this._binded_mouse_callback,\n            );\n            document.body.addEventListener(\n                \"mousemove\",\n                this._binded_mouse_callback,\n            );\n            document.body.addEventListener(\n                \"mouseup\",\n                this._binded_mouse_callback,\n            );\n        } else if (e.type === \"mousemove\") {\n            if (!ignore) {\n                const deltax = x - this.last_mouse[0];\n                const deltay = y - this.last_mouse[1];\n                if (this.dragging) {\n                    this.mouseDrag(deltax, deltay);\n                }\n            }\n        } else if (e.type === \"mouseup\") {\n            this.dragging = false;\n            document.body.removeEventListener(\n                \"mousemove\",\n                this._binded_mouse_callback,\n            );\n            document.body.removeEventListener(\n                \"mouseup\",\n                this._binded_mouse_callback,\n            );\n            canvas.addEventListener(\"mousemove\", this._binded_mouse_callback);\n        } else if (\n            e.type === \"mousewheel\"\n            || e.type === \"wheel\"\n            || e.type === \"DOMMouseScroll\"\n        ) {\n            e.eventType = \"mousewheel\";\n            if (e.type === \"wheel\") {\n                e.wheel = -e.deltaY;\n            } else {\n                e.wheel = e.wheelDeltaY != null ? e.wheelDeltaY : e.detail * -60;\n            }\n\n            // from stack overflow\n            if (e.wheelDelta) {\n                e.delta = e.wheelDelta / 40;\n            } else if (e.deltaY) {\n                e.delta = -e.deltaY / 3;\n            } else {\n                e.delta = 0;\n            }\n            this.changeDeltaScale(1.0 + e.delta * 0.05);\n        }\n\n        this.last_mouse[0] = x;\n        this.last_mouse[1] = y;\n\n        e.preventDefault();\n        e.stopPropagation();\n        return false;\n    }\n\n    toCanvasContext(ctx) {\n        ctx.scale(this.scale, this.scale);\n        ctx.translate(this.offset[0], this.offset[1]);\n    }\n\n    convertOffsetToCanvas(pos) {\n        // return [pos[0] / this.scale - this.offset[0], pos[1] / this.scale - this.offset[1]];\n        return [\n            (pos[0] + this.offset[0]) * this.scale,\n            (pos[1] + this.offset[1]) * this.scale,\n        ];\n    }\n\n    convertCanvasToOffset(pos, out) {\n        out = out || [0, 0];\n        out[0] = pos[0] / this.scale - this.offset[0];\n        out[1] = pos[1] / this.scale - this.offset[1];\n        return out;\n    }\n\n    mouseDrag(x, y) {\n        this.offset[0] += x / this.scale;\n        this.offset[1] += y / this.scale;\n\n        if (this.onredraw) {\n            this.onredraw(this);\n        }\n    }\n\n    changeScale(value, zoomingCenter) {\n        if (value < this.min_scale) {\n            value = this.min_scale;\n        } else if (value > this.max_scale) {\n            value = this.max_scale;\n        }\n\n        if (value === this.scale) {\n            return;\n        }\n\n        if (!this.element) {\n            return;\n        }\n\n        const rect = this.element.getBoundingClientRect();\n        if (!rect) {\n            return;\n        }\n\n        zoomingCenter = zoomingCenter || [\n            rect.width * 0.5,\n            rect.height * 0.5,\n        ];\n        const center = this.convertCanvasToOffset(zoomingCenter);\n        this.scale = value;\n        if (Math.abs(this.scale - 1) < 0.01) {\n            this.scale = 1;\n        }\n\n        const newCenter = this.convertCanvasToOffset(zoomingCenter);\n        const deltaOffset = [\n            newCenter[0] - center[0],\n            newCenter[1] - center[1],\n        ];\n\n        this.offset[0] += deltaOffset[0];\n        this.offset[1] += deltaOffset[1];\n\n        if (this.onredraw) {\n            this.onredraw(this);\n        }\n    }\n\n    changeDeltaScale(value, zoomingCenter) {\n        this.changeScale(this.scale * value, zoomingCenter);\n    }\n\n    reset() {\n        this.scale = 1;\n        this.offset[0] = 0;\n        this.offset[1] = 0;\n    }\n}\n","/**\n * ContextMenu from LiteGUI\n * @class ContextMenu\n * @constructor\n * @param {Array} values (allows object { title: \"Nice text\", callback: function ... })\n * @param {Object} options [optional] Some options:\\\n * - title: title to show on top of the menu\n * - callback: function to call when an option is clicked, it receives the item information\n * - ignore_item_callbacks: ignores the callback inside the item, it just calls the\n *     options.callback\n * - event: you can pass a MouseEvent, this way the ContextMenu appears in that position\n */\nexport default class ContextMenu {\n    constructor(values, options = {}) {\n        this.options = options;\n        const that = this;\n\n        // to link a menu with its parent\n        if (options.parentMenu) {\n            if (options.parentMenu.constructor !== this.constructor) {\n                console.error(\"parentMenu must be of class ContextMenu, ignoring it\");\n                options.parentMenu = null;\n            } else {\n                this.parentMenu = options.parentMenu;\n                this.parentMenu.lock = true;\n                this.parentMenu.current_submenu = this;\n            }\n        }\n\n        let eventClass = null;\n        if (options.event) eventClass = options.event.constructor.name;\n        if (eventClass !== \"MouseEvent\"\n            && eventClass !== \"CustomEvent\"\n            && eventClass !== \"PointerEvent\"\n        ) {\n            console.error(\n                \"Event passed to ContextMenu is not of type MouseEvent or CustomEvent. Ignoring it.\",\n            );\n            options.event = null;\n        }\n\n        const root = document.createElement(\"div\");\n        root.className = \"litegraph litecontextmenu litemenubar-panel\";\n        if (options.className) root.className += ` ${options.className}`;\n        root.style.minWidth = 100;\n        root.style.minHeight = 100;\n        root.style.pointerEvents = \"none\";\n        setTimeout(() => {\n            root.style.pointerEvents = \"auto\";\n        }, 100); // delay so the mouse up event is not caught by this element\n\n        // this prevents the default context browser menu to open in case this menu was created\n        // when pressing right button\n        root.addEventListener(\"mouseup\", (e) => {\n            e.preventDefault();\n            return true;\n        },\n        true);\n        root.addEventListener(\n            \"contextmenu\",\n            (e) => {\n                if (e.button !== 2) {\n                    // right button\n                    return false;\n                }\n                e.preventDefault();\n                return false;\n            },\n            true,\n        );\n\n        root.addEventListener(\n            \"mousedown\",\n            (e) => {\n                if (e.button === 2) {\n                    that.close();\n                    e.preventDefault();\n                    return true;\n                }\n            },\n            true,\n        );\n\n        function on_mouse_wheel(e) {\n            const pos = parseInt(root.style.top, 10);\n            root.style.top = `${(pos + e.deltaY * options.scroll_speed).toFixed()}px`;\n            e.preventDefault();\n            return true;\n        }\n\n        if (!options.scroll_speed) options.scroll_speed = 0.1;\n\n        root.addEventListener(\"wheel\", on_mouse_wheel, true);\n        root.addEventListener(\"mousewheel\", on_mouse_wheel, true);\n\n        this.root = root;\n\n        // title\n        if (options.title) {\n            const element = document.createElement(\"div\");\n            element.className = \"litemenu-title\";\n            element.innerHTML = options.title;\n            root.appendChild(element);\n        }\n\n        // entries\n        for (let i = 0; i < values.length; i++) {\n            let name = values.constructor === Array ? values[i] : i;\n            if (name && name.constructor !== String) {\n                name = name.content === undefined ? String(name) : name.content;\n            }\n            const value = values[i];\n            this.addItem(name, value, options);\n        }\n\n        // close on leave\n        root.addEventListener(\"mouseleave\", (e) => {\n            if (that.lock) return;\n            if (root.closing_timer) clearTimeout(root.closing_timer);\n            root.closing_timer = setTimeout(that.close.bind(that, e), 500);\n            // that.close(e);\n        });\n\n        root.addEventListener(\"mouseenter\", (e) => {\n            if (root.closing_timer) clearTimeout(root.closing_timer);\n        });\n\n        // insert before checking position\n        let rootDocument = document;\n        if (options.event) {\n            rootDocument = options.event.target.ownerDocument;\n        }\n\n        if (!rootDocument) {\n            rootDocument = document;\n        }\n\n        if (rootDocument.fullscreenElement) {\n            rootDocument.fullscreenElement.appendChild(root);\n        } else {\n            rootDocument.body.appendChild(root);\n        }\n\n        // compute best position\n        let left = options.left || 0;\n        let top = options.top || 0;\n        if (options.event) {\n            left = options.event.clientX - 10;\n            top = options.event.clientY - 10;\n            if (options.title) top -= 20;\n\n            if (options.parentMenu) {\n                const rect = options.parentMenu.root.getBoundingClientRect();\n                left = rect.left + rect.width;\n            }\n\n            const bodyRect = document.body.getBoundingClientRect();\n            const rootRect = root.getBoundingClientRect();\n            if (bodyRect.height === 0) console.error(\"document.body height is 0. That is dangerous, set html,body { height: 100%; }\");\n\n            if (bodyRect.width && left > bodyRect.width - rootRect.width - 10) {\n                left = bodyRect.width - rootRect.width - 10;\n            }\n            if (bodyRect.height && top > bodyRect.height - rootRect.height - 10) {\n                top = bodyRect.height - rootRect.height - 10;\n            }\n        }\n\n        root.style.left = `${left}px`;\n        root.style.top = `${top}px`;\n\n        if (options.scale) root.style.transform = `scale(${options.scale})`;\n    }\n\n    addItem(name, value, options = {}) {\n        const that = this;\n\n        const element = document.createElement(\"div\");\n        element.className = \"litemenu-entry submenu\";\n\n        let disabled = false;\n\n        if (value === null) element.classList.add(\"separator\");\n        else {\n            element.innerHTML = value && value.title ? value.title : name;\n            element.value = value;\n\n            if (value) {\n                if (value.disabled) {\n                    disabled = true;\n                    element.classList.add(\"disabled\");\n                }\n                if (value.submenu || value.has_submenu) element.classList.add(\"has_submenu\");\n            }\n\n            if (typeof value === \"function\") {\n                element.dataset.value = name;\n                element.onclick_callback = value;\n            } else element.dataset.value = value;\n\n            if (value.className) element.className += ` ${value.className}`;\n        }\n\n        this.root.appendChild(element);\n        if (!disabled) element.addEventListener(\"click\", inner_onclick);\n        if (options.autoopen) element.addEventListener(\"mouseenter\", inner_over);\n\n        function inner_over(e) {\n            const { value } = this;\n            if (!value || !value.has_submenu) return;\n            // if it is a submenu, autoopen like the item was clicked\n            inner_onclick.call(this, e);\n        }\n\n        // menu option clicked\n        function inner_onclick(e) {\n            const { value } = this;\n            let closeParent = true;\n\n            if (that.current_submenu) that.current_submenu.close(e);\n\n            // global callback\n            if (options.callback) {\n                const r = options.callback.call(\n                    this,\n                    value,\n                    options,\n                    e,\n                    that,\n                    options.node,\n                );\n                if (r === true) closeParent = false;\n            }\n\n            // special cases\n            if (value) {\n                if (\n                    value.callback\n                    && !options.ignore_item_callbacks\n                    && value.disabled !== true\n                ) {\n                    // item callback\n                    const r = value.callback.call(\n                        this,\n                        value,\n                        options,\n                        e,\n                        that,\n                        options.extra,\n                    );\n                    if (r === true) closeParent = false;\n                }\n                if (value.submenu) {\n                    if (!value.submenu.options) {\n                        throw new Error(\"ContextMenu submenu needs options\");\n                    }\n                    const submenu = new that.constructor(value.submenu.options, {\n                        callback: value.submenu.callback,\n                        event: e,\n                        parentMenu: that,\n                        ignore_item_callbacks:\n                        value.submenu.ignore_item_callbacks,\n                        title: value.submenu.title,\n                        extra: value.submenu.extra,\n                        autoopen: options.autoopen,\n                    });\n                    closeParent = false;\n                }\n            }\n\n            if (closeParent && !that.lock) that.close();\n        }\n\n        return element;\n    }\n\n    close(e, ignoreParentMenu) {\n        if (this.root.parentNode) {\n            this.root.remove()\n        }\n        if (this.parentMenu && !ignoreParentMenu) {\n            this.parentMenu.lock = false;\n            this.parentMenu.current_submenu = null;\n            if (e === undefined) this.parentMenu.close();\n            else if (e && !ContextMenu.isCursorOverElement(e, this.parentMenu.root)) {\n                ContextMenu.trigger(this.parentMenu.root, \"mouseleave\", e);\n            }\n        }\n        if (this.current_submenu) this.current_submenu.close(e, true);\n\n        if (this.root.closing_timer) clearTimeout(this.root.closing_timer);\n    }\n\n    // this code is used to trigger events easily (used in the context menu mouseleave\n    static trigger(element, eventName, params, origin) {\n        const evt = document.createEvent(\"CustomEvent\");\n        evt.initCustomEvent(eventName, true, true, params); // canBubble, cancelable, detail\n        evt.target = origin;\n        if (element.dispatchEvent) element.dispatchEvent(evt);\n        else if (element.__events) element.__events.dispatchEvent(evt);\n        // else nothing seems binded here so nothing to do\n        return evt;\n    }\n\n    // returns the top most menu\n    getTopMenu() {\n        if (this.options.parentMenu) return this.options.parentMenu.getTopMenu();\n        return this;\n    }\n\n    getFirstEvent() {\n        if (this.options.parentMenu) return this.options.parentMenu.getFirstEvent();\n        return this.options.event;\n    }\n\n    static closeAllContextMenus(ref_window = window) {\n        const elements = ref_window.document.querySelectorAll(\".litecontextmenu\");\n        if (!elements.length) {\n            return;\n        }\n\n        const result = [];\n        for (const el of elements) result.push(el);\n        for (const re of result) {\n            if (re.close) re.close();\n            else if (re.parentNode) re.remove();\n        }\n    }\n\n    static isCursorOverElement(event, element) {\n        const left = event.clientX;\n        const top = event.clientY;\n        const rect = element.getBoundingClientRect();\n        if (!rect) return false;\n        return top > rect.top\n            && top < rect.top + rect.height\n            && left > rect.left\n            && left < rect.left + rect.width;\n    }\n}\n","import DragAndScale from \"./DragAndScale\";\nimport { getFileExtension } from \"./utils/file\";\nimport ContextMenu from \"./ContextMenu\";\nimport { isValidConnection } from \"./utils/function\";\nimport LGraphNode from \"./LGraphNode\";\nimport { distance, isInsideRectangle, overlapBounding } from \"./utils/math\";\nimport LGraphGroup from \"./LGraphGroup\";\nimport * as registry from \"./utils/registry\";\nimport defaultConfig from \"./utils/defaultConfig\";\nimport getTime from \"./utils/time\";\n\nconst temp = new Float32Array(4);\nconst tempVC2 = new Float32Array(2);\nconst tempArea = new Float32Array(4);\nconst marginArea = new Float32Array(4);\nconst linkBounding = new Float32Array(4);\nconst tempA = new Float32Array(2);\nconst tempB = new Float32Array(2);\n\n/**\n * This class is in charge of rendering one graph inside a canvas. And provides all the\n * interaction required. Valid callbacks are: onNodeSelected, onNodeDeselected,\n * onShowNodePanel, onNodeDblClicked\n * @class LGraphCanvas\n * @constructor\n * @param {HTMLCanvasElement} canvas the canvas where you want to render\n *  (it accepts a selector in string format or the canvas element itself)\n * @param {LGraph} graph [optional]\n * @param {Object} options [optional] { skip_rendering, autoresize }\n */\nexport default class LGraphCanvas {\n    constructor(canvas, graph, options = {}) {\n        // if(graph === undefined)\n        // throw (\"No graph assigned\");\n        this.background_image = LGraphCanvas.DEFAULT_BACKGROUND_IMAGE;\n\n        if (canvas && canvas.constructor === String) {\n            canvas = document.querySelector(canvas);\n        }\n\n        this.ds = new DragAndScale();\n        this.zoom_modify_alpha = true; // otherwise it generates ugly patterns when scaling down\n        // too much\n\n        this.title_text_font = `${defaultConfig.NODE_TEXT_SIZE}px Arial`;\n        this.inner_text_font = `normal ${defaultConfig.NODE_SUBTEXT_SIZE}px Arial`;\n        this.node_title_color = defaultConfig.NODE_TITLE_COLOR;\n        this.default_link_color = defaultConfig.LINK_COLOR;\n        this.default_connection_color = {\n            input_off: \"#778\",\n            input_on: \"#7F7\",\n            output_off: \"#778\",\n            output_on: \"#7F7\",\n        };\n\n        this.highquality_render = true;\n        this.use_gradients = false; // set to true to render titlebar with gradients\n        this.editor_alpha = 1; // used for transition\n        this.pause_rendering = false;\n        this.clear_background = true;\n\n        this.read_only = false; // if set to true users cannot modify the graph\n        this.render_only_selected = true;\n        this.live_mode = false;\n        this.show_info = true;\n        this.allow_dragcanvas = true;\n        this.allow_dragnodes = true;\n        this.allow_interaction = true; // allow to control widgets, buttons, collapse, etc\n        this.allow_searchbox = true;\n        this.allow_reconnect_links = false; // allows to change a connection with having to redo it\n        // again\n\n        this.drag_mode = false;\n        this.dragging_rectangle = null;\n\n        this.filter = null; // allows to filter to only accept some type of nodes in a graph\n\n        this.set_canvas_dirty_on_mouse_event = true; // forces to redraw the canvas if the mouse\n        // does anything\n        this.always_render_background = false;\n        this.render_shadows = true;\n        this.render_canvas_border = true;\n        this.render_connections_shadows = false; // too much cpu\n        this.render_connections_border = true;\n        this.render_curved_connections = false;\n        this.render_connection_arrows = false;\n        this.render_collapsed_slots = true;\n        this.render_execution_order = false;\n        this.render_title_colored = true;\n        this.render_link_tooltip = true;\n\n        this.links_render_mode = defaultConfig.SPLINE_LINK;\n\n        this.mouse = [0, 0]; // mouse in canvas coordinates, where 0,0 is the top-left corner of\n        // the blue rectangle\n        this.graph_mouse = [0, 0]; // mouse in graph coordinates, where 0,0 is the top-left corner\n        // of the blue rectangle\n        this.canvas_mouse = this.graph_mouse; // LEGACY: REMOVE THIS, USE GRAPH_MOUSE INSTEAD\n\n        // to personalize the search box\n        this.onSearchBox = null;\n        this.onSearchBoxSelection = null;\n\n        // callbacks\n        this.onMouse = null;\n        this.onDrawBackground = null; // to render background objects (behind nodes and\n        // connections) in the canvas affected by transform\n        this.onDrawForeground = null; // to render foreground objects (above nodes and connections)\n        // in the canvas affected by transform\n        this.onDrawOverlay = null; // to render foreground objects not affected by transform (for\n        // GUIs)\n        this.onDrawLinkTooltip = null; // called when rendering a tooltip\n        this.onNodeMoved = null; // called after moving a node\n        this.onSelectionChange = null; // called if the selection changes\n        this.onConnectingChange = null; // called before any link changes\n        this.onBeforeChange = null; // called before modifying the graph\n        this.onAfterChange = null; // called after modifying the graph\n\n        this.connections_width = 3;\n        this.round_radius = 8;\n\n        this.current_node = null;\n        this.node_widget = null; // used for widgets\n        this.over_link_center = null;\n        this.last_mouse_position = [0, 0];\n        this.visible_area = this.ds.visible_area;\n        this.visible_links = [];\n\n        // link canvas and graph\n        if (graph) {\n            graph.attachCanvas(this);\n        }\n\n        this.setCanvas(canvas);\n        this.clear();\n\n        if (!options.skip_render) {\n            this.startRendering();\n        }\n\n        this.autoresize = options.autoresize;\n    }\n\n    static DEFAULT_BACKGROUND_IMAGE = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQBJREFUeNrs1rEKwjAUhlETUkj3vP9rdmr1Ysammk2w5wdxuLgcMHyptfawuZX4pJSWZTnfnu/lnIe/jNNxHHGNn//HNbbv+4dr6V+11uF527arU7+u63qfa/bnmh8sWLBgwYJlqRf8MEptXPBXJXa37BSl3ixYsGDBMliwFLyCV/DeLIMFCxYsWLBMwSt4Be/NggXLYMGCBUvBK3iNruC9WbBgwYJlsGApeAWv4L1ZBgsWLFiwYJmCV/AK3psFC5bBggULloJX8BpdwXuzYMGCBctgwVLwCl7Be7MMFixYsGDBsu8FH1FaSmExVfAxBa/gvVmwYMGCZbBg/W4vAQYA5tRF9QYlv/QAAAAASUVORK5CYII=\";\n\n    static link_type_colors = {\n        \"-1\": defaultConfig.EVENT_LINK_COLOR,\n        number: \"#AAA\",\n        node: \"#DCA\",\n    }\n\n    static gradients = {}\n\n    /**\n     * clears all the data inside\n     *\n     * @method clear\n     * @memberOf LGraphCanvas\n     */\n    clear() {\n        this.frame = 0;\n        this.last_draw_time = 0;\n        this.render_time = 0;\n        this.fps = 0;\n\n        // this.scale = 1;\n        // this.offset = [0,0];\n\n        this.dragging_rectangle = null;\n\n        this.selected_nodes = {};\n        this.selected_group = null;\n\n        this.visible_nodes = [];\n        this.node_dragged = null;\n        this.node_over = null;\n        this.node_capturing_input = null;\n        this.connecting_node = null;\n        this.highlighted_links = {};\n\n        this.dragging_canvas = false;\n\n        this.dirty_canvas = true;\n        this.dirty_bgcanvas = true;\n        this.dirty_area = null;\n\n        this.node_in_panel = null;\n        this.node_widget = null;\n\n        this.last_mouse = [0, 0];\n        this.last_mouseclick = 0;\n        this.visible_area.set([0, 0, 0, 0]);\n\n        if (this.onClear) this.onClear();\n    }\n\n    /**\n     * assigns a graph, you can reassign graphs to the same canvas\n     *\n     * @method setGraph\n     * @param {LGraph} graph\n     * @param {boolean=} skipClear\n     * @memberOf LGraphCanvas\n     */\n    setGraph(graph, skipClear) {\n        if (this.graph === graph) {\n            return;\n        }\n\n        if (!skipClear) this.clear();\n\n        if (!graph && this.graph) {\n            this.graph.detachCanvas(this);\n            return;\n        }\n\n        graph.attachCanvas(this);\n\n        // remove the graph stack in case a subgraph was open\n        if (this._graph_stack) this._graph_stack = null;\n\n        this.setDirty(true, true);\n    }\n\n    /**\n     * returns the top level graph (in case there are subgraphs open on the canvas)\n     *\n     * @method getTopGraph\n     * @return {LGraph} graph\n     * @memberOf LGraphCanvas\n     */\n    getTopGraph() {\n        if (this._graph_stack.length) return this._graph_stack[0];\n        return this.graph;\n    }\n\n    /**\n     * opens a graph contained inside a node in the current graph\n     *\n     * @method openSubgraph\n     * @param {LGraph} graph\n     * @memberOf LGraphCanvas\n     */\n    openSubgraph(graph) {\n        if (!graph) {\n            throw new Error(\"graph cannot be null\");\n        }\n\n        if (this.graph === graph) {\n            throw new Error(\"graph cannot be the same\");\n        }\n\n        this.clear();\n\n        if (this.graph) {\n            if (!this._graph_stack) {\n                this._graph_stack = [];\n            }\n            this._graph_stack.push(this.graph);\n        }\n\n        graph.attachCanvas(this);\n        this.checkPanels();\n        this.setDirty(true, true);\n    }\n\n    /**\n     * closes a subgraph contained inside a node\n     *\n     * @method closeSubgraph\n     * @memberOf LGraphCanvas\n     */\n    closeSubgraph() {\n        if (!this._graph_stack || this._graph_stack.length === 0) {\n            return;\n        }\n        const subgraphNode = this.graph._subgraph_node;\n        const graph = this._graph_stack.pop();\n        this.selected_nodes = {};\n        this.highlighted_links = {};\n        graph.attachCanvas(this);\n        this.setDirty(true, true);\n        if (subgraphNode) {\n            this.centerOnNode(subgraphNode);\n            this.selectNodes([subgraphNode]);\n        }\n    }\n\n    /**\n     * returns the visualy active graph (in case there are more in the stack)\n     * @method getCurrentGraph\n     * @return {LGraph} the active graph\n     * @memberOf LGraphCanvas\n     */\n    getCurrentGraph() {\n        return this.graph;\n    }\n\n    /**\n     * assigns a canvas\n     *\n     * @method setCanvas\n     * @param {HTMLCanvasElement | string | HTMLElement} canvas assigns a canvas\n     *  (also accepts the ID of the element (not a selector))\n     * @param {boolean} skipEvents\n     * @memberOf LGraphCanvas\n     */\n    setCanvas(canvas, skipEvents) {\n        if (canvas?.constructor === String) {\n            canvas = document.getElementById(canvas);\n            if (!canvas) {\n                throw new Error(\"Error creating LiteGraph canvas: Canvas not found\");\n            }\n        }\n\n        if (canvas === this.canvas) {\n            return;\n        }\n\n        if (!canvas && this.canvas) {\n            // maybe detach events from old_canvas\n            if (!skipEvents) {\n                this.unbindEvents();\n            }\n        }\n\n        this.canvas = canvas;\n        this.ds.element = canvas;\n\n        if (!canvas) return;\n\n        // this.canvas.tabindex = \"1000\";\n        canvas.className += \" lgraphcanvas\";\n        canvas.data = this;\n        canvas.tabindex = \"1\"; // to allow key events\n\n        // bg canvas: used for non changing stuff\n        this.bgcanvas = null;\n        this.bgcanvas = document.createElement(\"canvas\");\n        this.bgcanvas.width = this.canvas.width;\n        this.bgcanvas.height = this.canvas.height;\n\n        if (canvas.getContext === null) {\n            if (canvas.localName !== \"canvas\") {\n                throw new Error(`Element supplied for LGraphCanvas must be a <canvas> element, you passed a ${\n                    canvas.localName}`);\n            }\n            throw new Error(\"This browser doesn't support Canvas\");\n        }\n\n        this.ctx = canvas.getContext(\"2d\");\n        if (this.ctx == null) {\n            if (!canvas.webgl_enabled) {\n                console.warn(\n                    \"This canvas seems to be WebGL, enabling WebGL renderer\",\n                );\n            }\n            this.enableWebGL();\n        }\n\n        // input:  (move and up could be unbinded)\n        this._mousemove_callback = this.processMouseMove.bind(this);\n        this._mouseup_callback = this.processMouseUp.bind(this);\n\n        if (!skipEvents) this.bindEvents();\n    }\n\n    _doNothing(e) {\n        e.preventDefault();\n        return false;\n    }\n\n    _doReturnTrue(e) {\n        e.preventDefault();\n        return true;\n    }\n\n    /**\n     * binds mouse, keyboard, touch and drag events to the canvas\n     * @method bindEvents\n     * @memberOf LGraphCanvas\n     * */\n    bindEvents() {\n        if (this._events_binded) {\n            console.warn(\"LGraphCanvas: events already binded\");\n            return;\n        }\n\n        const { canvas } = this;\n\n        const refWindow = this.getCanvasWindow();\n        const { document } = refWindow; // hack used when moving canvas between windows\n\n        this._mousedown_callback = this.processMouseDown.bind(this);\n        this._mousewheel_callback = this.processMouseWheel.bind(this);\n\n        canvas.addEventListener(\"mousedown\", this._mousedown_callback, true); // down do not need\n        // to store the binded\n        canvas.addEventListener(\"mousemove\", this._mousemove_callback);\n        canvas.addEventListener(\"mousewheel\", this._mousewheel_callback);\n\n        canvas.addEventListener(\"contextmenu\", this._doNothing);\n        canvas.addEventListener(\"DOMMouseScroll\", this._mousewheel_callback);\n\n        canvas.addEventListener(\"touchstart\", this.touchHandler, true);\n        canvas.addEventListener(\"touchmove\", this.touchHandler, true);\n        canvas.addEventListener(\"touchend\", this.touchHandler, true);\n        canvas.addEventListener(\"touchcancel\", this.touchHandler, true);\n\n        // Keyboard ******************\n        this._key_callback = this.processKey.bind(this);\n\n        canvas.addEventListener(\"keydown\", this._key_callback, true);\n        document.addEventListener(\"keyup\", this._key_callback, true); // in document, otherwise it\n        // doesn't fire keyup\n\n        // Dropping Stuff over nodes ************************************\n        this._ondrop_callback = this.processDrop.bind(this);\n\n        canvas.addEventListener(\"dragover\", this._doNothing, false);\n        canvas.addEventListener(\"dragend\", this._doNothing, false);\n        canvas.addEventListener(\"drop\", this._ondrop_callback, false);\n        canvas.addEventListener(\"dragenter\", this._doReturnTrue, false);\n\n        this._events_binded = true;\n    }\n\n    /**\n     * unbinds mouse events from the canvas\n     * @method unbindEvents\n     * @memberOf LGraphCanvas\n     * */\n    unbindEvents() {\n        if (!this._events_binded) {\n            console.warn(\"LGraphCanvas: no events binded\");\n            return;\n        }\n\n        const refWindow = this.getCanvasWindow();\n        const { document } = refWindow;\n\n        this.canvas.removeEventListener(\"mousedown\", this._mousedown_callback);\n        this.canvas.removeEventListener(\n            \"mousewheel\",\n            this._mousewheel_callback,\n        );\n        this.canvas.removeEventListener(\n            \"DOMMouseScroll\",\n            this._mousewheel_callback,\n        );\n        this.canvas.removeEventListener(\"keydown\", this._key_callback);\n        document.removeEventListener(\"keyup\", this._key_callback);\n        this.canvas.removeEventListener(\"contextmenu\", this._doNothing);\n        this.canvas.removeEventListener(\"drop\", this._ondrop_callback);\n        this.canvas.removeEventListener(\"dragenter\", this._doReturnTrue);\n\n        this.canvas.removeEventListener(\"touchstart\", this.touchHandler);\n        this.canvas.removeEventListener(\"touchmove\", this.touchHandler);\n        this.canvas.removeEventListener(\"touchend\", this.touchHandler);\n        this.canvas.removeEventListener(\"touchcancel\", this.touchHandler);\n\n        this._mousedown_callback = null;\n        this._mousewheel_callback = null;\n        this._key_callback = null;\n        this._ondrop_callback = null;\n\n        this._events_binded = false;\n    }\n\n    /**\n     * this function allows to render the canvas using WebGL instead of Canvas2D\n     * this is useful if you plant to render 3D objects inside your nodes, it uses litegl.js for\n     * webgl and canvas2DtoWebGL to emulate the Canvas2D calls in webGL\n     * @method enableWebGL\n     * @memberOf LGraphCanvas\n     * */\n    enableWebGL() {\n        if (!GL) throw new Error(\"litegl.js must be included to use a WebGL canvas\");\n        if (!enableWebGLCanvas) throw new Error(\"webglCanvas.js must be included to use this feature\");\n\n        this.ctx = enableWebGLCanvas(this.canvas);\n        this.gl = this.ctx;\n        this.ctx.webgl = true;\n        this.bgcanvas = this.canvas;\n        this.bgctx = this.gl;\n        this.canvas.webgl_enabled = true;\n    }\n\n    /**\n     * marks as dirty the canvas, this way it will be rendered again\n     *\n     * @class LGraphCanvas\n     * @method setDirty\n     * @param {boolean} [fgcanvas] if the foreground canvas is dirty (the one containing the nodes)\n     * @param {boolean} [bgcanvas] if the background canvas is dirty (the one containing the wires)\n     * @memberOf LGraphCanvas\n     */\n    setDirty(fgcanvas, bgcanvas) {\n        if (fgcanvas) this.dirty_canvas = true;\n        if (bgcanvas) this.dirty_bgcanvas = true;\n    }\n\n    /**\n     * Used to attach the canvas in a popup\n     *\n     * @method getCanvasWindow\n     * @return {Window} returns the window where the canvas is attached (the DOM root node)\n     * @memberOf LGraphCanvas\n     */\n    getCanvasWindow() {\n        if (!this.canvas) return window;\n        const doc = this.canvas.ownerDocument;\n        return doc.defaultView;\n    }\n\n    /**\n     * starts rendering the content of the canvas when needed\n     *\n     * @method startRendering\n     * @memberOf LGraphCanvas\n     */\n    startRendering() {\n        if (this.is_rendering) return;\n\n        this.is_rendering = true;\n        this.renderFrame();\n    }\n\n    /**\n     * render a frame\n     *\n     * @method renderFrame\n     * @memberOf LGraphCanvas\n     */\n    renderFrame() {\n        if (!this.pause_rendering) this.draw();\n\n        const window = this.getCanvasWindow();\n        if (this.is_rendering) window.requestAnimationFrame(() => this.renderFrame());\n    }\n\n    /**\n     * stops rendering the content of the canvas (to save resources)\n     *\n     * @method stopRendering\n     * @memberOf LGraphCanvas\n     */\n    stopRendering() {\n        this.is_rendering = false;\n    }\n\n    /* LiteGraphCanvas input */\n\n    /**\n     * used to block future mouse events (because of im gui)\n     *\n     * @method blockClick\n     * @memberOf LGraphCanvas\n     */\n    blockClick() {\n        this.block_click = true;\n        this.last_mouseclick = 0;\n    }\n\n    processMouseDown(e) {\n        if (this.set_canvas_dirty_on_mouse_event) this.dirty_canvas = true;\n\n        if (!this.graph) return;\n\n        this.adjustMouseEvent(e);\n\n        const refWindow = this.getCanvasWindow();\n        LGraphCanvas.active_canvas = this;\n\n        // move mouse move event to the window in case it drags outside of the canvas\n        this.canvas.removeEventListener(\"mousemove\", this._mousemove_callback);\n        refWindow.document.addEventListener(\"mousemove\", this._mousemove_callback, true); // catch for the entire window\n        refWindow.document.addEventListener(\"mouseup\", this._mouseup_callback, true);\n\n        const node = this.graph.getNodeOnPos(e.canvasX, e.canvasY, this.visible_nodes, 5);\n        let skipAction = false;\n        const now = getTime();\n        const isDoubleClick = now - this.last_mouseclick < 300;\n        this.mouse[0] = e.localX;\n        this.mouse[1] = e.localY;\n        this.graph_mouse[0] = e.canvasX;\n        this.graph_mouse[1] = e.canvasY;\n        this.last_click_position = [this.mouse[0], this.mouse[1]];\n\n        this.canvas.focus();\n\n        ContextMenu.closeAllContextMenus(refWindow);\n\n        if (this.onMouse) {\n            if (this.onMouse(e)) return;\n        }\n\n        // left button mouse\n        if (e.which === 1) {\n            if (e.ctrlKey) {\n                this.dragging_rectangle = new Float32Array(4);\n                this.dragging_rectangle[0] = e.canvasX;\n                this.dragging_rectangle[1] = e.canvasY;\n                this.dragging_rectangle[2] = 1;\n                this.dragging_rectangle[3] = 1;\n                skipAction = true;\n            }\n\n            let clickingCanvasBg = false;\n\n            // when clicked on top of a node\n            // and it is not interactive\n            if (node && this.allow_interaction && !skipAction && !this.read_only) {\n                if (!this.live_mode && !node.flags.pinned) {\n                    this.bringToFront(node);\n                } // if it wasn't selected?\n\n                // not dragging mouse to connect two slots\n                if (!this.connecting_node && !node.flags.collapsed && !this.live_mode) {\n                // Search for corner for resize\n                    if (!skipAction\n                    && node.resizable\n                    && isInsideRectangle(\n                        e.canvasX,\n                        e.canvasY,\n                        node.pos[0] + node.size[0] - 5,\n                        node.pos[1] + node.size[1] - 5,\n                        1010,\n                    )\n                    ) {\n                        this.graph.beforeChange();\n                        this.resizing_node = node;\n                        this.canvas.style.cursor = \"se-resize\";\n                        skipAction = true;\n                    } else {\n                    // search for outputs\n                        if (node.outputs) {\n                            for (let i = 0, l = node.outputs.length; i < l; i++) {\n                                const output = node.outputs[i];\n                                const linkPos = node.getConnectionPos(false, i);\n                                if (isInsideRectangle(\n                                    e.canvasX,\n                                    e.canvasY,\n                                    linkPos[0] - 15,\n                                    linkPos[1] - 10,\n                                    30,\n                                    20,\n                                )) {\n                                    this.connecting_node = node;\n                                    this.connecting_output = output;\n                                    this.connecting_pos = node.getConnectionPos(false, i);\n                                    this.connecting_slot = i;\n                                    if (e.shiftKey) {\n                                        node.disconnectOutput(i);\n                                    }\n\n                                    if (isDoubleClick) {\n                                        if (node.onOutputDblClick) {\n                                            node.onOutputDblClick(i, e);\n                                        }\n                                    } else if (node.onOutputClick) {\n                                        node.onOutputClick(i, e);\n                                    }\n\n                                    skipAction = true;\n                                    break;\n                                }\n                            }\n                        }\n\n                        // search for inputs\n                        if (node.inputs) {\n                            for (let i = 0, l = node.inputs.length; i < l; i++) {\n                                const input = node.inputs[i];\n                                const linkPos = node.getConnectionPos(true, i);\n                                if (isInsideRectangle(\n                                    e.canvasX,\n                                    e.canvasY,\n                                    linkPos[0] - 15,\n                                    linkPos[1] - 10,\n                                    30, 20,\n                                )) {\n                                    if (isDoubleClick) {\n                                        if (node.onInputDblClick) {\n                                            node.onInputDblClick(i, e);\n                                        }\n                                    } else if (node.onInputClick) {\n                                        node.onInputClick(i, e);\n                                    }\n\n                                    if (input.link) {\n                                        const linkInfo = this.graph.links[\n                                            input.link\n                                        ]; // before disconnecting\n                                        node.disconnectInput(i);\n\n                                        if (\n                                            this.allow_reconnect_links\n                                            || e.shiftKey\n                                        ) {\n                                            this.connecting_node = this.graph._nodes_by_id[\n                                                linkInfo.origin_id\n                                            ];\n                                            this.connecting_slot = linkInfo.origin_slot;\n                                            this.connecting_output = this.connecting_node.outputs[\n                                                this.connecting_slot\n                                            ];\n\n                                            this.connecting_pos = this.connecting_node\n                                                .getConnectionPos(false, this.connecting_slot);\n                                        }\n\n                                        this.dirty_bgcanvas = true;\n                                        skipAction = true;\n                                    }\n                                }\n                            }\n                        }\n                    } // not resizing\n                }\n\n                // it wasn't clicked on the links boxes\n                if (!skipAction) {\n                    let blockDragNote = false;\n                    const pos = [e.canvasX - node.pos[0], e.canvasY - node.pos[1]];\n\n                    // widgets\n                    const widget = this.processNodeWidgets(node, this.graph_mouse, e);\n                    if (widget) {\n                        blockDragNote = true;\n                        this.node_widget = [node, widget];\n                    }\n\n                    // double clicking\n                    if (isDoubleClick && this.selected_nodes[node.id]) {\n                        // double click node\n                        if (node.onDblClick) {\n                            node.onDblClick(e, pos, this);\n                        }\n                        this.processNodeDblClicked(node);\n                        blockDragNote = true;\n                    }\n\n                    // if do not capture mouse\n                    if (node.onMouseDown && node.onMouseDown(e, pos, this)) {\n                        blockDragNote = true;\n                    } else {\n                        // open subgraph button\n                        if (node.subgraph && !node.skip_subgraph_button) {\n                            if (!node.flags.collapsed && pos[0]\n                                > node.size[0] - defaultConfig.NODE_TITLE_HEIGHT\n                                && pos[1] < 0) {\n                                setTimeout(() => {\n                                    this.openSubgraph(node.subgraph);\n                                }, 10);\n                            }\n                        }\n\n                        if (this.live_mode) {\n                            clickingCanvasBg = true;\n                            blockDragNote = true;\n                        }\n                    }\n\n                    if (!blockDragNote) {\n                        if (this.allow_dragnodes) {\n                            this.graph.beforeChange();\n                            this.node_dragged = node;\n                        }\n                        if (!this.selected_nodes[node.id]) {\n                            this.processNodeSelected(node, e);\n                        }\n                    }\n\n                    this.dirty_canvas = true;\n                }\n            } else {\n                // search for link connector\n                if (!this.read_only) {\n                    for (const link of this.visible_links) {\n                        const center = link._pos;\n                        if (\n                            !center\n                            || e.canvasX < center[0] - 4\n                            || e.canvasX > center[0] + 4\n                            || e.canvasY < center[1] - 4\n                            || e.canvasY > center[1] + 4\n                        ) {\n                            continue;\n                        }\n                        // link clicked\n                        this.showLinkMenu(link, e);\n                        this.over_link_center = null; // clear tooltip\n                        break;\n                    }\n                }\n\n                this.selected_group = this.graph.getGroupOnPos(e.canvasX, e.canvasY);\n                this.selected_group_resizing = false;\n                if (this.selected_group && !this.read_only) {\n                    if (e.ctrlKey) this.dragging_rectangle = null;\n\n                    const dist = distance([e.canvasX, e.canvasY],\n                        [this.selected_group.pos[0] + this.selected_group.size[0],\n                            this.selected_group.pos[1] + this.selected_group.size[1]]);\n                    if (dist * this.ds.scale < 10) {\n                        this.selected_group_resizing = true;\n                    } else {\n                        this.selected_group.recomputeInsideNodes();\n                    }\n                }\n\n                if (isDoubleClick && !this.read_only && this.allow_searchbox) {\n                    this.showSearchBox(e);\n                }\n\n                clickingCanvasBg = true;\n            }\n\n            if (!skipAction && clickingCanvasBg && this.allow_dragcanvas) {\n                this.dragging_canvas = true;\n            }\n        } else if (e.which === 2) {\n            // middle button\n        } else if (e.which === 3) {\n            // right button\n            if (!this.read_only) this.processContextMenu(node, e);\n        }\n\n        // TODO\n        // if(this.node_selected != prev_selected)\n        //\tthis.onNodeSelectionChange(this.node_selected);\n\n        this.last_mouse[0] = e.localX;\n        this.last_mouse[1] = e.localY;\n        this.last_mouseclick = getTime();\n        this.last_mouse_dragging = true;\n\n        /*\n    if( (this.dirty_canvas || this.dirty_bgcanvas) && this.rendering_timer_id == null)\n    this.draw();\n    */\n\n        this.graph.change();\n\n        // this is to ensure to defocus(blur) if a text input element is on focus\n        if (\n            !refWindow.document.activeElement\n            || (refWindow.document.activeElement.nodeName.toLowerCase()\n            !== \"input\"\n            && refWindow.document.activeElement.nodeName.toLowerCase()\n            !== \"textarea\")) {\n            e.preventDefault();\n        }\n        e.stopPropagation();\n\n        if (this.onMouseDown) {\n            this.onMouseDown(e);\n        }\n\n        return false;\n    }\n\n    /**\n     * Called when a mouse move event has to be processed\n     * @method processMouseMove\n     * @memberOf LGraphCanvas\n     * */\n    processMouseMove(e) {\n        if (this.autoresize) this.resize();\n\n        if (this.set_canvas_dirty_on_mouse_event) this.dirty_canvas = true;\n\n        if (!this.graph) return;\n\n        LGraphCanvas.active_canvas = this;\n        this.adjustMouseEvent(e);\n        const mouse = [e.localX, e.localY];\n        this.mouse[0] = mouse[0];\n        this.mouse[1] = mouse[1];\n        const delta = [\n            mouse[0] - this.last_mouse[0],\n            mouse[1] - this.last_mouse[1],\n        ];\n        this.last_mouse = mouse;\n        this.graph_mouse[0] = e.canvasX;\n        this.graph_mouse[1] = e.canvasY;\n\n        if (this.block_click) {\n            e.preventDefault();\n            return false;\n        }\n\n        e.dragging = this.last_mouse_dragging;\n\n        if (this.node_widget) {\n            this.processNodeWidgets(this.node_widget[0], this.graph_mouse, e, this.node_widget[1]);\n            this.dirty_canvas = true;\n        }\n\n        if (this.dragging_rectangle) {\n            this.dragging_rectangle[2] = e.canvasX - this.dragging_rectangle[0];\n            this.dragging_rectangle[3] = e.canvasY - this.dragging_rectangle[1];\n            this.dirty_canvas = true;\n        } else if (this.selected_group && !this.read_only) {\n            // moving/resizing a group\n            if (this.selected_group_resizing) {\n                this.selected_group.size = [\n                    e.canvasX - this.selected_group.pos[0],\n                    e.canvasY - this.selected_group.pos[1],\n                ];\n            } else {\n                const deltax = delta[0] / this.ds.scale;\n                const deltay = delta[1] / this.ds.scale;\n                this.selected_group.move(deltax, deltay, e.ctrlKey);\n                if (this.selected_group._nodes.length) this.dirty_canvas = true;\n            }\n            this.dirty_bgcanvas = true;\n        } else if (this.dragging_canvas) {\n            this.ds.offset[0] += delta[0] / this.ds.scale;\n            this.ds.offset[1] += delta[1] / this.ds.scale;\n            this.dirty_canvas = true;\n            this.dirty_bgcanvas = true;\n        } else if (this.allow_interaction && !this.read_only) {\n            if (this.connecting_node) this.dirty_canvas = true;\n\n            // get node over\n            const node = this.graph.getNodeOnPos(e.canvasX, e.canvasY, this.visible_nodes);\n\n            // remove mouseover flag\n            for (const _node of this.graph._nodes) {\n                if (_node.mouseOver && node !== _node) {\n                    // mouse leave\n                    _node.mouseOver = false;\n                    if (this.node_over && this.node_over.onMouseLeave) {\n                        this.node_over.onMouseLeave(e);\n                    }\n                    this.node_over = null;\n                    this.dirty_canvas = true;\n                }\n            }\n\n            // mouse over a node\n            if (node) {\n                if (node.redraw_on_mouse) this.dirty_canvas = true;\n\n                // this.canvas.style.cursor = \"move\";\n                if (!node.mouseOver) {\n                    // mouse enter\n                    node.mouseOver = true;\n                    this.node_over = node;\n                    this.dirty_canvas = true;\n\n                    if (node.onMouseEnter) node.onMouseEnter(e);\n                }\n\n                // in case the node wants to do something\n                if (node.onMouseMove) {\n                    node.onMouseMove(e, [e.canvasX - node.pos[0], e.canvasY - node.pos[1]], this);\n                }\n\n                // if dragging a link\n                if (this.connecting_node) {\n                    const pos = this._highlight_input || [0, 0];\n\n                    // on top of input\n                    if (this.isOverNodeBox(node, e.canvasX, e.canvasY)) {\n                        // mouse on top of the corner box, don't know what to do\n                    } else {\n                        // check if I have a slot below de mouse\n                        const slot = this.isOverNodeInput(node, e.canvasX, e.canvasY, pos);\n                        if (slot !== -1 && node.inputs[slot]) {\n                            const slotType = node.inputs[slot].type;\n                            if (isValidConnection(this.connecting_output.type, slotType)) {\n                                this._highlight_input = pos;\n                            }\n                        } else this._highlight_input = null;\n                    }\n                }\n\n                // Search for corner\n                if (this.canvas) {\n                    if (isInsideRectangle(\n                        e.canvasX,\n                        e.canvasY,\n                        node.pos[0] + node.size[0] - 5,\n                        node.pos[1] + node.size[1] - 5,\n                        5,\n                        5,\n                    )) {\n                        this.canvas.style.cursor = \"se-resize\";\n                    } else this.canvas.style.cursor = \"crosshair\";\n                }\n            } else { // not over a node\n                // search for link connector\n                let overLink = null;\n                for (const link of this.visible_links) {\n                    const center = link._pos;\n                    if (!center\n                        || e.canvasX < center[0] - 4\n                        || e.canvasX > center[0] + 4\n                        || e.canvasY < center[1] - 4\n                        || e.canvasY > center[1] + 4) {\n                        continue;\n                    }\n                    overLink = link;\n                    break;\n                }\n                if (overLink !== this.over_link_center) {\n                    this.over_link_center = overLink;\n                    this.dirty_canvas = true;\n                }\n\n                if (this.canvas) this.canvas.style.cursor = \"\";\n            } // end\n\n            // send event to node if capturing input (used with widgets that allow drag outside of\n            // the area of the node)\n            if (this.node_capturing_input && this.node_capturing_input !== node && this.node_capturing_input.onMouseMove) {\n                this.node_capturing_input.onMouseMove(e, [e.canvasX - this.node_capturing_input.pos[0], e.canvasY - this.node_capturing_input.pos[1]], this);\n            }\n\n            // node being dragged\n            if (this.node_dragged && !this.live_mode) {\n                for (const nKeys of Object.keys(this.selected_nodes)) {\n                    const n = this.selected_nodes[nKeys];\n                    n.pos[0] += delta[0] / this.ds.scale;\n                    n.pos[1] += delta[1] / this.ds.scale;\n                }\n\n                this.dirty_canvas = true;\n                this.dirty_bgcanvas = true;\n            }\n\n            if (this.resizing_node && !this.live_mode) {\n                // convert mouse to node space\n                const desiredSize = [\n                    e.canvasX - this.resizing_node.pos[0],\n                    e.canvasY - this.resizing_node.pos[1],\n                ];\n                const minSize = this.resizing_node.computeSize();\n                desiredSize[0] = Math.max(minSize[0], desiredSize[0]);\n                desiredSize[1] = Math.max(minSize[1], desiredSize[1]);\n                this.resizing_node.setSize(desiredSize);\n\n                this.canvas.style.cursor = \"se-resize\";\n                this.dirty_canvas = true;\n                this.dirty_bgcanvas = true;\n            }\n        }\n\n        e.preventDefault();\n        return false;\n    }\n\n    /**\n     * Called when a mouse up event has to be processed\n     * @method processMouseUp\n     * @memberOf LGraphCanvas\n     * */\n    processMouseUp(e) {\n        if (this.set_canvas_dirty_on_mouse_event) this.dirty_canvas = true;\n\n        if (!this.graph) return;\n\n        const window = this.getCanvasWindow();\n        const { document } = window;\n        LGraphCanvas.active_canvas = this;\n\n        // restore the mousemove event back to the canvas\n        document.removeEventListener(\"mousemove\", this._mousemove_callback, true);\n        this.canvas.addEventListener(\"mousemove\", this._mousemove_callback, true);\n        document.removeEventListener(\"mouseup\", this._mouseup_callback, true);\n\n        this.adjustMouseEvent(e);\n        const now = getTime();\n        e.click_time = now - this.last_mouseclick;\n        this.last_mouse_dragging = false;\n        this.last_click_position = null;\n\n        if (this.block_click) this.block_click = false;\n        // used to avoid sending twice a click in a immediate button\n\n        if (e.which === 1) {\n            if (this.node_widget) this.processNodeWidgets(this.node_widget[0], this.graph_mouse, e);\n\n            // left button\n            this.node_widget = null;\n\n            if (this.selected_group) {\n                const diffx = this.selected_group.pos[0]\n                    - Math.round(this.selected_group.pos[0]);\n                const diffy = this.selected_group.pos[1]\n                    - Math.round(this.selected_group.pos[1]);\n\n                this.selected_group.move(diffx, diffy, e.ctrlKey);\n\n                this.selected_group.pos[0] = Math.round(this.selected_group.pos[0]);\n                this.selected_group.pos[1] = Math.round(this.selected_group.pos[1]);\n\n                if (this.selected_group._nodes.length) this.dirty_canvas = true;\n                this.selected_group = null;\n            }\n            this.selected_group_resizing = false;\n\n            if (this.dragging_rectangle) {\n                if (this.graph) {\n                    const nodes = this.graph._nodes;\n                    const nodeBounding = new Float32Array(4);\n                    this.deselectAllNodes();\n                    // compute bounding and flip if left to right\n                    const w = Math.abs(this.dragging_rectangle[2]);\n                    const h = Math.abs(this.dragging_rectangle[3]);\n                    const startx = this.dragging_rectangle[2] < 0\n                        ? this.dragging_rectangle[0] - w\n                        : this.dragging_rectangle[0];\n                    const starty = this.dragging_rectangle[3] < 0\n                        ? this.dragging_rectangle[1] - h\n                        : this.dragging_rectangle[1];\n                    this.dragging_rectangle[0] = startx;\n                    this.dragging_rectangle[1] = starty;\n                    this.dragging_rectangle[2] = w;\n                    this.dragging_rectangle[3] = h;\n\n                    // test against all nodes (not visible because the rectangle maybe start outside\n                    const toSelect = [];\n\n                    for (const node of nodes) {\n                        node.getBounding(nodeBounding);\n                        if (\n                            !overlapBounding(\n                                this.dragging_rectangle,\n                                nodeBounding,\n                            )\n                        ) {\n                            continue;\n                        } // out of the visible area\n                        toSelect.push(node);\n                    }\n                    if (toSelect.length) {\n                        this.selectNodes(toSelect);\n                    }\n                }\n                this.dragging_rectangle = null;\n            } else if (this.connecting_node) {\n                // dragging a connection\n                this.dirty_canvas = true;\n                this.dirty_bgcanvas = true;\n\n                const node = this.graph.getNodeOnPos(\n                    e.canvasX,\n                    e.canvasY,\n                    this.visible_nodes,\n                );\n\n                // node below mouse\n                if (node) {\n                    if (\n                        this.connecting_output.type === defaultConfig.EVENT\n                        && this.isOverNodeBox(node, e.canvasX, e.canvasY)\n                    ) {\n                        this.connecting_node.connect(this.connecting_slot, node, defaultConfig.EVENT);\n                    } else {\n                        // slot below mouse? connect\n                        const slot = this.isOverNodeInput(node, e.canvasX, e.canvasY);\n                        if (slot !== -1) {\n                            this.connecting_node.connect(this.connecting_slot, node, slot);\n                        } else {\n                            // not on top of an input\n                            const input = node.getInputInfo(0);\n                            // auto connect\n                            if (this.connecting_output.type === defaultConfig.EVENT) {\n                                this.connecting_node.connect(\n                                    this.connecting_slot, node,\n                                    defaultConfig.EVENT,\n                                );\n                            } else if (\n                                input\n                                && !input.link\n                                && isValidConnection(\n                                    input.type && this.connecting_output.type,\n                                )\n                            ) {\n                                this.connecting_node.connect(this.connecting_slot, node, 0);\n                            }\n                        }\n                    }\n                }\n\n                this.connecting_output = null;\n                this.connecting_pos = null;\n                this.connecting_node = null;\n                this.connecting_slot = -1;\n            } else if (this.resizing_node) {\n                this.dirty_canvas = true;\n                this.dirty_bgcanvas = true;\n                this.graph.afterChange(this.resizing_node);\n                this.resizing_node = null;\n            } else if (this.node_dragged) {\n                // node being dragged?\n                const node = this.node_dragged;\n                if (\n                    node\n                    && e.click_time < 300\n                    && isInsideRectangle(\n                        e.canvasX,\n                        e.canvasY,\n                        node.pos[0],\n                        node.pos[1] - defaultConfig.NODE_TITLE_HEIGHT,\n                        defaultConfig.NODE_TITLE_HEIGHT,\n                        defaultConfig.NODE_TITLE_HEIGHT,\n                    )\n                ) {\n                    node.collapse();\n                }\n\n                this.dirty_canvas = true;\n                this.dirty_bgcanvas = true;\n                this.node_dragged.pos[0] = Math.round(this.node_dragged.pos[0]);\n                this.node_dragged.pos[1] = Math.round(this.node_dragged.pos[1]);\n                if (this.graph.config.align_to_grid) {\n                    this.node_dragged.alignToGrid();\n                }\n                if (this.onNodeMoved) this.onNodeMoved(this.node_dragged);\n                this.graph.afterChange(this.node_dragged);\n                this.node_dragged = null;\n            } else {\n                // get node over\n                const node = this.graph.getNodeOnPos(\n                    e.canvasX,\n                    e.canvasY,\n                    this.visible_nodes,\n                );\n\n                if (!node && e.click_time < 300) {\n                    this.deselectAllNodes();\n                }\n\n                this.dirty_canvas = true;\n                this.dragging_canvas = false;\n\n                if (this.node_over && this.node_over.onMouseUp) {\n                    this.node_over.onMouseUp(e, [e.canvasX - this.node_over.pos[0], e.canvasY - this.node_over.pos[1]], this);\n                }\n                if (\n                    this.node_capturing_input\n                    && this.node_capturing_input.onMouseUp\n                ) {\n                    this.node_capturing_input.onMouseUp(e, [\n                        e.canvasX - this.node_capturing_input.pos[0],\n                        e.canvasY - this.node_capturing_input.pos[1],\n                    ]);\n                }\n            }\n        } else if (e.which === 2) {\n            // middle button\n            // trace(\"middle\");\n            this.dirty_canvas = true;\n            this.dragging_canvas = false;\n        } else if (e.which === 3) {\n            // right button\n            // trace(\"right\");\n            this.dirty_canvas = true;\n            this.dragging_canvas = false;\n        }\n\n        this.graph.change();\n\n        e.stopPropagation();\n        e.preventDefault();\n        return false;\n    }\n\n    /**\n     * Called when a mouse wheel event has to be processed\n     * @method processMouseWheel\n     * @memberOf LGraphCanvas\n     * */\n    processMouseWheel(e) {\n        if (!this.graph || !this.allow_dragcanvas) {\n            return;\n        }\n\n        const delta = e.wheelDeltaY ?? e.detail * -60;\n\n        this.adjustMouseEvent(e);\n\n        let { scale } = this.ds;\n\n        if (delta > 0) {\n            scale *= 1.1;\n        } else if (delta < 0) {\n            scale *= 1 / 1.1;\n        }\n\n        // this.setZoom( scale, [ e.localX, e.localY ] );\n        this.ds.changeScale(scale, [e.localX, e.localY]);\n\n        this.graph.change();\n\n        e.preventDefault();\n        return false; // prevent default\n    }\n\n    /**\n     * returns true if a position (in graph space) is on top of a node little corner box\n     * @method isOverNodeBox\n     * @memberOf LGraphCanvas\n     * */\n    isOverNodeBox(node, canvasx, canvasy) {\n        const titleHeight = defaultConfig.NODE_TITLE_HEIGHT;\n        return !!isInsideRectangle(\n            canvasx,\n            canvasy,\n            node.pos[0] + 2,\n            node.pos[1] + 2 - titleHeight,\n            titleHeight - 4,\n            titleHeight - 4,\n        );\n    }\n\n    /**\n     * returns true if a position (in graph space) is on top of a node input slot\n     * @method isOverNodeInput\n     * @memberOf LGraphCanvas\n     * */\n    isOverNodeInput(\n        node,\n        canvasx,\n        canvasy,\n        slotPos,\n    ) {\n        if (node.inputs) {\n            for (let i = 0, l = node.inputs.length; i < l; ++i) {\n                const linkPos = node.getConnectionPos(true, i);\n                let isInside = false;\n                if (node.horizontal) {\n                    isInside = isInsideRectangle(\n                        canvasx,\n                        canvasy,\n                        linkPos[0] - 5,\n                        linkPos[1] - 10,\n                        10,\n                        20,\n                    );\n                } else {\n                    isInside = isInsideRectangle(\n                        canvasx,\n                        canvasy,\n                        linkPos[0] - 10,\n                        linkPos[1] - 5,\n                        40,\n                        10,\n                    );\n                }\n                if (isInside) {\n                    if (slotPos) {\n                        slotPos[0] = linkPos[0];\n                        slotPos[1] = linkPos[1];\n                    }\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * process a key event\n     * @method processKey\n     * @memberOf LGraphCanvas\n     * */\n    processKey(e) {\n        if (!this.graph) return;\n\n        let blockDefault = false;\n\n        if (e.target.localName === \"input\") {\n            return;\n        }\n\n        if (e.type === \"keydown\") {\n            if (e.keyCode === 32) {\n                // esc\n                this.dragging_canvas = true;\n                blockDefault = true;\n            }\n\n            // select all Control A\n            if (e.keyCode === 65 && e.ctrlKey) {\n                this.selectNodes();\n                blockDefault = true;\n            }\n\n            if (e.code === \"KeyC\" && (e.metaKey || e.ctrlKey) && !e.shiftKey) {\n                // copy\n                if (this.selected_nodes) {\n                    this.copyToClipboard();\n                    blockDefault = true;\n                }\n            }\n\n            if (e.code === \"KeyV\" && (e.metaKey || e.ctrlKey) && !e.shiftKey) {\n                // paste\n                this.pasteFromClipboard();\n            }\n\n            // delete or backspace\n            if ((e.keyCode === 46 || e.keyCode === 8)\n                && (e.target.localName !== \"input\" && e.target.localName !== \"textarea\")) {\n                this.deleteSelectedNodes();\n                blockDefault = true;\n            }\n\n            // collapse\n            // ...\n\n            // TODO\n            if (this.selected_nodes) {\n                for (var i in this.selected_nodes) {\n                    if (this.selected_nodes[i].onKeyDown) {\n                        this.selected_nodes[i].onKeyDown(e);\n                    }\n                }\n            }\n        } else if (e.type == \"keyup\") {\n            if (e.keyCode == 32) {\n                this.dragging_canvas = false;\n            }\n\n            if (this.selected_nodes) {\n                for (var i in this.selected_nodes) {\n                    if (this.selected_nodes[i].onKeyUp) {\n                        this.selected_nodes[i].onKeyUp(e);\n                    }\n                }\n            }\n        }\n\n        this.graph.change();\n\n        if (blockDefault) {\n            e.preventDefault();\n            e.stopImmediatePropagation();\n            return false;\n        }\n    }\n\n    pasteFromClipboard() {\n        const data = localStorage.getItem(\"litegrapheditor_clipboard\");\n        if (!data) return;\n\n        this.graph.beforeChange();\n\n        // create nodes\n        const clipboardInfo = JSON.parse(data);\n        const nodes = [];\n        for (const node_data of clipboardInfo.nodes) {\n            const node = LGraphNode.createNode(node_data.type);\n            if (node) {\n                node.configure(node_data);\n                node.pos[0] += 5;\n                node.pos[1] += 5;\n                this.graph.add(node);\n                nodes.push(node);\n            }\n        }\n\n        for (const link_info of clipboardInfo.links) {\n            const origin_node = nodes[link_info[0]];\n            const target_node = nodes[link_info[2]];\n            if (origin_node && target_node) origin_node.connect(link_info[1], target_node, link_info[3]);\n            else console.warn(\"Warning, nodes missing on pasting\");\n        }\n\n        this.selectNodes(nodes);\n\n        this.graph.afterChange();\n    }\n\n    copyToClipboard() {\n        const clipboardInfo = {\n            nodes: [],\n            links: [],\n        };\n        let index = 0;\n        const selectedNodesArray = [];\n\n        for (const selectedNode of this.selected_nodes) {\n            node._relative_id = index;\n            selectedNodesArray.push(node);\n            index += 1;\n        }\n\n        for (const node of selectedNodesArray) {\n            const cloned = node.clone();\n            if (!cloned) {\n                console.warn(`node type not found: ${node.type}`);\n                continue;\n            }\n            clipboardInfo.nodes.push(cloned.serialize());\n            if (node.inputs && node.inputs.length) {\n                for (let j = 0; j < node.inputs.length; ++j) {\n                    const input = node.inputs[j];\n                    if (!input || input.link == null) {\n                        continue;\n                    }\n                    const link_info = this.graph.links[input.link];\n                    if (!link_info) {\n                        continue;\n                    }\n                    const target_node = this.graph.getNodeById(\n                        link_info.origin_id,\n                    );\n                    if (!target_node || !this.selected_nodes[target_node.id]) {\n                        // improve this by allowing connections to non-selected nodes\n                        continue;\n                    } // not selected\n                    clipboardInfo.links.push([\n                        target_node._relative_id,\n                        link_info.origin_slot, // j,\n                        node._relative_id,\n                        link_info.target_slot,\n                    ]);\n                }\n            }\n        }\n\n        localStorage.setItem(\"litegrapheditor_clipboard\", JSON.stringify(clipboardInfo));\n    }\n\n    /**\n     * process a item drop event on top the canvas\n     * @method processDrop\n     * @memberOf LGraphCanvas\n     * */\n    processDrop(e) {\n        e.preventDefault();\n        this.adjustMouseEvent(e);\n\n        const pos = [e.canvasX, e.canvasY];\n        const node = this.graph ? this.graph.getNodeOnPos(pos[0], pos[1]) : null;\n\n        if (!node) {\n            let r = null;\n            if (this.onDropItem) r = this.onDropItem(e);\n            if (!r) {\n                this.checkDropItem(e);\n            }\n            return;\n        }\n\n        if (node.onDropFile || node.onDropData) {\n            const { files } = e.dataTransfer;\n            if (files && files.length) {\n                for (const file of files) {\n                    const filename = file.name;\n                    // console.log(file);\n\n                    if (node.onDropFile) {\n                        node.onDropFile(file);\n                    }\n\n                    if (node.onDropData) {\n                        // prepare reader\n                        const reader = new FileReader();\n                        reader.onload = (event) => {\n                            // console.log(event.target);\n                            const data = event.target.result;\n                            node.onDropData(data, filename, file);\n                        };\n\n                        // read data\n                        const type = file.type.split(\"/\")[0];\n                        if (type === \"text\" || type === \"\") {\n                            reader.readAsText(file);\n                        } else if (type === \"image\") {\n                            reader.readAsDataURL(file);\n                        } else {\n                            reader.readAsArrayBuffer(file);\n                        }\n                    }\n                }\n            }\n        }\n\n        if (node.onDropItem) {\n            if (node.onDropItem(e)) {\n                return true;\n            }\n        }\n\n        if (this.onDropItem) {\n            return this.onDropItem(e);\n        }\n\n        return false;\n    }\n\n    checkDropItem(e) {\n        if (e.dataTransfer.files.length) {\n            const file = e.dataTransfer.files[0];\n            const ext = getFileExtension(file.name).toLowerCase();\n            const nodetype = defaultConfig.node_types_by_file_extension[ext];\n            if (nodetype) {\n                this.graph.beforeChange();\n                const node = LGraphNode.createNode(nodetype.type);\n                node.pos = [e.canvasX, e.canvasY];\n                this.graph.add(node);\n                if (node.onDropFile) {\n                    node.onDropFile(file);\n                }\n                this.graph.afterChange();\n            }\n        }\n    }\n\n    processNodeDblClicked(n) {\n        if (this.onShowNodePanel) this.onShowNodePanel(n);\n        else this.showShowNodePanel(n);\n\n        if (this.onNodeDblClicked) this.onNodeDblClicked(n);\n\n        this.setDirty(true);\n    }\n\n    processNodeSelected(node, e) {\n        this.selectNode(node, e && e.shiftKey);\n        if (this.onNodeSelected) {\n            this.onNodeSelected(node);\n        }\n    }\n\n    /**\n     * selects a given node (or adds it to the current selection)\n     * @method selectNode\n     * @param {LGraphNode} node\n     * @param {boolean} addToCurrentSelection\n     * @memberOf LGraphCanvas\n     * */\n    selectNode(node, addToCurrentSelection) {\n        if (node == null) {\n            this.deselectAllNodes();\n        } else {\n            this.selectNodes([node], addToCurrentSelection);\n        }\n    }\n\n    /**\n     * selects several nodes (or adds them to the current selection)\n     * @method selectNodes\n     * @memberOf LGraphCanvas\n     * */\n    selectNodes(nodes = this.graph._nodes, addToCurrentSelection) {\n        if (!addToCurrentSelection) this.deselectAllNodes();\n\n        for (const node of nodes) {\n            if (node.is_selected) continue;\n\n            if (!node.is_selected && node.onSelected) node.onSelected();\n            node.is_selected = true;\n            this.selected_nodes[node.id] = node;\n\n            if (node.inputs) {\n                for (const input of node.inputs) this.highlighted_links[input.link] = true;\n            }\n\n            if (node.outputs) {\n                for (const out of node.outputs) {\n                    if (out.links) {\n                        for (const link of out.links) this.highlighted_links[link] = true;\n                    }\n                }\n            }\n        }\n\n        if (this.onSelectionChange) this.onSelectionChange(this.selected_nodes);\n\n        this.setDirty(true);\n    }\n\n    /**\n     * removes a node from the current selection\n     * @method deselectNode\n     * @memberOf LGraphCanvas\n     * */\n    deselectNode(node) {\n        if (!node.is_selected) return;\n        if (node.onDeselected) {\n            node.onDeselected();\n        }\n        node.is_selected = false;\n\n        if (this.onNodeDeselected) {\n            this.onNodeDeselected(node);\n        }\n\n        // remove highlighted\n        if (node.inputs) {\n            for (const input of node.inputs) delete this.highlighted_links[input.link];\n        }\n        if (node.outputs) {\n            for (const out of node.outputs) {\n                if (out.links) {\n                    for (const link of out.links) delete this.highlighted_links[link];\n                }\n            }\n        }\n    }\n\n    /**\n     * removes all nodes from the current selection\n     * @method deselectAllNodes\n     * @memberOf LGraphCanvas\n     * */\n    deselectAllNodes() {\n        if (!this.graph) return;\n        for (const node of this.graph._nodes) {\n            if (!node.is_selected) {\n                continue;\n            }\n            if (node.onDeselected) {\n                node.onDeselected();\n            }\n            node.is_selected = false;\n            if (this.onNodeDeselected) {\n                this.onNodeDeselected(node);\n            }\n        }\n        this.selected_nodes = {};\n        this.current_node = null;\n        this.highlighted_links = {};\n        if (this.onSelectionChange) this.onSelectionChange(this.selected_nodes);\n        this.setDirty(true);\n    }\n\n    /**\n     * deletes all nodes in the current selection from the graph\n     * @method deleteSelectedNodes\n     * @memberOf LGraphCanvas\n     * */\n    deleteSelectedNodes() {\n        this.graph.beforeChange();\n\n        // eslint-disable-next-line guard-for-in, no-restricted-syntax\n        for (const i in this.selected_nodes) {\n            const node = this.selected_nodes[i];\n\n            if (node.block_delete) continue;\n\n            // autoconnect when possible (very basic, only takes into account first input-output)\n            if (node.inputs\n                && node.inputs.length\n                && node.outputs\n                && node.outputs.length\n                && isValidConnection(node.inputs[0].type, node.outputs[0].type)\n                && node.inputs[0].link\n                && node.outputs[0].links\n                && node.outputs[0].links.length) {\n                const inputLink = node.graph.links[node.inputs[0].link];\n                const outputLink = node.graph.links[node.outputs[0].links[0]];\n                const inputNode = node.getInputNode(0);\n                const outputNode = node.getOutputNodes(0)[0];\n                if (inputNode && outputNode) {\n                    inputNode.connect(inputLink.origin_slot, outputNode, outputLink.target_slot);\n                }\n            }\n            this.graph.remove(node);\n            if (this.onNodeDeselected) this.onNodeDeselected(node);\n        }\n\n        this.selected_nodes = {};\n        this.current_node = null;\n        this.highlighted_links = {};\n        this.setDirty(true);\n        this.graph.afterChange();\n    }\n\n    /**\n     * centers the camera on a given node\n     * @method centerOnNode\n     * @memberOf LGraphCanvas\n     * */\n    centerOnNode(node) {\n        this.ds.offset[0] = -node.pos[0]\n            - node.size[0] * 0.5\n            + (this.canvas.width * 0.5) / this.ds.scale;\n        this.ds.offset[1] = -node.pos[1]\n            - node.size[1] * 0.5\n            + (this.canvas.height * 0.5) / this.ds.scale;\n        this.setDirty(true, true);\n    }\n\n    /**\n     * adds some useful properties to a mouse event, like the position in graph coordinates\n     * @method adjustMouseEvent\n     * @memberOf LGraphCanvas\n     * */\n    adjustMouseEvent(e) {\n        if (this.canvas) {\n            const b = this.canvas.getBoundingClientRect();\n            e.localX = e.clientX - b.left;\n            e.localY = e.clientY - b.top;\n        } else {\n            e.localX = e.clientX;\n            e.localY = e.clientY;\n        }\n\n        e.deltaX = e.localX - this.last_mouse_position[0];\n        e.deltaY = e.localY - this.last_mouse_position[1];\n\n        this.last_mouse_position[0] = e.localX;\n        this.last_mouse_position[1] = e.localY;\n\n        e.canvasX = e.localX / this.ds.scale - this.ds.offset[0];\n        e.canvasY = e.localY / this.ds.scale - this.ds.offset[1];\n    }\n\n    /**\n     * changes the zoom level of the graph (default is 1), you can pass also a place used to pivot\n     * the zoom\n     * @method setZoom\n     * @memberOf LGraphCanvas\n     * */\n    setZoom(value, zoomingCenter) {\n        this.ds.changeScale(value, zoomingCenter);\n        this.dirty_canvas = true;\n        this.dirty_bgcanvas = true;\n    }\n\n    /**\n     * converts a coordinate from graph coordinates to canvas2D coordinates\n     * @method convertOffsetToCanvas\n     * @memberOf LGraphCanvas\n     * */\n    convertOffsetToCanvas(pos) {\n        return this.ds.convertOffsetToCanvas(pos);\n    }\n\n    /**\n     * converts a coordinate from Canvas2D coordinates to graph space\n     * @method convertCanvasToOffset\n     * @memberOf LGraphCanvas\n     * */\n    convertCanvasToOffset(pos, out) {\n        return this.ds.convertCanvasToOffset(pos, out);\n    }\n\n    /**\n     * converts event coordinates from canvas2D to graph coordinates\n     * @method convertEventToCanvasOffset\n     * @param e\n     * @returns {Array}\n     * @memberOf LGraphCanvas\n     */\n    convertEventToCanvasOffset(e) {\n        const rect = this.canvas.getBoundingClientRect();\n        return this.convertCanvasToOffset([e.clientX - rect.left, e.clientY - rect.top]);\n    }\n\n    /**\n     * brings a node to front (above all other nodes)\n     * @method bringToFront\n     * @param {LGraphNode} node\n     * @memberOf LGraphCanvas\n     * */\n    bringToFront(node) {\n        const i = this.graph._nodes.indexOf(node);\n        if (i === -1) {\n            return;\n        }\n\n        this.graph._nodes.splice(i, 1);\n        this.graph._nodes.push(node);\n    }\n\n    /**\n     * sends a node to the back (below all other nodes)\n     * @method sendToBack\n     * @param {LGraphNode} node\n     * @memberOf LGraphCanvas\n     * */\n    sendToBack(node) {\n        const i = this.graph._nodes.indexOf(node);\n        if (i === -1) {\n            return;\n        }\n\n        this.graph._nodes.splice(i, 1);\n        this.graph._nodes.unshift(node);\n    }\n\n    /**\n     * checks which nodes are visible (inside the camera area)\n     * @method computeVisibleNodes\n     * @param {LGraphNode[]} [nodes]\n     * @param {LGraphNode[]} [out]\n     * @return {LGraphNode[]}\n     * @memberOf LGraphCanvas\n     * */\n    computeVisibleNodes(nodes, out = []) {\n        const visibleNodes = out;\n        nodes = this.graph._nodes;\n        visibleNodes.length = 0;\n        for (const n of nodes) {\n            // skip rendering nodes in live mode\n            if (this.live_mode && !n.onDrawBackground && !n.onDrawForeground) {\n                continue;\n            }\n\n            if (!overlapBounding(this.visible_area, n.getBounding(temp))) {\n                continue;\n            } // out of the visible area\n\n            visibleNodes.push(n);\n        }\n        return visibleNodes;\n    }\n\n    /**\n     * renders the whole canvas content, by rendering in two separated canvas, one containing the\n     * background grid and the connections, and one containing the nodes)\n     * @method draw\n     * @param {boolean} [force_canvas]\n     * @param {boolean} [force_bgcanvas]\n     * @memberOf LGraphCanvas\n     * */\n    draw(force_canvas, force_bgcanvas) {\n        if (!this.canvas || this.canvas.width === 0 || this.canvas.height === 0) return;\n\n        // fps counting\n        const now = getTime();\n        this.render_time = (now - this.last_draw_time) * 0.001;\n        this.last_draw_time = now;\n\n        if (this.graph) this.ds.computeVisibleArea();\n\n        if (\n            this.dirty_bgcanvas\n            || force_bgcanvas\n            || this.always_render_background\n            || (this.graph\n            && this.graph._last_trigger_time\n            && now - this.graph._last_trigger_time < 1000)\n        ) this.drawBackCanvas();\n\n        if (this.dirty_canvas || force_canvas) this.drawFrontCanvas();\n\n        this.fps = this.render_time ? 1.0 / this.render_time : 0;\n        this.frame += 1;\n    }\n\n    /**\n     * draws the front canvas (the one containing all the nodes)\n     * @method drawFrontCanvas\n     * @memberOf LGraphCanvas\n     * */\n    drawFrontCanvas() {\n        this.dirty_canvas = false;\n\n        if (!this.ctx) this.ctx = this.bgcanvas.getContext(\"2d\");\n        const { ctx } = this;\n        if (!ctx) return;\n\n        if (ctx.start2D) {\n            ctx.start2D();\n        }\n\n        const { canvas } = this;\n\n        // reset in case of error\n        ctx.restore();\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n\n        // clip dirty area if there is one, otherwise work in full canvas\n        if (this.dirty_area) {\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect(\n                this.dirty_area[0],\n                this.dirty_area[1],\n                this.dirty_area[2],\n                this.dirty_area[3],\n            );\n            ctx.clip();\n        }\n\n        if (this.clear_background) ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n        // draw bg canvas\n        if (this.bgcanvas === this.canvas) {\n            this.drawBackCanvas();\n        } else {\n            ctx.drawImage(this.bgcanvas, 0, 0);\n        }\n\n        // rendering\n        if (this.onRender) this.onRender(canvas, ctx);\n\n        // info widget\n        if (this.show_info) this.renderInfo(ctx);\n\n        if (this.graph) {\n            // apply transformations\n            ctx.save();\n            this.ds.toCanvasContext(ctx);\n\n            // draw nodes\n            let drawnNodes = 0;\n            const visibleNodes = this.computeVisibleNodes(null, this.visible_nodes);\n\n            for (const node of visibleNodes) {\n                // transform coords system\n                ctx.save();\n                ctx.translate(node.pos[0], node.pos[1]);\n\n                // Draw\n                this.drawNode(node, ctx);\n                drawnNodes += 1;\n\n                // Restore\n                ctx.restore();\n            }\n\n            // on top (debug)\n            if (this.render_execution_order) this.drawExecutionOrder(ctx);\n\n            // connections ontop?\n            if (this.graph.config.links_ontop && !this.live_mode) this.drawConnections(ctx);\n\n            // current connection (the one being dragged by the mouse)\n            if (this.connecting_pos) {\n                ctx.lineWidth = this.connections_width;\n                let linkColor = null;\n                switch (this.connecting_output.type) {\n                    case defaultConfig.EVENT:\n                        linkColor = defaultConfig.EVENT_LINK_COLOR;\n                        break;\n                    default:\n                        linkColor = defaultConfig.CONNECTING_LINK_COLOR;\n                }\n\n                // the connection being dragged by the mouse\n                this.renderLink(\n                    ctx,\n                    this.connecting_pos,\n                    [this.graph_mouse[0], this.graph_mouse[1]],\n                    null,\n                    false,\n                    null,\n                    linkColor,\n                    this.connecting_output.dir\n                    || (this.connecting_node.horizontal ? defaultConfig.DOWN : defaultConfig.RIGHT),\n                    defaultConfig.CENTER,\n                );\n\n                ctx.beginPath();\n                if (\n                    this.connecting_output.type === defaultConfig.EVENT\n                    || this.connecting_output.shape === defaultConfig.BOX_SHAPE\n                ) {\n                    ctx.rect(\n                        this.connecting_pos[0] - 6 + 0.5,\n                        this.connecting_pos[1] - 5 + 0.5,\n                        14,\n                        10,\n                    );\n                } else {\n                    ctx.arc(\n                        this.connecting_pos[0],\n                        this.connecting_pos[1],\n                        4,\n                        0,\n                        Math.PI * 2,\n                    );\n                }\n                ctx.fill();\n\n                ctx.fillStyle = \"#ffcc00\";\n                if (this._highlight_input) {\n                    ctx.beginPath();\n                    ctx.arc(\n                        this._highlight_input[0],\n                        this._highlight_input[1],\n                        6,\n                        0,\n                        Math.PI * 2,\n                    );\n                    ctx.fill();\n                }\n            }\n\n            // the selection rectangle\n            if (this.dragging_rectangle) {\n                ctx.strokeStyle = \"#FFF\";\n                ctx.strokeRect(\n                    this.dragging_rectangle[0],\n                    this.dragging_rectangle[1],\n                    this.dragging_rectangle[2],\n                    this.dragging_rectangle[3],\n                );\n            }\n\n            // on top of link center\n            if (this.over_link_center && this.render_link_tooltip) {\n                this.drawLinkTooltip(ctx, this.over_link_center);\n            } else if (this.onDrawLinkTooltip) {\n                this.onDrawLinkTooltip(ctx, null);\n            }\n\n            // custom info\n            if (this.onDrawForeground) {\n                this.onDrawForeground(ctx, this.visible_rect);\n            }\n\n            ctx.restore();\n        }\n\n        // draws panel in the corner\n        if (this._graph_stack && this._graph_stack.length) this.drawSubgraphPanel(ctx);\n\n        if (this.onDrawOverlay) this.onDrawOverlay(ctx);\n\n        if (this.dirty_area) ctx.restore();\n\n        if (ctx.finish2D) ctx.finish2D();\n    }\n\n    /**\n     * draws the panel in the corner that shows subgraph properties\n     * @method drawSubgraphPanel\n     * @memberOf LGraphCanvas\n     * */\n    drawSubgraphPanel(ctx) {\n        const subgraph = this.graph;\n        const subnode = subgraph._subgraph_node;\n        if (!subnode) {\n            console.warn(\"subgraph without subnode\");\n            return;\n        }\n\n        const num = subnode.inputs ? subnode.inputs.length : 0;\n        const w = 300;\n        const h = Math.floor(defaultConfig.NODE_SLOT_HEIGHT * 1.6);\n\n        ctx.fillStyle = \"#111\";\n        ctx.globalAlpha = 0.8;\n        ctx.beginPath();\n        ctx.roundRect(10, 10, w, (num + 1) * h + 50, 8);\n        ctx.fill();\n        ctx.globalAlpha = 1;\n\n        ctx.fillStyle = \"#888\";\n        ctx.font = \"14px Arial\";\n        ctx.textAlign = \"left\";\n        ctx.fillText(\"Graph Inputs\", 20, 34);\n\n        if (this.drawButton(w - 20, 20, 20, 20, \"X\", \"#151515\")) {\n            this.closeSubgraph();\n            return;\n        }\n\n        let y = 50;\n        ctx.font = \"20px Arial\";\n        if (subnode.inputs) {\n            for (const input of subnode.inputs) {\n                if (input.not_subgraph_input) continue;\n\n                // input button clicked\n                if (this.drawButton(20, y + 2, w - 20, h - 2)) {\n                    const type = subnode.constructor.input_node_type || \"graph/input\";\n                    this.graph.beforeChange();\n                    const newnode = createNode(type);\n                    if (newnode) {\n                        subgraph.add(newnode);\n                        this.block_click = false;\n                        this.last_click_position = null;\n                        this.selectNodes([newnode]);\n                        this.node_dragged = newnode;\n                        this.dragging_canvas = false;\n                        newnode.setProperty(\"name\", input.name);\n                        newnode.setProperty(\"type\", input.type);\n                        this.node_dragged.pos[0] = this.graph_mouse[0] - 5;\n                        this.node_dragged.pos[1] = this.graph_mouse[1] - 5;\n                        this.graph.afterChange();\n                    } else {\n                        console.error(\"graph input node not found:\", type);\n                    }\n                }\n\n                ctx.fillStyle = \"#9C9\";\n                ctx.beginPath();\n                ctx.arc(w - 16, y + h * 0.5, 5, 0, 2 * Math.PI);\n                ctx.fill();\n\n                ctx.fillStyle = \"#AAA\";\n                ctx.fillText(input.name, 50, y + h * 0.75);\n                const tw = ctx.measureText(input.name);\n                ctx.fillStyle = \"#777\";\n                ctx.fillText(input.type, 50 + tw.width + 10, y + h * 0.75);\n\n                y += h;\n            }\n        }\n\n        // add + button\n        if (this.drawButton(20, y + 2, w - 20, h - 2, \"+\", \"#151515\", \"#222\")) {\n            this.showSubgraphPropertiesDialog(subnode);\n        }\n    }\n\n    /**\n     * Draws a button into the canvas overlay and computes if it was clicked using the immediate\n     * gui paradigm\n     * @method drawButton\n     * @param x\n     * @param y\n     * @param w\n     * @param h\n     * @param text\n     * @param [bgcolor]\n     * @param [hovercolor]\n     * @param [textcolor]\n     * @returns {*|boolean}\n     * @memberOf LGraphCanvas\n     */\n    drawButton(x, y, w, h, text, bgcolor = defaultConfig.NODE_DEFAULT_COLOR, hovercolor = \"#555\", textcolor = defaultConfig.NODE_TEXT_COLOR) {\n        const { ctx } = this;\n\n        let pos = this.mouse;\n        const hover = isInsideRectangle(pos[0], pos[1], x, y, w, h);\n        pos = this.last_click_position;\n        const clicked = pos && isInsideRectangle(pos[0], pos[1], x, y, w, h);\n\n        ctx.fillStyle = hover ? hovercolor : bgcolor;\n        if (clicked) ctx.fillStyle = \"#AAA\";\n        ctx.beginPath();\n        ctx.roundRect(x, y, w, h, 4);\n        ctx.fill();\n\n        if (text) {\n            if (text.constructor === String) {\n                ctx.fillStyle = textcolor;\n                ctx.textAlign = \"center\";\n                // eslint-disable-next-line\n                ctx.font = `${(h * 0.65) | 0}px Arial`;\n                ctx.fillText(text, x + w * 0.5, y + h * 0.75);\n                ctx.textAlign = \"left\";\n            }\n        }\n\n        if (clicked) this.blockClick();\n        return clicked && !this.block_click;\n    }\n\n    isAreaClicked(x, y, w, h, holdClick) {\n        const pos = this.last_click_position;\n        const clicked = pos && isInsideRectangle(pos[0], pos[1], x, y, w, h);\n        if (clicked && holdClick) this.blockClick();\n        return clicked && !this.block_click;\n    }\n\n    /**\n     * draws some useful stats in the corner of the canvas\n     * @method renderInfo\n     * @memberOf LGraphCanvas\n     * */\n    renderInfo(ctx, x = 10, y = this.canvas.height - 80) {\n        ctx.save();\n        ctx.translate(x, y);\n\n        ctx.font = \"10px Arial\";\n        ctx.fillStyle = \"#888\";\n        if (this.graph) {\n            ctx.fillText(`T: ${this.graph.globaltime.toFixed(2)}s`, 5, 13);\n            ctx.fillText(`I: ${this.graph.iteration}`, 5, 13 * 2);\n            ctx.fillText(`N: ${this.graph._nodes.length} [${this.visible_nodes.length}]`, 5, 13 * 3);\n            ctx.fillText(`V: ${this.graph._version}`, 5, 13 * 4);\n            ctx.fillText(`FPS:${this.fps.toFixed(2)}`, 5, 13 * 5);\n        } else {\n            ctx.fillText(\"No graph selected\", 5, 13);\n        }\n        ctx.restore();\n    }\n\n    /**\n     * draws the back canvas (the one containing the background and the connections)\n     * @method drawBackCanvas\n     * @memberOf LGraphCanvas\n     * */\n    drawBackCanvas() {\n        const canvas = this.bgcanvas;\n        if (canvas.width !== this.canvas.width || canvas.height !== this.canvas.height) {\n            canvas.width = this.canvas.width;\n            canvas.height = this.canvas.height;\n        }\n\n        if (!this.bgctx) this.bgctx = this.bgcanvas.getContext(\"2d\");\n        const ctx = this.bgctx;\n        if (ctx.start) ctx.start();\n\n        // clear\n        if (this.clear_background) ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n        if (this._graph_stack && this._graph_stack.length) {\n            ctx.save();\n            const subgraphNode = this.graph._subgraph_node;\n            ctx.strokeStyle = subgraphNode.bgcolor;\n            ctx.lineWidth = 10;\n            ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);\n            ctx.lineWidth = 1;\n            ctx.font = \"40px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.fillStyle = subgraphNode.bgcolor || \"#AAA\";\n            let title = \"\";\n\n            for (const g of this._graph_stack) {\n                title += `${g._subgraph_node.getTitle()} >> `;\n            }\n\n            ctx.fillText(\n                title + subgraphNode.getTitle(),\n                canvas.width * 0.5,\n                40,\n            );\n            ctx.restore();\n        }\n\n        let bgAlreadyPainted = false;\n        if (this.onRenderBackground) {\n            bgAlreadyPainted = this.onRenderBackground(canvas, ctx);\n        }\n\n        // reset in case of error\n        ctx.restore();\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        this.visible_links.length = 0;\n\n        if (this.graph) {\n            // apply transformations\n            ctx.save();\n            this.ds.toCanvasContext(ctx);\n\n            // render BG\n            if (this.background_image && this.ds.scale > 0.5 && !bgAlreadyPainted) {\n                ctx.globalAlpha = this.zoom_modify_alpha\n                    ? (1.0 - 0.5 / this.ds.scale) * this.editor_alpha\n                    : this.editor_alpha;\n\n                ctx.imageSmoothingEnabled = false;\n                ctx.mozImageSmoothingEnabled = false;\n                ctx.imageSmoothingEnabled = false;\n                if (\n                    !this._bg_img\n                    || this._bg_img.id !== this.background_image\n                ) {\n                    this._bg_img = new Image();\n                    this._bg_img.id = this.background_image;\n                    this._bg_img.src = this.background_image;\n                    this._bg_img.onload = () => this.draw(true, true);\n                }\n\n                let pattern = null;\n                if (this._pattern == null && this._bg_img.width > 0) {\n                    pattern = ctx.createPattern(this._bg_img, \"repeat\");\n                    this._pattern_img = this._bg_img;\n                    this._pattern = pattern;\n                } else {\n                    pattern = this._pattern;\n                }\n                if (pattern) {\n                    ctx.fillStyle = pattern;\n                    ctx.fillRect(\n                        this.visible_area[0],\n                        this.visible_area[1],\n                        this.visible_area[2],\n                        this.visible_area[3],\n                    );\n                    ctx.fillStyle = \"transparent\";\n                }\n\n                ctx.globalAlpha = 1.0;\n                ctx.imageSmoothingEnabled = true;\n                ctx.mozImageSmoothingEnabled = true;\n                ctx.imageSmoothingEnabled = true;\n            }\n\n            // groups\n            if (this.graph._groups.length && !this.live_mode) this.drawGroups(canvas, ctx);\n\n            if (this.onDrawBackground) this.onDrawBackground(ctx, this.visible_area);\n\n            // bg\n            if (this.render_canvas_border) {\n                ctx.strokeStyle = \"#235\";\n                ctx.strokeRect(0, 0, canvas.width, canvas.height);\n            }\n\n            if (this.render_connections_shadows) {\n                ctx.shadowColor = \"#000\";\n                ctx.shadowOffsetX = 0;\n                ctx.shadowOffsetY = 0;\n                ctx.shadowBlur = 6;\n            } else {\n                ctx.shadowColor = \"rgba(0,0,0,0)\";\n            }\n\n            // draw connections\n            if (!this.live_mode) this.drawConnections(ctx);\n\n            ctx.shadowColor = \"rgba(0,0,0,0)\";\n\n            ctx.restore();\n        }\n\n        if (ctx.finish) ctx.finish();\n\n        this.dirty_bgcanvas = false;\n        this.dirty_canvas = true; // to force to repaint the front canvas with the bgcanvas\n    }\n\n    /**\n     * draws the given node inside the canvas\n     * @method drawNode\n     * @memberOf LGraphCanvas\n     * */\n    drawNode(node, ctx) {\n        let glow = false;\n        this.current_node = node;\n\n        const color = node.color || node.constructor.color || defaultConfig.NODE_DEFAULT_COLOR;\n        let bgcolor = node.bgcolor || node.constructor.bgcolor || defaultConfig.NODE_DEFAULT_BGCOLOR;\n\n        // shadow and glow\n        if (node.mouseOver) glow = true;\n\n        const lowQuality = this.ds.scale < 0.6; // zoomed out\n\n        // only render if it forces it to do it\n        if (this.live_mode) {\n            if (!node.flags.collapsed) {\n                ctx.shadowColor = \"transparent\";\n                if (node.onDrawForeground) {\n                    node.onDrawForeground(ctx, this, this.canvas);\n                }\n            }\n            return;\n        }\n\n        ctx.globalAlpha = this.editor_alpha;\n\n        if (this.render_shadows && !lowQuality) {\n            ctx.shadowColor = defaultConfig.DEFAULT_SHADOW_COLOR;\n            ctx.shadowOffsetX = 2 * this.ds.scale;\n            ctx.shadowOffsetY = 2 * this.ds.scale;\n            ctx.shadowBlur = 3 * this.ds.scale;\n        } else {\n            ctx.shadowColor = \"transparent\";\n        }\n\n        // custom draw collapsed method (draw after shadows because they are affected)\n        if (node.flags.collapsed\n            && node.onDrawCollapsed\n            && node.onDrawCollapsed(ctx, this) == true\n        ) {\n            return;\n        }\n\n        // clip if required (mask)\n        const shape = node._shape || defaultConfig.BOX_SHAPE;\n        const size = tempVC2;\n        tempVC2.set(node.size);\n        const { horizontal } = node; // || node.flags.horizontal;\n\n        if (node.flags.collapsed) {\n            ctx.font = this.inner_text_font;\n            const title = node.getTitle ? node.getTitle() : node.title;\n            if (title) {\n                node._collapsed_width = Math.min(\n                    node.size[0],\n                    ctx.measureText(title).width\n                    + defaultConfig.NODE_TITLE_HEIGHT * 2,\n                ); // LiteGraph.NODE_COLLAPSED_WIDTH;\n                size[0] = node._collapsed_width;\n                size[1] = 0;\n            }\n        }\n\n        if (node.clip_area) {\n            // Start clipping\n            ctx.save();\n            ctx.beginPath();\n            if (shape === defaultConfig.BOX_SHAPE) ctx.rect(0, 0, size[0], size[1]);\n            else if (shape === defaultConfig.ROUND_SHAPE) ctx.roundRect(0, 0, size[0], size[1], 10);\n            else if (shape === defaultConfig.CIRCLE_SHAPE) {\n                ctx.arc(\n                    size[0] * 0.5,\n                    size[1] * 0.5,\n                    size[0] * 0.5,\n                    0,\n                    Math.PI * 2,\n                );\n            }\n            ctx.clip();\n        }\n\n        // draw shape\n        if (node.has_errors) bgcolor = \"red\";\n        this.drawNodeShape(\n            node,\n            ctx,\n            size,\n            color,\n            bgcolor,\n            node.is_selected,\n            node.mouseOver,\n        );\n        ctx.shadowColor = \"transparent\";\n\n        // draw foreground\n        if (node.onDrawForeground) {\n            node.onDrawForeground(ctx, this, this.canvas);\n        }\n\n        // connection slots\n        ctx.textAlign = horizontal ? \"center\" : \"left\";\n        ctx.font = this.inner_text_font;\n\n        const renderText = !lowQuality;\n\n        const outSlot = this.connecting_output;\n        ctx.lineWidth = 1;\n\n        let maxY = 0;\n        const slotPos = new Float32Array(2); // to reuse\n\n        // render inputs and outputs\n        if (!node.flags.collapsed) {\n            // input connection slots\n            if (node.inputs) {\n                for (let i = 0; i < node.inputs.length; i++) {\n                    const slot = node.inputs[i];\n\n                    ctx.globalAlpha = this.editor_alpha;\n                    // change opacity of incompatible slots when dragging a connection\n                    if (this.connecting_node\n                        && !isValidConnection(slot.type, outSlot.type)) {\n                        ctx.globalAlpha = 0.4 * this.editor_alpha;\n                    }\n\n                    ctx.fillStyle = slot.link\n                        ? slot.color_on\n                        || this.default_connection_color.input_on\n                        : slot.color_off\n                        || this.default_connection_color.input_off;\n\n                    const pos = node.getConnectionPos(true, i, slotPos);\n                    pos[0] -= node.pos[0];\n                    pos[1] -= node.pos[1];\n                    if (maxY < pos[1] + defaultConfig.NODE_SLOT_HEIGHT * 0.5) {\n                        maxY = pos[1] + defaultConfig.NODE_SLOT_HEIGHT * 0.5;\n                    }\n\n                    ctx.beginPath();\n\n                    if (slot.type === defaultConfig.EVENT || slot.shape === defaultConfig.BOX_SHAPE) {\n                        if (horizontal) ctx.rect(pos[0] - 5 + 0.5, pos[1] - 8 + 0.5, 10, 14);\n                        else ctx.rect(pos[0] - 6 + 0.5, pos[1] - 5 + 0.5, 14, 10);\n                    } else if (slot.shape === defaultConfig.ARROW_SHAPE) {\n                        ctx.moveTo(pos[0] + 8, pos[1] + 0.5);\n                        ctx.lineTo(pos[0] - 4, pos[1] + 6 + 0.5);\n                        ctx.lineTo(pos[0] - 4, pos[1] - 6 + 0.5);\n                        ctx.closePath();\n                    } else if (lowQuality) {\n                        ctx.rect(pos[0] - 4, pos[1] - 4, 8, 8);\n                    } else {\n                        ctx.arc(pos[0], pos[1], 4, 0, Math.PI * 2);\n                    }\n                    ctx.fill();\n\n                    // render name\n                    if (renderText) {\n                        const text = slot.label ? slot.label : slot.name;\n                        if (text) {\n                            ctx.fillStyle = defaultConfig.NODE_TEXT_COLOR;\n                            if (horizontal || slot.dir === defaultConfig.UP) {\n                                ctx.fillText(text, pos[0], pos[1] - 10);\n                            } else {\n                                ctx.fillText(text, pos[0] + 10, pos[1] + 5);\n                            }\n                        }\n                    }\n                }\n            }\n\n            // output connection slots\n            if (this.connecting_node) {\n                ctx.globalAlpha = 0.4 * this.editor_alpha;\n            }\n\n            ctx.textAlign = horizontal ? \"center\" : \"right\";\n            ctx.strokeStyle = \"black\";\n            if (node.outputs) {\n                for (let i = 0; i < node.outputs.length; i++) {\n                    const slot = node.outputs[i];\n\n                    const pos = node.getConnectionPos(false, i, slotPos);\n                    pos[0] -= node.pos[0];\n                    pos[1] -= node.pos[1];\n                    if (maxY < pos[1] + defaultConfig.NODE_SLOT_HEIGHT * 0.5) {\n                        maxY = pos[1] + defaultConfig.NODE_SLOT_HEIGHT * 0.5;\n                    }\n\n                    ctx.fillStyle = slot.links && slot.links.length\n                        ? slot.color_on\n                        || this.default_connection_color.output_on\n                        : slot.color_off\n                        || this.default_connection_color.output_off;\n                    ctx.beginPath();\n                    // ctx.rect( node.size[0] - 14,i*14,10,10);\n\n                    if (\n                        slot.type === defaultConfig.EVENT\n                        || slot.shape === defaultConfig.BOX_SHAPE\n                    ) {\n                        if (horizontal) {\n                            ctx.rect(\n                                pos[0] - 5 + 0.5,\n                                pos[1] - 8 + 0.5,\n                                10,\n                                14,\n                            );\n                        } else {\n                            ctx.rect(\n                                pos[0] - 6 + 0.5,\n                                pos[1] - 5 + 0.5,\n                                14,\n                                10,\n                            );\n                        }\n                    } else if (slot.shape === defaultConfig.ARROW_SHAPE) {\n                        ctx.moveTo(pos[0] + 8, pos[1] + 0.5);\n                        ctx.lineTo(pos[0] - 4, pos[1] + 6 + 0.5);\n                        ctx.lineTo(pos[0] - 4, pos[1] - 6 + 0.5);\n                        ctx.closePath();\n                    } else if (lowQuality) {\n                        ctx.rect(pos[0] - 4, pos[1] - 4, 8, 8);\n                    } else {\n                        ctx.arc(pos[0], pos[1], 4, 0, Math.PI * 2);\n                    }\n\n                    ctx.fill();\n                    if (!lowQuality) ctx.stroke();\n\n                    // render output name\n                    if (renderText) {\n                        const text = slot.label != null ? slot.label : slot.name;\n                        if (text) {\n                            ctx.fillStyle = defaultConfig.NODE_TEXT_COLOR;\n                            if (horizontal || slot.dir === defaultConfig.DOWN) {\n                                ctx.fillText(text, pos[0], pos[1] - 8);\n                            } else {\n                                ctx.fillText(text, pos[0] - 10, pos[1] + 5);\n                            }\n                        }\n                    }\n                }\n            }\n\n            ctx.textAlign = \"left\";\n            ctx.globalAlpha = 1;\n\n            if (node.widgets) {\n                let widgetsY = maxY;\n                if (horizontal || node.widgets_up) widgetsY = 2;\n                if (node.widgets_start_y) widgetsY = node.widgets_start_y;\n                this.drawNodeWidgets(\n                    node,\n                    widgetsY,\n                    ctx,\n                    this.node_widget && this.node_widget[0] === node ? this.node_widget[1] : null,\n                );\n            }\n        } else if (this.render_collapsed_slots) {\n            // if collapsed\n            let inputSlot = null;\n            let outputSlot = null;\n            let storedSlot;\n\n            // get first connected slot to render\n            if (node.inputs) {\n                for (const slot of node.inputs) {\n                    if (slot.link == null) continue;\n                    inputSlot = slot;\n                    storedSlot = slot;\n                    break;\n                }\n            }\n            if (node.outputs) {\n                for (const slot of node.outputs) {\n                    if (!slot.links || !slot.links.length) continue;\n                    outputSlot = slot;\n                    storedSlot = slot;\n                }\n            }\n\n            if (inputSlot) {\n                let x = 0;\n                let y = defaultConfig.NODE_TITLE_HEIGHT * -0.5; // center\n                if (horizontal) {\n                    x = node._collapsed_width * 0.5;\n                    y = -defaultConfig.NODE_TITLE_HEIGHT;\n                }\n                ctx.fillStyle = \"#686\";\n                ctx.beginPath();\n                if (storedSlot.type === defaultConfig.EVENT\n                    || storedSlot.shape === defaultConfig.BOX_SHAPE) {\n                    ctx.rect(x - 7 + 0.5, y - 4, 14, 8);\n                } else if (storedSlot.shape === defaultConfig.ARROW_SHAPE) {\n                    ctx.moveTo(x + 8, y);\n                    ctx.lineTo(x + -4, y - 4);\n                    ctx.lineTo(x + -4, y + 4);\n                    ctx.closePath();\n                } else ctx.arc(x, y, 4, 0, Math.PI * 2);\n                ctx.fill();\n            }\n\n            if (outputSlot) {\n                let x = node._collapsed_width;\n                let y = defaultConfig.NODE_TITLE_HEIGHT * -0.5; // center\n                if (horizontal) {\n                    x = node._collapsed_width * 0.5;\n                    y = 0;\n                }\n                ctx.fillStyle = \"#686\";\n                ctx.strokeStyle = \"black\";\n                ctx.beginPath();\n                if (\n                    storedSlot.type === defaultConfig.EVENT\n                    || storedSlot.shape === defaultConfig.BOX_SHAPE\n                ) {\n                    ctx.rect(x - 7 + 0.5, y - 4, 14, 8);\n                } else if (slot.shape === defaultConfig.ARROW_SHAPE) {\n                    ctx.moveTo(x + 6, y);\n                    ctx.lineTo(x - 6, y - 4);\n                    ctx.lineTo(x - 6, y + 4);\n                    ctx.closePath();\n                } else ctx.arc(x, y, 4, 0, Math.PI * 2);\n                ctx.fill();\n                // ctx.stroke();\n            }\n        }\n\n        if (node.clip_area) ctx.restore();\n\n        ctx.globalAlpha = 1.0;\n    }\n\n    // used by this.over_link_center\n    drawLinkTooltip(ctx, link) {\n        const pos = link._pos;\n        ctx.fillStyle = \"black\";\n        ctx.beginPath();\n        ctx.arc(pos[0], pos[1], 3, 0, Math.PI * 2);\n        ctx.fill();\n\n        if (link.data == null) return;\n\n        if (this.onDrawLinkTooltip && this.onDrawLinkTooltip(ctx, link, this)) return;\n\n        const { data } = link;\n        let text;\n\n        if (data.constructor === Number) text = data.toFixed(2);\n        else if (data.constructor === String) text = `\"${data}\"`;\n        else if (data.constructor === Boolean) text = String(data);\n        else if (data.toToolTip) text = data.toToolTip();\n        else text = `[${data.constructor.name}]`;\n\n        if (!text) return;\n        text = text.substr(0, 30); // avoid weird\n\n        ctx.font = \"14px Courier New\";\n        const info = ctx.measureText(text);\n        const w = info.width + 20;\n        const h = 24;\n        ctx.shadowColor = \"black\";\n        ctx.shadowOffsetX = 2;\n        ctx.shadowOffsetY = 2;\n        ctx.shadowBlur = 3;\n        ctx.fillStyle = \"#454\";\n        ctx.beginPath();\n        ctx.roundRect(pos[0] - w * 0.5, pos[1] - 15 - h, w, h, 3, 3);\n        ctx.moveTo(pos[0] - 10, pos[1] - 15);\n        ctx.lineTo(pos[0] + 10, pos[1] - 15);\n        ctx.lineTo(pos[0], pos[1] - 5);\n        ctx.fill();\n        ctx.shadowColor = \"transparent\";\n        ctx.textAlign = \"center\";\n        ctx.fillStyle = \"#CEC\";\n        ctx.fillText(text, pos[0], pos[1] - 15 - h * 0.3);\n    }\n\n    /**\n     * draws the shape of the given node in the canvas\n     * @method drawNodeShape\n     * @memberOf LGraphCanvas\n     * */\n    drawNodeShape(\n        node,\n        ctx,\n        size,\n        fgcolor,\n        bgcolor,\n        selected,\n        mouseHover,\n    ) {\n        // bg rect\n        ctx.strokeStyle = fgcolor;\n        ctx.fillStyle = bgcolor;\n\n        const titleHeight = defaultConfig.NODE_TITLE_HEIGHT;\n        const lowQuality = this.ds.scale < 0.5;\n\n        // render node area depending on shape\n        const shape = node._shape || node.constructor.shape || defaultConfig.ROUND_SHAPE;\n\n        const { title_mode } = node.constructor;\n\n        let renderTitle = true;\n        if (title_mode === defaultConfig.TRANSPARENT_TITLE) renderTitle = false;\n        else if (title_mode === defaultConfig.AUTOHIDE_TITLE && mouseHover) renderTitle = true;\n\n        const area = tempArea;\n        area[0] = 0; // x\n        area[1] = renderTitle ? -titleHeight : 0; // y\n        area[2] = size[0] + 1; // w\n        area[3] = renderTitle ? size[1] + titleHeight : size[1]; // h\n\n        const oldAlpha = ctx.globalAlpha;\n\n        ctx.beginPath();\n        if (shape === defaultConfig.BOX_SHAPE || lowQuality) {\n            ctx.fillRect(area[0], area[1], area[2], area[3]);\n        } else if (shape === defaultConfig.ROUND_SHAPE || shape === defaultConfig.CARD_SHAPE) {\n            ctx.roundRect(\n                area[0],\n                area[1],\n                area[2],\n                area[3],\n                this.round_radius,\n                shape === defaultConfig.CARD_SHAPE ? 0 : this.round_radius,\n            );\n        } else if (shape === defaultConfig.CIRCLE_SHAPE) {\n            ctx.arc(\n                size[0] * 0.5,\n                size[1] * 0.5,\n                size[0] * 0.5,\n                0,\n                Math.PI * 2,\n            );\n        }\n        ctx.fill();\n\n        // separator\n        if (!node.flags.collapsed) {\n            ctx.shadowColor = \"transparent\";\n            ctx.fillStyle = \"rgba(0,0,0,0.2)\";\n            ctx.fillRect(0, -1, area[2], 2);\n        }\n        ctx.shadowColor = \"transparent\";\n\n        if (node.onDrawBackground) node.onDrawBackground(ctx, this, this.canvas, this.graph_mouse);\n\n        // title bg (remember, it is rendered ABOVE the node)\n        if (renderTitle || title_mode === defaultConfig.TRANSPARENT_TITLE) {\n            // title bar\n            if (node.onDrawTitleBar) {\n                node.onDrawTitleBar(ctx, titleHeight, size, this.ds.scale, fgcolor);\n            } else if (\n                title_mode !== defaultConfig.TRANSPARENT_TITLE\n                && (node.constructor.title_color || this.render_title_colored)\n            ) {\n                const titleColor = node.constructor.title_color || fgcolor;\n\n                if (node.flags.collapsed) {\n                    ctx.shadowColor = defaultConfig.DEFAULT_SHADOW_COLOR;\n                }\n\n                //* gradient test\n                if (this.use_gradients) {\n                    let grad = LGraphCanvas.gradients[titleColor];\n                    if (!grad) {\n                        grad = ctx.createLinearGradient(0, 0, 400, 0);\n                        LGraphCanvas.gradients[titleColor] = grad;\n                        grad.addColorStop(0, titleColor);\n                        grad.addColorStop(1, \"#000\");\n                    }\n                    ctx.fillStyle = grad;\n                } else {\n                    ctx.fillStyle = titleColor;\n                }\n\n                // ctx.globalAlpha = 0.5 * old_alpha;\n                ctx.beginPath();\n                if (shape === defaultConfig.BOX_SHAPE || lowQuality) {\n                    ctx.rect(0, -titleHeight, size[0] + 1, titleHeight);\n                } else if (shape === defaultConfig.ROUND_SHAPE || shape === defaultConfig.CARD_SHAPE) {\n                    ctx.roundRect(\n                        0,\n                        -titleHeight,\n                        size[0] + 1,\n                        titleHeight,\n                        this.round_radius,\n                        node.flags.collapsed ? this.round_radius : 0,\n                    );\n                }\n                ctx.fill();\n                ctx.shadowColor = \"transparent\";\n            }\n\n            // title box\n            const boxSize = 10;\n            if (node.onDrawTitleBox) {\n                node.onDrawTitleBox(ctx, titleHeight, size, this.ds.scale);\n            } else if ([defaultConfig.ROUND_SHAPE, defaultConfig.CIRCLE_SHAPE, defaultConfig.CARD_SHAPE].includes(shape)) {\n                if (lowQuality) {\n                    ctx.fillStyle = \"black\";\n                    ctx.beginPath();\n                    ctx.arc(\n                        titleHeight * 0.5,\n                        titleHeight * -0.5,\n                        boxSize * 0.5 + 1,\n                        0,\n                        Math.PI * 2,\n                    );\n                    ctx.fill();\n                }\n\n                ctx.fillStyle = node.boxcolor || defaultConfig.NODE_DEFAULT_BOXCOLOR;\n                if (lowQuality) ctx.fillRect(titleHeight * 0.5 - boxSize * 0.5, titleHeight * -0.5 - boxSize * 0.5, boxSize, boxSize);\n                else {\n                    ctx.beginPath();\n                    ctx.arc(\n                        titleHeight * 0.5,\n                        titleHeight * -0.5,\n                        boxSize * 0.5,\n                        0,\n                        Math.PI * 2,\n                    );\n                    ctx.fill();\n                }\n            } else {\n                if (lowQuality) {\n                    ctx.fillStyle = \"black\";\n                    ctx.fillRect(\n                        (titleHeight - boxSize) * 0.5 - 1,\n                        (titleHeight + boxSize) * -0.5 - 1,\n                        boxSize + 2,\n                        boxSize + 2,\n                    );\n                }\n                ctx.fillStyle = node.boxcolor || defaultConfig.NODE_DEFAULT_BOXCOLOR;\n                ctx.fillRect(\n                    (titleHeight - boxSize) * 0.5,\n                    (titleHeight + boxSize) * -0.5,\n                    boxSize,\n                    boxSize,\n                );\n            }\n            ctx.globalAlpha = oldAlpha;\n\n            // title text\n            if (node.onDrawTitleText) {\n                node.onDrawTitleText(\n                    ctx,\n                    titleHeight,\n                    size,\n                    this.ds.scale,\n                    this.title_text_font,\n                    selected,\n                );\n            }\n            if (!lowQuality) {\n                ctx.font = this.title_text_font;\n                const title = String(node.getTitle());\n                if (title) {\n                    if (selected) ctx.fillStyle = defaultConfig.NODE_SELECTED_TITLE_COLOR;\n                    else ctx.fillStyle = node.constructor.title_text_color || this.node_title_color;\n                    if (node.flags.collapsed) {\n                        ctx.textAlign = \"left\";\n                        const measure = ctx.measureText(title);\n                        ctx.fillText(\n                            title.substr(0, 20), // avoid urls too long\n                            titleHeight, // + measure.width * 0.5,\n                            defaultConfig.NODE_TITLE_TEXT_Y - titleHeight,\n                        );\n                        ctx.textAlign = \"left\";\n                    } else {\n                        ctx.textAlign = \"left\";\n                        ctx.fillText(\n                            title,\n                            titleHeight,\n                            defaultConfig.NODE_TITLE_TEXT_Y - titleHeight,\n                        );\n                    }\n                }\n            }\n\n            // subgraph box\n            if (!node.flags.collapsed && node.subgraph && !node.skip_subgraph_button) {\n                const w = defaultConfig.NODE_TITLE_HEIGHT;\n                const x = node.size[0] - w;\n                const over = isInsideRectangle(\n                    this.graph_mouse[0] - node.pos[0],\n                    this.graph_mouse[1] - node.pos[1],\n                    x + 2,\n                    -w + 2,\n                    w - 4,\n                    w - 4,\n                );\n                ctx.fillStyle = over ? \"#888\" : \"#555\";\n                if (shape === defaultConfig.BOX_SHAPE || lowQuality) {\n                    ctx.fillRect(x + 2, -w + 2, w - 4, w - 4);\n                } else {\n                    ctx.beginPath();\n                    ctx.roundRect(x + 2, -w + 2, w - 4, w - 4, 4);\n                    ctx.fill();\n                }\n                ctx.fillStyle = \"#333\";\n                ctx.beginPath();\n                ctx.moveTo(x + w * 0.2, -w * 0.6);\n                ctx.lineTo(x + w * 0.8, -w * 0.6);\n                ctx.lineTo(x + w * 0.5, -w * 0.3);\n                ctx.fill();\n            }\n\n            // custom title render\n            if (node.onDrawTitle) node.onDrawTitle(ctx);\n        }\n\n        // render selection marker\n        if (selected) {\n            if (node.onBounding) node.onBounding(area);\n\n            if (title_mode === defaultConfig.TRANSPARENT_TITLE) {\n                area[1] -= titleHeight;\n                area[3] += titleHeight;\n            }\n            ctx.lineWidth = 1;\n            ctx.globalAlpha = 0.8;\n            ctx.beginPath();\n            if (shape === defaultConfig.BOX_SHAPE) {\n                ctx.rect(\n                    -6 + area[0],\n                    -6 + area[1],\n                    12 + area[2],\n                    12 + area[3],\n                );\n            } else if (\n                shape === defaultConfig.ROUND_SHAPE\n                || (shape === defaultConfig.CARD_SHAPE && node.flags.collapsed)\n            ) {\n                ctx.roundRect(\n                    -6 + area[0],\n                    -6 + area[1],\n                    12 + area[2],\n                    12 + area[3],\n                    this.round_radius * 2,\n                );\n            } else if (shape === defaultConfig.CARD_SHAPE) {\n                ctx.roundRect(\n                    -6 + area[0],\n                    -6 + area[1],\n                    12 + area[2],\n                    12 + area[3],\n                    this.round_radius * 2,\n                    2,\n                );\n            } else if (shape === defaultConfig.CIRCLE_SHAPE) {\n                ctx.arc(\n                    size[0] * 0.5,\n                    size[1] * 0.5,\n                    size[0] * 0.5 + 6,\n                    0,\n                    Math.PI * 2,\n                );\n            }\n            ctx.strokeStyle = defaultConfig.NODE_BOX_OUTLINE_COLOR;\n            ctx.stroke();\n            ctx.strokeStyle = fgcolor;\n            ctx.globalAlpha = 1;\n        }\n    }\n\n    /**\n     * draws every connection visible in the canvas\n     * OPTIMIZE THIS: pre-catch connections position instead of recomputing them every time\n     * @method drawConnections\n     * @memberOf LGraphCanvas\n     * */\n    drawConnections(ctx) {\n        const now = getTime();\n        const { visible_area } = this;\n        marginArea[0] = visible_area[0] - 20;\n        marginArea[1] = visible_area[1] - 20;\n        marginArea[2] = visible_area[2] + 40;\n        marginArea[3] = visible_area[3] + 40;\n\n        // draw connections\n        ctx.lineWidth = this.connections_width;\n\n        ctx.fillStyle = \"#AAA\";\n        ctx.strokeStyle = \"#AAA\";\n        ctx.globalAlpha = this.editor_alpha;\n        // for every node\n        const nodes = this.graph._nodes;\n        for (const node of nodes) {\n            // for every input (we render just inputs because it is easier as every slot can only\n            // have one input)\n            if (!node.inputs || !node.inputs.length) {\n                continue;\n            }\n\n            for (let i = 0; i < node.inputs.length; ++i) {\n                const input = node.inputs[i];\n                if (!input || input.link == null) continue;\n\n                const linkId = input.link;\n                const link = this.graph.links[linkId];\n                if (!link) continue;\n\n                // find link info\n                const startNode = this.graph.getNodeById(link.origin_id);\n                if (!startNode) continue;\n\n                const startNodeSlot = link.origin_slot;\n                let startNodeSlotPos = null;\n                if (startNodeSlot === -1) {\n                    startNodeSlotPos = [\n                        startNode.pos[0] + 10,\n                        startNode.pos[1] + 10,\n                    ];\n                } else {\n                    startNodeSlotPos = startNode.getConnectionPos(\n                        false,\n                        startNodeSlot,\n                        tempA,\n                    );\n                }\n\n                const endNodeSlotPos = node.getConnectionPos(true, i, tempB);\n\n                // compute link bounding\n                linkBounding[0] = startNodeSlotPos[0];\n                linkBounding[1] = startNodeSlotPos[1];\n                linkBounding[2] = endNodeSlotPos[0] - startNodeSlotPos[0];\n                linkBounding[3] = endNodeSlotPos[1] - startNodeSlotPos[1];\n\n                if (linkBounding[2] < 0) {\n                    linkBounding[0] += linkBounding[2];\n                    linkBounding[2] = Math.abs(linkBounding[2]);\n                }\n                if (linkBounding[3] < 0) {\n                    linkBounding[1] += linkBounding[3];\n                    linkBounding[3] = Math.abs(linkBounding[3]);\n                }\n\n                // skip links outside of the visible area of the canvas\n                if (!overlapBounding(linkBounding, marginArea)) {\n                    continue;\n                }\n\n                const startSlot = startNode.outputs[startNodeSlot];\n                const endSlot = node.inputs[i];\n                if (!startSlot || !endSlot) continue;\n                const startDir = startSlot.dir\n                    || (startNode.horizontal ? defaultConfig.DOWN : defaultConfig.RIGHT);\n                const endDir = endSlot.dir\n                    || (node.horizontal ? defaultConfig.UP : defaultConfig.LEFT);\n\n                this.renderLink(\n                    ctx,\n                    startNodeSlotPos,\n                    endNodeSlotPos,\n                    link,\n                    false,\n                    0,\n                    null,\n                    startDir,\n                    endDir,\n                );\n\n                // event triggered rendered on top\n                if (link && link._last_time && now - link._last_time < 1000) {\n                    const f = 2.0 - (now - link._last_time) * 0.002;\n                    const tmp = ctx.globalAlpha;\n                    ctx.globalAlpha = tmp * f;\n                    this.renderLink(\n                        ctx,\n                        startNodeSlotPos,\n                        endNodeSlotPos,\n                        link,\n                        true,\n                        f,\n                        \"white\",\n                        startDir,\n                        endDir,\n                    );\n                    ctx.globalAlpha = tmp;\n                }\n            }\n        }\n        ctx.globalAlpha = 1;\n    }\n\n    /**\n     * draws a link between two points\n     * @method renderLink\n     * @param {vec2} a start pos\n     * @param {vec2} b end pos\n     * @param {Object} link the link object with all the link info\n     * @param {boolean} skipBorder ignore the shadow of the link\n     * @param {boolean} flow show flow animation (for events)\n     * @param {string} color the color for the link\n     * @param {number} startDir the direction enum\n     * @param {number} endDir the direction enum\n     * @param {number} numSubline number of sublines (useful to represent vec3 or rgb)\n     * @memberOf LGraphCanvas\n     * */\n    renderLink(\n        ctx,\n        a,\n        b,\n        link,\n        skipBorder,\n        flow,\n        color,\n        startDir,\n        endDir,\n        numSubline,\n    ) {\n        if (link) this.visible_links.push(link);\n\n        // choose color\n        if (!color && link) color = link.color || LGraphCanvas.link_type_colors[link.type];\n        if (!color) color = this.default_link_color;\n        if (link != null && this.highlighted_links[link.id]) color = \"#FFF\";\n\n        startDir = startDir || defaultConfig.RIGHT;\n        endDir = endDir || defaultConfig.LEFT;\n\n        const dist = distance(a, b);\n\n        if (this.render_connections_border && this.ds.scale > 0.6) {\n            ctx.lineWidth = this.connections_width + 4;\n        }\n        ctx.lineJoin = \"round\";\n        numSubline = numSubline || 1;\n        if (numSubline > 1) ctx.lineWidth = 0.5;\n\n        // begin line shape\n        ctx.beginPath();\n        for (let i = 0; i < numSubline; i += 1) {\n            const offsety = (i - (numSubline - 1) * 0.5) * 5;\n\n            if (this.links_render_mode === defaultConfig.SPLINE_LINK) {\n                ctx.moveTo(a[0], a[1] + offsety);\n                let startOffsetX = 0;\n                let startOffsetY = 0;\n                let endOffsetX = 0;\n                let endOffsetY = 0;\n                switch (startDir) {\n                    case defaultConfig.LEFT:\n                        startOffsetX = dist * -0.25;\n                        break;\n                    case defaultConfig.RIGHT:\n                        startOffsetX = dist * 0.25;\n                        break;\n                    case defaultConfig.UP:\n                        startOffsetY = dist * -0.25;\n                        break;\n                    case defaultConfig.DOWN:\n                        startOffsetY = dist * 0.25;\n                        break;\n                    default:\n                        break;\n                }\n                switch (endDir) {\n                    case defaultConfig.LEFT:\n                        endOffsetX = dist * -0.25;\n                        break;\n                    case defaultConfig.RIGHT:\n                        endOffsetX = dist * 0.25;\n                        break;\n                    case defaultConfig.UP:\n                        endOffsetY = dist * -0.25;\n                        break;\n                    case defaultConfig.DOWN:\n                        endOffsetY = dist * 0.25;\n                        break;\n                    default:\n                        break;\n                }\n                ctx.bezierCurveTo(\n                    a[0] + startOffsetX,\n                    a[1] + startOffsetY + offsety,\n                    b[0] + endOffsetX,\n                    b[1] + endOffsetY + offsety,\n                    b[0],\n                    b[1] + offsety,\n                );\n            } else if (this.links_render_mode === defaultConfig.LINEAR_LINK) {\n                ctx.moveTo(a[0], a[1] + offsety);\n                let startOffsetX = 0;\n                let startOffsetY = 0;\n                let endOffsetX = 0;\n                let endOffsetY = 0;\n                switch (startDir) {\n                    case defaultConfig.LEFT:\n                        startOffsetX = -1;\n                        break;\n                    case defaultConfig.RIGHT:\n                        startOffsetX = 1;\n                        break;\n                    case defaultConfig.UP:\n                        startOffsetY = -1;\n                        break;\n                    case defaultConfig.DOWN:\n                        startOffsetY = 1;\n                        break;\n                    default:\n                        break;\n                }\n                switch (endDir) {\n                    case defaultConfig.LEFT:\n                        endOffsetX = -1;\n                        break;\n                    case defaultConfig.RIGHT:\n                        endOffsetX = 1;\n                        break;\n                    case defaultConfig.UP:\n                        endOffsetY = -1;\n                        break;\n                    case defaultConfig.DOWN:\n                        endOffsetY = 1;\n                        break;\n                    default:\n                        break;\n                }\n                const l = 15;\n                ctx.lineTo(\n                    a[0] + startOffsetX * l,\n                    a[1] + startOffsetY * l + offsety,\n                );\n                ctx.lineTo(\n                    b[0] + endOffsetX * l,\n                    b[1] + endOffsetY * l + offsety,\n                );\n                ctx.lineTo(b[0], b[1] + offsety);\n            } else if (this.links_render_mode === defaultConfig.STRAIGHT_LINK) {\n                ctx.moveTo(a[0], a[1]);\n                let startX = a[0];\n                let startY = a[1];\n                let endX = b[0];\n                let endY = b[1];\n\n                if (startDir === defaultConfig.RIGHT) startX += 10;\n                else startY += 10;\n                if (endDir === defaultConfig.LEFT) endX -= 10;\n                else endY -= 10;\n\n                ctx.lineTo(startX, startY);\n                ctx.lineTo((startX + endX) * 0.5, startY);\n                ctx.lineTo((startX + endX) * 0.5, endY);\n                ctx.lineTo(endX, endY);\n                ctx.lineTo(b[0], b[1]);\n            } else return;\n        }\n\n        // rendering the outline of the connection can be a little bit slow\n        if (this.render_connections_border && this.ds.scale > 0.6 && !skipBorder) {\n            ctx.strokeStyle = \"rgba(0,0,0,0.5)\";\n            ctx.stroke();\n        }\n\n        ctx.lineWidth = this.connections_width;\n        ctx.fillStyle = color;\n        ctx.strokeStyle = color;\n        ctx.stroke();\n        // end line shape\n\n        const posConnectionPoint = this.computeConnectionPoint(a, b, 0.5, startDir, endDir);\n        if (link && link._pos) {\n            link._pos[0] = posConnectionPoint[0];\n            link._pos[1] = posConnectionPoint[1];\n        }\n\n        // render arrow in the middle\n        if (this.ds.scale >= 0.6 && this.highquality_render && endDir !== defaultConfig.CENTER) {\n            // render arrow\n            if (this.render_connection_arrows) {\n                // compute two points in the connection\n                const posA = this.computeConnectionPoint(a, b, 0.25, startDir, endDir);\n                const posB = this.computeConnectionPoint(a, b, 0.26, startDir, endDir);\n                const posC = this.computeConnectionPoint(a, b, 0.75, startDir, endDir);\n                const posD = this.computeConnectionPoint(a, b, 0.76, startDir, endDir);\n\n                // compute the angle between them so the arrow points in the right direction\n                let angleA = 0;\n                let angleB = 0;\n                if (this.render_curved_connections) {\n                    angleA = -Math.atan2(posB[0] - posA[0], posB[1] - posA[1]);\n                    angleB = -Math.atan2(posD[0] - posC[0], posD[1] - posC[1]);\n                } else angleB = angleA = b[1] > a[1] ? 0 : Math.PI;\n\n                // render arrow\n                ctx.save();\n                ctx.translate(posA[0], posA[1]);\n                ctx.rotate(angleA);\n                ctx.beginPath();\n                ctx.moveTo(-5, -3);\n                ctx.lineTo(0, 7);\n                ctx.lineTo(5, -3);\n                ctx.fill();\n                ctx.restore();\n                ctx.save();\n                ctx.translate(posC[0], posC[1]);\n                ctx.rotate(angleB);\n                ctx.beginPath();\n                ctx.moveTo(-5, -3);\n                ctx.lineTo(0, 7);\n                ctx.lineTo(5, -3);\n                ctx.fill();\n                ctx.restore();\n            }\n\n            // circle\n            ctx.beginPath();\n            ctx.arc(posConnectionPoint[0], posConnectionPoint[1], 5, 0, Math.PI * 2);\n            ctx.fill();\n        }\n\n        // render flowing points\n        if (flow) {\n            ctx.fillStyle = color;\n            for (let i = 0; i < 5; ++i) {\n                const f = (getTime() * 0.001 + i * 0.2) % 1;\n                const pos = this.computeConnectionPoint(a, b, f, startDir, endDir);\n                ctx.beginPath();\n                ctx.arc(pos[0], pos[1], 5, 0, 2 * Math.PI);\n                ctx.fill();\n            }\n        }\n    }\n\n    /**\n     * returns the link center point based on curvature\n     * @method computeConnectionPoint\n     * @param a\n     * @param b\n     * @param t\n     * @param [startDir]\n     * @param [endDir]\n     * @returns {number[]}\n     * @memberOf LGraphCanvas\n     */\n    computeConnectionPoint(a, b, t, startDir = defaultConfig.RIGHT, endDir = defaultConfig.LEFT) {\n        const dist = distance(a, b);\n        const p0 = a;\n        const p1 = [a[0], a[1]];\n        const p2 = [b[0], b[1]];\n        const p3 = b;\n\n        switch (startDir) {\n            case defaultConfig.LEFT:\n                p1[0] += dist * -0.25;\n                break;\n            case defaultConfig.RIGHT:\n                p1[0] += dist * 0.25;\n                break;\n            case defaultConfig.UP:\n                p1[1] += dist * -0.25;\n                break;\n            case defaultConfig.DOWN:\n                p1[1] += dist * 0.25;\n                break;\n            default:\n                break;\n        }\n        switch (endDir) {\n            case defaultConfig.LEFT:\n                p2[0] += dist * -0.25;\n                break;\n            case defaultConfig.RIGHT:\n                p2[0] += dist * 0.25;\n                break;\n            case defaultConfig.UP:\n                p2[1] += dist * -0.25;\n                break;\n            case defaultConfig.DOWN:\n                p2[1] += dist * 0.25;\n                break;\n            default:\n                break;\n        }\n\n        const c1 = (1 - t) * (1 - t) * (1 - t);\n        const c2 = 3 * ((1 - t) * (1 - t)) * t;\n        const c3 = 3 * (1 - t) * (t * t);\n        const c4 = t * t * t;\n\n        const x = c1 * p0[0] + c2 * p1[0] + c3 * p2[0] + c4 * p3[0];\n        const y = c1 * p0[1] + c2 * p1[1] + c3 * p2[1] + c4 * p3[1];\n        return [x, y];\n    }\n\n    drawExecutionOrder(ctx) {\n        ctx.shadowColor = \"transparent\";\n        ctx.globalAlpha = 0.25;\n\n        ctx.textAlign = \"center\";\n        ctx.strokeStyle = \"white\";\n        ctx.globalAlpha = 0.75;\n\n        const { visible_nodes } = this;\n        for (const node of visible_nodes) {\n            ctx.fillStyle = \"black\";\n            ctx.fillRect(\n                node.pos[0] - defaultConfig.NODE_TITLE_HEIGHT,\n                node.pos[1] - defaultConfig.NODE_TITLE_HEIGHT,\n                defaultConfig.NODE_TITLE_HEIGHT,\n                defaultConfig.NODE_TITLE_HEIGHT,\n            );\n            if (node.order === 0) {\n                ctx.strokeRect(\n                    node.pos[0] - defaultConfig.NODE_TITLE_HEIGHT + 0.5,\n                    node.pos[1] - defaultConfig.NODE_TITLE_HEIGHT + 0.5,\n                    defaultConfig.NODE_TITLE_HEIGHT,\n                    defaultConfig.NODE_TITLE_HEIGHT,\n                );\n            }\n            ctx.fillStyle = \"#FFF\";\n            ctx.fillText(\n                node.order,\n                node.pos[0] + defaultConfig.NODE_TITLE_HEIGHT * -0.5,\n                node.pos[1] - 6,\n            );\n        }\n        ctx.globalAlpha = 1;\n    }\n\n    /**\n     * draws the widgets stored inside a node\n     * @method drawNodeWidgets\n     * @memberOf LGraphCanvas\n     * */\n    drawNodeWidgets(node, posY, ctx, active_widget) {\n        if (!node.widgets || !node.widgets.length) return 0;\n        const width = node.size[0];\n        const { widgets } = node;\n        posY += 2;\n        const H = defaultConfig.NODE_WIDGET_HEIGHT;\n        const showText = this.ds.scale > 0.5;\n        ctx.save();\n        ctx.globalAlpha = this.editor_alpha;\n        const outlineColor = defaultConfig.WIDGET_OUTLINE_COLOR;\n        const backgroundColor = defaultConfig.WIDGET_BGCOLOR;\n        const textColor = defaultConfig.WIDGET_TEXT_COLOR;\n        const secondaryTextColor = defaultConfig.WIDGET_SECONDARY_TEXT_COLOR;\n        const margin = 15;\n\n        for (const w of widgets) {\n            let y = posY;\n            if (w.y) y = w.y;\n            w.last_y = y;\n            ctx.strokeStyle = outlineColor;\n            ctx.fillStyle = \"#222\";\n            ctx.textAlign = \"left\";\n            // ctx.lineWidth = 2;\n            if (w.disabled) ctx.globalAlpha *= 0.5;\n            const widgetWidth = w.width || width;\n\n            switch (w.type) {\n                case \"button\":\n                    if (w.clicked) {\n                        ctx.fillStyle = \"#AAA\";\n                        w.clicked = false;\n                        this.dirty_canvas = true;\n                    }\n                    ctx.fillRect(margin, y, widgetWidth - margin * 2, H);\n                    if (showText && !w.disabled) ctx.strokeRect(margin, y, widgetWidth - margin * 2, H);\n                    if (showText) {\n                        ctx.textAlign = \"center\";\n                        ctx.fillStyle = textColor;\n                        ctx.fillText(w.name, widgetWidth * 0.5, y + H * 0.7);\n                    }\n                    break;\n                case \"toggle\":\n                    ctx.textAlign = \"left\";\n                    ctx.strokeStyle = outlineColor;\n                    ctx.fillStyle = backgroundColor;\n                    ctx.beginPath();\n\n                    if (showText) ctx.roundRect(margin, posY, widgetWidth - margin * 2, H, H * 0.5);\n                    else ctx.rect(margin, posY, widgetWidth - margin * 2, H);\n\n                    ctx.fill();\n                    if (showText && !w.disabled) ctx.stroke();\n                    ctx.fillStyle = w.value ? \"#89A\" : \"#333\";\n                    ctx.beginPath();\n                    ctx.arc(widgetWidth - margin * 2, y + H * 0.5, H * 0.36, 0, Math.PI * 2);\n                    ctx.fill();\n                    if (showText) {\n                        ctx.fillStyle = secondaryTextColor;\n                        if (w.name) ctx.fillText(w.name, margin * 2, y + H * 0.7);\n                        ctx.fillStyle = w.value ? textColor : secondaryTextColor;\n                        ctx.textAlign = \"right\";\n                        ctx.fillText(\n                            w.value\n                                ? w.options.on || \"true\"\n                                : w.options.off || \"false\",\n                            widgetWidth - 40,\n                            y + H * 0.7,\n                        );\n                    }\n                    break;\n                case \"slider\":\n                    ctx.fillStyle = backgroundColor;\n                    ctx.fillRect(margin, y, widgetWidth - margin * 2, H);\n                    var range = w.options.max - w.options.min;\n                    var nvalue = (w.value - w.options.min) / range;\n                    ctx.fillStyle = active_widget === w ? \"#89A\" : \"#678\";\n                    ctx.fillRect(margin, y, nvalue * (widgetWidth - margin * 2), H);\n                    if (showText && !w.disabled) ctx.strokeRect(margin, y, widgetWidth - margin * 2, H);\n                    if (w.marker) {\n                        const marker_nvalue = (w.marker - w.options.min) / range;\n                        ctx.fillStyle = \"#AA9\";\n                        ctx.fillRect(margin + marker_nvalue * (widgetWidth - margin * 2), y, 2, H);\n                    }\n                    if (showText) {\n                        ctx.textAlign = \"center\";\n                        ctx.fillStyle = textColor;\n                        ctx.fillText(\n                            `${w.name}  ${Number(w.value)\n                                .toFixed(3)}`,\n                            widgetWidth * 0.5,\n                            y + H * 0.7,\n                        );\n                    }\n                    break;\n                case \"number\":\n                case \"combo\":\n                    ctx.textAlign = \"left\";\n                    ctx.strokeStyle = outlineColor;\n                    ctx.fillStyle = backgroundColor;\n                    ctx.beginPath();\n                    if (showText) ctx.roundRect(margin, posY, widgetWidth - margin * 2, H, H * 0.5);\n                    else ctx.rect(margin, posY, widgetWidth - margin * 2, H);\n                    ctx.fill();\n                    if (showText) {\n                        if (!w.disabled) ctx.stroke();\n                        ctx.fillStyle = textColor;\n                        if (!w.disabled) {\n                            ctx.beginPath();\n                            ctx.moveTo(margin + 16, posY + 5);\n                            ctx.lineTo(margin + 6, posY + H * 0.5);\n                            ctx.lineTo(margin + 16, posY + H - 5);\n                            ctx.fill();\n                            ctx.beginPath();\n                            ctx.moveTo(widgetWidth - margin - 16, posY + 5);\n                            ctx.lineTo(widgetWidth - margin - 6, posY + H * 0.5);\n                            ctx.lineTo(widgetWidth - margin - 16, posY + H - 5);\n                            ctx.fill();\n                        }\n                        ctx.fillStyle = secondaryTextColor;\n                        ctx.fillText(w.name, margin * 2 + 5, y + H * 0.7);\n                        ctx.fillStyle = textColor;\n                        ctx.textAlign = \"right\";\n                        if (w.type === \"number\") {\n                            ctx.fillText(\n                                Number(w.value)\n                                    .toFixed(\n                                        w.options.precision\n                                            ? w.options.precision\n                                            : 3,\n                                    ),\n                                widgetWidth - margin * 2 - 20,\n                                y + H * 0.7,\n                            );\n                        } else {\n                            let v = w.value;\n                            if (w.options.values) {\n                                let { values } = w.options;\n                                if (values.constructor === Function) values = values();\n                                if (values && values.constructor !== Array) v = values[w.value];\n                            }\n                            ctx.fillText(\n                                v,\n                                widgetWidth - margin * 2 - 20,\n                                y + H * 0.7,\n                            );\n                        }\n                    }\n                    break;\n                case \"string\":\n                case \"text\":\n                    ctx.textAlign = \"left\";\n                    ctx.strokeStyle = outlineColor;\n                    ctx.fillStyle = backgroundColor;\n                    ctx.beginPath();\n\n                    if (showText) ctx.roundRect(margin, posY, widgetWidth - margin * 2, H, H * 0.5);\n                    else ctx.rect(margin, posY, widgetWidth - margin * 2, H);\n\n                    ctx.fill();\n                    if (showText) {\n                        if (!w.disabled) ctx.stroke();\n                        ctx.save();\n                        ctx.beginPath();\n                        ctx.rect(margin, posY, widgetWidth - margin * 2, H);\n                        ctx.clip();\n\n                        // ctx.stroke();\n                        ctx.fillStyle = secondaryTextColor;\n                        if (w.name) ctx.fillText(w.name, margin * 2, y + H * 0.7);\n                        ctx.fillStyle = textColor;\n                        ctx.textAlign = \"right\";\n                        ctx.fillText(String(w.value)\n                            .substr(0, 30), widgetWidth - margin * 2, y + H * 0.7); // 30 chars max\n                        ctx.restore();\n                    }\n                    break;\n                default:\n                    if (w.draw) w.draw(ctx, node, widgetWidth, y, H);\n                    break;\n            }\n            posY += (w.computeSize ? w.computeSize(widgetWidth)[1] : H) + 4;\n            ctx.globalAlpha = this.editor_alpha;\n        }\n        ctx.restore();\n        ctx.textAlign = \"left\";\n    }\n\n    /**\n     * process an event on widgets\n     * @method processNodeWidgets\n     * @memberOf LGraphCanvas\n     * */\n    processNodeWidgets(node, pos, event, activeWidget) {\n        if (!node.widgets || !node.widgets.length) return null;\n\n        const x = pos[0] - node.pos[0];\n        const y = pos[1] - node.pos[1];\n        const width = node.size[0];\n        const refWindow = this.getCanvasWindow();\n\n        for (const w of node.widgets) {\n            if (!w || w.disabled) continue;\n            const widgetHeight = w.computeSize ? w.computeSize(width)[1] : defaultConfig.NODE_WIDGET_HEIGHT;\n            const widgetWidth = w.width || width;\n            // outside\n            if (w !== activeWidget\n                && (x < 6 || x > widgetWidth - 12 || y < w.last_y || y > w.last_y + widgetHeight)) {\n                continue;\n            }\n\n            const oldValue = w.value;\n\n            // if ( w == active_widget || (x > 6 && x < widget_width - 12 && y > w.last_y && y <\n            // w.last_y + widget_height) ) { inside widget\n            switch (w.type) {\n                case \"button\":\n                    if (event.type === \"mousemove\") {\n                        break;\n                    }\n                    if (w.callback) {\n                        setTimeout(() => w.callback(w, this, node, pos, event), 20);\n                    }\n                    w.clicked = true;\n                    this.dirty_canvas = true;\n                    break;\n                case \"slider\":\n                    const range = w.options.max - w.options.min;\n                    const nvalue = Math.clamp((x - 15) / (widgetWidth - 30), 0, 1);\n                    w.value = w.options.min + (w.options.max - w.options.min) * nvalue;\n                    if (w.callback) {\n                        setTimeout(() => innerValueChange(w, w.value), 20);\n                    }\n                    this.dirty_canvas = true;\n                    break;\n                case \"number\":\n                case \"combo\":\n                    const oldValue = w.value;\n                    if (event.type === \"mousemove\" && w.type === \"number\") {\n                        w.value += event.deltaX * 0.1 * (w.options.step || 1);\n                        if (w.options.min && w.value < w.options.min) w.value = w.options.min;\n                        if (w.options.max && w.value > w.options.max) w.value = w.options.max;\n                    } else if (event.type === \"mousedown\") {\n                        let { values } = w.options;\n                        if (values && values.constructor === Function) {\n                            values = w.options.values(w, node);\n                        }\n                        let valuesList = [];\n\n                        if (w.type !== \"number\") valuesList = values.constructor === Array ? values : Object.keys(values);\n\n                        const delta = x < 40 ? -1 : x > widgetWidth - 40 ? 1 : 0;\n                        if (w.type === \"number\") {\n                            w.value += delta * 0.1 * (w.options.step || 1);\n                            if (w.options.min != null && w.value < w.options.min) {\n                                w.value = w.options.min;\n                            }\n                            if (w.options.max != null && w.value > w.options.max) {\n                                w.value = w.options.max;\n                            }\n                        } else if (delta) { // clicked in arrow, used for combos\n                            let index = -1;\n                            this.last_mouseclick = 0; // avoids dobl click event\n                            if (values.constructor === Object) {\n                                index = valuesList.indexOf(String(w.value)) + delta;\n                            } else {\n                                index = valuesList.indexOf(w.value) + delta;\n                            }\n                            if (index >= valuesList.length) {\n                                index = valuesList.length - 1;\n                            }\n                            if (index < 0) {\n                                index = 0;\n                            }\n                            if (values.constructor === Array) {\n                                w.value = values[index];\n                            } else {\n                                w.value = index;\n                            }\n                        } else { // combo clicked\n                            const textValues = values !== valuesList\n                                ? Object.values(values)\n                                : values;\n                            const menu = new ContextMenu(textValues, {\n                                scale: Math.max(1, this.ds.scale),\n                                event,\n                                className: \"dark\",\n                                callback: innerClicked.bind(w),\n                            },\n                            refWindow);\n\n                            function innerClicked(v, option, event) {\n                                if (values != valuesList) v = textValues.indexOf(v);\n                                this.value = v;\n                                innerValueChange(this, v);\n                                that.dirty_canvas = true;\n                                return false;\n                            }\n                        }\n                    } else if (event.type === \"mouseup\" && w.type === \"number\") {\n                        const delta = x < 40 ? -1 : x > widgetWidth - 40 ? 1 : 0;\n                        if (event.click_time < 200 && delta == 0) {\n                            this.prompt(\"Value\", w.value, (v) => {\n                                w.value = Number(v);\n                                innerValueChange(w, w.value);\n                            }, event);\n                        }\n                    }\n\n                    if (oldValue !== w.value) {\n                        setTimeout(\n                            () => {\n                                innerValueChange(this, this.value);\n                            },\n                            20,\n                        );\n                    }\n                    this.dirty_canvas = true;\n                    break;\n                case \"toggle\":\n                    if (event.type === \"mousedown\") {\n                        w.value = !w.value;\n                        setTimeout(() => {\n                            innerValueChange(w, w.value);\n                        }, 20);\n                    }\n                    break;\n                case \"string\":\n                case \"text\":\n                    if (event.type === \"mousedown\") {\n                        this.prompt(\"Value\", w.value, (v) => {\n                            w.value = v;\n                            innerValueChange(w, v);\n                        }, event, w.options ? w.options.multiline : false);\n                    }\n                    break;\n                default:\n                    if (w.mouse) {\n                        this.dirty_canvas = w.mouse(event, [x, y], node);\n                    }\n                    break;\n            } // end switch\n\n            // value changed\n            if (oldValue !== w.value) {\n                if (node.onWidgetChanged) node.onWidgetChanged(w.name, w.value, oldValue, w);\n                node.graph._version++;\n            }\n\n            return w;\n        }\n\n        const that = this;\n        function innerValueChange(widget, value) {\n            widget.value = value;\n            if (widget.options && widget.options.property && node.properties[widget.options.property]) {\n                node.setProperty(widget.options.property, value);\n            }\n            if (widget.callback) {\n                widget.callback(widget.value, that, node, pos, event);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * draws every group area in the background\n     * @method drawGroups\n     * @memberOf LGraphCanvas\n     * */\n    drawGroups(canvas, ctx) {\n        if (!this.graph) return;\n\n        const groups = this.graph._groups;\n\n        ctx.save();\n        ctx.globalAlpha = 0.5 * this.editor_alpha;\n\n        for (const group of groups) {\n            if (!overlapBounding(this.visible_area, group._bounding)) {\n                continue;\n            } // out of the visible area\n\n            ctx.fillStyle = group.color || \"#335\";\n            ctx.strokeStyle = group.color || \"#335\";\n            const pos = group._pos;\n            const size = group._size;\n            ctx.globalAlpha = 0.25 * this.editor_alpha;\n            ctx.beginPath();\n            ctx.rect(pos[0] + 0.5, pos[1] + 0.5, size[0], size[1]);\n            ctx.fill();\n            ctx.globalAlpha = this.editor_alpha;\n            ctx.stroke();\n\n            ctx.beginPath();\n            ctx.moveTo(pos[0] + size[0], pos[1] + size[1]);\n            ctx.lineTo(pos[0] + size[0] - 10, pos[1] + size[1]);\n            ctx.lineTo(pos[0] + size[0], pos[1] + size[1] - 10);\n            ctx.fill();\n\n            const fontSize = group.font_size || defaultConfig.DEFAULT_GROUP_FONT_SIZE;\n            ctx.font = `${fontSize}px Arial`;\n            ctx.fillText(group.title, pos[0] + 4, pos[1] + fontSize);\n        }\n\n        ctx.restore();\n    }\n\n    adjustNodesSize() {\n        const nodes = this.graph._nodes;\n        for (const node of nodes) node.size = node.computeSize();\n        this.setDirty(true, true);\n    }\n\n    /**\n     * resizes the canvas to a given size, if no size is passed, then it tries to fill the\n     * parentNode\n     * @method resize\n     * @memberOf LGraphCanvas\n     * */\n    resize(width, height) {\n        if (!width && !height) {\n            const parent = this.canvas.parentNode;\n            width = parent.offsetWidth;\n            height = parent.offsetHeight;\n        }\n\n        if (this.canvas.width === width && this.canvas.height === height) {\n            return;\n        }\n\n        this.canvas.width = width;\n        this.canvas.height = height;\n        this.bgcanvas.width = this.canvas.width;\n        this.bgcanvas.height = this.canvas.height;\n        this.setDirty(true, true);\n    }\n\n    /**\n     * switches to live mode (node shapes are not rendered, only the content)\n     * this feature was designed when graphs where meant to create user interfaces\n     * @method switchLiveMode\n     * @memberOf LGraphCanvas\n     * */\n    switchLiveMode(transition) {\n        if (!transition) {\n            this.live_mode = !this.live_mode;\n            this.dirty_canvas = true;\n            this.dirty_bgcanvas = true;\n            return;\n        }\n\n        const delta = this.live_mode ? 1.1 : 0.9;\n        if (this.live_mode) {\n            this.live_mode = false;\n            this.editor_alpha = 0.1;\n        }\n\n        const t = setInterval(() => {\n            this.editor_alpha *= delta;\n            this.dirty_canvas = true;\n            this.dirty_bgcanvas = true;\n\n            if (delta < 1 && this.editor_alpha < 0.01) {\n                clearInterval(t);\n                if (delta < 1) {\n                    this.live_mode = true;\n                }\n            }\n            if (delta > 1 && this.editor_alpha > 0.99) {\n                clearInterval(t);\n                this.editor_alpha = 1;\n            }\n        }, 1);\n    }\n\n    /**\n     * @method onNodeSelectionChange\n     * @param node\n     * @todo Need create event\n     * @memberOf LGraphCanvas\n     */\n    onNodeSelectionChange(node) {\n        // disabled\n    }\n\n    /**\n     * @method touchHandler\n     * @param {TouchEvent} event\n     * @memberOf LGraphCanvas\n     */\n    touchHandler(event) {\n        // alert(\"foo\");\n        const touches = event.changedTouches;\n        const first = touches[0];\n        let type = \"\";\n\n        switch (event.type) {\n            case \"touchstart\":\n                type = \"mousedown\";\n                break;\n            case \"touchmove\":\n                type = \"mousemove\";\n                break;\n            case \"touchend\":\n                type = \"mouseup\";\n                break;\n            default:\n                return;\n        }\n\n        // initMouseEvent(type, canBubble, cancelable, view, clickCount,\n        //           screenX, screenY, clientX, clientY, ctrlKey,\n        //           altKey, shiftKey, metaKey, button, relatedTarget);\n\n        const window = this.getCanvasWindow();\n        const { document } = window;\n\n        const simulatedEvent = document.createEvent(\"MouseEvent\");\n        simulatedEvent.initMouseEvent(\n            type,\n            true,\n            true,\n            window,\n            1,\n            first.screenX,\n            first.screenY,\n            first.clientX,\n            first.clientY,\n            false,\n            false,\n            false,\n            false,\n            0 /* left */,\n            null,\n        );\n        first.target.dispatchEvent(simulatedEvent);\n        event.preventDefault();\n    }\n\n    /**\n     * @method onGroupAdd\n     * @param info\n     * @param entry\n     * @param {MouseEvent} mouseEvent\n     * @memberOf LGraphCanvas\n     */\n    static onGroupAdd(info, entry, mouseEvent) {\n        const canvas = LGraphCanvas.active_canvas;\n\n        const group = new LGraphGroup();\n        group.pos = canvas.convertEventToCanvasOffset(mouseEvent);\n        canvas.graph.add(group);\n    }\n\n    static onMenuAdd(node, options, e, previousMenu, callback) {\n        const canvas = LGraphCanvas.active_canvas;\n        const refWindow = canvas.getCanvasWindow();\n        const { graph } = canvas;\n        if (!graph) return;\n\n        function inner_onMenuAdded(base_category, prev_menu) {\n            const categories = registry.getNodeTypesCategories(canvas.filter || graph.filter)\n                .filter((category) => category.startsWith(base_category));\n            const entries = [];\n\n            categories.forEach((category) => {\n                if (!category) {\n                    return;\n                }\n\n                const base_category_regex = new RegExp(`^(${base_category})`);\n                const category_name = category.replace(base_category_regex, \"\").split(\"/\")[0];\n                const category_path = base_category === \"\" ? `${category_name}/` : `${base_category + category_name}/`;\n\n                let name = category_name;\n                if (name.indexOf(\"::\") != -1) {\n                    name = name.split(\"::\")[1];\n                }\n\n                const index = entries.findIndex((entry) => entry.value === category_path);\n                if (index === -1) {\n                    entries.push({\n                        value: category_path,\n                        content: name,\n                        has_submenu: true,\n                        callback(value, event, mouseEvent, contextMenu) {\n                            inner_onMenuAdded(value.value, contextMenu);\n                        },\n                    });\n                }\n            });\n\n            const nodes = registry.getNodeTypesInCategory(base_category.slice(0, -1), canvas.filter || graph.filter);\n            nodes.forEach((node) => {\n                if (node.skip_list) return;\n\n                const entry = {\n                    value: node.type,\n                    content: node.title,\n                    has_submenu: false,\n                    callback(value, event, mouseEvent, contextMenu) {\n                        const first_event = contextMenu.getFirstEvent();\n                        canvas.graph.beforeChange();\n                        const node = LGraphNode.createNode(value.value);\n                        if (node) {\n                            node.pos = canvas.convertEventToCanvasOffset(first_event);\n                            canvas.graph.add(node);\n                        }\n                        if (callback) callback(node);\n                        canvas.graph.afterChange();\n                    },\n                };\n\n                entries.push(entry);\n            });\n\n            new ContextMenu(entries, {\n                event: e,\n                parentMenu: prev_menu,\n            }, refWindow);\n        }\n\n        inner_onMenuAdded(\"\", previousMenu);\n        return false;\n    }\n\n    /**\n     * @method onMenuCollapseAll\n     * @todo Need create event\n     * @memberOf LGraphCanvas\n     */\n    static onMenuCollapseAll() {\n    }\n\n    /**\n     * @method onMenuNodeEdit\n     * @todo Need create event\n     * @memberOf LGraphCanvas\n     */\n    static onMenuNodeEdit() {\n    }\n\n    static showMenuNodeOptionalInputs(v, optionsParam, e, previousMenu, node) {\n        if (!node) return;\n\n        const that = this;\n        const canvas = LGraphCanvas.active_canvas;\n        const refWindow = canvas.getCanvasWindow();\n\n        let options = node.optional_inputs;\n        if (node.onGetInputs) options = node.onGetInputs();\n\n        let entries = [];\n        if (options) {\n            for (const entry of options) {\n                if (!entry) {\n                    entries.push(null);\n                    continue;\n                }\n                let label = entry[0];\n                if (entry[2] && entry[2].label) {\n                    label = entry[2].label;\n                }\n                const data = {\n                    content: label,\n                    value: entry,\n                };\n                if (entry[1] === defaultConfig.ACTION) {\n                    data.className = \"event\";\n                }\n                entries.push(data);\n            }\n        }\n\n        if (this.onMenuNodeInputs) entries = this.onMenuNodeInputs(entries);\n\n        if (!entries.length) {\n            console.log(\"no input entries\");\n            return;\n        }\n\n        const menu = new ContextMenu(\n            entries,\n            {\n                event: e,\n                callback: innerClicked,\n                parentMenu: previousMenu,\n                node,\n            },\n            refWindow,\n        );\n\n        function innerClicked(v, e, prev) {\n            if (!node) {\n                return;\n            }\n\n            if (v.callback) {\n                v.callback.call(that, node, v, e, prev);\n            }\n\n            if (v.value) {\n                node.graph.beforeChange();\n                node.addInput(v.value[0], v.value[1], v.value[2]);\n                node.setDirtyCanvas(true, true);\n                node.graph.afterChange();\n            }\n        }\n\n        return false;\n    }\n\n    static showMenuNodeOptionalOutputs(v, optionsParam, e, previousMenu, node) {\n        if (!node) return;\n\n        const that = this;\n        const canvas = LGraphCanvas.active_canvas;\n        const refWindow = canvas.getCanvasWindow();\n\n        let options = node.optional_outputs;\n        if (node.onGetOutputs) {\n            options = node.onGetOutputs();\n        }\n\n        let entries = [];\n        if (options) {\n            for (const entry of options) {\n                if (!entry) {\n                    // separator?\n                    entries.push(null);\n                    continue;\n                }\n\n                if (node.flags\n                    && node.flags.skip_repeated_outputs\n                    && node.findOutputSlot(entry[0]) !== -1) {\n                    continue;\n                } // skip the ones already on\n                let label = entry[0];\n                if (entry[2] && entry[2].label) label = entry[2].label;\n                const data = {\n                    content: label,\n                    value: entry,\n                };\n                if (entry[1] === defaultConfig.EVENT) data.className = \"event\";\n                entries.push(data);\n            }\n        }\n\n        if (this.onMenuNodeOutputs) entries = this.onMenuNodeOutputs(entries);\n\n        if (!entries.length) return;\n\n        const menu = new ContextMenu(\n            entries,\n            {\n                event: e,\n                callback: innerClicked,\n                parentMenu: previousMenu,\n                node,\n            },\n            refWindow,\n        );\n\n        function innerClicked(v, e, prev) {\n            if (!node) return;\n\n            if (v.callback) v.callback.call(that, node, v, e, prev);\n\n            if (!v.value) {\n                return;\n            }\n\n            const value = v.value[1];\n\n            if (\n                value\n                && (value.constructor === Object || value.constructor === Array)\n            ) {\n                // submenu why?\n                const entries = [];\n                for (const i in value) {\n                    entries.push({\n                        content: i,\n                        value: value[i],\n                    });\n                }\n                new ContextMenu(entries, {\n                    event: e,\n                    callback: innerClicked,\n                    parentMenu: previousMenu,\n                    node,\n                });\n                return false;\n            }\n            node.graph.beforeChange();\n            node.addOutput(v.value[0], v.value[1], v.value[2]);\n            node.setDirtyCanvas(true, true);\n            node.graph.afterChange();\n        }\n\n        return false;\n    }\n\n    static onShowMenuNodeProperties(value, options, e, previousMenu, node) {\n        if (!node || !node.properties) {\n            return;\n        }\n\n        const canvas = LGraphCanvas.active_canvas;\n        const refWindow = canvas.getCanvasWindow();\n\n        const entries = [];\n        // eslint-disable-next-line\n        for (const i in node.properties) {\n            let value = node.properties[i] ? node.properties[i] : \" \";\n            if (typeof value === \"object\") value = JSON.stringify(value);\n            const info = node.getPropertyInfo(i);\n            if (info.type == \"enum\" || info.type == \"combo\") value = LGraphCanvas.getPropertyPrintableValue(value, info.values);\n\n            // value could contain invalid html characters, clean that\n            value = LGraphCanvas.decodeHTML(value);\n            entries.push({\n                content:\n                    `<span class=\"property_name\">${\n                        info.label ? info.label : i\n                    }</span>`\n                    + `<span class=\"property_value\">${\n                        value\n                    }</span>`,\n                value: i,\n            });\n        }\n        if (!entries.length) {\n            return;\n        }\n\n        const menu = new ContextMenu(\n            entries,\n            {\n                event: e,\n                callback: innerClicked,\n                parentMenu: previousMenu,\n                allow_html: true,\n                node,\n            },\n            refWindow,\n        );\n\n        function innerClicked(v) {\n            if (!node) {\n                return;\n            }\n            const rect = this.getBoundingClientRect();\n            canvas.showEditPropertyValue(node, v.value, {\n                position: [rect.left, rect.top],\n            });\n        }\n\n        return false;\n    }\n\n    static decodeHTML(str) {\n        const e = document.createElement(\"div\");\n        e.innerText = str;\n        return e.innerHTML;\n    }\n\n    static onResizeNode(value, options, e, menu, node) {\n        if (!node) return;\n        node.size = node.computeSize();\n        if (node.onResize) node.onResize(node.size);\n        node.setDirtyCanvas(true, true);\n    }\n\n    showLinkMenu(link, e) {\n        const that = this;\n        const options = [\"Add Node\", null, \"Delete\"];\n        const menu = new ContextMenu(options, {\n            event: e,\n            title: link.data != null ? link.data.constructor.name : null,\n            callback: innerClicked,\n        });\n\n        function innerClicked(v, options, e) {\n            switch (v) {\n                case \"Add Node\":\n                    LGraphCanvas.onMenuAdd(null, null, e, menu, (node) => {\n                        console.log(\"node autoconnect\");\n                        const nodeLeft = that.graph.getNodeById(link.origin_id);\n                        const nodeRight = that.graph.getNodeById(link.target_id);\n                        if (!node.inputs\n                            || !node.inputs.length\n                            || !node.outputs\n                            || !node.outputs.length) return;\n                        if (nodeLeft.outputs[link.origin_slot].type === node.inputs[0].type && node.outputs[0].type === nodeRight.inputs[0].type) {\n                            nodeLeft.connect(link.origin_slot, node, 0);\n                            node.connect(0, nodeRight, link.target_slot);\n                            node.pos[0] -= node.size[0] * 0.5;\n                        }\n                    });\n                    break;\n                case \"Delete\":\n                    that.graph.removeLink(link.id);\n                    break;\n                default:\n            }\n        }\n\n        return false;\n    }\n\n    static onShowPropertyEditor(item, options, e, menu, node) {\n        const property = item.property || \"title\";\n        const value = node[property];\n\n        const dialog = document.createElement(\"div\");\n        dialog.className = \"graphdialog\";\n        dialog.innerHTML = \"<span class='name'></span><input autofocus type='text' class='value'/><button>OK</button>\";\n\n        const title = dialog.querySelector(\".name\");\n        title.innerText = property;\n\n        const input = dialog.querySelector(\".value\");\n        if (input) {\n            input.value = value;\n            input.addEventListener(\"blur\", (e) => {\n                input.focus();\n            });\n            input.addEventListener(\"keydown\", (e) => {\n                if (e.keyCode !== 13 && e.target.localName !== \"textarea\") return;\n                setValue(input.value);\n                e.preventDefault();\n                e.stopPropagation();\n            });\n        }\n\n        const graphcanvas = LGraphCanvas.active_canvas;\n        const { canvas } = graphcanvas;\n\n        const rect = canvas.getBoundingClientRect();\n        let offsetx = -20;\n        let offsety = -20;\n        if (rect) {\n            offsetx -= rect.left;\n            offsety -= rect.top;\n        }\n\n        if (e) {\n            dialog.style.left = `${e.clientX + offsetx}px`;\n            dialog.style.top = `${e.clientY + offsety}px`;\n        } else {\n            dialog.style.left = `${canvas.width * 0.5 + offsetx}px`;\n            dialog.style.top = `${canvas.height * 0.5 + offsety}px`;\n        }\n\n        const button = dialog.querySelector(\"button\");\n        button.addEventListener(\"click\", () => setValue(input.value));\n        canvas.parentNode.appendChild(dialog);\n\n        function setValue(value) {\n            if (item.type === \"Number\") {\n                value = Number(value);\n            } else if (item.type === \"Boolean\") {\n                value = Boolean(value);\n            }\n            node[property] = value;\n            if (dialog.parentNode) {\n                dialog.remove();\n            }\n            node.setDirtyCanvas(true, true);\n        }\n    }\n\n    prompt(title = \"\", value, callback, event, multiline) {\n        const that = this;\n\n        let modified = false;\n\n        const dialog = document.createElement(\"div\");\n        dialog.className = \"graphdialog rounded\";\n        if (multiline) {\n            dialog.innerHTML = \"<span class='name'></span> <textarea autofocus class='value'></textarea><button class='rounded'>OK</button>\";\n        } else {\n            dialog.innerHTML = \"<span class='name'></span> <input autofocus type='text' class='value'/><button class='rounded'>OK</button>\";\n        }\n        dialog.close = () => {\n            this.prompt_box = null;\n            if (dialog.parentNode) dialog.remove();\n        };\n\n        if (this.ds.scale > 1) {\n            dialog.style.transform = `scale(${this.ds.scale})`;\n        }\n\n        dialog.addEventListener(\"mouseleave\", (e) => {\n            if (!modified) dialog.close();\n        });\n\n        if (this.prompt_box) {\n            this.prompt_box.close();\n        }\n        this.prompt_box = dialog;\n\n        const first = null;\n        const timeout = null;\n        const selected = null;\n\n        const nameElement = dialog.querySelector(\".name\");\n        nameElement.innerText = title;\n        const valueElement = dialog.querySelector(\".value\");\n        valueElement.value = value;\n\n        const input = valueElement;\n        input.addEventListener(\"keydown\", (e) => {\n            modified = true;\n            if (e.keyCode === 27) dialog.close();\n            else if (e.keyCode === 13 && e.target.localName !== \"textarea\") {\n                if (callback) {\n                    callback(input.value);\n                }\n                dialog.close();\n            } else {\n                return;\n            }\n            e.preventDefault();\n            e.stopPropagation();\n        });\n\n        const button = dialog.querySelector(\"button\");\n        button.addEventListener(\"click\", () => {\n            if (callback) callback(input.value);\n            this.setDirty(true);\n            dialog.close();\n        });\n\n        const graphcanvas = LGraphCanvas.active_canvas;\n        const { canvas } = graphcanvas;\n\n        const rect = canvas.getBoundingClientRect();\n        let offsetx = -20;\n        let offsety = -20;\n        if (rect) {\n            offsetx -= rect.left;\n            offsety -= rect.top;\n        }\n\n        if (event) {\n            dialog.style.left = `${event.clientX + offsetx}px`;\n            dialog.style.top = `${event.clientY + offsety}px`;\n        } else {\n            dialog.style.left = `${canvas.width * 0.5 + offsetx}px`;\n            dialog.style.top = `${canvas.height * 0.5 + offsety}px`;\n        }\n\n        canvas.parentNode.appendChild(dialog);\n        setTimeout(() => input.focus(), 10);\n\n        return dialog;\n    }\n\n    static search_limit = -1\n\n    showSearchBox = function (event) {\n        const that = this;\n        const graphcanvas = LGraphCanvas.active_canvas;\n        const { canvas } = graphcanvas;\n        const rootDocument = canvas.ownerDocument || document;\n\n        const dialog = document.createElement(\"div\");\n        dialog.className = \"litegraph litesearchbox graphdialog rounded\";\n        dialog.innerHTML = \"<span class='name'>Search</span> <input autofocus type='text' class='value rounded'/><div class='helper'></div>\";\n        dialog.close = () => {\n            this.search_box = null;\n            rootDocument.body.focus();\n            rootDocument.body.style.overflow = \"\";\n\n            setTimeout(() => {\n                this.canvas.focus();\n            }, 20); // important, if canvas loses focus keys wont be captured\n            if (dialog.parentNode) {\n                dialog.remove();\n            }\n        };\n\n        let timeoutClose = null;\n\n        if (this.ds.scale > 1) dialog.style.transform = `scale(${this.ds.scale})`;\n\n        dialog.addEventListener(\"mouseenter\", () => {\n            if (timeoutClose) {\n                clearTimeout(timeoutClose);\n                timeoutClose = null;\n            }\n        });\n\n        dialog.addEventListener(\"mouseleave\", () => {\n            // dialog.close();\n            timeoutClose = setTimeout(() => dialog.close(), 500);\n        });\n\n        if (this.search_box) this.search_box.close();\n        this.search_box = dialog;\n\n        const helper = dialog.querySelector(\".helper\");\n\n        let first = null;\n        let timeout = null;\n        let selected = null;\n\n        const input = dialog.querySelector(\"input\");\n        if (input) {\n            input.addEventListener(\"blur\", () => input.focus());\n            input.addEventListener(\"keydown\", (e) => {\n                if (e.keyCode === 38) {\n                    // UP\n                    changeSelection(false);\n                } else if (e.keyCode === 40) {\n                    // DOWN\n                    changeSelection(true);\n                } else if (e.keyCode === 27) {\n                    // ESC\n                    dialog.close();\n                } else if (e.keyCode === 13) {\n                    if (selected) {\n                        select(selected.innerHTML);\n                    } else if (first) {\n                        select(first);\n                    } else {\n                        dialog.close();\n                    }\n                } else {\n                    if (timeout) {\n                        clearInterval(timeout);\n                    }\n                    timeout = setTimeout(refreshHelper, 10);\n                    return;\n                }\n                e.preventDefault();\n                e.stopPropagation();\n                e.stopImmediatePropagation();\n                return true;\n            });\n        }\n\n        if (rootDocument.fullscreenElement) rootDocument.fullscreenElement.appendChild(dialog);\n        else {\n            rootDocument.body.appendChild(dialog);\n            rootDocument.body.style.overflow = \"hidden\";\n        }\n\n        // compute best position\n        const rect = canvas.getBoundingClientRect();\n\n        const left = (event ? event.clientX : (rect.left + rect.width * 0.5)) - 80;\n        const top = (event ? event.clientY : (rect.top + rect.height * 0.5)) - 20;\n        dialog.style.left = `${left}px`;\n        dialog.style.top = `${top}px`;\n\n        // To avoid out of screen problems\n        if (event.layerY > (rect.height - 200)) {\n            helper.style.maxHeight = `${rect.height - event.layerY - 20}px`;\n        }\n\n        input.focus();\n\n        function select(name) {\n            if (name) {\n                if (that.onSearchBoxSelection) {\n                    that.onSearchBoxSelection(name, event, graphcanvas);\n                } else {\n                    const extra = defaultConfig.searchbox_extras[name.toLowerCase()];\n                    if (extra) {\n                        name = extra.type;\n                    }\n\n                    graphcanvas.graph.beforeChange();\n                    const node = LGraphNode.createNode(name);\n                    if (node) {\n                        node.pos = graphcanvas.convertEventToCanvasOffset(\n                            event,\n                        );\n                        graphcanvas.graph.add(node);\n                    }\n\n                    if (extra && extra.data) {\n                        if (extra.data.properties) {\n                            // eslint-disable-next-line\n                            for (const i in extra.data.properties) {\n                                node.addProperty(i, extra.data.properties[i]);\n                            }\n                        }\n                        if (extra.data.inputs) {\n                            node.inputs = [];\n                            // eslint-disable-next-line\n                            for (const i in extra.data.inputs) {\n                                node.addOutput(\n                                    extra.data.inputs[i][0],\n                                    extra.data.inputs[i][1],\n                                );\n                            }\n                        }\n                        if (extra.data.outputs) {\n                            node.outputs = [];\n                            // eslint-disable-next-line\n                            for (const i in extra.data.outputs) {\n                                node.addOutput(\n                                    extra.data.outputs[i][0],\n                                    extra.data.outputs[i][1],\n                                );\n                            }\n                        }\n                        if (extra.data.title) node.title = extra.data.title;\n                        if (extra.data.json) node.configure(extra.data.json);\n\n                        graphcanvas.graph.afterChange();\n                    }\n                }\n            }\n\n            dialog.close();\n        }\n\n        function changeSelection(forward) {\n            const prev = selected;\n            if (selected) selected.classList.remove(\"selected\");\n            if (!selected) {\n                selected = forward\n                    ? helper.childNodes[0]\n                    : helper.childNodes[helper.childNodes.length];\n            } else {\n                selected = forward\n                    ? selected.nextSibling\n                    : selected.previousSibling;\n                if (!selected) selected = prev;\n            }\n            if (!selected) return;\n            selected.classList.add(\"selected\");\n            selected.scrollIntoView({\n                block: \"end\",\n                behavior: \"smooth\",\n            });\n        }\n\n        function refreshHelper() {\n            timeout = null;\n            let str = input.value;\n            first = null;\n            helper.innerHTML = \"\";\n            if (!str) return;\n\n            if (that.onSearchBox) {\n                const list = that.onSearchBox(helper, str, graphcanvas);\n                if (list) {\n                    for (const l of list) addResult(l);\n                }\n            } else {\n                let c = 0;\n                str = str.toLowerCase();\n                const filter = graphcanvas.filter || graphcanvas.graph.filter;\n\n                // extras\n                // eslint-disable-next-line\n                for (const i in defaultConfig.searchbox_extras) {\n                    const extra = defaultConfig.searchbox_extras[i];\n                    if (extra.desc.toLowerCase().indexOf(str) === -1) {\n                        continue;\n                    }\n                    const ctor = defaultConfig.registered_node_types[extra.type];\n                    if (ctor && ctor.filter !== filter) continue;\n                    addResult(extra.desc, \"searchbox_extra\");\n                    if (LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit) {\n                        break;\n                    }\n                }\n\n                const keys = Object.keys(defaultConfig.registered_node_types); // types\n                const filtered = keys.filter((type) => {\n                    const ctor = defaultConfig.registered_node_types[type];\n                    if (filter && ctor.filter !== filter) return false;\n                    return type.toLowerCase().indexOf(str) !== -1;\n                });\n\n                for (const filteredItem of filtered) {\n                    addResult(filteredItem);\n                    if (LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit) {\n                        break;\n                    }\n                }\n            }\n\n            function addResult(type, className) {\n                const help = document.createElement(\"div\");\n                if (!first) first = type;\n                help.innerText = type;\n                help.dataset.type = escape(type);\n                help.className = \"litegraph lite-search-item\";\n                if (className) help.className += ` ${className}`;\n                help.addEventListener(\"click\", () => {\n                    select(unescape(help.dataset.type));\n                });\n                helper.appendChild(help);\n            }\n        }\n\n        return dialog;\n    }\n\n    showEditPropertyValue(node, property, options = {}) {\n        if (!node || node.properties[property] === undefined) return;\n\n        const info = node.getPropertyInfo(property);\n        const { type } = info;\n\n        let inputHTML = \"\";\n\n        if ([\"sring\", \"number\", \"array\", \"object\"].includes(type)) {\n            inputHTML = \"<input autofocus type='text' class='value'/>\";\n        } else if ([\"enum\", \"combo\"].includes(type) && info.values) {\n            inputHTML = \"<select autofocus type='text' class='value'>\";\n            // eslint-disable-next-line\n            for (const i in info.values) {\n                let value = i;\n                if (info.values.constructor === Array) value = info.values[i];\n\n                inputHTML += `<option value=\"${value}\" ${value == node.properties[property] ? \"selected\" : \"\"}>${info.values[i]}</option>`;\n            }\n            inputHTML += \"</select>\";\n        } else if (type === \"boolean\") {\n            inputHTML = `<input autofocus type=\"checkbox\" class=\"value\" ${\n                node.properties[property] ? \"checked\" : \"\"\n            }/>`;\n        } else {\n            console.warn(`unknown type: ${type}`);\n            return;\n        }\n\n        const dialog = this.createDialog(\n            `<span class=\"name\">${\n                info.label ? info.label : property\n            }</span>${\n                inputHTML\n            }<button>OK</button>`,\n            options,\n        );\n\n        if ([\"enum\", \"combo\"].includes(type) && info.values) {\n            const input = dialog.querySelector(\"select\");\n            input.addEventListener(\"change\", (e) => {\n                setValue(e.target.value);\n            });\n        } else if (type === \"boolean\") {\n            const input = dialog.querySelector(\"input\");\n            if (input) {\n                input.addEventListener(\"click\", () => setValue(!!input.checked));\n            }\n        } else {\n            const input = dialog.querySelector(\"input\");\n            if (input) {\n                input.addEventListener(\"blur\", () => { input.focus(); });\n\n                let v = node.properties[property] ? node.properties[property] : \"\";\n                if (type !== \"string\") {\n                    v = JSON.stringify(v);\n                }\n\n                input.value = v;\n                input.addEventListener(\"keydown\", (e) => {\n                    if (e.keyCode != 13) return;\n                    setValue(input.value);\n                    e.preventDefault();\n                    e.stopPropagation();\n                });\n            }\n        }\n\n        const button = dialog.querySelector(\"button\");\n        button.addEventListener(\"click\", () => setValue(input.value));\n        function setValue(value) {\n            if (info\n                && info.values\n                && info.values.constructor === Object\n                && info.values[value]) value = info.values[value];\n\n            if (typeof node.properties[property] === \"number\") {\n                value = Number(value);\n            }\n            if ([\"array\", \"object\"].includes(type)) {\n                value = JSON.parse(value);\n            }\n            node.properties[property] = value;\n            if (node.graph) {\n                node.graph._version++;\n            }\n            if (node.onPropertyChanged) {\n                node.onPropertyChanged(property, value);\n            }\n            if (options.onclose) options.onclose();\n            dialog.close();\n            node.setDirtyCanvas(true, true);\n        }\n\n        return dialog;\n    }\n\n    createDialog(html, options = {}) {\n        const dialog = document.createElement(\"div\");\n        dialog.className = \"graphdialog\";\n        dialog.innerHTML = html;\n\n        const rect = this.canvas.getBoundingClientRect();\n        let offsetx = -20;\n        let offsety = -20;\n        if (rect) {\n            offsetx -= rect.left;\n            offsety -= rect.top;\n        }\n\n        if (options.position) {\n            offsetx += options.position[0];\n            offsety += options.position[1];\n        } else if (options.event) {\n            offsetx += options.event.clientX;\n            offsety += options.event.clientY;\n        } // centered\n        else {\n            offsetx += this.canvas.width * 0.5;\n            offsety += this.canvas.height * 0.5;\n        }\n\n        dialog.style.left = `${offsetx}px`;\n        dialog.style.top = `${offsety}px`;\n\n        this.canvas.parentNode.appendChild(dialog);\n\n        dialog.close = () => {\n            if (dialog.parentNode) dialog.remove();\n        };\n\n        return dialog;\n    }\n\n    createPanel(title, options = {}) {\n        const refWindow = options.window || window;\n\n        const root = document.createElement(\"div\");\n        root.className = \"litegraph dialog\";\n        root.innerHTML = \"<div class='dialog-header'><span class='dialog-title'></span></div><div class='dialog-content'></div><div class='dialog-footer'></div>\";\n        root.header = root.querySelector(\".dialog-header\");\n\n        if (options.width) root.style.width = options.width + (options.width.constructor === Number ? \"px\" : \"\");\n        if (options.height) root.style.height = options.height + (options.height.constructor === Number ? \"px\" : \"\");\n        if (options.closable) {\n            const close = document.createElement(\"span\");\n            close.innerHTML = \"&#10005;\";\n            close.classList.add(\"close\");\n            close.addEventListener(\"click\", () => root.close());\n            root.header.appendChild(close);\n        }\n        root.title_element = root.querySelector(\".dialog-title\");\n        root.title_element.innerText = title;\n        root.content = root.querySelector(\".dialog-content\");\n        root.footer = root.querySelector(\".dialog-footer\");\n\n        root.close = () => root.remove();\n\n        root.clear = () => root.content.innerHTML = \"\";\n\n        root.addHTML = (code, classname, onFooter) => {\n            const elem = document.createElement(\"div\");\n            if (classname) elem.className = classname;\n            elem.innerHTML = code;\n            if (onFooter) root.footer.appendChild(elem);\n            else root.content.appendChild(elem);\n            return elem;\n        };\n\n        root.addButton = (name, callback, options) => {\n            const elem = document.createElement(\"button\");\n            elem.innerText = name;\n            elem.options = options;\n            elem.classList.add(\"btn\");\n            elem.addEventListener(\"click\", callback);\n            root.footer.appendChild(elem);\n            return elem;\n        };\n\n        root.addSeparator = () => {\n            const elem = document.createElement(\"div\");\n            elem.className = \"separator\";\n            root.content.appendChild(elem);\n        };\n\n        root.addWidget = (type, name, value, options = {}, callback) => {\n            type = type.toLowerCase();\n            value = String(value);\n            let strValue = type === \"number\" ? new Number(value).toFixed(3) : value.toString();\n            const elem = document.createElement(\"div\");\n            elem.className = \"property\";\n            elem.innerHTML = \"<span class='property_name'></span><span class='property_value'></span>\";\n            elem.querySelector(\".property_name\").innerText = name;\n            const valueElement = elem.querySelector(\".property_value\");\n            valueElement.innerText = strValue;\n            elem.dataset.property = name;\n            elem.dataset.type = options.type || type;\n            elem.options = options;\n            elem.value = strValue;\n\n            if (type === \"boolean\") {\n                elem.classList.add(\"boolean\");\n                if (value) elem.classList.add(\"bool-on\");\n                elem.addEventListener(\"click\", () => {\n                    // var v = node.properties[this.dataset[\"property\"]];\n                    // node.setProperty(this.dataset[\"property\"],!v); this.innerText = v ? \"true\" :\n                    // \"false\";\n                    const propname = elem.dataset.property;\n                    this.value = !elem.value;\n                    this.classList.toggle(\"bool-on\");\n                    this.querySelector(\".property_value\").innerText = elem.value ? \"true\" : \"false\";\n                    innerChange(propname, elem.value);\n                });\n            } else if ([\"string\", \"number\"].includes(type)) {\n                valueElement.setAttribute(\"contenteditable\", true);\n                valueElement.addEventListener(\"keydown\", (e) => {\n                    if (e.code === \"Enter\") {\n                        e.preventDefault();\n                        valueElement.blur();\n                    }\n                });\n                valueElement.addEventListener(\"blur\", () => {\n                    let v = valueElement.innerText;\n                    const propname = valueElement.parentNode.dataset.property;\n                    const proptype = valueElement.parentNode.dataset.type;\n                    if (proptype === \"number\") v = Number(v);\n                    innerChange(propname, v);\n                });\n            } else if ([\"enum\", \"combo\"].includes(type)) strValue = LGraphCanvas.getPropertyPrintableValue(value, options.values);\n            valueElement.innerText = strValue;\n\n            valueElement.addEventListener(\"click\", (event) => {\n                const values = options.values || [];\n                const propname = valueElement.parentNode.dataset.property;\n                const menu = new ContextMenu(values, {\n                    event,\n                    className: \"dark\",\n                    callback: (v, option, event) => {\n                        this.innerText = v;\n                        innerChange(propname, v);\n                        return false;\n                    },\n                },\n                refWindow);\n            });\n\n            root.content.appendChild(elem);\n\n            function innerChange(name, value) {\n                console.log(\"change\", name, value);\n                // that.dirty_canvas = true;\n                if (options.callback) options.callback(name, value);\n                if (callback) callback(name, value);\n            }\n\n            return elem;\n        };\n\n        return root;\n    }\n\n    static getPropertyPrintableValue(value, values) {\n        if (!values) return String(value);\n        if (values.constructor === Array) return String(value);\n\n        if (values.constructor === Object) {\n            let desc_value = \"\";\n            for (const k in values) {\n                if (values[k] !== value) continue;\n                desc_value = k;\n                break;\n            }\n            return `${String(value)} (${desc_value})`;\n        }\n    }\n\n    showShowNodePanel = function (node) {\n        window.SELECTED_NODE = node;\n        let panel = document.querySelector(\"#node-panel\");\n        if (panel) panel.close();\n        const refWindow = this.getCanvasWindow();\n        panel = this.createPanel(node.title || \"\", {\n            closable: true,\n            window: refWindow,\n        });\n        panel.id = \"node-panel\";\n        panel.node = node;\n        panel.classList.add(\"settings\");\n        const that = this;\n        const graphcanvas = this;\n\n        const inner_refresh = () => {\n            panel.content.innerHTML = \"\"; // clear\n            panel.addHTML(`<span class=\"node_type\">${node.type}</span><span class=\"node_desc\">${node.constructor.desc || \"\"}</span><span class=\"separator\"></span>`);\n\n            panel.addHTML(\"<h3>Properties</h3>\");\n\n            for (const i in node.properties) {\n                const value = node.properties[i];\n                const info = node.getPropertyInfo(i);\n\n                if (node.onAddPropertyToPanel && node.onAddPropertyToPanel(i, panel)) continue;\n\n                panel.addWidget(info.widget || info.type, i, value, info, (name, value) => {\n                    graphcanvas.graph.beforeChange(node);\n                    node.setProperty(name, value);\n                    graphcanvas.graph.afterChange();\n                    graphcanvas.dirty_canvas = true;\n                });\n            }\n\n            panel.addSeparator();\n\n            if (node.onShowCustomPanelInfo) node.onShowCustomPanelInfo(panel);\n            panel.addButton(\"Delete\", () => {\n                if (node.block_delete) return;\n                node.graph.remove(node);\n                panel.close();\n            })\n                .classList\n                .add(\"delete\");\n        };\n\n        function inner_showCodePad(node, propname) {\n            panel.style.top = \"calc( 50% - 250px)\";\n            panel.style.left = \"calc( 50% - 400px)\";\n            panel.style.width = \"800px\";\n            panel.style.height = \"500px\";\n\n            panel.content.innerHTML = \"<textarea class='code'></textarea>\";\n            const textarea = panel.content.querySelector(\"textarea\");\n            textarea.value = node.properties[propname];\n            textarea.addEventListener(\"keydown\", (e) => {\n                if (e.code === \"Enter\" && e.ctrlKey) {\n                    console.log(\"Assigned\");\n                    node.setProperty(propname, textarea.value);\n                }\n            });\n            textarea.style.height = \"calc(100% - 40px)\";\n\n            const assign = that.createButton(\"Assign\", null, () => {\n                node.setProperty(propname, textarea.value);\n            });\n            panel.content.appendChild(assign);\n            const button = that.createButton(\"Close\", null, () => {\n                panel.style.height = \"\";\n                inner_refresh();\n            });\n            button.style.float = \"right\";\n            panel.content.appendChild(button);\n        }\n\n        inner_refresh();\n\n        this.canvas.parentNode.appendChild(panel);\n    }\n\n    showSubgraphPropertiesDialog(node) {\n        console.log(\"showing subgraph properties dialog\");\n\n        const old_panel = this.canvas.parentNode.querySelector(\".subgraph_dialog\");\n        if (old_panel) old_panel.close();\n\n        const panel = this.createPanel(\"Subgraph Inputs\", {\n            closable: true,\n            width: 500,\n        });\n        panel.node = node;\n        panel.classList.add(\"subgraph_dialog\");\n\n        function inner_refresh() {\n            panel.clear();\n\n            // show currents\n            if (node.inputs) {\n                for (const input of node.inputs) {\n                    if (input.not_subgraph_input) continue;\n                    const html = \"<button>&#10005;</button> <span class='bullet_icon'></span><span class='name'></span><span class='type'></span>\";\n                    const elem = panel.addHTML(html, \"subgraph_property\");\n                    elem.dataset.name = input.name;\n                    elem.dataset.slot = i;\n                    elem.querySelector(\".name\").innerText = input.name;\n                    elem.querySelector(\".type\").innerText = input.type;\n                    elem.querySelector(\"button\")\n                        .addEventListener(\"click\", () => {\n                            node.removeInput(Number(elem.parentNode.dataset.slot));\n                            inner_refresh();\n                        });\n                }\n            }\n        }\n\n        // add extra\n        const html = \" + <span class='label'>Name</span><input class='name'/><span class='label'>Type</span><input class='type'/><button>+</button>\";\n        const elem = panel.addHTML(html, \"subgraph_property extra\", true);\n        elem.querySelector(\"button\")\n            .addEventListener(\"click\", function (e) {\n                const elem = this.parentNode;\n                const name = elem.querySelector(\".name\").value;\n                const type = elem.querySelector(\".type\").value;\n                if (!name || node.findInputSlot(name) !== -1) return;\n                node.addInput(name, type);\n                elem.querySelector(\".name\").value = \"\";\n                elem.querySelector(\".type\").value = \"\";\n                inner_refresh();\n            });\n\n        inner_refresh();\n        this.canvas.parentNode.appendChild(panel);\n        return panel;\n    }\n\n    checkPanels() {\n        if (!this.canvas) return;\n        const panels = this.canvas.parentNode.querySelectorAll(\".litegraph.dialog\");\n        for (const panel of panels) {\n            if (!panel.node) continue;\n            if (!panel.node.graph || panel.graph !== this.graph) panel.close();\n        }\n    }\n\n    static onMenuNodeCollapse(value, options, e, menu, node) {\n        node.graph.beforeChange(node);\n        node.collapse();\n        node.graph.afterChange(node);\n    }\n\n    static onMenuNodePin(value, options, e, menu, node) {\n        node.pin();\n    }\n\n    static onMenuNodeMode = function (value, options, e, menu, node) {\n        new ContextMenu(\n            [\"Always\", \"On Event\", \"On Trigger\", \"Never\"],\n            {\n                event: e,\n                callback: (v) => {\n                    if (!node) {\n                        return;\n                    }\n                    switch (v) {\n                        case \"On Event\":\n                            node.mode = defaultConfig.ON_EVENT;\n                            break;\n                        case \"On Trigger\":\n                            node.mode = defaultConfig.ON_TRIGGER;\n                            break;\n                        case \"Never\":\n                            node.mode = defaultConfig.NEVER;\n                            break;\n                        case \"Always\":\n                        default:\n                            node.mode = defaultConfig.ALWAYS;\n                            break;\n                    }\n                },\n                parentMenu: menu,\n                node,\n            },\n        );\n        return false;\n    }\n\n    static onMenuNodeColors(value, options, e, menu, node) {\n        if (!node) throw new Error(\"no node for color\");\n        const values = [];\n        values.push({\n            value: null,\n            content:\n                \"<span style='display: block; padding-left: 4px;'>No color</span>\",\n        });\n\n        // eslint-disable-next-line\n        for (const i in LGraphCanvas.node_colors) {\n            const color = LGraphCanvas.node_colors[i];\n            values.push({\n                value: i,\n                content: `<span style=\"display: block; color: #999; padding-left: 4px; border-left: 8px solid ${color.color}; background-color:${color.bgcolor}\">${i}</span>`,\n            });\n        }\n        new ContextMenu(values, {\n            event: e,\n            callback: (v) => {\n                if (!node) {\n                    return;\n                }\n\n                const color = v.value ? LGraphCanvas.node_colors[v.value] : null;\n                if (color) {\n                    if (node.constructor.name === \"LGraphGroup\") {\n                        node.color = color.groupcolor;\n                    } else {\n                        node.color = color.color;\n                        node.bgcolor = color.bgcolor;\n                    }\n                } else {\n                    delete node.color;\n                    delete node.bgcolor;\n                }\n                node.setDirtyCanvas(true, true);\n            },\n            parentMenu: menu,\n            node,\n        });\n\n        return false;\n    }\n\n    static onMenuNodeShapes(value, options, e, menu, node) {\n        if (!node) {\n            throw new Error(\"no node passed\");\n        }\n\n        new ContextMenu(defaultConfig.VALID_SHAPES, {\n            event: e,\n            callback: (v) => {\n                if (!node) return;\n                node.graph.beforeChange(node);\n                node.shape = v;\n                node.graph.afterChange(node);\n                node.setDirtyCanvas(true);\n            },\n        }, {\n            parentMenu: menu,\n            node,\n        });\n\n        return false;\n    }\n\n    static onMenuNodeRemove(value, options, e, menu, node) {\n        if (!node) throw new Error(\"no node passed\");\n        if (node.removable === false) return;\n\n        const { graph } = node;\n        graph.beforeChange();\n        graph.remove(node);\n        graph.afterChange();\n        node.setDirtyCanvas(true, true);\n    }\n\n    static onMenuNodeToSubgraph(value, options, e, menu, node) {\n        const { graph } = node;\n        const graphcanvas = LGraphCanvas.active_canvas;\n        if (!graphcanvas) return;\n\n        let nodesList = Object.values(graphcanvas.selected_nodes || {});\n        if (!nodesList.length) nodesList = [node];\n\n        const subgraphNode = LGraphNode.createNode(\"graph/subgraph\");\n        subgraphNode.pos = node.pos.concat();\n        graph.add(subgraphNode);\n\n        subgraphNode.buildFromNodes(nodesList);\n\n        graphcanvas.deselectAllNodes();\n        node.setDirtyCanvas(true, true);\n    }\n\n    static onMenuNodeClone(value, options, e, menu, node) {\n        if (node.clonable === false) return;\n        const newnode = node.clone();\n        if (!newnode) return;\n        newnode.pos = [node.pos[0] + 5, node.pos[1] + 5];\n\n        node.graph.beforeChange();\n        node.graph.add(newnode);\n        node.graph.afterChange();\n\n        node.setDirtyCanvas(true, true);\n    }\n\n    static node_colors = {\n        red: {\n            color: \"#322\",\n            bgcolor: \"#533\",\n            groupcolor: \"#A88\",\n        },\n        brown: {\n            color: \"#332922\",\n            bgcolor: \"#593930\",\n            groupcolor: \"#b06634\",\n        },\n        green: {\n            color: \"#232\",\n            bgcolor: \"#353\",\n            groupcolor: \"#8A8\",\n        },\n        blue: {\n            color: \"#223\",\n            bgcolor: \"#335\",\n            groupcolor: \"#88A\",\n        },\n        pale_blue: {\n            color: \"#2a363b\",\n            bgcolor: \"#3f5159\",\n            groupcolor: \"#3f789e\",\n        },\n        cyan: {\n            color: \"#233\",\n            bgcolor: \"#355\",\n            groupcolor: \"#8AA\",\n        },\n        purple: {\n            color: \"#323\",\n            bgcolor: \"#535\",\n            groupcolor: \"#a1309b\",\n        },\n        yellow: {\n            color: \"#432\",\n            bgcolor: \"#653\",\n            groupcolor: \"#b58b2a\",\n        },\n        black: {\n            color: \"#222\",\n            bgcolor: \"#000\",\n            groupcolor: \"#444\",\n        },\n    }\n\n    getCanvasMenuOptions() {\n        let options = null;\n        if (this.getMenuOptions) {\n            options = this.getMenuOptions();\n        } else {\n            options = [\n                {\n                    content: \"Add Node\",\n                    has_submenu: true,\n                    callback: LGraphCanvas.onMenuAdd,\n                },\n                {\n                    content: \"Add Group\",\n                    callback: LGraphCanvas.onGroupAdd,\n                },\n                // {content:\"Collapse All\", callback: LGraphCanvas.onMenuCollapseAll }\n            ];\n\n            if (this._graph_stack && this._graph_stack.length > 0) {\n                options.push(null, {\n                    content: \"Close subgraph\",\n                    callback: this.closeSubgraph.bind(this),\n                });\n            }\n        }\n\n        if (this.getExtraMenuOptions) {\n            const extra = this.getExtraMenuOptions(this, options);\n            if (extra) options = options.concat(extra);\n        }\n\n        return options;\n    }\n\n    getNodeMenuOptions(node) {\n        let options = null;\n\n        if (node.getMenuOptions) options = node.getMenuOptions(this);\n        else {\n            options = [\n                {\n                    content: \"Inputs\",\n                    has_submenu: true,\n                    disabled: true,\n                    callback: LGraphCanvas.showMenuNodeOptionalInputs,\n                },\n                {\n                    content: \"Outputs\",\n                    has_submenu: true,\n                    disabled: true,\n                    callback: LGraphCanvas.showMenuNodeOptionalOutputs,\n                },\n                null,\n                {\n                    content: \"Properties\",\n                    has_submenu: true,\n                    callback: LGraphCanvas.onShowMenuNodeProperties,\n                },\n                null,\n                {\n                    content: \"Title\",\n                    callback: LGraphCanvas.onShowPropertyEditor,\n                },\n                {\n                    content: \"Mode\",\n                    has_submenu: true,\n                    callback: LGraphCanvas.onMenuNodeMode,\n                },\n                {\n                    content: \"Resize\",\n                    callback() {\n                        if (node.resizable) {\n                            return LGraphCanvas.onResizeNode;\n                        }\n                    },\n                },\n                {\n                    content: \"Collapse\",\n                    callback: LGraphCanvas.onMenuNodeCollapse,\n                },\n                {\n                    content: \"Pin\",\n                    callback: LGraphCanvas.onMenuNodePin,\n                },\n                {\n                    content: \"Colors\",\n                    has_submenu: true,\n                    callback: LGraphCanvas.onMenuNodeColors,\n                },\n                {\n                    content: \"Shapes\",\n                    has_submenu: true,\n                    callback: LGraphCanvas.onMenuNodeShapes,\n                },\n                null,\n            ];\n        }\n\n        if (node.onGetInputs) {\n            const inputs = node.onGetInputs();\n            if (inputs && inputs.length) options[0].disabled = false;\n        }\n\n        if (node.onGetOutputs) {\n            const outputs = node.onGetOutputs();\n            if (outputs && outputs.length) options[1].disabled = false;\n        }\n\n        if (node.getExtraMenuOptions) {\n            const extra = node.getExtraMenuOptions(this, options);\n            if (extra) {\n                extra.push(null);\n                options = extra.concat(options);\n            }\n        }\n\n        if (node.clonable) {\n            options.push({\n                content: \"Clone\",\n                callback: LGraphCanvas.onMenuNodeClone,\n            });\n        }\n\n        options.push(null, {\n            content: \"Remove\",\n            disabled: !(node.removable !== false && !node.block_delete),\n            callback: LGraphCanvas.onMenuNodeRemove,\n        });\n\n        if (node.graph && node.graph.onGetNodeMenuOptions) {\n            node.graph.onGetNodeMenuOptions(options, node);\n        }\n\n        return options;\n    }\n\n    getGroupMenuOptions() {\n        return [\n            {\n                content: \"Title\",\n                callback: LGraphCanvas.onShowPropertyEditor,\n            },\n            {\n                content: \"Color\",\n                has_submenu: true,\n                callback: LGraphCanvas.onMenuNodeColors,\n            },\n            {\n                content: \"Font size\",\n                property: \"font_size\",\n                type: \"Number\",\n                callback: LGraphCanvas.onShowPropertyEditor,\n            },\n            null,\n            {\n                content: \"Remove\",\n                callback: LGraphCanvas.onMenuNodeRemove,\n            },\n        ];\n    }\n\n    processContextMenu(node, event) {\n        const that = this;\n        const canvas = LGraphCanvas.active_canvas;\n        const refWindow = canvas.getCanvasWindow();\n\n        let menuInfo = null;\n        const options = {\n            event,\n            callback: inner_option_clicked,\n            extra: node,\n        };\n\n        if (node) options.title = node.type;\n\n        // check if mouse is in input\n        let slot = null;\n        if (node) {\n            slot = node.getSlotInPosition(event.canvasX, event.canvasY);\n            LGraphCanvas.active_node = node;\n        }\n\n        if (slot) {\n            // on slot\n            menuInfo = [];\n            if (node.getSlotMenuOptions) menuInfo = node.getSlotMenuOptions(slot);\n            else {\n                if (slot && slot.output && slot.output.links && slot.output.links.length) {\n                    menuInfo.push({\n                        content: \"Disconnect Links\",\n                        slot,\n                    });\n                }\n                const _slot = slot.input || slot.output;\n                menuInfo.push(_slot.locked ? \"Cannot remove\" : { content: \"Remove Slot\", slot });\n                menuInfo.push(_slot.nameLocked ? \"Cannot rename\" : { content: \"Rename Slot\", slot });\n            }\n            options.title = (slot.input ? slot.input.type : slot.output.type) || \"*\";\n            if (slot.input && slot.input.type === defaultConfig.ACTION) options.title = \"Action\";\n            if (slot.output && slot.output.type === defaultConfig.EVENT) options.title = \"Event\";\n        } else if (node) {\n            menuInfo = this.getNodeMenuOptions(node);\n        } else {\n            menuInfo = this.getCanvasMenuOptions();\n            const group = this.graph.getGroupOnPos(event.canvasX, event.canvasY);\n            if (group) {\n                // on group\n                menuInfo.push(null, {\n                    content: \"Edit Group\",\n                    has_submenu: true,\n                    submenu: {\n                        title: \"Group\",\n                        extra: group,\n                        options: this.getGroupMenuOptions(group),\n                    },\n                });\n            }\n        }\n\n        // show menu\n        if (!menuInfo) return;\n\n        const menu = new ContextMenu(menuInfo, options, refWindow);\n\n        function inner_option_clicked(v, options, e) {\n            if (!v) {\n                return;\n            }\n\n            if (v.content === \"Remove Slot\") {\n                const info = v.slot;\n                if (info.input) node.removeInput(info.slot);\n                else if (info.output) node.removeOutput(info.slot);\n            } else if (v.content === \"Disconnect Links\") {\n                const info = v.slot;\n                if (info.output) node.disconnectOutput(info.slot);\n                else if (info.input) node.disconnectInput(info.slot);\n            } else if (v.content === \"Rename Slot\") {\n                const info = v.slot;\n                const slotInfo = info.input\n                    ? node.getInputInfo(info.slot) : node.getOutputInfo(info.slot);\n                const dialog = that.createDialog(\n                    \"<span class='name'>Name</span><input autofocus type='text'/><button>OK</button>\",\n                    options,\n                );\n                const input = dialog.querySelector(\"input\");\n                if (input && slotInfo) input.value = slotInfo.label || \"\";\n                dialog.querySelector(\"button\")\n                    .addEventListener(\"click\", () => {\n                        if (input.value) {\n                            if (slotInfo) slotInfo.label = input.value;\n                            that.setDirty(true);\n                        }\n                        dialog.close();\n                    });\n            }\n        }\n    }\n}\n","/**\n * @module File Utils\n */\nimport defaultConfig from \"./defaultConfig\";\n\nexport function getFileExtension(url) {\n    const question = url.indexOf(\"?\");\n    if (question !== -1) {\n        url = url.substr(0, question);\n    }\n    const point = url.lastIndexOf(\".\");\n    if (point === -1) {\n        return \"\";\n    }\n    return url.substr(point + 1).toLowerCase();\n}\n\n/**\n * Wrapper to load files (from url using fetch or from file using FileReader)\n * @method fetchFile\n * @param {String|File|Blob} url the url of the file (or the file itself)\n * @param {String} type an string to know how to fetch it:\n *     \"text\",\"arraybuffer\",\"json\",\"blob\"\n * @param {Function} onComplete callback(data)\n * @param {Function} onError in case of an error\n * @return {FileReader|Promise|void} returns the object used to\n */\nexport function fetchFile(url, type = \"text\", onComplete, onError) {\n    if (!url) return null;\n\n    if (url.constructor === String) {\n        if (url.substr(0, 4) === \"http\" && defaultConfig.proxy) {\n            url = defaultConfig.proxy + url.substr(url.indexOf(\":\") + 3);\n        }\n        return fetch(url)\n            .then((response) => {\n                if (!response.ok) throw new Error(\"File not found\"); // it will be catch\n                // below\n                if (type === \"arraybuffer\") return response.arrayBuffer();\n                if ([\"string\", \"text\"].includes(type)) return response.text();\n                if (type === \"json\") return response.json();\n                if (type === \"blob\") return response.blob();\n            })\n            .then((data) => {\n                if (onComplete) onComplete(data);\n            })\n            .catch((error) => {\n                console.error(\"error fetching file:\", url);\n                if (onError) onError(error);\n            });\n    }\n    if (url.constructor === File || url.constructor === Blob) {\n        const reader = new FileReader();\n        reader.onload = (e) => {\n            let v = e.target.result;\n            if (type === \"json\") v = JSON.parse(v);\n            if (onComplete) onComplete(v);\n        };\n        if (type === \"arraybuffer\") return reader.readAsArrayBuffer(url);\n        if ([\"string\", \"text\"].includes(type)) return reader.readAsText(url);\n        if (type === \"blob\") return reader.readAsBinaryString(url);\n    }\n    return null;\n}\n","import defaultConfig from \"./utils/defaultConfig\";\nimport getTime from \"./utils/time\";\nimport LGraphNode from \"./LGraphNode\";\nimport LGraphGroup from \"./LGraphGroup\";\nimport LGraphCanvas from \"./LGraphCanvas\";\n\n/**\n * LGraph is the class that contain a full graph.\n * We instantiate one and add nodes to it, and then we can run the execution loop.\n * supported callbacks:\n + onNodeAdded: when a new node is added to the graph\n + onNodeRemoved: when a node inside this graph is removed\n + onNodeConnectionChange: some connection has changed in the graph (connected or disconnected)\n *\n * @class LGraph\n * @constructor\n * @param {Object} o data from previous serialization [optional]\n */\nexport default class LGraph {\n    constructor(o) {\n        if (defaultConfig.debug) {\n            console.log(\"Graph created\");\n        }\n        this.list_of_graphcanvas = null;\n        this.clear();\n\n        if (o) {\n            this.configure(o);\n        }\n    }\n\n    getSupportedTypes() {\n        return this.supportedTypes || LGraph.supportedTypes;\n    }\n\n    STATUS_STOPPED = 1;\n\n    STATUS_RUNNING = 2;\n\n    supportedTypes = [\"number\", \"string\", \"boolean\"];\n\n    static supportedTypes = [\"number\", \"string\", \"boolean\"];\n    // used to know which types of connections support this graph (some graphs do not allow certain\n    // types)\n\n    /**\n     * Removes all nodes from this graph\n     * @method clear\n     * @memberOf LGraph\n     */\n    clear() {\n        this.stop();\n        this.status = this.STATUS_STOPPED;\n\n        this.last_node_id = 0;\n        this.last_link_id = 0;\n\n        this._version = -1; // used to detect changes\n\n        // safe clear\n        if (this._nodes) {\n            for (const node of this._nodes) {\n                if (node.onRemoved) node.onRemoved();\n            }\n        }\n\n        // nodes\n        this._nodes = [];\n        this._nodes_by_id = {};\n        this._nodes_in_order = []; // nodes sorted in execution order\n        this._nodes_executable = null; // nodes that contain onExecute sorted in execution order\n\n        // other scene stuff\n        this._groups = [];\n\n        // links\n        this.links = {}; // container with all the links\n\n        // iterations\n        this.iteration = 0;\n\n        // custom data\n        this.config = {};\n        this.vars = {};\n        this.extra = {}; // to store custom data\n\n        // timing\n        this.globaltime = 0;\n        this.runningtime = 0;\n        this.fixedtime = 0;\n        this.fixedtime_lapse = 0.01;\n        this.elapsed_time = 0.01;\n        this.last_update_time = 0;\n        this.starttime = 0;\n\n        this.catch_errors = true;\n\n        // subgraph_data\n        this.inputs = {};\n        this.outputs = {};\n\n        // notify canvas to redraw\n        this.change();\n\n        this.sendActionToCanvas(\"clear\");\n    }\n\n    /**\n     * Attach Canvas to this graph\n     * @method attachCanvas\n     * @param {GraphCanvas} graphcanvas\n     * @memberOf LGraph\n     */\n    attachCanvas(graphcanvas) {\n        if (graphcanvas.constructor !== LGraphCanvas) {\n            throw new Error(\"attachCanvas expects a LGraphCanvas instance\");\n        }\n        if (graphcanvas.graph && graphcanvas.graph !== this) {\n            graphcanvas.graph.detachCanvas(graphcanvas);\n        }\n\n        graphcanvas.graph = this;\n\n        if (!this.list_of_graphcanvas) this.list_of_graphcanvas = [];\n        this.list_of_graphcanvas.push(graphcanvas);\n    }\n\n    /**\n     * Detach Canvas from this graph\n     * @method detachCanvas\n     * @param {GraphCanvas} graphcanvas\n     * @memberOf LGraph\n     */\n    detachCanvas(graphcanvas) {\n        if (!this.list_of_graphcanvas) {\n            return;\n        }\n\n        const pos = this.list_of_graphcanvas.indexOf(graphcanvas);\n        if (pos === -1) {\n            return;\n        }\n        graphcanvas.graph = null;\n        this.list_of_graphcanvas.splice(pos, 1);\n    }\n\n    /**\n     * Starts running this graph every interval milliseconds.\n     * @method start\n     * @param {number} interval amount of milliseconds between executions, if 0 then it renders to\n     *     the monitor refresh rate\n     * @memberOf LGraph\n     */\n    start(interval) {\n        if (this.status === LGraph.STATUS_RUNNING) {\n            return;\n        }\n        this.status = LGraph.STATUS_RUNNING;\n\n        if (this.onPlayEvent) {\n            this.onPlayEvent();\n        }\n\n        this.sendEventToAllNodes(\"onStart\");\n\n        // launch\n        this.starttime = getTime();\n        this.last_update_time = this.starttime;\n        interval = interval || 0;\n        const that = this;\n\n        // execute once per frame\n        if (interval === 0 && typeof window !== \"undefined\" && window.requestAnimationFrame) {\n            // eslint-disable-next-line no-inner-declarations\n            function onFrame() {\n                if (that.execution_timer_id !== -1) {\n                    return;\n                }\n                window.requestAnimationFrame(onFrame);\n                if (that.onBeforeStep) that.onBeforeStep();\n                that.runStep(1, !that.catch_errors);\n                if (that.onAfterStep) that.onAfterStep();\n            }\n\n            this.execution_timer_id = -1;\n            onFrame();\n        } else { // execute every 'interval' ms\n            this.execution_timer_id = setInterval(() => {\n                // execute\n                if (that.onBeforeStep) that.onBeforeStep();\n                that.runStep(1, !that.catch_errors);\n                if (that.onAfterStep) that.onAfterStep();\n            }, interval);\n        }\n    }\n\n    /**\n     * Stops the execution loop of the graph\n     * @method stop execution\n     * @memberOf LGraph\n     */\n    stop() {\n        if (this.status === LGraph.STATUS_STOPPED) {\n            return;\n        }\n\n        this.status = LGraph.STATUS_STOPPED;\n\n        if (this.onStopEvent) {\n            this.onStopEvent();\n        }\n\n        if (this.execution_timer_id) {\n            if (this.execution_timer_id !== -1) {\n                clearInterval(this.execution_timer_id);\n            }\n            this.execution_timer_id = null;\n        }\n\n        this.sendEventToAllNodes(\"onStop\");\n    }\n\n    /**\n     * Run N steps (cycles) of the graph\n     * @method runStep\n     * @param {number} num number of steps to run, default is 1\n     * @param {Boolean} doNotCatchError [optional] if you want to try/catch errors\n     * @param {number} limit max number of nodes to execute (used to execute from start to a node)\n     * @memberOf LGraph\n     */\n    runStep(num, doNotCatchError, limit) {\n        num = num || 1;\n\n        const start = getTime();\n        this.globaltime = 0.001 * (start - this.starttime);\n\n        const nodes = this._nodes_executable\n            ? this._nodes_executable\n            : this._nodes;\n        if (!nodes) {\n            return;\n        }\n\n        limit = limit || nodes.length;\n\n        if (doNotCatchError) {\n            // iterations\n            for (let i = 0; i < num; i++) {\n                for (let j = 0; j < limit; j++) {\n                    const node = nodes[j];\n                    if (node.mode === defaultConfig.ALWAYS && node.onExecute) {\n                        node.onExecute(); // hard to send elapsed time\n                    }\n                }\n\n                this.fixedtime += this.fixedtime_lapse;\n                if (this.onExecuteStep) {\n                    this.onExecuteStep();\n                }\n            }\n\n            if (this.onAfterExecute) {\n                this.onAfterExecute();\n            }\n        } else {\n            try {\n                // iterations\n                for (let i = 0; i < num; i++) {\n                    for (let j = 0; j < limit; ++j) {\n                        const node = nodes[j];\n                        if (node.mode === defaultConfig.ALWAYS && node.onExecute) {\n                            node.onExecute();\n                        }\n                    }\n\n                    this.fixedtime += this.fixedtime_lapse;\n                    if (this.onExecuteStep) {\n                        this.onExecuteStep();\n                    }\n                }\n\n                if (this.onAfterExecute) {\n                    this.onAfterExecute();\n                }\n                this.errors_in_execution = false;\n            } catch (err) {\n                this.errors_in_execution = true;\n                if (defaultConfig.throw_errors) {\n                    throw err;\n                }\n                if (defaultConfig.debug) {\n                    console.log(`Error during execution: ${err}`);\n                }\n                this.stop();\n            }\n        }\n\n        const now = getTime();\n        let elapsed = now - start;\n        if (elapsed === 0) {\n            elapsed = 1;\n        }\n        this.execution_time = 0.001 * elapsed;\n        this.globaltime += 0.001 * elapsed;\n        this.iteration += 1;\n        this.elapsed_time = (now - this.last_update_time) * 0.001;\n        this.last_update_time = now;\n    }\n\n    /**\n     * Updates the graph execution order according to relevance of the nodes (nodes with only\n     * outputs have more relevance than nodes with only inputs.\n     * @method updateExecutionOrder\n     * @memberOf LGraph\n     */\n    updateExecutionOrder() {\n        this._nodes_in_order = this.computeExecutionOrder(false);\n        this._nodes_executable = [];\n        for (const node of this._nodes_in_order) {\n            if (node.onExecute) {\n                this._nodes_executable.push(node);\n            }\n        }\n    }\n\n    /**\n     * It computes the executable nodes in order and returns it\n     * @param onlyOnExecute\n     * @param setLevel\n     * @returns {this}\n     * @internal\n     * @memberOf LGraph\n     */\n    computeExecutionOrder(onlyOnExecute, setLevel) {\n        let L = [];\n        const S = [];\n        const M = {};\n        const visitedLinks = {}; // to avoid repeating links\n        const remainingLinks = {}; // to a\n\n        // search for the nodes without inputs (starting nodes)\n        for (const node of this._nodes) {\n            if (onlyOnExecute && !node.onExecute) {\n                continue;\n            }\n\n            M[node.id] = node; // add to pending nodes\n\n            let num = 0; // num of input connections\n            if (node.inputs) {\n                for (let j = 0, l2 = node.inputs.length; j < l2; j++) {\n                    if (node.inputs[j] && node.inputs[j].link != null) {\n                        num += 1;\n                    }\n                }\n            }\n\n            if (num === 0) {\n                // is a starting node\n                S.push(node);\n                if (setLevel) {\n                    node._level = 1;\n                }\n            } else {\n                if (setLevel) {\n                    node._level = 0;\n                }\n                remainingLinks[node.id] = num;\n            }\n        }\n\n        while (true) {\n            if (S.length === 0) {\n                break;\n            }\n\n            // get an starting node\n            const node = S.shift();\n            L.push(node); // add to ordered list\n            delete M[node.id]; // remove from the pending nodes\n\n            if (!node.outputs) {\n                continue;\n            }\n\n            // for every output\n            for (const output of node.outputs) {\n                if (\n                    output == null\n                    || output.links == null\n                    || output.links.length === 0\n                ) {\n                    continue;\n                }\n\n                // for every connection\n                for (const linkId of output.links) {\n                    const link = this.links[linkId];\n                    if (!link) {\n                        continue;\n                    }\n\n                    // already visited link (ignore it)\n                    if (visitedLinks[link.id]) {\n                        continue;\n                    }\n\n                    const targetNode = this.getNodeById(link.target_id);\n                    if (targetNode == null) {\n                        visitedLinks[link.id] = true;\n                        continue;\n                    }\n\n                    if (\n                        setLevel\n                        && (!targetNode._level\n                        || targetNode._level <= node._level)\n                    ) {\n                        targetNode._level = node._level + 1;\n                    }\n\n                    visitedLinks[link.id] = true; // mark as visited\n                    remainingLinks[targetNode.id] -= 1; // reduce the number of links remaining\n                    if (remainingLinks[targetNode.id] === 0) {\n                        S.push(targetNode);\n                    } // if no more links, then add to starters array\n                }\n            }\n        }\n\n        // the remaining ones (loops)\n        // eslint-disable-next-line guard-for-in,no-restricted-syntax\n        for (const i in M) L.push(M[i]);\n\n        if (L.length !== this._nodes.length && defaultConfig.debug) {\n            console.warn(\"something went wrong, nodes missing\");\n        }\n\n        const l = L.length;\n\n        // save order number in the node\n        for (let i = 0; i < l; i++) L[i].order = i;\n\n        // sort now by priority\n        L = L.sort((A, B) => {\n            const Ap = A.constructor.priority || A.priority || 0;\n            const Bp = B.constructor.priority || B.priority || 0;\n            if (Ap === Bp) {\n                // if same priority, sort by order\n                return A.order - B.order;\n            }\n            return Ap - Bp; // sort by priority\n        });\n\n        // save order number in the node, again...\n        for (let i = 0; i < l; ++i) L[i].order = i;\n\n        return L;\n    }\n\n    /**\n     * Returns all the nodes that could affect this one (ancestors) by crawling all the inputs\n     * recursively. It doesn't include the node itself\n     * @method getAncestors\n     * @memberOf LGraph\n     * @return {Array} an array with all the LGraphNodes that affect this node, in order of\n     *     execution\n     */\n    // eslint-disable-next-line class-methods-use-this\n    getAncestors(node) {\n        const ancestors = [];\n        const pending = [node];\n        const visited = {};\n\n        while (pending.length) {\n            const current = pending.shift();\n            if (!current.inputs) {\n                continue;\n            }\n            if (!visited[current.id] && current !== node) {\n                visited[current.id] = true;\n                ancestors.push(current);\n            }\n\n            for (let i = 0; i < current.inputs.length; ++i) {\n                const input = current.getInputNode(i);\n                if (input && ancestors.indexOf(input) === -1) {\n                    pending.push(input);\n                }\n            }\n        }\n\n        ancestors.sort((a, b) => a.order - b.order);\n        return ancestors;\n    }\n\n    /**\n     * Positions every node in a more readable manner\n     * @method arrange\n     * @memberOf LGraph\n     */\n    arrange(margin) {\n        margin = margin || 100;\n\n        const nodes = this.computeExecutionOrder(false, true);\n        const columns = [];\n        for (const node of nodes) {\n            const col = node._level || 1;\n            if (!columns[col]) {\n                columns[col] = [];\n            }\n            columns[col].push(node);\n        }\n\n        let x = margin;\n\n        for (const column of columns) {\n            if (!column) {\n                continue;\n            }\n            let maxSize = 100;\n            let y = margin + defaultConfig.NODE_TITLE_HEIGHT;\n            for (const node of column) {\n                node.pos[0] = x;\n                node.pos[1] = y;\n                if (node.size[0] > maxSize) maxSize = node.size[0];\n                y += node.size[1] + margin + defaultConfig.NODE_TITLE_HEIGHT;\n            }\n            x += maxSize + margin;\n        }\n\n        this.setDirtyCanvas(true, true);\n    }\n\n    /**\n     * Returns the amount of time the graph has been running in milliseconds\n     * @method getTime\n     * @return {number} number of milliseconds the graph has been running\n     * @memberOf LGraph\n     */\n    getTime() {\n        return this.globaltime;\n    }\n\n    /**\n     * Returns the amount of time accumulated using the fixedtime_lapse var. This is used in\n     * context where the time increments should be constant\n     * @method getFixedTime\n     * @return {number} number of milliseconds the graph has been running\n     * @memberOf LGraph\n     */\n\n    getFixedTime() {\n        return this.fixedtime;\n    }\n\n    /**\n     * Returns the amount of time it took to compute the latest iteration. Take into account that\n     * this number could be not correct if the nodes are using graphical actions\n     * @method getElapsedTime\n     * @return {number} number of milliseconds it took the last cycle\n     * @memberOf LGraph\n     */\n\n    getElapsedTime() {\n        return this.elapsed_time;\n    }\n\n    /**\n     * Sends an event to all the nodes, useful to trigger stuff\n     * @method sendEventToAllNodes\n     * @param {String} eventname the name of the event (function to be called)\n     * @param {Array} params parameters in array format\n     * @memberOf LGraph\n     */\n    sendEventToAllNodes(eventname, params, mode) {\n        mode = mode || defaultConfig.ALWAYS;\n\n        const nodes = this._nodes_in_order ? this._nodes_in_order : this._nodes;\n        if (!nodes) {\n            return;\n        }\n\n        for (let j = 0, l = nodes.length; j < l; ++j) {\n            const node = nodes[j];\n\n            if (\n                node.constructor.name === \"Subgraph\"\n                && eventname !== \"onExecute\"\n            ) {\n                if (node.mode === mode) {\n                    node.sendEventToAllNodes(eventname, params, mode);\n                }\n                continue;\n            }\n\n            if (!node[eventname] || node.mode !== mode) {\n                continue;\n            }\n            if (params === undefined) {\n                node[eventname]();\n            } else if (params && params.constructor === Array) {\n                node[eventname](...params);\n            } else {\n                node[eventname](params);\n            }\n        }\n    }\n\n    sendActionToCanvas(action, params = []) {\n        if (!this.list_of_graphcanvas) {\n            return;\n        }\n\n        for (const c of this.list_of_graphcanvas) {\n            if (c[action]) {\n                c[action](...params);\n            }\n        }\n    }\n\n    /**\n     * Adds a new node instance to this graph\n     * @method add\n     * @param {LGraphNode} node the instance of the node\n     * @param {boolean} skipComputeOrder\n     * @memberOf LGraph\n     */\n\n    add(node, skipComputeOrder) {\n        if (!node) {\n            return;\n        }\n\n        // groups\n        if (node.constructor === LGraphGroup) {\n            this._groups.push(node);\n            this.setDirtyCanvas(true);\n            this.change();\n            node.graph = this;\n            this._version++;\n            return;\n        }\n\n        // nodes\n        if (node.id !== -1 && this._nodes_by_id[node.id]) {\n            console.warn(\n                \"LiteGraph: there is already a node with this ID, changing it\",\n            );\n            node.id = ++this.last_node_id;\n        }\n\n        if (this._nodes.length >= defaultConfig.MAX_NUMBER_OF_NODES) {\n            throw new Error(\"LiteGraph: max number of nodes in a graph reached\");\n        }\n\n        // give him an id\n        if (!node.id || node.id === -1) {\n            node.id = ++this.last_node_id;\n        } else if (this.last_node_id < node.id) {\n            this.last_node_id = node.id;\n        }\n\n        node.graph = this;\n        this._version++;\n\n        this._nodes.push(node);\n        this._nodes_by_id[node.id] = node;\n\n        if (node.onAdded) node.onAdded(this);\n\n        if (this.config.align_to_grid) node.alignToGrid();\n\n        if (!skipComputeOrder) this.updateExecutionOrder();\n\n        if (this.onNodeAdded) this.onNodeAdded(node);\n\n        this.setDirtyCanvas(true);\n        this.change();\n\n        return node; // to chain actions\n    }\n\n    /**\n     * Removes a node from the graph\n     * @method remove\n     * @param {LGraphNode} node the instance of the node\n     * @memberOf LGraph\n     */\n\n    remove(node) {\n        if (node.constructor.name === \"LGraphGroup\") {\n            const index = this._groups.indexOf(node);\n            if (index !== -1) {\n                this._groups.splice(index, 1);\n            }\n            node.graph = null;\n            this._version++;\n            this.setDirtyCanvas(true, true);\n            this.change();\n            return;\n        }\n\n        if (this._nodes_by_id[node.id] == null) {\n            return;\n        } // not found\n\n        if (node.ignore_remove) {\n            return;\n        } // cannot be removed\n\n        this.beforeChange(); // sure?\n\n        // disconnect inputs\n        if (node.inputs) {\n            for (let i = 0; i < node.inputs.length; i++) {\n                const slot = node.inputs[i];\n                if (slot.link != null) {\n                    node.disconnectInput(i);\n                }\n            }\n        }\n\n        // disconnect outputs\n        if (node.outputs) {\n            for (let i = 0; i < node.outputs.length; i++) {\n                const slot = node.outputs[i];\n                if (slot.links != null && slot.links.length) {\n                    node.disconnectOutput(i);\n                }\n            }\n        }\n\n        // node.id = -1; //why?\n\n        // callback\n        if (node.onRemoved) {\n            node.onRemoved();\n        }\n\n        node.graph = null;\n        this._version++;\n\n        // remove from canvas render\n        if (this.list_of_graphcanvas) {\n            for (const canvas of this.list_of_graphcanvas) {\n                if (canvas.selected_nodes[node.id]) {\n                    delete canvas.selected_nodes[node.id];\n                }\n                if (canvas.node_dragged === node) {\n                    canvas.node_dragged = null;\n                }\n            }\n        }\n\n        // remove from containers\n        if (this._nodes.includes(node)) {\n            this._nodes = this._nodes.filter(n => n !== node);\n        }\n        delete this._nodes_by_id[node.id];\n\n        if (this.onNodeRemoved) {\n            this.onNodeRemoved(node);\n        }\n\n        // close panels\n        this.sendActionToCanvas(\"checkPanels\");\n\n        this.setDirtyCanvas(true, true);\n        this.afterChange(); // sure?\n        this.change();\n\n        this.updateExecutionOrder();\n    }\n\n    /**\n     * Returns a node by its id.\n     * @method getNodeById\n     * @param {Number} id\n     * @memberOf LGraph\n     */\n\n    getNodeById(id) {\n        if (id == null) {\n            return null;\n        }\n        return this._nodes_by_id[id];\n    }\n\n    /**\n     * Returns a list of nodes that matches a class\n     * @method findNodesByClass\n     * @param {Class} classObject the class itself (not an string)\n     * @param {Array} result\n     * @return {Array} a list with all the nodes of this type\n     * @memberOf LGraph\n     */\n    findNodesByClass(classObject, result = []) {\n        result.length = 0;\n        for (const node of this._nodes) {\n            if (node.constructor === classObject) result.push(node);\n        }\n        return result;\n    }\n\n    /**\n     * Returns a list of nodes that matches a type\n     * @method findNodesByType\n     * @param {String} type the name of the node type\n     * @param {Array} result\n     * @return {Array} a list with all the nodes of this type\n     * @memberOf LGraph\n     */\n    findNodesByType(type, result = []) {\n        type = type.toLowerCase();\n        result = result || [];\n        result.length = 0;\n        for (const node of this._nodes) {\n            if (node.type.toLowerCase() === type) result.push(node);\n        }\n        return result;\n    }\n\n    /**\n     * Returns the first node that matches a name in its title\n     * @method findNodeByTitle\n     * @param {String} title the name of the node to search\n     * @return {Node} the node or null\n     * @memberOf LGraph\n     */\n    findNodeByTitle(title) {\n        for (const node of this._nodes) {\n            if (node.title === title) return node;\n        }\n        return null;\n    }\n\n    /**\n     * Returns a list of nodes that matches a name\n     * @method findNodesByTitle\n     * @param {String} title the name of the node to search\n     * @return {Array} a list with all the nodes with this name\n     * @memberOf LGraph\n     */\n    findNodesByTitle(title) {\n        const result = [];\n        for (const node of this._nodes) {\n            if (node.title === title) result.push(node);\n        }\n        return result;\n    }\n\n    /**\n     * Returns the top-most node in this position of the canvas\n     * @method getNodeOnPos\n     * @param {number} x the x coordinate in canvas space\n     * @param {number} y the y coordinate in canvas space\n     * @param {Array} nodesList a list with all the nodes to search from, by default is all the\n     *     nodes in the graph\n     * @param {number} margin\n     * @return {LGraphNode} the node at this position or null\n     * @memberOf LGraph\n     */\n    getNodeOnPos(x, y, nodesList = this._nodes, margin) {\n        for (const n of nodesList) {\n            if (n.isPointInside(x, y, margin)) return n;\n        }\n        return null;\n    }\n\n    /**\n     * Returns the top-most group in that position\n     * @method getGroupOnPos\n     * @param {number} x the x coordinate in canvas space\n     * @param {number} y the y coordinate in canvas space\n     * @return {LGraphGroup} the group or null\n     * @memberOf LGraph\n     */\n    getGroupOnPos(x, y) {\n        for (const g of this._groups) {\n            if (g.isPointInside(x, y, 2, true)) return g;\n        }\n        return null;\n    }\n\n    /**\n     * Checks that the node type matches the node type registered, used when replacing a nodetype\n     * by a newer version during execution this replaces the ones using the old version with the\n     * new version\n     * @method checkNodeTypes\n     * @memberOf LGraph\n     */\n    checkNodeTypes() {\n        for (let node of this._nodes) {\n            const ctor = defaultConfig.registered_node_types[node.type];\n            if (node.constructor === ctor) {\n                continue;\n            }\n            console.log(`node being replaced by newer version: ${node.type}`);\n            const newnode = LGraphNode.createNode(node.type);\n            node = newnode;\n            newnode.configure(node.serialize());\n            newnode.graph = this;\n            this._nodes_by_id[newnode.id] = newnode;\n            if (node.inputs) {\n                newnode.inputs = node.inputs.concat();\n            }\n            if (node.outputs) {\n                newnode.outputs = node.outputs.concat();\n            }\n        }\n        this.updateExecutionOrder();\n    }\n\n    onAction(action, param) {\n        this._input_nodes = this.findNodesByClass(\n            LiteGraph.GraphInput,\n            this._input_nodes,\n        );\n        for (const node of this._input_nodes) {\n            if (node.properties.name !== action) {\n                continue;\n            }\n            node.onAction(action, param);\n            break;\n        }\n    }\n\n    trigger(action, param) {\n        if (this.onTrigger) {\n            this.onTrigger(action, param);\n        }\n    }\n\n    /**\n     * Tell this graph it has a global graph input of this type\n     * @method addGlobalInput\n     * @param {String} name\n     * @param {String} type\n     * @param {*} value [optional]\n     * @memberOf LGraph\n     */\n    addInput(name, type, value) {\n        const input = this.inputs[name];\n        if (input) {\n            // already exist\n            return;\n        }\n\n        this.beforeChange();\n        this.inputs[name] = {\n            name,\n            type,\n            value,\n        };\n        this._version++;\n        this.afterChange();\n\n        if (this.onInputAdded) {\n            this.onInputAdded(name, type);\n        }\n\n        if (this.onInputsOutputsChange) {\n            this.onInputsOutputsChange();\n        }\n    }\n\n    /**\n     * Assign a data to the global graph input\n     * @method setGlobalInputData\n     * @param {String} name\n     * @param {*} data\n     * @memberOf LGraph\n     */\n    setInputData(name, data) {\n        const input = this.inputs[name];\n        if (!input) {\n            return;\n        }\n        input.value = data;\n    }\n\n    /**\n     * Returns the current value of a global graph input\n     * @method getInputData\n     * @param {String} name\n     * @return {*} the data\n     * @memberOf LGraph\n     */\n    getInputData(name) {\n        const input = this.inputs[name];\n        if (!input) {\n            return null;\n        }\n        return input.value;\n    }\n\n    /**\n     * Changes the newName of a global graph input\n     * @method renameInput\n     * @param {String} oldName\n     * @param {String} new_name\n     * @memberOf LGraph\n     */\n    renameInput(oldName, newName) {\n        if (newName === oldName) {\n            return;\n        }\n\n        if (!this.inputs[oldName]) {\n            return false;\n        }\n\n        if (this.inputs[newName]) {\n            console.error(\"there is already one input with that newName\");\n            return false;\n        }\n\n        this.inputs[newName] = this.inputs[oldName];\n        delete this.inputs[oldName];\n        this._version++;\n\n        if (this.onInputRenamed) {\n            this.onInputRenamed(oldName, newName);\n        }\n\n        if (this.onInputsOutputsChange) {\n            this.onInputsOutputsChange();\n        }\n    }\n\n    /**\n     * Changes the type of a global graph input\n     * @method changeInputType\n     * @param {String} name\n     * @param {String} type\n     * @memberOf LGraph\n     */\n    changeInputType(name, type) {\n        if (!this.inputs[name]) {\n            return false;\n        }\n\n        if (\n            this.inputs[name].type\n            && String(this.inputs[name].type).toLowerCase()\n            === String(type).toLowerCase()\n        ) {\n            return;\n        }\n\n        this.inputs[name].type = type;\n        this._version++;\n        if (this.onInputTypeChanged) {\n            this.onInputTypeChanged(name, type);\n        }\n    }\n\n    /**\n     * Removes a global graph input\n     * @method removeInput\n     * @param {String} name\n     * @memberOf LGraph\n     */\n    removeInput(name) {\n        if (!this.inputs[name]) {\n            return false;\n        }\n\n        delete this.inputs[name];\n        this._version++;\n\n        if (this.onInputRemoved) {\n            this.onInputRemoved(name);\n        }\n\n        if (this.onInputsOutputsChange) {\n            this.onInputsOutputsChange();\n        }\n        return true;\n    }\n\n    /**\n     * Creates a global graph output\n     * @method addOutput\n     * @param {String} name\n     * @param {String} type\n     * @param {*} value\n     * @memberOf LGraph\n     */\n    addOutput(name, type, value) {\n        this.outputs[name] = {\n            name,\n            type,\n            value,\n        };\n        this._version++;\n\n        if (this.onOutputAdded) {\n            this.onOutputAdded(name, type);\n        }\n\n        if (this.onInputsOutputsChange) {\n            this.onInputsOutputsChange();\n        }\n    }\n\n    /**\n     * Assign a data to the global output\n     * @method setOutputData\n     * @param {String} name\n     * @param {String} value\n     * @memberOf LGraph\n     */\n    setOutputData(name, value) {\n        const output = this.outputs[name];\n        if (!output) {\n            return;\n        }\n        output.value = value;\n    }\n\n    /**\n     * Returns the current value of a global graph output\n     * @method getOutputData\n     * @param {String} name\n     * @return {*} the data\n     * @memberOf LGraph\n     */\n    getOutputData(name) {\n        const output = this.outputs[name];\n        if (!output) {\n            return null;\n        }\n        return output.value;\n    }\n\n    /**\n     * Renames a global graph output\n     * @method renameOutput\n     * @param {String} oldName\n     * @param {String} newName\n     * @memberOf LGraph\n     */\n    renameOutput(oldName, newName) {\n        if (!this.outputs[oldName]) {\n            return false;\n        }\n\n        if (this.outputs[newName]) {\n            console.error(\"there is already one output with that newName\");\n            return false;\n        }\n\n        this.outputs[newName] = this.outputs[oldName];\n        delete this.outputs[oldName];\n        this._version++;\n\n        if (this.onOutputRenamed) {\n            this.onOutputRenamed(oldName, newName);\n        }\n\n        if (this.onInputsOutputsChange) {\n            this.onInputsOutputsChange();\n        }\n    }\n\n    /**\n     * Changes the type of a global graph output\n     * @method changeOutputType\n     * @param {String} name\n     * @param {String} type\n     * @memberOf LGraph\n     */\n    changeOutputType(name, type) {\n        if (!this.outputs[name]) {\n            return false;\n        }\n\n        if (\n            this.outputs[name].type\n            && String(this.outputs[name].type).toLowerCase()\n            === String(type).toLowerCase()\n        ) {\n            return;\n        }\n\n        this.outputs[name].type = type;\n        this._version++;\n        if (this.onOutputTypeChanged) {\n            this.onOutputTypeChanged(name, type);\n        }\n    }\n\n    /**\n     * Removes a global graph output\n     * @method removeOutput\n     * @param {String} name\n     * @memberOf LGraph\n     */\n    removeOutput(name) {\n        if (!this.outputs[name]) {\n            return false;\n        }\n        delete this.outputs[name];\n        this._version++;\n\n        if (this.onOutputRemoved) {\n            this.onOutputRemoved(name);\n        }\n\n        if (this.onInputsOutputsChange) {\n            this.onInputsOutputsChange();\n        }\n        return true;\n    }\n\n    triggerInput(name, value) {\n        const nodes = this.findNodesByTitle(name);\n        for (let i = 0; i < nodes.length; ++i) {\n            nodes[i].onTrigger(value);\n        }\n    }\n\n    setCallback(name, func) {\n        const nodes = this.findNodesByTitle(name);\n        for (let i = 0; i < nodes.length; ++i) {\n            nodes[i].setTrigger(func);\n        }\n    }\n\n    // used for undo, called before any change is made to the graph\n    beforeChange(info) {\n        if (this.onBeforeChange) {\n            this.onBeforeChange(this, info);\n        }\n        this.sendActionToCanvas(\"onBeforeChange\", this);\n    }\n\n    // used to resend actions, called after any change is made to the graph\n    afterChange(info) {\n        if (this.onAfterChange) {\n            this.onAfterChange(this, info);\n        }\n        this.sendActionToCanvas(\"onAfterChange\", this);\n    }\n\n    connectionChange(node) {\n        this.updateExecutionOrder();\n        if (this.onConnectionChange) {\n            this.onConnectionChange(node);\n        }\n        this._version++;\n        this.sendActionToCanvas(\"onConnectionChange\");\n    }\n\n    /**\n     * returns if the graph is in live mode\n     * @method isLive\n     * @memberOf LGraph\n     */\n\n    isLive() {\n        if (!this.list_of_graphcanvas) {\n            return false;\n        }\n\n        for (let i = 0; i < this.list_of_graphcanvas.length; ++i) {\n            const c = this.list_of_graphcanvas[i];\n            if (c.live_mode) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * clears the triggered slot animation in all links (stop visual animation)\n     * @method clearTriggeredSlots\n     * @memberOf LGraph\n     */\n    clearTriggeredSlots() {\n        // eslint-disable-next-line guard-for-in,no-restricted-syntax\n        for (const i in this.links) {\n            const linkInfo = this.links[i];\n            if (!linkInfo) {\n                continue;\n            }\n            if (linkInfo._last_time) {\n                linkInfo._last_time = 0;\n            }\n        }\n    }\n\n    /* Called when something visually changed (not the graph!) */\n    change() {\n        if (defaultConfig.debug) {\n            console.log(\"Graph changed\");\n        }\n        this.sendActionToCanvas(\"setDirty\", [true, true]);\n        if (this.on_change) this.on_change(this);\n    }\n\n    setDirtyCanvas(fg, bg) {\n        this.sendActionToCanvas(\"setDirty\", [fg, bg]);\n    }\n\n    /**\n     * Destroys a link\n     * @method removeLink\n     * @param {Number} linkId\n     * @memberOf LGraph\n     */\n    removeLink(linkId) {\n        const link = this.links[linkId];\n        if (!link) {\n            return;\n        }\n        const node = this.getNodeById(link.target_id);\n        if (node) {\n            node.disconnectInput(link.target_slot);\n        }\n    }\n\n    // save and recover app state ***************************************\n    /**\n     * Creates a Object containing all the info about this graph, it can be serialized\n     * @method serialize\n     * @return {Object} value of the node\n     * @memberOf LGraph\n     */\n    serialize() {\n        const nodesInfo = [];\n        for (const node of this._nodes) {\n            nodesInfo.push(node.serialize());\n        }\n\n        // pack link info into a non-verbose format\n        const links = [];\n        // eslint-disable-next-line guard-for-in,no-restricted-syntax\n        for (const i in this.links) {\n            // links is an OBJECT\n            let link = this.links[i];\n            if (!link.serialize) {\n                // weird bug I havent solved yet\n                console.warn(\n                    \"weird LLink bug, link info is not a LLink but a regular object\",\n                );\n                const link2 = new LLink();\n                // eslint-disable-next-line guard-for-in,no-restricted-syntax\n                for (const j in link) {\n                    link2[j] = link[j];\n                }\n                this.links[i] = link2;\n                link = link2;\n            }\n\n            links.push(link.serialize());\n        }\n\n        const groupsInfo = [];\n        for (const group of this._groups) groupsInfo.push(group.serialize());\n\n        const data = {\n            last_node_id: this.last_node_id,\n            last_link_id: this.last_link_id,\n            nodes: nodesInfo,\n            links,\n            groups: groupsInfo,\n            config: this.config,\n            extra: this.extra,\n            version: defaultConfig.VERSION,\n        };\n\n        if (this.onSerialize) this.onSerialize(data);\n\n        return data;\n    }\n\n    /**\n     * Configure a graph from a JSON string\n     * @method configure\n     * @param {String} str configure a graph from a JSON string\n     * @param {Boolean} returns if there was any error parsing\n     * @memberOf LGraph\n     */\n    configure(data, keepOld) {\n        if (!data) {\n            return;\n        }\n\n        if (!keepOld) this.clear();\n\n        const { nodes } = data;\n\n        // decode links info (they are very verbose)\n        if (data.links && data.links.constructor === Array) {\n            const links = [];\n            for (const linkData of data.links) {\n                if (!linkData) {\n                    console.warn(\"serialized graph link data contains errors, skipping.\");\n                    continue;\n                }\n                const link = new LLink();\n                link.configure(linkData);\n                links[link.id] = link;\n            }\n            data.links = links;\n        }\n\n        // copy all stored fields\n        // eslint-disable-next-line guard-for-in,no-restricted-syntax\n        for (const i in data) {\n            if (i === \"nodes\" || i === \"groups\") {\n                continue;\n            }\n            this[i] = data[i];\n        }\n\n        let error = false;\n\n        // create nodes\n        this._nodes = [];\n        if (nodes) {\n            for (const nInfo of nodes) {\n                let node = LGraphNode.createNode(nInfo.type, nInfo.title);\n                if (!node) {\n                    if (defaultConfig.debug) {\n                        console.log(\n                            `Node not found or has errors: ${nInfo.type}`,\n                        );\n                    }\n\n                    // in case of error we create a replacement node to avoid losing info\n                    node = new LGraphNode();\n                    node.last_serialization = nInfo;\n                    node.has_errors = true;\n                    error = true;\n                    // continue;\n                }\n\n                node.id = nInfo.id; // id it or it will create a new id\n                this.add(node, true); // add before configure, otherwise configure cannot create\n                // links\n            }\n\n            // configure nodes afterwards so they can reach each other\n            for (const nInfo of nodes) {\n                const node = this.getNodeById(nInfo.id);\n                if (node) {\n                    node.configure(nInfo);\n                }\n            }\n        }\n\n        // groups\n        this._groups.length = 0;\n        if (data.groups) {\n            for (const dataGroup of data.groups) {\n                const group = new LGraphGroup();\n                group.configure(dataGroup);\n                this.add(group);\n            }\n        }\n\n        this.updateExecutionOrder();\n\n        this.extra = data.extra || {};\n\n        if (this.onConfigure) this.onConfigure(data);\n\n        this._version++;\n        this.setDirtyCanvas(true, true);\n        return error;\n    }\n\n    load(url, callback) {\n        const that = this;\n\n        // from file\n        if (url.constructor === File || url.constructor === Blob) {\n            const reader = new FileReader();\n            reader.addEventListener(\"load\", (event) => {\n                const data = JSON.parse(event.target.result);\n                that.configure(data);\n                if (callback) callback();\n            });\n\n            reader.readAsText(url);\n            return;\n        }\n\n        // is a string, then an URL\n        const req = new XMLHttpRequest();\n        req.open(\"GET\", url, true);\n        req.send(null);\n        req.onload(() => {\n            if (req.status !== 200) {\n                console.error(\"Error loading graph:\", req.status, req.response);\n                return;\n            }\n            const data = JSON.parse(req.response);\n            that.configure(data);\n            if (callback) callback();\n        });\n        req.onerror((err) => {\n            console.error(\"Error loading graph:\", err);\n        });\n    }\n\n    /**\n     * Node event manager\n     * @todo Need create event\n     * @param node\n     * @param msg\n     * @param color\n     * @memberOf LGraph\n     */\n    onNodeTrace(node, msg, color) {\n        // TODO\n    }\n}\n","/**\n * @class CurveEditor\n * @param points\n */\nexport default class CurveEditor {\n    constructor(points) {\n        this.points = points;\n        this.selected = -1;\n        this.nearest = -1;\n        this.size = null; // stores last size used\n        this.must_update = true;\n        this.margin = 5;\n    }\n\n    sampleCurve(f, points) {\n        if (!points) return;\n        for (let i = 0; i < points.length - 1; ++i) {\n            const p = points[i];\n            const pn = points[i + 1];\n            if (pn[0] < f) continue;\n            const r = (pn[0] - p[0]);\n            if (Math.abs(r) < 0.00001) return p[1];\n            const localF = (f - p[0]) / r;\n            return p[1] * (1.0 - localF) + pn[1] * localF;\n        }\n        return 0;\n    }\n\n    draw(ctx, size, graphcanvas, backgroundColor, lineColor = \"#666\", inactive) {\n        const { points } = this;\n        if (!points) return;\n        this.size = size;\n        const w = size[0] - this.margin * 2;\n        const h = size[1] - this.margin * 2;\n\n        ctx.save();\n        ctx.translate(this.margin, this.margin);\n\n        if (backgroundColor) {\n            ctx.fillStyle = \"#111\";\n            ctx.fillRect(0, 0, w, h);\n            ctx.fillStyle = \"#222\";\n            ctx.fillRect(w * 0.5, 0, 1, h);\n            ctx.strokeStyle = \"#333\";\n            ctx.strokeRect(0, 0, w, h);\n        }\n        ctx.strokeStyle = lineColor;\n        if (inactive) ctx.globalAlpha = 0.5;\n        ctx.beginPath();\n        for (const point of points) {\n            ctx.lineTo(point[0] * w, (1.0 - point[1]) * h);\n        }\n        ctx.stroke();\n        ctx.globalAlpha = 1;\n        if (!inactive) {\n            for (let i = 0; i < points.length; ++i) {\n                const p = points[i];\n                if (this.selected === i) ctx.fillStyle = \"#FFF\";\n                else if (this.nearest === i) ctx.fillStyle = \"#DDD\";\n                else ctx.fillStyle = \"#AAA\";\n                ctx.beginPath();\n                ctx.arc(p[0] * w, (1.0 - p[1]) * h, 2, 0, Math.PI * 2);\n                ctx.fill();\n            }\n        }\n        ctx.restore();\n    }\n\n    onMouseDown(localpos, graphcanvas) {\n        const { points } = this;\n        if (!points) return;\n        if (localpos[1] < 0) return;\n\n        // this.captureInput(true);\n        const w = this.size[0] - this.margin * 2;\n        const h = this.size[1] - this.margin * 2;\n        const x = localpos[0] - this.margin;\n        const y = localpos[1] - this.margin;\n        const pos = [x, y];\n        const maxDist = 30 / graphcanvas.ds.scale;\n        // search closer one\n        this.selected = this.getCloserPoint(pos, maxDist);\n        // create one\n        if (this.selected === -1) {\n            const point = [x / w, 1 - y / h];\n            points.push(point);\n            points.sort((a, b) => a[0] - b[0]);\n            this.selected = points.indexOf(point);\n            this.must_update = true;\n        }\n        if (this.selected !== -1) return true;\n    }\n\n    onMouseMove(localpos, graphcanvas) {\n        const { points } = this;\n        if (!points) return;\n        const s = this.selected;\n        if (s < 0) return;\n        const x = (localpos[0] - this.margin) / (this.size[0] - this.margin * 2);\n        const y = (localpos[1] - this.margin) / (this.size[1] - this.margin * 2);\n        const curvepos = [(localpos[0] - this.margin), (localpos[1] - this.margin)];\n        const maxDist = 30 / graphcanvas.ds.scale;\n        this._nearest = this.getCloserPoint(curvepos, maxDist);\n        const point = points[s];\n        if (point) {\n            const isEdgePoint = s === 0 || s === points.length - 1;\n            if (!isEdgePoint\n                && (localpos[0] < -10\n                    || localpos[0] > this.size[0] + 10\n                    || localpos[1] < -10\n                    || localpos[1] > this.size[1] + 10)) {\n                points.splice(s, 1);\n                this.selected = -1;\n                return;\n            }\n            if (!isEdgePoint) {\n                point[0] = Math.clamp(x, 0, 1);\n            } else {\n                point[0] = s === 0 ? 0 : 1;\n            }\n            point[1] = 1.0 - Math.clamp(y, 0, 1);\n            points.sort((a, b) => a[0] - b[0]);\n            this.selected = points.indexOf(point);\n            this.must_update = true;\n        }\n    }\n\n    onMouseUp() {\n        this.selected = -1;\n        return false;\n    }\n\n    getCloserPoint(pos, maxDist = 30) {\n        const { points } = this;\n        if (!points) return -1;\n        const w = (this.size[0] - this.margin * 2);\n        const h = (this.size[1] - this.margin * 2);\n        const num = points.length;\n        const p2 = [0, 0];\n        let minDist = 1000000;\n        let closest = -1;\n        let lastValid = -1;\n        for (let i = 0; i < num; ++i) {\n            const p = points[i];\n            p2[0] = p[0] * w;\n            p2[1] = (1.0 - p[1]) * h;\n            // eslint-disable-next-line no-unused-vars\n            if (p2[0] < pos[0]) lastValid = i;\n            const dist = vec2.distance(pos, p2);\n            if (dist > minDist || dist > maxDist) continue;\n            closest = i;\n            minDist = dist;\n        }\n        return closest;\n    }\n}\n","// Creates an interface to access extra features from a graph (like play, stop, live, etc)\nimport LGraph from \"./LGraph\";\nimport LGraphCanvas from \"./LGraphCanvas\";\n\n/**\n * @class Editor\n * @param containerId\n * @param options\n */\nexport default class Editor {\n    constructor(containerId, options) {\n        options = options || {};\n\n        // fill container\n        const html = \"<div class='content'><div class='editor-area'><canvas class='graphcanvas' width='1000' height='500' tabindex=10></canvas></div></div>\";\n\n        const root = document.createElement(\"div\");\n        this.root = root;\n        root.className = \"litegraph litegraph-editor\";\n        root.innerHTML = html;\n\n        this.content = root.querySelector(\".content\");\n        this.footer = root.querySelector(\".footer\");\n\n        const canvas = root.querySelector(\".graphcanvas\");\n\n        // create graph\n        const graph = (this.graph = new LGraph());\n        const graphcanvas = (this.graphcanvas = new LGraphCanvas(canvas, graph));\n        graphcanvas.background_image = \"imgs/grid.png\";\n        graph.onAfterExecute = function () {\n            graphcanvas.draw(true);\n        };\n\n        graphcanvas.onDropItem = this.onDropItem.bind(this);\n\n        if (options.miniwindow) {\n            this.addMiniWindow(300, 200);\n        }\n\n        // append to DOM\n        const parent = document.getElementById(containerId);\n        if (parent) {\n            parent.appendChild(root);\n        }\n\n        graphcanvas.resize();\n        // graphcanvas.draw(true,true);\n    }\n\n    onDropItem(e) {\n        for (const file of e.dataTransfer.files) {\n            const ext = LGraphCanvas.getFileExtension(file.name);\n            const reader = new FileReader();\n            if (ext === \"json\") {\n                reader.onload = (event) => {\n                    this.graph.configure(JSON.parse(event.target.result));\n                };\n                reader.readAsText(file);\n            }\n        }\n    }\n\n    addMiniWindow(w, h) {\n        const miniwindow = document.createElement(\"div\");\n        miniwindow.className = \"litegraph miniwindow\";\n        miniwindow.innerHTML = `<canvas class='graphcanvas' width='${\n            w\n        }' height='${\n            h\n        }' tabindex=10></canvas>`;\n        const canvas = miniwindow.querySelector(\"canvas\");\n        const that = this;\n\n        const graphcanvas = new LGraphCanvas(canvas, this.graph);\n        graphcanvas.show_info = false;\n        graphcanvas.background_image = \"imgs/grid.png\";\n        graphcanvas.scale = 0.25;\n        graphcanvas.allow_dragnodes = false;\n        graphcanvas.allow_interaction = false;\n        graphcanvas.render_shadows = false;\n        graphcanvas.max_zoom = 0.25;\n        this.miniwindow_graphcanvas = graphcanvas;\n        graphcanvas.onClear = function () {\n            graphcanvas.scale = 0.25;\n            graphcanvas.allow_dragnodes = false;\n            graphcanvas.allow_interaction = false;\n        };\n        graphcanvas.onRenderBackground = function (canvas, ctx) {\n            ctx.strokeStyle = \"#567\";\n            let tl = that.graphcanvas.convertOffsetToCanvas([0, 0]);\n            let br = that.graphcanvas.convertOffsetToCanvas([\n                that.graphcanvas.canvas.width,\n                that.graphcanvas.canvas.height,\n            ]);\n            tl = this.convertCanvasToOffset(tl);\n            br = this.convertCanvasToOffset(br);\n            ctx.lineWidth = 1;\n            ctx.strokeRect(\n                Math.floor(tl[0]) + 0.5,\n                Math.floor(tl[1]) + 0.5,\n                Math.floor(br[0] - tl[0]),\n                Math.floor(br[1] - tl[1]),\n            );\n        };\n\n        miniwindow.style.position = \"absolute\";\n        miniwindow.style.top = \"4px\";\n        miniwindow.style.right = \"4px\";\n\n        const closeBouton = document.createElement(\"div\");\n        closeBouton.className = \"corner-button\";\n        closeBouton.innerHTML = \"&#10060;\";\n        closeBouton.addEventListener(\"click\", (e) => {\n            graphcanvas.setGraph(null);\n            miniwindow.remove();\n        });\n        miniwindow.appendChild(closeBouton);\n\n        this.root.querySelector(\".content\").appendChild(miniwindow);\n    }\n}\n","import \"../css/litegraph.css\";\nimport \"../css/litegraph-editor.css\";\n\nexport { default as LGraph } from \"./LGraph\";\nexport { default as LLink } from \"./LLink\";\nexport { default as LGraphNode } from \"./LGraphNode\";\nexport { default as LGraphGroup } from \"./LGraphGroup\";\nexport { default as DragAndScale } from \"./DragAndScale\";\nexport { default as CurveEditor } from \"./CurveEditor\";\nexport { default as LGraphCanvas } from \"./LGraphCanvas\";\nexport { default as ContextMenu } from \"./ContextMenu\";\nexport { default as Editor } from \"./litegraph-editor\";\n\nexport { default as defaultConfig } from \"./utils/defaultConfig\";\nexport * from \"./utils/registry\";\nexport * from \"./utils/math\";\nexport * from \"./utils/function\";\n\nif (window && window.CanvasRenderingContext2D) {\n    window.CanvasRenderingContext2D.prototype.roundRect = function roundRect(\n        x,\n        y,\n        width,\n        height,\n        radius = 5,\n        radiusLow = radius,\n    ) {\n        this.moveTo(x + radius, y);\n        this.lineTo(x + width - radius, y);\n        this.quadraticCurveTo(x + width, y, x + width, y + radius);\n\n        this.lineTo(x + width, y + height - radiusLow);\n        this.quadraticCurveTo(\n            x + width,\n            y + height,\n            x + width - radiusLow,\n            y + height,\n        );\n        this.lineTo(x + radiusLow, y + height);\n        this.quadraticCurveTo(x, y + height, x, y + height - radiusLow);\n        this.lineTo(x, y + radius);\n        this.quadraticCurveTo(x, y, x + radius, y);\n    };\n}\n"],"names":["styleInject","css","ref","insertAt","document","head","getElementsByTagName","style","createElement","type","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","VERSION","CANVAS_GRID_SIZE","NODE_TITLE_HEIGHT","NODE_TITLE_TEXT_Y","NODE_SLOT_HEIGHT","NODE_WIDGET_HEIGHT","NODE_WIDTH","NODE_MIN_WIDTH","NODE_COLLAPSED_RADIUS","NODE_COLLAPSED_WIDTH","NODE_TITLE_COLOR","NODE_SELECTED_TITLE_COLOR","NODE_TEXT_SIZE","NODE_TEXT_COLOR","NODE_SUBTEXT_SIZE","NODE_DEFAULT_COLOR","NODE_DEFAULT_BGCOLOR","NODE_DEFAULT_BOXCOLOR","NODE_DEFAULT_SHAPE","NODE_BOX_OUTLINE_COLOR","DEFAULT_SHADOW_COLOR","DEFAULT_GROUP_FONT","WIDGET_BGCOLOR","WIDGET_OUTLINE_COLOR","WIDGET_TEXT_COLOR","WIDGET_SECONDARY_TEXT_COLOR","LINK_COLOR","EVENT_LINK_COLOR","CONNECTING_LINK_COLOR","MAX_NUMBER_OF_NODES","DEFAULT_POSITION","VALID_SHAPES","BOX_SHAPE","ROUND_SHAPE","CIRCLE_SHAPE","CARD_SHAPE","ARROW_SHAPE","INPUT","OUTPUT","EVENT","ACTION","ALWAYS","ON_EVENT","NEVER","ON_TRIGGER","UP","DOWN","LEFT","RIGHT","CENTER","STRAIGHT_LINK","LINEAR_LINK","SPLINE_LINK","NORMAL_TITLE","NO_TITLE","TRANSPARENT_TITLE","AUTOHIDE_TITLE","proxy","node_images_path","debug","catch_exceptions","throw_errors","allow_scripts","registered_node_types","node_types_by_file_extension","Nodes","Globals","searchbox_extras","auto_sort_node_types","getTime","performance","now","Date","process","t","hrtime","cloneObject","obj","target","r","JSON","parse","stringify","i","registerNodeType","baseClass","prototype","TypeError","defaultConfig","console","log","classname","name","pos","lastIndexOf","category","substr","title","prev","Object","hasOwnProperty","call","defineProperty","set","v","this","_shape","get","enumerable","configurable","onPropertyChange","warn","supported_extensions","ext","constructor","String","toLowerCase","onNodeTypeRegistered","onNodeTypeReplaced","getNodeTypesInCategory","filter","push","sort","getNodeTypesCategories","categories","id","skip_list","result","getParameterNames","func","replace","split","Boolean","isValidConnection","typeA","typeB","indexOf","supportedTypesA","supportedTypesB","length","j","LLink","origin_id","origin_slot","target_id","target_slot","_data","_pos","Float32Array","o","Array","distance","a","b","Math","sqrt","isInsideRectangle","x","y","left","top","width","height","overlapBounding","AEndX","AEndY","BEndX","BEndY","LGraphNode","size","graph","inputs","outputs","connections","properties","properties_info","flags","info","_version","_typeof","configure","k","onPropertyChanged","onConnectionsChange","input","linkInfo","links","link","output","widgets","widget","options","property","value","widgets_values","onConfigure","order","mode","last_serialization","serialize_widgets","color","bgcolor","boxcolor","shape","onSerialize","node","createNode","data","serialize","prevValue","w","slot","output_info","link_id","force_update","getNodeById","updateOutputData","onExecute","slot_name","findInputSlot","getInputData","slot_info","link_info","l","input_info","target_node","action","param","_last_trigger_time","triggerSlot","_last_time","target_connection","onAction","onResize","default_value","extra_info","onOutputAdded","setSize","computeSize","setDirtyCanvas","array","disconnectOutput","splice","onOutputRemoved","onInputAdded","disconnectInput","onInputRemoved","direction","out","concat","rows","max","font_size","title_width","compute_text_size","input_width","output_width","text_width","label","slot_start_y","widgets_height","text","widgets_up","widgets_start_y","min_height","widgets_info","onGetPropertyInfo","callback","Function","values","custom_widget","onBounding","margin","skip_title","margin_top","isLive","collapsed","_collapsed_width","link_pos","getConnectionPos","findOutputSlot","Number","changed","beforeChange","onConnectInput","last_link_id","onNodeConnectionChange","afterChange","connectionChange","is_input","slot_number","num_slots","offset","horizontal","round","msg","MAX_CONSOLE","shift","onNodeTrace","dirty_foreground","dirty_background","sendActionToCanvas","url","img","Image","src","ready","onload","_this","list_of_graphcanvas","list","c","node_capturing_input","force","collapsable","pinned","undefined","graphcanvas","scale","err","error","folderWildcard","scriptFiles","docHeadObj","location","href","dynamicScript","removeChild","object","getOwnPropertyNames","LGraphGroup","isPointInside","_ctor","_bounding","subarray","_size","_nodes","nodes","node_bounding","getBounding","deltax","deltay","ignore_nodes","bounding","font","DragAndScale","element","skipEvents","max_scale","min_scale","onredraw","enabled","last_mouse","visible_area","bindEvents","_binded_mouse_callback","onMouse","bind","addEventListener","startx","starty","endx","endy","e","canvas","rect","getBoundingClientRect","clientX","clientY","canvasx","canvasy","dragging","ignore","onmouse","removeEventListener","body","mouseDrag","eventType","wheel","deltaY","wheelDeltaY","detail","wheelDelta","delta","changeDeltaScale","preventDefault","stopPropagation","ctx","translate","zoomingCenter","center","convertCanvasToOffset","abs","newCenter","deltaOffset","changeScale","ContextMenu","that","parentMenu","lock","current_submenu","eventClass","event","root","on_mouse_wheel","parseInt","scroll_speed","toFixed","className","minWidth","minHeight","pointerEvents","setTimeout","button","close","innerHTML","content","addItem","closing_timer","clearTimeout","rootDocument","ownerDocument","fullscreenElement","bodyRect","rootRect","transform","disabled","inner_over","has_submenu","inner_onclick","closeParent","ignore_item_callbacks","extra","submenu","Error","autoopen","classList","add","dataset","onclick_callback","ignoreParentMenu","parentNode","remove","isCursorOverElement","trigger","getTopMenu","getFirstEvent","eventName","params","origin","evt","createEvent","initCustomEvent","dispatchEvent","__events","ref_window","window","elements","querySelectorAll","el","re","temp","tempVC2","tempArea","marginArea","linkBounding","tempA","tempB","LGraphCanvas","active_canvas","dialog","search_box","focus","overflow","timeoutClose","ds","helper","querySelector","first","timeout","selected","keyCode","changeSelection","clearInterval","refreshHelper","select","stopImmediatePropagation","onSearchBoxSelection","convertEventToCanvasOffset","addProperty","addOutput","json","forward","nextSibling","previousSibling","childNodes","scrollIntoView","block","behavior","str","onSearchBox","addResult","desc","ctor","search_limit","keys","help","innerText","escape","unescape","layerY","maxHeight","SELECTED_NODE","panel","refWindow","getCanvasWindow","createPanel","closable","addHTML","getPropertyInfo","onAddPropertyToPanel","addWidget","setProperty","dirty_canvas","addSeparator","onShowCustomPanelInfo","addButton","block_delete","inner_refresh","background_image","DEFAULT_BACKGROUND_IMAGE","zoom_modify_alpha","title_text_font","inner_text_font","node_title_color","default_link_color","default_connection_color","input_off","input_on","output_off","output_on","highquality_render","use_gradients","editor_alpha","pause_rendering","clear_background","read_only","render_only_selected","live_mode","show_info","allow_dragcanvas","allow_dragnodes","allow_interaction","allow_searchbox","allow_reconnect_links","drag_mode","dragging_rectangle","set_canvas_dirty_on_mouse_event","always_render_background","render_shadows","render_canvas_border","render_connections_shadows","render_connections_border","render_curved_connections","render_connection_arrows","render_collapsed_slots","render_execution_order","render_title_colored","render_link_tooltip","links_render_mode","mouse","graph_mouse","canvas_mouse","onDrawBackground","onDrawForeground","onDrawOverlay","onDrawLinkTooltip","onNodeMoved","onSelectionChange","onConnectingChange","onBeforeChange","onAfterChange","connections_width","round_radius","current_node","node_widget","over_link_center","last_mouse_position","visible_links","attachCanvas","setCanvas","clear","skip_render","startRendering","autoresize","frame","last_draw_time","render_time","fps","selected_nodes","selected_group","visible_nodes","node_dragged","node_over","connecting_node","highlighted_links","dragging_canvas","dirty_bgcanvas","dirty_area","node_in_panel","last_mouseclick","onClear","skipClear","_graph_stack","setDirty","detachCanvas","checkPanels","subgraphNode","_subgraph_node","pop","centerOnNode","selectNodes","getElementById","unbindEvents","tabindex","bgcanvas","getContext","localName","webgl_enabled","enableWebGL","_mousemove_callback","processMouseMove","_mouseup_callback","processMouseUp","_events_binded","_mousedown_callback","processMouseDown","_mousewheel_callback","processMouseWheel","_doNothing","touchHandler","_key_callback","processKey","_ondrop_callback","processDrop","_doReturnTrue","GL","enableWebGLCanvas","gl","webgl","bgctx","fgcanvas","defaultView","is_rendering","renderFrame","draw","requestAnimationFrame","_this2","block_click","adjustMouseEvent","getNodeOnPos","canvasX","canvasY","skipAction","isDoubleClick","localX","localY","last_click_position","closeAllContextMenus","which","ctrlKey","clickingCanvasBg","bringToFront","resizable","resizing_node","cursor","linkPos","connecting_output","connecting_pos","connecting_slot","shiftKey","onOutputDblClick","onOutputClick","onInputDblClick","onInputClick","_nodes_by_id","blockDragNote","processNodeWidgets","onDblClick","processNodeDblClicked","onMouseDown","subgraph","skip_subgraph_button","_this3","openSubgraph","processNodeSelected","showLinkMenu","getGroupOnPos","selected_group_resizing","recomputeInsideNodes","showSearchBox","processContextMenu","last_mouse_dragging","change","activeElement","nodeName","resize","move","_node","mouseOver","onMouseLeave","redraw_on_mouse","onMouseEnter","onMouseMove","_highlight_input","isOverNodeBox","isOverNodeInput","slotType","overLink","nKeys","n","desiredSize","minSize","click_time","diffx","diffy","nodeBounding","deselectAllNodes","h","toSelect","connect","getInputInfo","collapse","config","align_to_grid","alignToGrid","onMouseUp","titleHeight","slotPos","blockDefault","code","metaKey","copyToClipboard","pasteFromClipboard","deleteSelectedNodes","onKeyDown","onKeyUp","localStorage","getItem","clipboardInfo","node_data","origin_node","index","selectedNodesArray","_relative_id","cloned","clone","setItem","onDropItem","checkDropItem","onDropFile","onDropData","files","dataTransfer","file","filename","reader","FileReader","readAsText","readAsDataURL","readAsArrayBuffer","question","point","getFileExtension","nodetype","onShowNodePanel","showShowNodePanel","onNodeDblClicked","selectNode","onNodeSelected","addToCurrentSelection","is_selected","onSelected","onDeselected","onNodeDeselected","inputLink","outputLink","inputNode","getInputNode","outputNode","getOutputNodes","deltaX","convertOffsetToCanvas","unshift","visibleNodes","force_canvas","force_bgcanvas","computeVisibleArea","drawBackCanvas","drawFrontCanvas","start2D","restore","setTransform","save","beginPath","clip","clearRect","drawImage","onRender","renderInfo","toCanvasContext","computeVisibleNodes","drawNode","drawExecutionOrder","links_ontop","drawConnections","lineWidth","linkColor","renderLink","dir","arc","PI","fill","fillStyle","strokeStyle","strokeRect","drawLinkTooltip","visible_rect","drawSubgraphPanel","finish2D","subnode","num","floor","globalAlpha","roundRect","textAlign","fillText","drawButton","closeSubgraph","not_subgraph_input","input_node_type","newnode","tw","measureText","showSubgraphPropertiesDialog","hovercolor","textcolor","hover","clicked","blockClick","holdClick","globaltime","iteration","start","g","getTitle","bgAlreadyPainted","onRenderBackground","imageSmoothingEnabled","mozImageSmoothingEnabled","_bg_img","_this4","pattern","_pattern","createPattern","_pattern_img","fillRect","_groups","drawGroups","shadowColor","shadowOffsetX","shadowOffsetY","shadowBlur","finish","lowQuality","onDrawCollapsed","min","clip_area","has_errors","drawNodeShape","renderText","outSlot","maxY","storedSlot","inputSlot","outputSlot","moveTo","lineTo","closePath","color_on","color_off","stroke","widgetsY","drawNodeWidgets","toToolTip","fgcolor","mouseHover","title_mode","renderTitle","area","oldAlpha","onDrawTitleBar","title_color","titleColor","grad","gradients","createLinearGradient","addColorStop","boxSize","onDrawTitleBox","includes","onDrawTitleText","title_text_color","over","onDrawTitle","linkId","startNode","startNodeSlot","startNodeSlotPos","endNodeSlotPos","startSlot","endSlot","startDir","endDir","f","tmp","skipBorder","flow","numSubline","link_type_colors","dist","lineJoin","offsety","startOffsetX","startOffsetY","endOffsetX","endOffsetY","bezierCurveTo","startX","startY","endX","endY","posConnectionPoint","computeConnectionPoint","posA","posB","posC","posD","angleA","angleB","atan2","rotate","p0","p1","p2","p3","c1","c2","c3","c4","posY","active_widget","H","showText","outlineColor","backgroundColor","textColor","secondaryTextColor","last_y","widgetWidth","on","off","range","nvalue","marker","marker_nvalue","precision","activeWidget","widgetHeight","oldValue","_this5","clamp","innerValueChange","step","valuesList","textValues","option","prompt","multiline","onWidgetChanged","groups","group","fontSize","DEFAULT_GROUP_FONT_SIZE","parent","offsetWidth","offsetHeight","transition","setInterval","_this6","changedTouches","simulatedEvent","initMouseEvent","screenX","screenY","menu","onMenuAdd","nodeLeft","nodeRight","removeLink","modified","_this7","prompt_box","nameElement","valueElement","offsetx","inputHTML","createDialog","setValue","checked","onclose","html","position","header","title_element","footer","onFooter","elem","strValue","toString","innerChange","propname","_this8","toggle","setAttribute","blur","getPropertyPrintableValue","old_panel","removeInput","addInput","getMenuOptions","onGroupAdd","getExtraMenuOptions","showMenuNodeOptionalInputs","showMenuNodeOptionalOutputs","onShowMenuNodeProperties","onShowPropertyEditor","onMenuNodeMode","onResizeNode","onMenuNodeCollapse","onMenuNodePin","onMenuNodeColors","onMenuNodeShapes","onGetInputs","onGetOutputs","clonable","onMenuNodeClone","removable","onMenuNodeRemove","onGetNodeMenuOptions","menuInfo","removeOutput","slotInfo","getOutputInfo","getSlotInPosition","active_node","getSlotMenuOptions","_slot","locked","nameLocked","getNodeMenuOptions","getCanvasMenuOptions","getGroupMenuOptions","entry","mouseEvent","previousMenu","inner_onMenuAdded","base_category","prev_menu","registry","startsWith","entries","forEach","base_category_regex","RegExp","category_name","category_path","findIndex","contextMenu","slice","first_event","optionsParam","optional_inputs","onMenuNodeInputs","optional_outputs","skip_repeated_outputs","onMenuNodeOutputs","innerClicked","decodeHTML","showEditPropertyValue","allow_html","item","desc_value","pin","node_colors","groupcolor","nodesList","buildFromNodes","number","red","brown","green","blue","pale_blue","cyan","purple","yellow","black","LGraph","supportedTypes","stop","status","STATUS_STOPPED","last_node_id","onRemoved","_nodes_in_order","_nodes_executable","vars","runningtime","fixedtime","fixedtime_lapse","elapsed_time","last_update_time","starttime","catch_errors","interval","STATUS_RUNNING","onPlayEvent","sendEventToAllNodes","execution_timer_id","onFrame","onBeforeStep","runStep","onAfterStep","onStopEvent","doNotCatchError","limit","onExecuteStep","onAfterExecute","errors_in_execution","elapsed","execution_time","computeExecutionOrder","onlyOnExecute","setLevel","L","S","M","visitedLinks","remainingLinks","l2","_level","targetNode","A","B","Ap","priority","Bp","ancestors","pending","visited","current","columns","col","column","maxSize","eventname","skipComputeOrder","onAdded","updateExecutionOrder","onNodeAdded","ignore_remove","onNodeRemoved","classObject","_input_nodes","findNodesByClass","LiteGraph","GraphInput","onTrigger","onInputsOutputsChange","oldName","newName","onInputRenamed","onInputTypeChanged","onOutputRenamed","onOutputTypeChanged","findNodesByTitle","setTrigger","onConnectionChange","on_change","fg","bg","nodesInfo","link2","groupsInfo","version","keepOld","linkData","nInfo","dataGroup","File","Blob","req","XMLHttpRequest","open","send","response","onerror","CurveEditor","points","nearest","must_update","p","pn","localF","lineColor","inactive","localpos","maxDist","getCloserPoint","s","curvepos","_nearest","isEdgePoint","minDist","closest","vec2","Editor","containerId","miniwindow","addMiniWindow","max_zoom","miniwindow_graphcanvas","tl","br","right","closeBouton","setGraph","CanvasRenderingContext2D","radius","radiusLow","quadraticCurveTo","nodeType","description","paramType","returnType","names","classobj","apply","setOutputData"],"mappings":"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"}
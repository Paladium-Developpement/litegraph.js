{"version":3,"file":"litegraph.min.js","sources":["../src/utils/defaultConfig.js","../src/utils/time.js","../src/utils/object.js","../src/utils/registry.js","../src/utils/function.js","../src/LGraphNode.js","../src/LGraphGroup.js","../src/DragAndScale.js","../src/ContextMenu.js","../src/utils/math.js","../src/LGraphCanvas.js","../src/utils/file.js","../src/LGraph.js","../src/LLink.js","../src/CurveEditor.js","../src/litegraph-editor.js","../src/index.js"],"sourcesContent":["export default {\n    VERSION: 0.4,\n\n    CANVAS_GRID_SIZE: 10,\n\n    NODE_TITLE_HEIGHT: 30,\n    NODE_TITLE_TEXT_Y: 20,\n    NODE_SLOT_HEIGHT: 20,\n    NODE_WIDGET_HEIGHT: 20,\n    NODE_WIDTH: 140,\n    NODE_MIN_WIDTH: 50,\n    NODE_COLLAPSED_RADIUS: 10,\n    NODE_COLLAPSED_WIDTH: 80,\n    NODE_TITLE_COLOR: \"#999\",\n    NODE_SELECTED_TITLE_COLOR: \"#FFF\",\n    NODE_TEXT_SIZE: 14,\n    NODE_TEXT_COLOR: \"#AAA\",\n    NODE_SUBTEXT_SIZE: 12,\n    NODE_DEFAULT_COLOR: \"#333\",\n    NODE_DEFAULT_BGCOLOR: \"#353535\",\n    NODE_DEFAULT_BOXCOLOR: \"#666\",\n    NODE_DEFAULT_SHAPE: \"box\",\n    NODE_BOX_OUTLINE_COLOR: \"#FFF\",\n    DEFAULT_SHADOW_COLOR: \"rgba(0,0,0,0.5)\",\n    DEFAULT_GROUP_FONT: 24,\n\n    WIDGET_BGCOLOR: \"#222\",\n    WIDGET_OUTLINE_COLOR: \"#666\",\n    WIDGET_TEXT_COLOR: \"#DDD\",\n    WIDGET_SECONDARY_TEXT_COLOR: \"#999\",\n\n    LINK_COLOR: \"#9A9\",\n    EVENT_LINK_COLOR: \"#A86\",\n    CONNECTING_LINK_COLOR: \"#AFA\",\n\n    MAX_NUMBER_OF_NODES: 1000, // avoid infinite loops\n    DEFAULT_POSITION: [100, 100], // default node position\n    VALID_SHAPES: [\"default\", \"box\", \"round\", \"card\"], // ,\"circle\"\n\n    // shapes are used for nodes but also for slots\n    BOX_SHAPE: 1,\n    ROUND_SHAPE: 2,\n    CIRCLE_SHAPE: 3,\n    CARD_SHAPE: 4,\n    ARROW_SHAPE: 5,\n\n    // enums\n    INPUT: 1,\n    OUTPUT: 2,\n\n    EVENT: -1, // for outputs\n    ACTION: -1, // for inputs\n\n    ALWAYS: 0,\n    ON_EVENT: 1,\n    NEVER: 2,\n    ON_TRIGGER: 3,\n\n    UP: 1,\n    DOWN: 2,\n    LEFT: 3,\n    RIGHT: 4,\n    CENTER: 5,\n\n    STRAIGHT_LINK: 0,\n    LINEAR_LINK: 1,\n    SPLINE_LINK: 2,\n\n    NORMAL_TITLE: 0,\n    NO_TITLE: 1,\n    TRANSPARENT_TITLE: 2,\n    AUTOHIDE_TITLE: 3,\n\n    proxy: null, // used to redirect calls\n    node_images_path: \"\",\n\n    debug: false,\n    catch_exceptions: true,\n    throw_errors: true,\n    allow_scripts: false,\n    // if set to true some nodes like Formula would be allowed\n    // to evaluate code that comes from unsafe sources\n    // (like node configuration), which could lead to exploits\n    registered_node_types: {}, // nodetypes by string\n    node_types_by_file_extension: {}, // used for dropping files in the canvas\n    Nodes: {}, // node types by classname\n    Globals: {}, // used to store vars between graphs\n\n    searchbox_extras: {}, // used to add extra features to the search box\n    auto_sort_node_types: false,\n    // If set to true, will automatically sort node types / categories in the context menus\n}\n","export default function getTime() {\n    if (performance) return performance.now();\n    if (Date && Date.now) return Date.now\n    if (process) {\n        const t = process.hrtime();\n        return t[0] * 0.001 + t[1] * 1e-6;\n    }\n    return new Date().getTime();\n}\n","// separated just to improve if it doesn't work\nexport default function cloneObject(obj, target) {\n    if (obj == null) return null;\n    const r = JSON.parse(JSON.stringify(obj));\n    if (!target) return r;\n\n    // eslint-disable-next-line guard-for-in,no-restricted-syntax\n    for (const i in r) target[i] = r[i];\n    return target;\n}\n","/**\n * removes a node type from the system\n * @method unregisterNodeType\n * @param {String|Object} type name of the node or the node constructor itself\n */\nimport defaultConfig from \"./defaultConfig\";\n\nexport function unregisterNodeType(type) {\n    const baseClass = type.constructor === String ? this.registered_node_types[type] : type;\n    if (!baseClass) throw new Error(`node type not found: ${type}`);\n    delete defaultConfig.registered_node_types[baseClass.type];\n    if (baseClass.constructor.name) delete defaultConfig.Nodes[baseClass.constructor.name];\n}\n\n/**\n * Register a node class so it can be listed when the user wants to create a new one\n * @method registerNodeType\n * @param {LGraphNode} type name of the node and path\n * @param {Class} baseClass class containing the structure of a node\n */\nexport function registerNodeType(type, baseClass) {\n    if (!baseClass.prototype) {\n        throw new TypeError(\"Cannot register a simple object, it must be a class with a prototype\");\n    }\n    baseClass.type = type;\n\n    if (defaultConfig.debug) {\n        console.log(`Node registered: ${type}`);\n    }\n\n    const classname = baseClass.name;\n\n    const pos = type.lastIndexOf(\"/\");\n    baseClass.category = type.substr(0, pos);\n\n    if (!baseClass.title) {\n        baseClass.title = classname;\n    }\n    // info.name = name.substr(pos+1,name.length - pos);\n\n    const prev = defaultConfig.registered_node_types[type];\n    if (prev) {\n        console.log(`replacing node type: ${type}`);\n    } else {\n        if (!Object.hasOwnProperty.call(baseClass.prototype, \"shape\")) {\n            Object.defineProperty(baseClass.prototype, \"shape\", {\n                set(v) {\n                    switch (v) {\n                        case \"default\":\n                            delete this._shape;\n                            break;\n                        case \"box\":\n                            this._shape = defaultConfig.BOX_SHAPE;\n                            break;\n                        case \"round\":\n                            this._shape = defaultConfig.ROUND_SHAPE;\n                            break;\n                        case \"circle\":\n                            this._shape = defaultConfig.CIRCLE_SHAPE;\n                            break;\n                        case \"card\":\n                            this._shape = defaultConfig.CARD_SHAPE;\n                            break;\n                        default:\n                            this._shape = v;\n                    }\n                },\n                get() {\n                    return this._shape;\n                },\n                enumerable: true,\n                configurable: true,\n            });\n        }\n\n        // warnings\n        if (baseClass.prototype.onPropertyChange) {\n            console.warn(\n                `LiteGraph node class ${\n                    type\n                } has onPropertyChange method, it must be called onPropertyChanged with d at the end`,\n            );\n        }\n\n        // used to know which nodes create when dragging files to the canvas\n        if (baseClass.supported_extensions) {\n            for (const ext of baseClass.supported_extensions) {\n                if (ext && ext.constructor === String) {\n                    defaultConfig.node_types_by_file_extension[ext.toLowerCase()] = baseClass;\n                }\n            }\n        }\n    }\n\n    defaultConfig.registered_node_types[type] = baseClass;\n    if (baseClass.constructor.name) defaultConfig.Nodes[classname] = baseClass;\n\n    if (defaultConfig.onNodeTypeRegistered) defaultConfig.onNodeTypeRegistered(type, baseClass);\n    if (prev && defaultConfig.onNodeTypeReplaced) {\n        defaultConfig.onNodeTypeReplaced(type, baseClass, prev);\n    }\n\n    // warnings\n    if (baseClass.prototype.onPropertyChange) {\n        console.warn(\n            `LiteGraph node class ${\n                type\n            } has onPropertyChange method, it must be called onPropertyChanged with d at the end`,\n        );\n    }\n\n    // used to know which nodes create when dragging files to the canvas\n    if (baseClass.supported_extensions) {\n        for (const ext of baseClass.supported_extensions) {\n            if (ext && ext.constructor === String) {\n                defaultConfig.node_types_by_file_extension[ext.toLowerCase()] = baseClass;\n            }\n        }\n    }\n}\n\n/**\n * Removes all previously registered node's types\n */\nexport function clearRegisteredTypes() {\n    defaultConfig.registered_node_types = {};\n    defaultConfig.node_types_by_file_extension = {};\n    defaultConfig.Nodes = {};\n    defaultConfig.searchbox_extras = {};\n}\n\n/**\n * Returns a registered node type with a given name\n * @method getNodeType\n * @param {String} type full name of the node class. p.e. \"math/sin\"\n * @return {Class} the node class\n */\nexport function getNodeType(type) {\n    return this.registered_node_types[type];\n}\n\n/**\n * Returns a list of node types matching one category\n * @method getNodeType\n * @param {String} category category name\n * @return {Array} array with all the node classes\n */\nexport function getNodeTypesInCategory(category, filter) {\n    const r = [];\n    // eslint-disable-next-line\n    for (const i in this.registered_node_types) {\n        const type = this.registered_node_types[i];\n        if (type.filter !== filter) continue;\n\n        if (category === \"\") {\n            if (!type.category) r.push(type);\n        } else if (type.category === category) {\n            r.push(type);\n        }\n    }\n\n    return this.auto_sort_node_types ? r.sort() : r;\n}\n\n/**\n * Register a string in the search box so when the user types it it will recommend this node\n * @method registerSearchboxExtra\n * @param {String} nodeType the node recommended\n * @param {String} description text to show next to it\n * @param {Object} data it could contain info of how the node should be configured\n * @return {Boolean} true if they can be connected\n */\nexport function registerSearchboxExtra(nodeType, description, data) {\n    this.searchbox_extras[description.toLowerCase()] = {\n        type: nodeType,\n        desc: description,\n        data,\n    };\n}\n/**\n * Returns a list with all the node type categories\n * @method getNodeTypesCategories\n * @param {String} filter only nodes with ctor.filter equal can be shown\n * @return {Array} array with all the names of the categories\n */\nexport function getNodeTypesCategories(filter) {\n    const categories = { \"\": 1 };\n    for (const type of this.registered_node_types) {\n        if (type.category && !type.skip_list) {\n            if (type.filter !== filter) continue;\n            categories[type.category] = 1;\n        }\n    }\n    const result = [];\n    // eslint-disable-next-line\n    for (const i in categories) result.push(i);\n    return this.auto_sort_node_types ? result.sort() : result;\n}\n","// used to create nodes from wrapping functions\nimport defaultConfig from \"./defaultConfig\";\nimport { registerNodeType } from \"./registry\";\n\nexport function getParameterNames(func) {\n    return (`${func}`)\n        .replace(/[/][/].*$/gm, \"\") // strip single-line comments\n        .replace(/\\s+/g, \"\") // strip white space\n        .replace(/[/][*][^/*]*[*][/]/g, \"\") // strip multi-line comments  /**/\n        .split(\"){\", 1)[0]\n        .replace(/^[^(]*[(]/, \"\") // extract the parameters\n        .replace(/=[^,]+/g, \"\") // strip any ES6 defaults\n        .split(\",\")\n        .filter(Boolean); // split & filter [\"\"]\n}\n\n/**\n * Create a new nodetype by passing a function, it wraps it with a proper class and\n * generates inputs according to the parameters of the function. Useful to wrap simple\n * methods that do not require properties, and that only process some input to generate an\n * output.\n * @method wrapFunctionAsNode\n * @param {String} name node name with namespace (p.e.: 'math/sum')\n * @param {Function} func\n * @param {Array} paramType [optional] an array containing the type of every parameter,\n *     otherwise parameters will accept any type\n * @param {String} returnType [optional] string with the return type, otherwise it will be\n *     generic\n * @param {Object} properties [optional] properties to be configurable\n */\nexport function wrapFunctionAsNode(\n    name,\n    func,\n    paramType,\n    returnType,\n    properties,\n) {\n    const params = Array(func.length);\n    let code = \"\";\n    const names = getParameterNames(func);\n    for (let i = 0; i < names.length; ++i) {\n        code += `this.addInput('${names[i]}',${paramType && paramType[i] ? `'${paramType[i]}'` : \"0\"});\\n`;\n    }\n    code += `this.addOutput('out',${returnType ? `'${returnType}'` : 0});\\n`;\n    if (properties) code += `this.properties = ${JSON.stringify(properties)};\\n`;\n    const classobj = Function(code);\n    classobj.title = name.split(\"/\").pop();\n    classobj.desc = `Generated from ${func.name}`;\n    classobj.prototype.onExecute = function onExecute() {\n        for (let i = 0; i < params.length; ++i) {\n            params[i] = this.getInputData(i);\n        }\n        const r = func.apply(this, params);\n        this.setOutputData(0, r);\n    };\n    registerNodeType(name, classobj);\n}\n/**\n * Returns if the types of two slots are compatible (taking into account wildcards, etc)\n * @method isValidConnection\n * @param {String} typeA\n * @param {String} typeB\n * @return {Boolean} true if they can be connected\n */\nexport function isValidConnection(typeA, typeB) {\n    if (\n        !typeA\n        || !typeB\n        || typeA === typeB\n        || (typeA === defaultConfig.EVENT && typeB === defaultConfig.ACTION)\n    ) {\n        return true;\n    }\n\n    // Enforce string type to handle toLowerCase call (-1 number not ok)\n    typeA = String(typeA);\n    typeB = String(typeB);\n    typeA = typeA.toLowerCase();\n    typeB = typeB.toLowerCase();\n\n    // For nodes supporting multiple connection types\n    if (typeA.indexOf(\",\") === -1 && typeB.indexOf(\",\") === -1) return typeA === typeB;\n\n    // Check all permutations to see if one is valid\n    const supportedTypesA = typeA.split(\",\");\n    const supportedTypesB = typeB.split(\",\");\n    for (let i = 0; i < supportedTypesA.length; ++i) {\n        for (let j = 0; j < supportedTypesB.length; ++j) {\n            if (supportedTypesA[i] === supportedTypesB[j]) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n","import defaultConfig from \"./utils/defaultConfig\";\nimport cloneObject from \"./utils/object\";\nimport getTime from \"./utils/time\";\nimport { isValidConnection } from \"./utils/function\";\n\n/*\ntitle: string\npos: [x,y]\nsize: [x,y]\n\ninput|output: every connection\n+  { name:string, type:string, pos: [x,y]=Optional, direction: \"input\"|\"output\", links: Array });\n\ngeneral properties:\n+ clip_area: if you render outside the node, it will be clipped\n+ unsafe_execution: not allowed for safe execution\n+ skip_repeated_outputs: when adding new outputs, it wont show if there is one already connected\n+ resizable: if set to false it wont be resizable with the mouse\n+ horizontal: slots are distributed horizontally\n+ widgets_start_y: widgets start at y distance from the top of the node\n\nflags object:\n+ collapsed: if it is collapsed\n\nsupported callbacks:\n+ onAdded: when added to graph (warning: this is called BEFORE the node is configured when loading)\n+ onRemoved: when removed from graph\n+ onStart:\twhen the graph starts playing\n+ onStop:\twhen the graph stops playing\n+ onDrawForeground: render the inside widgets inside the node\n+ onDrawBackground: render the background area inside the node (only in edit mode)\n+ onMouseDown\n+ onMouseMove\n+ onMouseUp\n+ onMouseEnter\n+ onMouseLeave\n+ onExecute: execute the node\n+ onPropertyChanged: when a property is changed in the panel (return true to skip default behaviour)\n+ onGetInputs: returns an array of possible inputs\n+ onGetOutputs: returns an array of possible outputs\n+ onBounding: in case this node has a bigger bounding than the node itself (the callback receives the bounding as [x,y,w,h])\n+ onDblClick: double clicked in the node\n+ onInputDblClick: input slot double clicked (can be used to automatically create a node connected)\n+ onOutputDblClick: output slot double clicked (can be used to automatically create a node connected)\n+ onConfigure: called after the node has been configured\n+ onSerialize: to add extra info when serializing (the callback receives the object that should be filled with the data)\n+ onSelected\n+ onDeselected\n+ onDropItem : DOM item dropped over the node\n+ onDropFile : file dropped over the node\n+ onConnectInput : if returns false the incoming connection will be canceled\n+ onConnectionsChange : a connection changed (new one or removed) (LiteGraph.INPUT or LiteGraph.OUTPUT, slot, true if connected, link_info, input_info )\n+ onAction: action slot triggered\n+ getExtraMenuOptions: to add option to context menu\n*/\n\nexport default class LGraphNode {\n    /**\n     * Base Class for all the node type classes\n     * @class LGraphNode\n     * @param {String} title a name for the node\n     */\n    constructor(title) {\n        this._ctor(title);\n        this.title = title || \"Unnamed\";\n        this.size = [defaultConfig.NODE_WIDTH, 60];\n        this.graph = null;\n        this.id = -1; // not know till not added\n        this.type = null;\n        // inputs available: array of inputs\n        this.inputs = [];\n        this.outputs = [];\n        this.connections = [];\n\n        // local data\n        this.properties = {}; // for the values\n        this.properties_info = []; // for the info\n\n        this.flags = {};\n    }\n\n    /**\n     * Internal position array\n     * @internal\n     * @type {Float32Array}\n     * @private\n     */\n    _pos = new Float32Array(10, 10)\n\n    set pos(v) {\n        if (!v || v.length < 2) {\n            return;\n        }\n        this._pos[0] = v[0];\n        this._pos[1] = v[1];\n    }\n\n    get pos() {\n        return this._pos;\n    }\n\n    /**\n     * configure a node from an object containing the serialized info\n     * @method configure\n     */\n    configure(info) {\n        if (this.graph) {\n            this.graph._version++;\n        }\n        // eslint-disable-next-line guard-for-in,no-restricted-syntax\n        for (const j in info) {\n            if (j === \"properties\") {\n                // i don't want to clone properties, I want to reuse the old container\n                // eslint-disable-next-line guard-for-in,no-restricted-syntax\n                for (const k in info.properties) {\n                    this.properties[k] = info.properties[k];\n                    if (this.onPropertyChanged) {\n                        this.onPropertyChanged(k, info.properties[k]);\n                    }\n                }\n                continue;\n            }\n\n            if (info[j] == null) {\n                continue;\n            } else if (typeof info[j] === \"object\") {\n                // object\n                if (this[j] && this[j].configure) {\n                    this[j].configure(info[j]);\n                } else {\n                    this[j] = cloneObject(info[j], this[j]);\n                }\n            } else {\n                this[j] = info[j];\n            }\n        }\n\n        if (!info.title) {\n            this.title = this.constructor.title;\n        }\n\n        if (this.onConnectionsChange) {\n            if (this.inputs) {\n                for (let i = 0; i < this.inputs.length; ++i) {\n                    const input = this.inputs[i];\n                    const linkInfo = this.graph\n                        ? this.graph.links[input.link]\n                        : null;\n                    this.onConnectionsChange(\n                        defaultConfig.INPUT,\n                        i,\n                        true,\n                        linkInfo,\n                        input,\n                    ); // linkInfo has been created now, so its updated\n                }\n            }\n\n            if (this.outputs) {\n                for (let i = 0; i < this.outputs.length; ++i) {\n                    const output = this.outputs[i];\n                    if (!output.links) {\n                        continue;\n                    }\n                    for (let j = 0; j < output.links.length; ++j) {\n                        const linkInfo = this.graph\n                            ? this.graph.links[output.links[j]]\n                            : null;\n                        this.onConnectionsChange(\n                            defaultConfig.OUTPUT,\n                            i,\n                            true,\n                            linkInfo,\n                            output,\n                        ); // link_info has been created now, so its updated\n                    }\n                }\n            }\n        }\n\n        if (this.widgets) {\n            for (const widget of this.widgets) {\n                if (!widget) continue;\n                if (widget.options\n                    && widget.options.property\n                    // eslint-disable-next-line max-len\n                    && this.properties[widget.options.property]) widget.value = JSON.parse(JSON.stringify(this.properties[widget.options.property]));\n            }\n            if (info.widgets_values) {\n                for (let i = 0; i < info.widgets_values.length; ++i) {\n                    if (this.widgets[i]) {\n                        this.widgets[i].value = info.widgets_values[i];\n                    }\n                }\n            }\n        }\n\n        if (this.onConfigure) {\n            this.onConfigure(info);\n        }\n    }\n\n    /**\n     * serialize the content\n     * @method serialize\n     */\n\n    serialize() {\n        // create serialization object\n        const o = {\n            id: this.id,\n            type: this.type,\n            pos: this.pos,\n            size: this.size,\n            flags: cloneObject(this.flags),\n            order: this.order,\n            mode: this.mode,\n        };\n\n        // special case for when there were errors\n        if (this.constructor === LGraphNode && this.last_serialization) {\n            return this.last_serialization;\n        }\n\n        if (this.inputs) {\n            o.inputs = this.inputs;\n        }\n\n        if (this.outputs) {\n            // clear outputs last data (because data in connections is never serialized but stored\n            // inside the outputs info)\n            for (let i = 0; i < this.outputs.length; i++) {\n                delete this.outputs[i]._data;\n            }\n            o.outputs = this.outputs;\n        }\n\n        if (this.title && this.title != this.constructor.title) {\n            o.title = this.title;\n        }\n\n        if (this.properties) {\n            o.properties = cloneObject(this.properties);\n        }\n\n        if (this.widgets && this.serialize_widgets) {\n            o.widgets_values = [];\n            for (let i = 0; i < this.widgets.length; ++i) {\n                if (this.widgets[i]) {\n                    o.widgets_values[i] = this.widgets[i].value;\n                } else {\n                    o.widgets_values[i] = null;\n                }\n            }\n        }\n\n        if (!o.type) o.type = this.constructor.type;\n\n        if (this.color) o.color = this.color;\n        if (this.bgcolor) o.bgcolor = this.bgcolor;\n        if (this.boxcolor) o.boxcolor = this.boxcolor;\n        if (this.shape) o.shape = this.shape;\n\n        if (this.onSerialize) {\n            if (this.onSerialize(o)) {\n                console.warn(\n                    \"node onSerialize shouldnt return anything, data should be stored in the object pass in the first parameter\",\n                );\n            }\n        }\n\n        return o;\n    }\n\n    /* Creates a clone of this node */\n    clone() {\n        const node = LGraphNode.createNode(this.type);\n        if (!node) {\n            return null;\n        }\n\n        // we clone it because serialize returns shared containers\n        const data = LGraphNode.cloneObject(this.serialize());\n\n        // remove links\n        if (data.inputs) {\n            for (let i = 0; i < data.inputs.length; ++i) {\n                data.inputs[i].link = null;\n            }\n        }\n\n        if (data.outputs) {\n            for (let i = 0; i < data.outputs.length; ++i) {\n                if (data.outputs[i].links) {\n                    data.outputs[i].links.length = 0;\n                }\n            }\n        }\n\n        delete data.id;\n        // remove links\n        node.configure(data);\n\n        return node;\n    }\n\n    /**\n     * serialize and stringify\n     * @method toString\n     */\n\n    toString() {\n        return JSON.stringify(this.serialize());\n    }\n\n    // deserialize = function(info) {} //this cannot be done from within, must\n    // be done in LiteGraph\n\n    /**\n     * get the title string\n     * @method getTitle\n     */\n\n    getTitle() {\n        return this.title || this.constructor.title;\n    }\n\n    /**\n     * sets the value of a property\n     * @method setProperty\n     * @param {String} name\n     * @param {*} value\n     */\n    setProperty(name, value) {\n        if (!this.properties) {\n            this.properties = {};\n        }\n        if (value === this.properties[name]) return;\n        const prevValue = this.properties[name];\n        this.properties[name] = value;\n        if (this.onPropertyChanged) {\n            if (this.onPropertyChanged(name, value, prevValue) === false) {\n                this.properties[name] = prevValue;\n            }\n        }\n        if (this.widgets) {\n            for (let i = 0; i < this.widgets.length; ++i) {\n                const w = this.widgets[i];\n                if (!w) continue;\n                if (w.options.property == name) {\n                    w.value = value;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Execution *************************\n    /**\n     * sets the output data\n     * @method setOutputData\n     * @param {number} slot\n     * @param {*} data\n     */\n    setOutputData(slot, data) {\n        if (!this.outputs) {\n            return;\n        }\n\n        // this maybe slow and a niche case\n        // if(slot && slot.constructor === String)\n        //\tslot = this.findOutputSlot(slot);\n\n        if (slot == -1 || slot >= this.outputs.length) {\n            return;\n        }\n\n        const output_info = this.outputs[slot];\n        if (!output_info) {\n            return;\n        }\n\n        // store data in the output itself in case we want to debug\n        output_info._data = data;\n\n        // if there are connections, pass the data to the connections\n        if (this.outputs[slot].links) {\n            for (let i = 0; i < this.outputs[slot].links.length; i++) {\n                const link_id = this.outputs[slot].links[i];\n                const link = this.graph.links[link_id];\n                if (link) link.data = data;\n            }\n        }\n    }\n\n    /**\n     * sets the output data type, useful when you want to be able to overwrite the data type\n     * @method setOutputDataType\n     * @param {number} slot\n     * @param {String} datatype\n     */\n    setOutputDataType(slot, type) {\n        if (!this.outputs) {\n            return;\n        }\n        if (slot == -1 || slot >= this.outputs.length) {\n            return;\n        }\n        const output_info = this.outputs[slot];\n        if (!output_info) {\n            return;\n        }\n        // store data in the output itself in case we want to debug\n        output_info.type = type;\n\n        // if there are connections, pass the data to the connections\n        if (this.outputs[slot].links) {\n            for (let i = 0; i < this.outputs[slot].links.length; i++) {\n                const link_id = this.outputs[slot].links[i];\n                this.graph.links[link_id].type = type;\n            }\n        }\n    }\n\n    /**\n     * Retrieves the input data (data traveling through the connection) from one slot\n     * @method getInputData\n     * @param {number} slot\n     * @param {boolean} force_update if set to true it will force the connected node of this slot\n     *     to output data into this link\n     * @return {*} data or if it is not connected returns undefined\n     */\n    getInputData(slot, force_update) {\n        if (!this.inputs) {\n            return;\n        } // undefined;\n\n        if (slot >= this.inputs.length || this.inputs[slot].link == null) {\n            return;\n        }\n\n        const link_id = this.inputs[slot].link;\n        const link = this.graph.links[link_id];\n        if (!link) {\n            // bug: weird case but it happens sometimes\n            return null;\n        }\n\n        if (!force_update) {\n            return link.data;\n        }\n\n        // special case: used to extract data from the incoming connection before the graph has\n        // been executed\n        const node = this.graph.getNodeById(link.origin_id);\n        if (!node) {\n            return link.data;\n        }\n\n        if (node.updateOutputData) {\n            node.updateOutputData(link.origin_slot);\n        } else if (node.onExecute) {\n            node.onExecute();\n        }\n\n        return link.data;\n    }\n\n    /**\n     * Retrieves the input data type (in case this supports multiple input types)\n     * @method getInputDataType\n     * @param {number} slot\n     * @return {String} datatype in string format\n     */\n    getInputDataType(slot) {\n        if (!this.inputs) {\n            return null;\n        } // undefined;\n\n        if (slot >= this.inputs.length || this.inputs[slot].link == null) {\n            return null;\n        }\n        const link_id = this.inputs[slot].link;\n        const link = this.graph.links[link_id];\n        if (!link) {\n            // bug: weird case but it happens sometimes\n            return null;\n        }\n        const node = this.graph.getNodeById(link.origin_id);\n        if (!node) {\n            return link.type;\n        }\n        const output_info = node.outputs[link.origin_slot];\n        if (output_info) {\n            return output_info.type;\n        }\n        return null;\n    }\n\n    /**\n     * Retrieves the input data from one slot using its name instead of slot number\n     * @method getInputDataByName\n     * @param {String} slot_name\n     * @param {boolean} force_update if set to true it will force the connected node of this slot\n     *     to output data into this link\n     * @return {*} data or if it is not connected returns null\n     */\n    getInputDataByName(\n        slot_name,\n        force_update,\n    ) {\n        const slot = this.findInputSlot(slot_name);\n        if (slot == -1) {\n            return null;\n        }\n        return this.getInputData(slot, force_update);\n    }\n\n    /**\n     * tells you if there is a connection in one input slot\n     * @method isInputConnected\n     * @param {number} slot\n     * @return {boolean}\n     */\n    isInputConnected(slot) {\n        if (!this.inputs) {\n            return false;\n        }\n        return slot < this.inputs.length && this.inputs[slot].link != null;\n    }\n\n    /**\n     * tells you info about an input connection (which node, type, etc)\n     * @method getInputInfo\n     * @param {number} slot\n     * @return {Object} object or null { link: id, name: string, type: string or 0 }\n     */\n    getInputInfo(slot) {\n        if (!this.inputs) {\n            return null;\n        }\n        if (slot < this.inputs.length) {\n            return this.inputs[slot];\n        }\n        return null;\n    }\n\n    /**\n     * Returns the link info in the connection of an input slot\n     * @method getInputLink\n     * @param {number} slot\n     * @return {LLink} object or null\n     */\n    getInputLink(slot) {\n        if (!this.inputs) {\n            return null;\n        }\n        if (slot < this.inputs.length) {\n            const slot_info = this.inputs[slot];\n            return this.graph.links[slot_info.link];\n        }\n        return null;\n    }\n\n    /**\n     * returns the node connected in the input slot\n     * @method getInputNode\n     * @param {number} slot\n     * @return {LGraphNode} node or null\n     */\n    getInputNode(slot) {\n        if (!this.inputs) {\n            return null;\n        }\n        if (slot >= this.inputs.length) {\n            return null;\n        }\n        const input = this.inputs[slot];\n        if (!input || input.link === null) {\n            return null;\n        }\n        const link_info = this.graph.links[input.link];\n        if (!link_info) {\n            return null;\n        }\n        return this.graph.getNodeById(link_info.origin_id);\n    }\n\n    /**\n     * returns the value of an input with this name, otherwise checks if there is a property with\n     * that name\n     * @method getInputOrProperty\n     * @param {string} name\n     * @return {*} value\n     */\n    getInputOrProperty(name) {\n        if (!this.inputs || !this.inputs.length) {\n            return this.properties ? this.properties[name] : null;\n        }\n\n        for (let i = 0, l = this.inputs.length; i < l; ++i) {\n            const input_info = this.inputs[i];\n            if (name == input_info.name && input_info.link != null) {\n                const link = this.graph.links[input_info.link];\n                if (link) {\n                    return link.data;\n                }\n            }\n        }\n        return this.properties[name];\n    }\n\n    /**\n     * tells you the last output data that went in that slot\n     * @method getOutputData\n     * @param {number} slot\n     * @return {Object}  object or null\n     */\n    getOutputData(slot) {\n        if (!this.outputs) {\n            return null;\n        }\n        if (slot >= this.outputs.length) {\n            return null;\n        }\n\n        const info = this.outputs[slot];\n        return info._data;\n    }\n\n    /**\n     * tells you info about an output connection (which node, type, etc)\n     * @method getOutputInfo\n     * @param {number} slot\n     * @return {Object}  object or null { name: string, type: string, links: [ ids of links in\n     *     number ] }\n     */\n    getOutputInfo(slot) {\n        if (!this.outputs) {\n            return null;\n        }\n        if (slot < this.outputs.length) {\n            return this.outputs[slot];\n        }\n        return null;\n    }\n\n    /**\n     * tells you if there is a connection in one output slot\n     * @method isOutputConnected\n     * @param {number} slot\n     * @return {boolean}\n     */\n    isOutputConnected(slot) {\n        if (!this.outputs) {\n            return false;\n        }\n        return (\n            slot < this.outputs.length\n            && this.outputs[slot].links\n            && this.outputs[slot].links.length\n        );\n    }\n\n    /**\n     * tells you if there is any connection in the output slots\n     * @method isAnyOutputConnected\n     * @return {boolean}\n     */\n    isAnyOutputConnected() {\n        if (!this.outputs) {\n            return false;\n        }\n        for (let i = 0; i < this.outputs.length; ++i) {\n            if (this.outputs[i].links && this.outputs[i].links.length) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * retrieves all the nodes connected to this output slot\n     * @method getOutputNodes\n     * @param {number} slot\n     * @return {array}\n     */\n    getOutputNodes(slot) {\n        if (!this.outputs || this.outputs.length == 0) {\n            return null;\n        }\n\n        if (slot >= this.outputs.length) {\n            return null;\n        }\n\n        const output = this.outputs[slot];\n        if (!output.links || output.links.length == 0) {\n            return null;\n        }\n\n        const r = [];\n        for (let i = 0; i < output.links.length; i++) {\n            const link_id = output.links[i];\n            const link = this.graph.links[link_id];\n            if (link) {\n                const target_node = this.graph.getNodeById(link.target_id);\n                if (target_node) {\n                    r.push(target_node);\n                }\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Triggers an event in this node, this will trigger any output with the same name\n     * @method trigger\n     * @param {String} event name ( \"on_play\", ... ) if action is equivalent to false then the\n     *     event is send to all\n     * @param {*} param\n     */\n    trigger(action, param) {\n        if (!this.outputs || !this.outputs.length) {\n            return;\n        }\n\n        if (this.graph) this.graph._last_trigger_time = getTime();\n\n        for (let i = 0; i < this.outputs.length; ++i) {\n            const output = this.outputs[i];\n            if (!output || output.type !== defaultConfig.EVENT || (action && output.name != action)) continue;\n            this.triggerSlot(i, param);\n        }\n    }\n\n    /**\n     * Triggers an slot event in this node\n     * @method triggerSlot\n     * @param {Number} slot the index of the output slot\n     * @param {*} param\n     * @param {Number} link_id [optional] in case you want to trigger and specific output link in a\n     *     slot\n     */\n    triggerSlot(slot, param, link_id) {\n        if (!this.outputs) {\n            return;\n        }\n\n        const output = this.outputs[slot];\n        if (!output) {\n            return;\n        }\n\n        const { links } = output;\n        if (!links || !links.length) {\n            return;\n        }\n\n        if (this.graph) {\n            this.graph._last_trigger_time = getTime();\n        }\n\n        // for every link attached here\n        for (let k = 0; k < links.length; ++k) {\n            const id = links[k];\n            if (link_id != null && link_id != id) {\n                // to skip links\n                continue;\n            }\n            const link_info = this.graph.links[links[k]];\n            if (!link_info) {\n                // not connected\n                continue;\n            }\n            link_info._last_time = getTime();\n            const node = this.graph.getNodeById(link_info.target_id);\n            if (!node) {\n                // node not found?\n                continue;\n            }\n\n            // used to mark events in graph\n            const target_connection = node.inputs[link_info.target_slot];\n\n            if (node.mode === defaultConfig.ON_TRIGGER) {\n                if (node.onExecute) {\n                    node.onExecute(param);\n                }\n            } else if (node.onAction) {\n                node.onAction(target_connection.name, param);\n            }\n        }\n    }\n\n    /**\n     * clears the trigger slot animation\n     * @method clearTriggeredSlot\n     * @param {Number} slot the index of the output slot\n     * @param {Number} link_id [optional] in case you want to trigger and specific output link in a\n     *     slot\n     */\n    clearTriggeredSlot(slot, link_id) {\n        if (!this.outputs) {\n            return;\n        }\n\n        const output = this.outputs[slot];\n        if (!output) {\n            return;\n        }\n\n        const { links } = output;\n        if (!links || !links.length) {\n            return;\n        }\n\n        // for every link attached here\n        for (let k = 0; k < links.length; ++k) {\n            const id = links[k];\n            if (link_id != null && link_id != id) {\n                // to skip links\n                continue;\n            }\n            const link_info = this.graph.links[links[k]];\n            if (!link_info) {\n                // not connected\n                continue;\n            }\n            link_info._last_time = 0;\n        }\n    }\n\n    /**\n     * changes node size and triggers callback\n     * @method setSize\n     * @param {vec2} size\n     */\n    setSize(size) {\n        this.size = size;\n        if (this.onResize) this.onResize(this.size);\n    }\n\n    /**\n     * add a new property to this node\n     * @method addProperty\n     * @param {string} name\n     * @param {*} default_value\n     * @param {string} type string defining the output type (\"vec3\",\"number\",...)\n     * @param {Object} extra_info this can be used to have special properties of the property (like\n     *     values, etc)\n     */\n    addProperty(\n        name,\n        default_value,\n        type,\n        extra_info,\n    ) {\n        const o = {\n            name,\n            type,\n            default_value,\n        };\n        if (extra_info) {\n            for (const i in extra_info) {\n                o[i] = extra_info[i];\n            }\n        }\n        if (!this.properties_info) {\n            this.properties_info = [];\n        }\n        this.properties_info.push(o);\n        if (!this.properties) {\n            this.properties = {};\n        }\n        this.properties[name] = default_value;\n        return o;\n    }\n\n    // connections\n\n    /**\n     * add a new output slot to use in this node\n     * @method addOutput\n     * @param {string} name\n     * @param {string} type string defining the output type (\"vec3\",\"number\",...)\n     * @param {Object} extra_info this can be used to have special properties of an output (label,\n     *     special color, position, etc)\n     */\n    addOutput(name, type, extra_info) {\n        const o = {\n            name,\n            type,\n            links: null,\n        };\n        if (extra_info) {\n            for (const i in extra_info) {\n                o[i] = extra_info[i];\n            }\n        }\n\n        if (!this.outputs) {\n            this.outputs = [];\n        }\n        this.outputs.push(o);\n        if (this.onOutputAdded) {\n            this.onOutputAdded(o);\n        }\n        this.setSize(this.computeSize());\n        this.setDirtyCanvas(true, true);\n        return o;\n    }\n\n    /**\n     * add a new output slot to use in this node\n     * @method addOutputs\n     * @param {Array} array of triplets like [[name,type,extra_info],[...]]\n     */\n    addOutputs(array) {\n        for (let i = 0; i < array.length; ++i) {\n            const info = array[i];\n            const o = {\n                name: info[0],\n                type: info[1],\n                link: null,\n            };\n            if (array[2]) {\n                for (const j in info[2]) {\n                    o[j] = info[2][j];\n                }\n            }\n\n            if (!this.outputs) {\n                this.outputs = [];\n            }\n            this.outputs.push(o);\n            if (this.onOutputAdded) {\n                this.onOutputAdded(o);\n            }\n        }\n\n        this.setSize(this.computeSize());\n        this.setDirtyCanvas(true, true);\n    }\n\n    /**\n     * remove an existing output slot\n     * @method removeOutput\n     * @param {number} slot\n     */\n    removeOutput(slot) {\n        this.disconnectOutput(slot);\n        this.outputs.splice(slot, 1);\n        for (let i = slot; i < this.outputs.length; ++i) {\n            if (!this.outputs[i] || !this.outputs[i].links) {\n                continue;\n            }\n            const { links } = this.outputs[i];\n            for (let j = 0; j < links.length; ++j) {\n                const link = this.graph.links[links[j]];\n                if (!link) {\n                    continue;\n                }\n                link.origin_slot -= 1;\n            }\n        }\n\n        this.setSize(this.computeSize());\n        if (this.onOutputRemoved) {\n            this.onOutputRemoved(slot);\n        }\n        this.setDirtyCanvas(true, true);\n    }\n\n    /**\n     * add a new input slot to use in this node\n     * @method addInput\n     * @param {string} name\n     * @param {string} type string defining the input type (\"vec3\",\"number\",...), it its a generic\n     *     one use 0\n     * @param {Object} extra_info this can be used to have special properties of an input (label,\n     *     color, position, etc)\n     */\n    addInput(name, type, extra_info) {\n        type = type || 0;\n        const o = {\n            name,\n            type,\n            link: null,\n        };\n        if (extra_info) {\n            for (const i in extra_info) {\n                o[i] = extra_info[i];\n            }\n        }\n\n        if (!this.inputs) {\n            this.inputs = [];\n        }\n\n        this.inputs.push(o);\n        this.setSize(this.computeSize());\n\n        if (this.onInputAdded) {\n            this.onInputAdded(o);\n        }\n\n        this.setDirtyCanvas(true, true);\n        return o;\n    }\n\n    /**\n     * add several new input slots in this node\n     * @method addInputs\n     * @param {Array} array of triplets like [[name,type,extra_info],[...]]\n     */\n    addInputs(array) {\n        for (let i = 0; i < array.length; ++i) {\n            const info = array[i];\n            const o = {\n                name: info[0],\n                type: info[1],\n                link: null,\n            };\n            if (array[2]) {\n                for (const j in info[2]) {\n                    o[j] = info[2][j];\n                }\n            }\n\n            if (!this.inputs) {\n                this.inputs = [];\n            }\n            this.inputs.push(o);\n            if (this.onInputAdded) {\n                this.onInputAdded(o);\n            }\n        }\n\n        this.setSize(this.computeSize());\n        this.setDirtyCanvas(true, true);\n    }\n\n    /**\n     * remove an existing input slot\n     * @method removeInput\n     * @param {number} slot\n     */\n    removeInput(slot) {\n        this.disconnectInput(slot);\n        const slot_info = this.inputs.splice(slot, 1);\n        for (let i = slot; i < this.inputs.length; ++i) {\n            if (!this.inputs[i]) {\n                continue;\n            }\n            const link = this.graph.links[this.inputs[i].link];\n            if (!link) {\n                continue;\n            }\n            link.target_slot -= 1;\n        }\n        this.setSize(this.computeSize());\n        if (this.onInputRemoved) {\n            this.onInputRemoved(slot, slot_info[0]);\n        }\n        this.setDirtyCanvas(true, true);\n    }\n\n    /**\n     * add an special connection to this node (used for special kinds of graphs)\n     * @method addConnection\n     * @param {string} name\n     * @param {string} type string defining the input type (\"vec3\",\"number\",...)\n     * @param {[x,y]} pos position of the connection inside the node\n     * @param {string} direction if is input or output\n     */\n    addConnection(name, type, pos, direction) {\n        const o = {\n            name,\n            type,\n            pos,\n            direction,\n            links: null,\n        };\n        this.connections.push(o);\n        return o;\n    }\n\n    /**\n     * computes the minimum size of a node according to its inputs and output slots\n     * @method computeSize\n     * @param {number} minHeight\n     * @return {number} the total size\n     */\n    computeSize(out) {\n        if (this.constructor.size) {\n            return this.constructor.size.concat();\n        }\n\n        let rows = Math.max(\n            this.inputs ? this.inputs.length : 1,\n            this.outputs ? this.outputs.length : 1,\n        );\n        const size = out || new Float32Array([0, 0]);\n        rows = Math.max(rows, 1);\n        var font_size = defaultConfig.NODE_TEXT_SIZE; // although it should be\n        // graphcanvas.inner_text_font size\n\n        var font_size = font_size;\n        const title_width = compute_text_size(this.title);\n        let input_width = 0;\n        let output_width = 0;\n\n        if (this.inputs) {\n            for (var i = 0, l = this.inputs.length; i < l; ++i) {\n                const input = this.inputs[i];\n                var text = input.label || input.name || \"\";\n                var text_width = compute_text_size(text);\n                if (input_width < text_width) {\n                    input_width = text_width;\n                }\n            }\n        }\n\n        if (this.outputs) {\n            for (var i = 0, l = this.outputs.length; i < l; ++i) {\n                const output = this.outputs[i];\n                var text = output.label || output.name || \"\";\n                var text_width = compute_text_size(text);\n                if (output_width < text_width) {\n                    output_width = text_width;\n                }\n            }\n        }\n\n        size[0] = Math.max(input_width + output_width + 10, title_width);\n        size[0] = Math.max(size[0], defaultConfig.NODE_WIDTH);\n        if (this.widgets && this.widgets.length) {\n            size[0] = Math.max(size[0], defaultConfig.NODE_WIDTH * 1.5);\n        }\n\n        size[1] = (this.constructor.slot_start_y || 0) + rows * defaultConfig.NODE_SLOT_HEIGHT;\n\n        let widgets_height = 0;\n        if (this.widgets && this.widgets.length) {\n            for (var i = 0, l = this.widgets.length; i < l; ++i) {\n                if (this.widgets[i].computeSize) {\n                    widgets_height += this.widgets[i].computeSize(size[0])[1] + 4;\n                } else {\n                    widgets_height += defaultConfig.NODE_WIDGET_HEIGHT + 4;\n                }\n            }\n            widgets_height += 8;\n        }\n\n        // compute height using widgets height\n        if (this.widgets_up) {\n            size[1] = Math.max(size[1], widgets_height);\n        } else if (this.widgets_start_y != null) {\n            size[1] = Math.max(size[1], widgets_height + this.widgets_start_y);\n        } else {\n            size[1] += widgets_height;\n        }\n\n        function compute_text_size(text) {\n            if (!text) {\n                return 0;\n            }\n            return font_size * text.length * 0.6;\n        }\n\n        if (\n            this.constructor.min_height\n            && size[1] < this.constructor.min_height\n        ) {\n            size[1] = this.constructor.min_height;\n        }\n\n        size[1] += 6; // margin\n\n        return size;\n    }\n\n    /**\n     * returns all the info available about a property of this node.\n     *\n     * @method getPropertyInfo\n     * @param {String} property name of the property\n     * @return {Object} the object with all the available info\n     */\n    getPropertyInfo(property) {\n        let info = null;\n\n        // there are several ways to define info about a property\n        // legacy mode\n        if (this.properties_info) {\n            for (let i = 0; i < this.properties_info.length; ++i) {\n                if (this.properties_info[i].name == property) {\n                    info = this.properties_info[i];\n                    break;\n                }\n            }\n        }\n        // litescene mode using the constructor\n        if (this.constructor[`@${property}`]) info = this.constructor[`@${property}`];\n\n        if (this.constructor.widgets_info && this.constructor.widgets_info[property]) info = this.constructor.widgets_info[property];\n\n        // litescene mode using the constructor\n        if (!info && this.onGetPropertyInfo) {\n            info = this.onGetPropertyInfo(property);\n        }\n\n        if (!info) info = {};\n        if (!info.type) info.type = typeof this.properties[property];\n        if (info.widget == \"combo\") info.type = \"enum\";\n\n        return info;\n    }\n\n    /**\n     * Defines a widget inside the node, it will be rendered on top of the node, you can control\n     * lots of properties\n     *\n     * @method addWidget\n     * @param {String} type the widget type (could be \"number\",\"string\",\"combo\"\n     * @param {String} name the text to show on the widget\n     * @param {String} value the default value\n     * @param {Function|String} callback function to call when it changes (optionally, it can be\n     *     the name of the property to modify)\n     * @param {Object} options the object that contains special properties of this widget\n     * @return {Object} the created widget object\n     */\n    addWidget(type, name, value, callback, options) {\n        if (!this.widgets) {\n            this.widgets = [];\n        }\n\n        if (!options && callback && callback.constructor === Object) {\n            options = callback;\n            callback = null;\n        }\n\n        if (options && options.constructor === String) // options can be the property name\n        {\n            options = { property: options };\n        }\n\n        if (callback && callback.constructor === String) // callback can be the property name\n        {\n            if (!options) options = {};\n            options.property = callback;\n            callback = null;\n        }\n\n        if (callback && callback.constructor !== Function) {\n            console.warn(\"addWidget: callback must be a function\");\n            callback = null;\n        }\n\n        const w = {\n            type: type.toLowerCase(),\n            name,\n            value,\n            callback,\n            options: options || {},\n        };\n\n        if (w.options.y !== undefined) {\n            w.y = w.options.y;\n        }\n\n        if (!callback && !w.options.callback && !w.options.property) {\n            console.warn(\"LiteGraph addWidget(...) without a callback or property assigned\");\n        }\n        if (type == \"combo\" && !w.options.values) {\n            throw \"LiteGraph addWidget('combo',...) requires to pass values in options: { values:['red','blue'] }\";\n        }\n        this.widgets.push(w);\n        this.setSize(this.computeSize());\n        return w;\n    }\n\n    addCustomWidget(custom_widget) {\n        if (!this.widgets) {\n            this.widgets = [];\n        }\n        this.widgets.push(custom_widget);\n        return custom_widget;\n    }\n\n    /**\n     * returns the bounding of the object, used for rendering purposes\n     * bounding is: [topleft_cornerx, topleft_cornery, width, height]\n     * @method getBounding\n     * @return {Float32Array[4]} the total size\n     */\n    getBounding(out) {\n        out = out || new Float32Array(4);\n        out[0] = this.pos[0] - 4;\n        out[1] = this.pos[1] - defaultConfig.NODE_TITLE_HEIGHT;\n        out[2] = this.size[0] + 4;\n        out[3] = this.size[1] + defaultConfig.NODE_TITLE_HEIGHT;\n\n        if (this.onBounding) {\n            this.onBounding(out);\n        }\n        return out;\n    }\n\n    /**\n     * checks if a point is inside the shape of a node\n     * @method isPointInside\n     * @param {number} x\n     * @param {number} y\n     * @return {boolean}\n     */\n    isPointInside(x, y, margin, skip_title) {\n        margin = margin || 0;\n\n        let margin_top = this.graph && this.graph.isLive() ? 0 : defaultConfig.NODE_TITLE_HEIGHT;\n        if (skip_title) {\n            margin_top = 0;\n        }\n        if (this.flags && this.flags.collapsed) {\n            // if ( distance([x,y], [this.pos[0] + this.size[0]*0.5, this.pos[1] +\n            // this.size[1]*0.5]) < LiteGraph.NODE_COLLAPSED_RADIUS)\n            if (\n                isInsideRectangle(\n                    x,\n                    y,\n                    this.pos[0] - margin,\n                    this.pos[1] - defaultConfig.NODE_TITLE_HEIGHT - margin,\n                    (this._collapsed_width || defaultConfig.NODE_COLLAPSED_WIDTH)\n                    + 2 * margin,\n                    defaultConfig.NODE_TITLE_HEIGHT + 2 * margin,\n                )\n            ) {\n                return true;\n            }\n        } else if (\n            this.pos[0] - 4 - margin < x\n            && this.pos[0] + this.size[0] + 4 + margin > x\n            && this.pos[1] - margin_top - margin < y\n            && this.pos[1] + this.size[1] + margin > y\n        ) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * checks if a point is inside a node slot, and returns info about which slot\n     * @method getSlotInPosition\n     * @param {number} x\n     * @param {number} y\n     * @return {Object} if found the object contains { input|output: slot object, slot: number,\n     *     link_pos: [x,y] }\n     */\n    getSlotInPosition(x, y) {\n        // search for inputs\n        const link_pos = new Float32Array(2);\n        if (this.inputs) {\n            for (var i = 0, l = this.inputs.length; i < l; ++i) {\n                const input = this.inputs[i];\n                this.getConnectionPos(true, i, link_pos);\n                if (\n                    isInsideRectangle(\n                        x,\n                        y,\n                        link_pos[0] - 10,\n                        link_pos[1] - 5,\n                        20,\n                        10,\n                    )\n                ) {\n                    return {\n                        input,\n                        slot: i,\n                        link_pos,\n                    };\n                }\n            }\n        }\n\n        if (this.outputs) {\n            for (var i = 0, l = this.outputs.length; i < l; ++i) {\n                const output = this.outputs[i];\n                this.getConnectionPos(false, i, link_pos);\n                if (\n                    isInsideRectangle(\n                        x,\n                        y,\n                        link_pos[0] - 10,\n                        link_pos[1] - 5,\n                        20,\n                        10,\n                    )\n                ) {\n                    return {\n                        output,\n                        slot: i,\n                        link_pos,\n                    };\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * returns the input slot with a given name (used for dynamic slots), -1 if not found\n     * @method findInputSlot\n     * @param {string} name the name of the slot\n     * @return {number} the slot (-1 if not found)\n     */\n    findInputSlot(name) {\n        if (!this.inputs) {\n            return -1;\n        }\n        for (let i = 0, l = this.inputs.length; i < l; ++i) {\n            if (name == this.inputs[i].name) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * returns the output slot with a given name (used for dynamic slots), -1 if not found\n     * @method findOutputSlot\n     * @param {string} name the name of the slot\n     * @return {number} the slot (-1 if not found)\n     */\n    findOutputSlot(name) {\n        if (!this.outputs) {\n            return -1;\n        }\n        for (let i = 0, l = this.outputs.length; i < l; ++i) {\n            if (name == this.outputs[i].name) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * connect this node output to the input of another node\n     * @method connect\n     * @param {number_or_string} slot (could be the number of the slot or the string with the name\n     *     of the slot)\n     * @param {LGraphNode} node the target node\n     * @param {number_or_string} target_slot the input slot of the target node (could be the number\n     *     of the slot or the string with the name of the slot, or -1 to connect a trigger)\n     * @return {Object} the link_info is created, otherwise null\n     */\n    connect(slot, target_node, target_slot) {\n        target_slot = target_slot || 0;\n\n        if (!this.graph) {\n            // could be connected before adding it to a graph\n            console.log(\n                \"Connect: Error, node doesn't belong to any graph. Nodes must be added first to a graph before connecting them.\",\n            ); // due to link ids being associated with graphs\n            return null;\n        }\n\n        // seek for the output slot\n        if (slot.constructor === String) {\n            slot = this.findOutputSlot(slot);\n            if (slot == -1) {\n                if (defaultConfig.debug) {\n                    console.log(`Connect: Error, no slot of name ${slot}`);\n                }\n                return null;\n            }\n        } else if (!this.outputs || slot >= this.outputs.length) {\n            if (defaultConfig.debug) {\n                console.log(\"Connect: Error, slot number not found\");\n            }\n            return null;\n        }\n\n        if (target_node && target_node.constructor === Number) {\n            target_node = this.graph.getNodeById(target_node);\n        }\n        if (!target_node) {\n            throw \"target node is null\";\n        }\n\n        // avoid loopback\n        if (target_node == this) {\n            return null;\n        }\n\n        // you can specify the slot by name\n        if (target_slot.constructor === String) {\n            target_slot = target_node.findInputSlot(target_slot);\n            if (target_slot == -1) {\n                if (defaultConfig.debug) {\n                    console.log(\n                        `Connect: Error, no slot of name ${target_slot}`,\n                    );\n                }\n                return null;\n            }\n        } else if (target_slot === defaultConfig.EVENT) {\n            // search for first slot with event?\n            /*\n    //create input for trigger\n    var input = target_node.addInput(\"onTrigger\", LiteGraph.EVENT );\n    target_slot = target_node.inputs.length - 1; //last one is the one created\n    target_node.mode = LiteGraph.ON_TRIGGER;\n    */\n            return null;\n        } else if (\n            !target_node.inputs\n            || target_slot >= target_node.inputs.length\n        ) {\n            if (defaultConfig.debug) {\n                console.log(\"Connect: Error, slot number not found\");\n            }\n            return null;\n        }\n\n        let changed = false;\n\n        // if there is something already plugged there, disconnect\n        if (target_node.inputs[target_slot].link != null) {\n            this.graph.beforeChange();\n            target_node.disconnectInput(target_slot);\n            changed = true;\n        }\n\n        // why here??\n        // this.setDirtyCanvas(false,true);\n        // this.graph.connectionChange( this );\n\n        const output = this.outputs[slot];\n\n        // allows nodes to block connection\n        if (target_node.onConnectInput) {\n            if (target_node.onConnectInput(target_slot, output.type, output, this, slot) === false) {\n                return null;\n            }\n        }\n\n        const input = target_node.inputs[target_slot];\n        let link_info = null;\n\n        // this slots cannot be connected (different types)\n        if (!isValidConnection(output.type, input.type)) {\n            this.setDirtyCanvas(false, true);\n            if (changed) this.graph.connectionChange(this, link_info);\n            return null;\n        }\n\n        if (!changed) this.graph.beforeChange();\n\n        // create link class\n        link_info = new LLink(\n            ++this.graph.last_link_id,\n            input.type,\n            this.id,\n            slot,\n            target_node.id,\n            target_slot,\n        );\n\n        // add to graph links list\n        this.graph.links[link_info.id] = link_info;\n\n        // connect in output\n        if (output.links == null) {\n            output.links = [];\n        }\n        output.links.push(link_info.id);\n        // connect in input\n        target_node.inputs[target_slot].link = link_info.id;\n        if (this.graph) {\n            this.graph._version++;\n        }\n        if (this.onConnectionsChange) {\n            this.onConnectionsChange(\n                defaultConfig.OUTPUT,\n                slot,\n                true,\n                link_info,\n                output,\n            );\n        } // link_info has been created now, so its updated\n        if (target_node.onConnectionsChange) {\n            target_node.onConnectionsChange(\n                defaultConfig.INPUT,\n                target_slot,\n                true,\n                link_info,\n                input,\n            );\n        }\n        if (this.graph && this.graph.onNodeConnectionChange) {\n            this.graph.onNodeConnectionChange(\n                defaultConfig.INPUT,\n                target_node,\n                target_slot,\n                this,\n                slot,\n            );\n            this.graph.onNodeConnectionChange(\n                defaultConfig.OUTPUT,\n                this,\n                slot,\n                target_node,\n                target_slot,\n            );\n        }\n\n        this.setDirtyCanvas(false, true);\n        this.graph.afterChange();\n        this.graph.connectionChange(this, link_info);\n\n        return link_info;\n    }\n\n    /**\n     * disconnect one output to an specific node\n     * @method disconnectOutput\n     * @param {number_or_string} slot (could be the number of the slot or the string with the name\n     *     of the slot)\n     * @param {LGraphNode} target_node the target node to which this slot is connected [Optional,\n     *     if not target_node is specified all nodes will be disconnected]\n     * @return {boolean} if it was disconnected successfully\n     */\n    disconnectOutput(slot, target_node) {\n        if (slot.constructor === String) {\n            slot = this.findOutputSlot(slot);\n            if (slot == -1) {\n                if (defaultConfig.debug) {\n                    console.log(`Connect: Error, no slot of name ${slot}`);\n                }\n                return false;\n            }\n        } else if (!this.outputs || slot >= this.outputs.length) {\n            if (defaultConfig.debug) {\n                console.log(\"Connect: Error, slot number not found\");\n            }\n            return false;\n        }\n\n        // get output slot\n        const output = this.outputs[slot];\n        if (!output || !output.links || output.links.length == 0) {\n            return false;\n        }\n\n        // one of the output links in this slot\n        if (target_node) {\n            if (target_node.constructor === Number) {\n                target_node = this.graph.getNodeById(target_node);\n            }\n            if (!target_node) {\n                throw \"Target Node not found\";\n            }\n\n            for (var i = 0, l = output.links.length; i < l; i++) {\n                var link_id = output.links[i];\n                var link_info = this.graph.links[link_id];\n\n                // is the link we are searching for...\n                if (link_info.target_id == target_node.id) {\n                    output.links.splice(i, 1); // remove here\n                    var input = target_node.inputs[link_info.target_slot];\n                    input.link = null; // remove there\n                    delete this.graph.links[link_id]; // remove the link from the links pool\n                    if (this.graph) {\n                        this.graph._version++;\n                    }\n                    if (target_node.onConnectionsChange) {\n                        target_node.onConnectionsChange(\n                            defaultConfig.INPUT,\n                            link_info.target_slot,\n                            false,\n                            link_info,\n                            input,\n                        );\n                    } // link_info hasn't been modified so its ok\n                    if (this.onConnectionsChange) {\n                        this.onConnectionsChange(\n                            defaultConfig.OUTPUT,\n                            slot,\n                            false,\n                            link_info,\n                            output,\n                        );\n                    }\n                    if (this.graph && this.graph.onNodeConnectionChange) {\n                        this.graph.onNodeConnectionChange(\n                            defaultConfig.OUTPUT,\n                            this,\n                            slot,\n                        );\n                    }\n                    if (this.graph && this.graph.onNodeConnectionChange) {\n                        this.graph.onNodeConnectionChange(\n                            defaultConfig.OUTPUT,\n                            this,\n                            slot,\n                        );\n                        this.graph.onNodeConnectionChange(\n                            defaultConfig.INPUT,\n                            target_node,\n                            link_info.target_slot,\n                        );\n                    }\n                    break;\n                }\n            }\n        } // all the links in this output slot\n        else {\n            for (var i = 0, l = output.links.length; i < l; i++) {\n                var link_id = output.links[i];\n                var link_info = this.graph.links[link_id];\n                if (!link_info) {\n                    // bug: it happens sometimes\n                    continue;\n                }\n\n                var target_node = this.graph.getNodeById(link_info.target_id);\n                var input = null;\n                if (this.graph) {\n                    this.graph._version++;\n                }\n                if (target_node) {\n                    input = target_node.inputs[link_info.target_slot];\n                    input.link = null; // remove other side link\n                    if (target_node.onConnectionsChange) {\n                        target_node.onConnectionsChange(\n                            defaultConfig.INPUT,\n                            link_info.target_slot,\n                            false,\n                            link_info,\n                            input,\n                        );\n                    } // link_info hasn't been modified so its ok\n                    if (this.graph && this.graph.onNodeConnectionChange) {\n                        this.graph.onNodeConnectionChange(\n                            defaultConfig.INPUT,\n                            target_node,\n                            link_info.target_slot,\n                        );\n                    }\n                }\n                delete this.graph.links[link_id]; // remove the link from the links pool\n                if (this.onConnectionsChange) {\n                    this.onConnectionsChange(\n                        defaultConfig.OUTPUT,\n                        slot,\n                        false,\n                        link_info,\n                        output,\n                    );\n                }\n                if (this.graph && this.graph.onNodeConnectionChange) {\n                    this.graph.onNodeConnectionChange(\n                        defaultConfig.OUTPUT,\n                        this,\n                        slot,\n                    );\n                    this.graph.onNodeConnectionChange(\n                        defaultConfig.INPUT,\n                        target_node,\n                        link_info.target_slot,\n                    );\n                }\n            }\n            output.links = null;\n        }\n\n        this.setDirtyCanvas(false, true);\n        this.graph.connectionChange(this);\n        return true;\n    }\n\n    /**\n     * disconnect one input\n     * @method disconnectInput\n     * @param {number_or_string} slot (could be the number of the slot or the string with the name\n     *     of the slot)\n     * @return {boolean} if it was disconnected successfully\n     */\n    disconnectInput(slot) {\n        // seek for the output slot\n        if (slot.constructor === String) {\n            slot = this.findInputSlot(slot);\n            if (slot == -1) {\n                if (defaultConfig.debug) {\n                    console.log(`Connect: Error, no slot of name ${slot}`);\n                }\n                return false;\n            }\n        } else if (!this.inputs || slot >= this.inputs.length) {\n            if (defaultConfig.debug) {\n                console.log(\"Connect: Error, slot number not found\");\n            }\n            return false;\n        }\n\n        const input = this.inputs[slot];\n        if (!input) {\n            return false;\n        }\n\n        const link_id = this.inputs[slot].link;\n        if (link_id != null) {\n            this.inputs[slot].link = null;\n\n            // remove other side\n            const link_info = this.graph.links[link_id];\n            if (link_info) {\n                const target_node = this.graph.getNodeById(link_info.origin_id);\n                if (!target_node) {\n                    return false;\n                }\n\n                const output = target_node.outputs[link_info.origin_slot];\n                if (!output || !output.links || output.links.length == 0) {\n                    return false;\n                }\n\n                // search in the inputs list for this link\n                for (var i = 0, l = output.links.length; i < l; i++) {\n                    if (output.links[i] == link_id) {\n                        output.links.splice(i, 1);\n                        break;\n                    }\n                }\n\n                delete this.graph.links[link_id]; // remove from the pool\n                if (this.graph) {\n                    this.graph._version++;\n                }\n                if (this.onConnectionsChange) {\n                    this.onConnectionsChange(\n                        defaultConfig.INPUT,\n                        slot,\n                        false,\n                        link_info,\n                        input,\n                    );\n                }\n                if (target_node.onConnectionsChange) {\n                    target_node.onConnectionsChange(\n                        defaultConfig.OUTPUT,\n                        i,\n                        false,\n                        link_info,\n                        output,\n                    );\n                }\n                if (this.graph && this.graph.onNodeConnectionChange) {\n                    this.graph.onNodeConnectionChange(\n                        defaultConfig.OUTPUT,\n                        target_node,\n                        i,\n                    );\n                    this.graph.onNodeConnectionChange(defaultConfig.INPUT, this, slot);\n                }\n            }\n        } // link != null\n\n        this.setDirtyCanvas(false, true);\n        if (this.graph) this.graph.connectionChange(this);\n        return true;\n    }\n\n    /**\n     * returns the center of a connection point in canvas coords\n     * @method getConnectionPos\n     * @param {boolean} is_input true if if a input slot, false if it is an output\n     * @param {number_or_string} slot (could be the number of the slot or the string with the name\n     *     of the slot)\n     * @param {vec2} out [optional] a place to store the output, to free garbage\n     * @return {[x,y]} the position\n     * */\n    getConnectionPos(\n        is_input,\n        slot_number,\n        out,\n    ) {\n        out = out || new Float32Array(2);\n        let num_slots = 0;\n        if (is_input && this.inputs) {\n            num_slots = this.inputs.length;\n        }\n        if (!is_input && this.outputs) {\n            num_slots = this.outputs.length;\n        }\n\n        const offset = defaultConfig.NODE_SLOT_HEIGHT * 0.5;\n\n        if (this.flags.collapsed) {\n            const w = this._collapsed_width || defaultConfig.NODE_COLLAPSED_WIDTH;\n            if (this.horizontal) {\n                out[0] = this.pos[0] + w * 0.5;\n                if (is_input) {\n                    out[1] = this.pos[1] - defaultConfig.NODE_TITLE_HEIGHT;\n                } else {\n                    out[1] = this.pos[1];\n                }\n            } else {\n                if (is_input) {\n                    out[0] = this.pos[0];\n                } else {\n                    out[0] = this.pos[0] + w;\n                }\n                out[1] = this.pos[1] - defaultConfig.NODE_TITLE_HEIGHT * 0.5;\n            }\n            return out;\n        }\n\n        // weird feature that never got finished\n        if (is_input && slot_number == -1) {\n            out[0] = this.pos[0] + defaultConfig.NODE_TITLE_HEIGHT * 0.5;\n            out[1] = this.pos[1] + defaultConfig.NODE_TITLE_HEIGHT * 0.5;\n            return out;\n        }\n\n        // hard-coded pos\n        if (\n            is_input\n            && num_slots > slot_number\n            && this.inputs[slot_number].pos\n        ) {\n            out[0] = this.pos[0] + this.inputs[slot_number].pos[0];\n            out[1] = this.pos[1] + this.inputs[slot_number].pos[1];\n            return out;\n        }\n        if (\n            !is_input\n            && num_slots > slot_number\n            && this.outputs[slot_number].pos\n        ) {\n            out[0] = this.pos[0] + this.outputs[slot_number].pos[0];\n            out[1] = this.pos[1] + this.outputs[slot_number].pos[1];\n            return out;\n        }\n\n        // horizontal distributed slots\n        if (this.horizontal) {\n            out[0] = this.pos[0] + (slot_number + 0.5) * (this.size[0] / num_slots);\n            if (is_input) {\n                out[1] = this.pos[1] - defaultConfig.NODE_TITLE_HEIGHT;\n            } else {\n                out[1] = this.pos[1] + this.size[1];\n            }\n            return out;\n        }\n\n        // default vertical slots\n        if (is_input) {\n            out[0] = this.pos[0] + offset;\n        } else {\n            out[0] = this.pos[0] + this.size[0] + 1 - offset;\n        }\n        out[1] = this.pos[1]\n            + (slot_number + 0.7) * defaultConfig.NODE_SLOT_HEIGHT\n            + (this.constructor.slot_start_y || 0);\n        return out;\n    }\n\n    /* Force align to grid */\n    alignToGrid() {\n        this.pos[0] = defaultConfig.CANVAS_GRID_SIZE\n            * Math.round(this.pos[0] / defaultConfig.CANVAS_GRID_SIZE);\n        this.pos[1] = defaultConfig.CANVAS_GRID_SIZE\n            * Math.round(this.pos[1] / defaultConfig.CANVAS_GRID_SIZE);\n    }\n\n    /* Console output */\n    trace(msg) {\n        if (!this.console) {\n            this.console = [];\n        }\n\n        this.console.push(msg);\n        if (this.console.length > LGraphNode.MAX_CONSOLE) {\n            this.console.shift();\n        }\n\n        if (this.graph.onNodeTrace) this.graph.onNodeTrace(this, msg);\n    }\n\n    /* Forces to redraw or the main canvas (LGraphNode) or the bg canvas (links) */\n    setDirtyCanvas(\n        dirty_foreground,\n        dirty_background,\n    ) {\n        if (!this.graph) {\n            return;\n        }\n        this.graph.sendActionToCanvas(\"setDirty\", [\n            dirty_foreground,\n            dirty_background,\n        ]);\n    }\n\n    loadImage(url) {\n        const img = new Image();\n        img.src = defaultConfig.node_images_path + url;\n        img.ready = false;\n\n        img.onload = () => {\n            img.ready = true;\n            this.setDirtyCanvas(true);\n        };\n        return img;\n    }\n\n    // safe LGraphNode action execution (not sure if safe)\n    /*\n    executeAction = function(action)\n    {\n    if(action == \"\") return false;\n\n    if( action.indexOf(\";\") != -1 || action.indexOf(\"}\") != -1)\n    {\n    this.trace(\"Error: Action contains unsafe characters\");\n    return false;\n    }\n\n    var tokens = action.split(\"(\");\n    var func_name = tokens[0];\n    if( typeof(this[func_name]) != \"function\")\n    {\n    this.trace(\"Error: Action not found on node: \" + func_name);\n    return false;\n    }\n\n    var code = action;\n\n    try\n    {\n    var _foo = eval;\n    eval = null;\n    (new Function(\"with(this) { \" + code + \"}\")).call(this);\n    eval = _foo;\n    }\n    catch (err)\n    {\n    this.trace(\"Error executing action {\" + action + \"} :\" + err);\n    return false;\n    }\n\n    return true;\n    }\n    */\n\n    /* Allows to get onMouseMove and onMouseUp events even if the mouse is out of focus */\n    captureInput(v) {\n        if (!this.graph || !this.graph.list_of_graphcanvas) {\n            return;\n        }\n\n        const list = this.graph.list_of_graphcanvas;\n\n        for (let i = 0; i < list.length; ++i) {\n            const c = list[i];\n            // releasing somebody elses capture?!\n            if (!v && c.node_capturing_input != this) {\n                continue;\n            }\n\n            // change\n            c.node_capturing_input = v ? this : null;\n        }\n    }\n\n    /**\n     * Collapse the node to make it smaller on the canvas\n     * @method collapse\n     * */\n    collapse(force) {\n        this.graph._version++;\n        if (this.constructor.collapsable === false && !force) {\n            return;\n        }\n        this.flags.collapsed = !this.flags.collapsed;\n        this.setDirtyCanvas(true, true);\n    }\n\n    /**\n     * Forces the node to do not move or realign on Z\n     * @method pin\n     * */\n\n    pin(v) {\n        this.graph._version++;\n        if (v === undefined) {\n            this.flags.pinned = !this.flags.pinned;\n        } else {\n            this.flags.pinned = v;\n        }\n    }\n\n    localToScreen(x, y, graphcanvas) {\n        return [\n            (x + this.pos[0]) * graphcanvas.scale + graphcanvas.offset[0],\n            (y + this.pos[1]) * graphcanvas.scale + graphcanvas.offset[1],\n        ];\n    }\n\n    /**\n     * Create a node of a given type with a name. The node is not attached to any graph yet.\n     * @method createNode\n     * @param {String} type full name of the node class. p.e. \"math/sin\"\n     * @param {String} name a name to distinguish from other nodes\n     * @param {Object} options to set options\n     */\n    static createNode(type, title, options) {\n        const baseClass = this.registered_node_types[type];\n        if (!baseClass) {\n            if (defaultConfig.debug) console.log(`GraphNode type \"${type}\" not registered.`);\n            return null;\n        }\n\n        const prototype = baseClass.prototype || baseClass;\n\n        title = title || baseClass.title || type;\n\n        let node = null;\n\n        if (defaultConfig.catch_exceptions) {\n            try {\n                node = new baseClass(title);\n            } catch (err) {\n                console.error(err);\n                return null;\n            }\n        } else {\n            node = new baseClass(title);\n        }\n\n        node.type = type;\n\n        if (!node.title && title) {\n            node.title = title;\n        }\n        if (!node.properties) {\n            node.properties = {};\n        }\n        if (!node.properties_info) {\n            node.properties_info = [];\n        }\n        if (!node.flags) {\n            node.flags = {};\n        }\n        if (!node.size) {\n            node.size = node.computeSize();\n            // call onresize?\n        }\n        if (!node.pos) {\n            node.pos = defaultConfig.DEFAULT_POSITION.concat();\n        }\n        if (!node.mode) {\n            node.mode = defaultConfig.ALWAYS;\n        }\n\n        // extra options\n        if (options) {\n            // eslint-disable-next-line\n            for (const i in options) node[i] = options[i];\n        }\n\n        return node;\n    }\n\n    // debug purposes: reloads all the js scripts that matches a wildcard\n    static reloadNodes(folderWildcard) {\n        const tmp = document.getElementsByTagName(\"script\");\n        // weird, this array changes by its own, so we use a copy\n        const scriptFiles = [];\n        for (const t of tmp) scriptFiles.push(t);\n\n        const docHeadObj = document.getElementsByTagName(\"head\")[0];\n        folderWildcard = document.location.href + folderWildcard;\n\n        for (const script of scriptFiles) {\n            const { src } = script;\n            if (\n                !src\n                || src.substr(0, folderWildcard.length) !== folderWildcard\n            ) continue;\n\n            try {\n                if (defaultConfig.debug) {\n                    console.log(`Reloading: ${src}`);\n                }\n                const dynamicScript = document.createElement(\"script\");\n                dynamicScript.type = \"text/javascript\";\n                dynamicScript.src = src;\n                docHeadObj.appendChild(dynamicScript);\n                docHeadObj.removeChild(scriptFiles[i]);\n            } catch (err) {\n                if (defaultConfig.throw_errors) {\n                    throw err;\n                }\n                if (defaultConfig.debug) console.log(`Error while reloading ${src}`);\n            }\n        }\n\n        if (defaultConfig.debug) {\n            console.log(\"Nodes reloaded\");\n        }\n    }\n\n    /**\n     * Adds this method to all nodetypes, existing and to be created\n     * (You can add it to LGraphNode.prototype but then existing node types wont have it)\n     * @method addNodeMethod\n     * @param {Function} func\n     */\n    static addNodeMethod(name, func) {\n        LGraphNode.prototype[name] = func;\n        for (const i in this.registered_node_types) {\n            const type = this.registered_node_types[i];\n            if (type.prototype[name]) type.prototype[`_${name}`] = type.prototype[name];\n            type.prototype[name] = func;\n        }\n    }\n}\n","import LGraphNode from \"./LGraphNode\";\nimport defaultConfig from \"./utils/defaultConfig\";\n\nexport default class LGraphGroup {\n    constructor(title) {\n        this._ctor(title);\n    }\n\n    _ctor(title) {\n        this.title = title || \"Group\";\n        this.font_size = 24;\n        this.color = LGraphCanvas?.node_colors.pale_blue\n            ? LGraphCanvas.node_colors.pale_blue.groupcolor\n            : \"#AAA\";\n        this._bounding = new Float32Array([10, 10, 140, 80]);\n        this._pos = this._bounding.subarray(0, 2);\n        this._size = this._bounding.subarray(2, 4);\n        this._nodes = [];\n        this.graph = null;\n\n        Object.defineProperty(this, \"pos\", {\n            set(v) {\n                if (!v || v.length < 2) {\n                    return;\n                }\n                this._pos[0] = v[0];\n                this._pos[1] = v[1];\n            },\n            get() {\n                return this._pos;\n            },\n            enumerable: true,\n        });\n\n        Object.defineProperty(this, \"size\", {\n            set(v) {\n                if (!v || v.length < 2) {\n                    return;\n                }\n                this._size[0] = Math.max(140, v[0]);\n                this._size[1] = Math.max(80, v[1]);\n            },\n            get() {\n                return this._size;\n            },\n            enumerable: true,\n        });\n    }\n\n    recomputeInsideNodes() {\n        this._nodes.length = 0;\n        const nodes = this.graph._nodes;\n        const node_bounding = new Float32Array(4);\n\n        for (let i = 0; i < nodes.length; ++i) {\n            const node = nodes[i];\n            node.getBounding(node_bounding);\n            if (!overlapBounding(this._bounding, node_bounding)) {\n                continue;\n            } // out of the visible area\n            this._nodes.push(node);\n        }\n    }\n\n    move(deltax, deltay, ignore_nodes) {\n        this._pos[0] += deltax;\n        this._pos[1] += deltay;\n        if (ignore_nodes) {\n            return;\n        }\n        for (let i = 0; i < this._nodes.length; ++i) {\n            const node = this._nodes[i];\n            node.pos[0] += deltax;\n            node.pos[1] += deltay;\n        }\n    }\n\n    serialize() {\n        const b = this._bounding;\n        return {\n            title: this.title,\n            bounding: [\n                Math.round(b[0]),\n                Math.round(b[1]),\n                Math.round(b[2]),\n                Math.round(b[3]),\n            ],\n            color: this.color,\n            font: this.font,\n        };\n    }\n\n    configure(o) {\n        this.title = o.title;\n        this._bounding.set(o.bounding);\n        this.color = o.color;\n        this.font = o.font;\n    }\n\n    isPointInside = LGraphNode.prototype.isPointInside\n\n    setDirtyCanvas = LGraphNode.prototype.setDirtyCanvas\n}\n","export default class DragAndScale {\n    constructor(element, skipEvents) {\n        this.offset = new Float32Array([0, 0]);\n        this.scale = 1;\n        this.max_scale = 10;\n        this.min_scale = 0.1;\n        this.onredraw = null;\n        this.enabled = true;\n        this.last_mouse = [0, 0];\n        this.element = null;\n        this.visible_area = new Float32Array(4);\n\n        if (element) {\n            this.element = element;\n            if (!skipEvents) {\n                this.bindEvents(element);\n            }\n        }\n    }\n\n    bindEvents(element) {\n        this.last_mouse = new Float32Array(2);\n\n        this._binded_mouse_callback = this.onMouse.bind(this);\n\n        element.addEventListener(\"mousedown\", this._binded_mouse_callback);\n        element.addEventListener(\"mousemove\", this._binded_mouse_callback);\n\n        element.addEventListener(\n            \"mousewheel\",\n            this._binded_mouse_callback,\n            false,\n        );\n        element.addEventListener(\"wheel\", this._binded_mouse_callback, false);\n    }\n\n    computeVisibleArea() {\n        if (!this.element) {\n            // eslint-disable-next-line\n            this.visible_area[0] = this.visible_area[1] = this.visible_area[2] = this.visible_area[3] = 0;\n            return;\n        }\n        const { width } = this.element;\n        const { height } = this.element;\n        const startx = -this.offset[0];\n        const starty = -this.offset[1];\n        const endx = startx + width / this.scale;\n        const endy = starty + height / this.scale;\n        this.visible_area[0] = startx;\n        this.visible_area[1] = starty;\n        this.visible_area[2] = endx - startx;\n        this.visible_area[3] = endy - starty;\n    }\n\n    onMouse(e) {\n        if (!this.enabled) {\n            return;\n        }\n\n        const canvas = this.element;\n        const rect = canvas.getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        const y = e.clientY - rect.top;\n        e.canvasx = x;\n        e.canvasy = y;\n        e.dragging = this.dragging;\n\n        let ignore = false;\n        if (this.onmouse) {\n            ignore = this.onmouse(e);\n        }\n\n        if (e.type === \"mousedown\") {\n            this.dragging = true;\n            canvas.removeEventListener(\n                \"mousemove\",\n                this._binded_mouse_callback,\n            );\n            document.body.addEventListener(\n                \"mousemove\",\n                this._binded_mouse_callback,\n            );\n            document.body.addEventListener(\n                \"mouseup\",\n                this._binded_mouse_callback,\n            );\n        } else if (e.type === \"mousemove\") {\n            if (!ignore) {\n                const deltax = x - this.last_mouse[0];\n                const deltay = y - this.last_mouse[1];\n                if (this.dragging) {\n                    this.mouseDrag(deltax, deltay);\n                }\n            }\n        } else if (e.type === \"mouseup\") {\n            this.dragging = false;\n            document.body.removeEventListener(\n                \"mousemove\",\n                this._binded_mouse_callback,\n            );\n            document.body.removeEventListener(\n                \"mouseup\",\n                this._binded_mouse_callback,\n            );\n            canvas.addEventListener(\"mousemove\", this._binded_mouse_callback);\n        } else if (\n            e.type === \"mousewheel\"\n            || e.type === \"wheel\"\n            || e.type === \"DOMMouseScroll\"\n        ) {\n            e.eventType = \"mousewheel\";\n            if (e.type === \"wheel\") {\n                e.wheel = -e.deltaY;\n            } else {\n                e.wheel = e.wheelDeltaY != null ? e.wheelDeltaY : e.detail * -60;\n            }\n\n            // from stack overflow\n            if (e.wheelDelta){\n                e.delta = e.wheelDelta / 40\n            } else if (e.deltaY) {\n                e.delta = -e.deltaY / 3\n            } else {\n                e.delta = 0\n            }\n            this.changeDeltaScale(1.0 + e.delta * 0.05);\n        }\n\n        this.last_mouse[0] = x;\n        this.last_mouse[1] = y;\n\n        e.preventDefault();\n        e.stopPropagation();\n        return false;\n    }\n\n    toCanvasContext(ctx) {\n        ctx.scale(this.scale, this.scale);\n        ctx.translate(this.offset[0], this.offset[1]);\n    }\n\n    convertOffsetToCanvas(pos) {\n        // return [pos[0] / this.scale - this.offset[0], pos[1] / this.scale - this.offset[1]];\n        return [\n            (pos[0] + this.offset[0]) * this.scale,\n            (pos[1] + this.offset[1]) * this.scale,\n        ];\n    }\n\n    convertCanvasToOffset(pos, out) {\n        out = out || [0, 0];\n        out[0] = pos[0] / this.scale - this.offset[0];\n        out[1] = pos[1] / this.scale - this.offset[1];\n        return out;\n    }\n\n    mouseDrag(x, y) {\n        this.offset[0] += x / this.scale;\n        this.offset[1] += y / this.scale;\n\n        if (this.onredraw) {\n            this.onredraw(this);\n        }\n    }\n\n    changeScale(value, zoomingCenter) {\n        if (value < this.min_scale) {\n            value = this.min_scale;\n        } else if (value > this.max_scale) {\n            value = this.max_scale;\n        }\n\n        if (value === this.scale) {\n            return;\n        }\n\n        if (!this.element) {\n            return;\n        }\n\n        const rect = this.element.getBoundingClientRect();\n        if (!rect) {\n            return;\n        }\n\n        zoomingCenter = zoomingCenter || [\n            rect.width * 0.5,\n            rect.height * 0.5,\n        ];\n        const center = this.convertCanvasToOffset(zoomingCenter);\n        this.scale = value;\n        if (Math.abs(this.scale - 1) < 0.01) {\n            this.scale = 1;\n        }\n\n        const newCenter = this.convertCanvasToOffset(zoomingCenter);\n        const deltaOffset = [\n            newCenter[0] - center[0],\n            newCenter[1] - center[1],\n        ];\n\n        this.offset[0] += deltaOffset[0];\n        this.offset[1] += deltaOffset[1];\n\n        if (this.onredraw) {\n            this.onredraw(this);\n        }\n    }\n\n    changeDeltaScale(value, zoomingCenter) {\n        this.changeScale(this.scale * value, zoomingCenter);\n    }\n\n    reset() {\n        this.scale = 1;\n        this.offset[0] = 0;\n        this.offset[1] = 0;\n    }\n}\n","export default class ContextMenu {\n    /**\n     * ContextMenu from LiteGUI\n     *\n     * @class ContextMenu\n     * @constructor\n     * @param {Array} values (allows object { title: \"Nice text\", callback: function ... })\n     * @param {Object} options [optional] Some options:\\\n     * - title: title to show on top of the menu\n     * - callback: function to call when an option is clicked, it receives the item information\n     * - ignore_item_callbacks: ignores the callback inside the item, it just calls the\n     *     options.callback\n     * - event: you can pass a MouseEvent, this way the ContextMenu appears in that position\n     */\n    constructor(values, options = {}) {\n        this.options = options;\n        const that = this;\n\n        // to link a menu with its parent\n        if (options.parentMenu) {\n            if (options.parentMenu.constructor !== this.constructor) {\n                console.error(\"parentMenu must be of class ContextMenu, ignoring it\");\n                options.parentMenu = null;\n            } else {\n                this.parentMenu = options.parentMenu;\n                this.parentMenu.lock = true;\n                this.parentMenu.current_submenu = this;\n            }\n        }\n\n        let eventClass = null;\n        if (options.event) eventClass = options.event.constructor.name;\n        if (eventClass !== \"MouseEvent\"\n            && eventClass !== \"CustomEvent\"\n            && eventClass !== \"PointerEvent\"\n        ) {\n            console.error(\n                \"Event passed to ContextMenu is not of type MouseEvent or CustomEvent. Ignoring it.\",\n            );\n            options.event = null;\n        }\n\n        const root = document.createElement(\"div\");\n        root.className = \"litegraph litecontextmenu litemenubar-panel\";\n        if (options.className) root.className += ` ${options.className}`;\n        root.style.minWidth = 100;\n        root.style.minHeight = 100;\n        root.style.pointerEvents = \"none\";\n        setTimeout(() => {\n            root.style.pointerEvents = \"auto\";\n        }, 100); // delay so the mouse up event is not caught by this element\n\n        // this prevents the default context browser menu to open in case this menu was created\n        // when pressing right button\n        root.addEventListener(\"mouseup\", (e) => {\n            e.preventDefault();\n            return true;\n        },\n        true);\n        root.addEventListener(\n            \"contextmenu\",\n            (e) => {\n                if (e.button !== 2) {\n                    // right button\n                    return false;\n                }\n                e.preventDefault();\n                return false;\n            },\n            true,\n        );\n\n        root.addEventListener(\n            \"mousedown\",\n            (e) => {\n                if (e.button === 2) {\n                    that.close();\n                    e.preventDefault();\n                    return true;\n                }\n            },\n            true,\n        );\n\n        function on_mouse_wheel(e) {\n            const pos = parseInt(root.style.top, 10);\n            root.style.top = `${(pos + e.deltaY * options.scroll_speed).toFixed()}px`;\n            e.preventDefault();\n            return true;\n        }\n\n        if (!options.scroll_speed) options.scroll_speed = 0.1;\n\n        root.addEventListener(\"wheel\", on_mouse_wheel, true);\n        root.addEventListener(\"mousewheel\", on_mouse_wheel, true);\n\n        this.root = root;\n\n        // title\n        if (options.title) {\n            const element = document.createElement(\"div\");\n            element.className = \"litemenu-title\";\n            element.innerHTML = options.title;\n            root.appendChild(element);\n        }\n\n        // entries\n        for (let i = 0; i < values.length; i++) {\n            let name = values.constructor === Array ? values[i] : i;\n            if (name && name.constructor !== String) {\n                name = name.content === undefined ? String(name) : name.content;\n            }\n            const value = values[i];\n            this.addItem(name, value, options);\n        }\n\n        // close on leave\n        root.addEventListener(\"mouseleave\", (e) => {\n            if (that.lock) return;\n            if (root.closing_timer) clearTimeout(root.closing_timer);\n            root.closing_timer = setTimeout(that.close.bind(that, e), 500);\n            // that.close(e);\n        });\n\n        root.addEventListener(\"mouseenter\", (e) => {\n            if (root.closing_timer) clearTimeout(root.closing_timer);\n        });\n\n        // insert before checking position\n        let rootDocument = document;\n        if (options.event) {\n            rootDocument = options.event.target.ownerDocument;\n        }\n\n        if (!rootDocument) {\n            rootDocument = document;\n        }\n\n        if (rootDocument.fullscreenElement) {\n            rootDocument.fullscreenElement.appendChild(root);\n        } else {\n            rootDocument.body.appendChild(root);\n        }\n\n        // compute best position\n        let left = options.left || 0;\n        let top = options.top || 0;\n        if (options.event) {\n            left = options.event.clientX - 10;\n            top = options.event.clientY - 10;\n            if (options.title) top -= 20;\n\n            if (options.parentMenu) {\n                const rect = options.parentMenu.root.getBoundingClientRect();\n                left = rect.left + rect.width;\n            }\n\n            const bodyRect = document.body.getBoundingClientRect();\n            const rootRect = root.getBoundingClientRect();\n            if (bodyRect.height === 0) console.error(\"document.body height is 0. That is dangerous, set html,body { height: 100%; }\");\n\n            if (bodyRect.width && left > bodyRect.width - rootRect.width - 10) {\n                left = bodyRect.width - rootRect.width - 10;\n            }\n            if (bodyRect.height && top > bodyRect.height - rootRect.height - 10) {\n                top = bodyRect.height - rootRect.height - 10;\n            }\n        }\n\n        root.style.left = `${left}px`;\n        root.style.top = `${top}px`;\n\n        if (options.scale) root.style.transform = `scale(${options.scale})`;\n    }\n\n    addItem(name, value, options = {}) {\n        const that = this;\n\n        const element = document.createElement(\"div\");\n        element.className = \"litemenu-entry submenu\";\n\n        let disabled = false;\n\n        if (value === null) element.classList.add(\"separator\");\n        else {\n            element.innerHTML = value && value.title ? value.title : name;\n            element.value = value;\n\n            if (value) {\n                if (value.disabled) {\n                    disabled = true;\n                    element.classList.add(\"disabled\");\n                }\n                if (value.submenu || value.has_submenu) element.classList.add(\"has_submenu\");\n            }\n\n            if (typeof value === \"function\") {\n                element.dataset.value = name;\n                element.onclick_callback = value;\n            } else element.dataset.value = value;\n\n            if (value.className) element.className += ` ${value.className}`;\n        }\n\n        this.root.appendChild(element);\n        if (!disabled) element.addEventListener(\"click\", inner_onclick);\n        if (options.autoopen) element.addEventListener(\"mouseenter\", inner_over);\n\n        function inner_over(e) {\n            const { value } = this;\n            if (!value || !value.has_submenu) return;\n            // if it is a submenu, autoopen like the item was clicked\n            inner_onclick.call(this, e);\n        }\n\n        // menu option clicked\n        function inner_onclick(e) {\n            const { value } = this;\n            let closeParent = true;\n\n            if (that.current_submenu) that.current_submenu.close(e);\n\n            // global callback\n            if (options.callback) {\n                const r = options.callback.call(\n                    this,\n                    value,\n                    options,\n                    e,\n                    that,\n                    options.node,\n                );\n                if (r === true) closeParent = false;\n            }\n\n            // special cases\n            if (value) {\n                if (\n                    value.callback\n                    && !options.ignore_item_callbacks\n                    && value.disabled !== true\n                ) {\n                    // item callback\n                    const r = value.callback.call(\n                        this,\n                        value,\n                        options,\n                        e,\n                        that,\n                        options.extra,\n                    );\n                    if (r === true) closeParent = false;\n                }\n                if (value.submenu) {\n                    if (!value.submenu.options) {\n                        throw new Error(\"ContextMenu submenu needs options\");\n                    }\n                    const submenu = new that.constructor(value.submenu.options, {\n                        callback: value.submenu.callback,\n                        event: e,\n                        parentMenu: that,\n                        ignore_item_callbacks:\n                        value.submenu.ignore_item_callbacks,\n                        title: value.submenu.title,\n                        extra: value.submenu.extra,\n                        autoopen: options.autoopen,\n                    });\n                    closeParent = false;\n                }\n            }\n\n            if (closeParent && !that.lock) that.close();\n        }\n\n        return element;\n    }\n\n    close(e, ignoreParentMenu) {\n        if (this.root.parentNode) {\n            this.root.parentNode.removeChild(this.root);\n        }\n        if (this.parentMenu && !ignoreParentMenu) {\n            this.parentMenu.lock = false;\n            this.parentMenu.current_submenu = null;\n            if (e === undefined) this.parentMenu.close();\n            else if (e && !ContextMenu.isCursorOverElement(e, this.parentMenu.root)) {\n                ContextMenu.trigger(this.parentMenu.root, \"mouseleave\", e);\n            }\n        }\n        if (this.current_submenu) this.current_submenu.close(e, true);\n\n        if (this.root.closing_timer) clearTimeout(this.root.closing_timer);\n    }\n\n    // this code is used to trigger events easily (used in the context menu mouseleave\n    static trigger(element, eventName, params, origin) {\n        const evt = document.createEvent(\"CustomEvent\");\n        evt.initCustomEvent(eventName, true, true, params); // canBubble, cancelable, detail\n        evt.target = origin;\n        if (element.dispatchEvent) element.dispatchEvent(evt);\n        else if (element.__events) element.__events.dispatchEvent(evt);\n        // else nothing seems binded here so nothing to do\n        return evt;\n    }\n\n    // returns the top most menu\n    getTopMenu() {\n        if (this.options.parentMenu) return this.options.parentMenu.getTopMenu();\n        return this;\n    }\n\n    getFirstEvent() {\n        if (this.options.parentMenu) return this.options.parentMenu.getFirstEvent();\n        return this.options.event;\n    }\n\n    static closeAllContextMenus(ref_window = window) {\n        const elements = ref_window.document.querySelectorAll(\".litecontextmenu\");\n        if (!elements.length) {\n            return;\n        }\n\n        const result = [];\n        for (const el of elements) result.push(el);\n        for (const re of result) {\n            if (re.close) re.close();\n            else if (re.parentNode) re.parentNode.removeChild(result[i]);\n        }\n    }\n\n    static isCursorOverElement(event, element) {\n        const left = event.clientX;\n        const top = event.clientY;\n        const rect = element.getBoundingClientRect();\n        if (!rect) return false;\n        return top > rect.top\n            && top < rect.top + rect.height\n            && left > rect.left\n            && left < rect.left + rect.width;\n    }\n}\n","export function distance(a, b) {\n    return Math.sqrt(\n        (b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1]),\n    );\n}\n\nexport function isInsideRectangle(x, y, left, top, width, height) {\n    return left < x && left + width > x && top < y && top + height > y;\n}\n\n// bounding overlap, format: [ startx, starty, width, height ]\nexport function overlapBounding(a, b) {\n    const AEndX = a[0] + a[2];\n    const AEndY = a[1] + a[3];\n    const BEndX = b[0] + b[2];\n    const BEndY = b[1] + b[3];\n\n    return !(a[0] > BEndX\n        || a[1] > BEndY\n        || AEndX < b[0]\n        || AEndY < b[1]);\n}\n\nexport function clamp(v, a, b) {\n    // eslint-disable-next-line no-nested-ternary\n    return a > v ? a : b < v ? b : v;\n}\n","import DragAndScale from \"./DragAndScale\";\nimport { getFileExtension } from \"./utils/file\";\nimport ContextMenu from \"./ContextMenu\";\nimport { isValidConnection } from \"./utils/function\";\nimport LGraphNode from \"./LGraphNode\";\nimport { isInsideRectangle, overlapBounding } from \"./utils/math\";\nimport LGraphGroup from \"./LGraphGroup\";\nimport * as registry from \"./utils/registry\";\nimport defaultConfig from \"./utils/defaultConfig\";\nimport getTime from \"./utils/time\";\n\nconst temp = new Float32Array(4);\nconst tempVC2 = new Float32Array(2);\nconst tempArea = new Float32Array(4);\nconst marginArea = new Float32Array(4);\nconst linkBounding = new Float32Array(4);\nconst tempA = new Float32Array(2);\nconst tempB = new Float32Array(2);\n\nexport default class LGraphCanvas {\n    /**\n     * This class is in charge of rendering one graph inside a canvas. And provides all the\n     * interaction required. Valid callbacks are: onNodeSelected, onNodeDeselected,\n     * onShowNodePanel, onNodeDblClicked\n     *\n     * @class LGraphCanvas\n     * @constructor\n     * @param {HTMLCanvasElement} canvas the canvas where you want to render\n     *  (it accepts a selector in string format or the canvas element itself)\n     * @param {LGraph} graph [optional]\n     * @param {Object} options [optional] { skip_rendering, autoresize }\n     */\n    constructor(canvas, graph, options = {}) {\n        // if(graph === undefined)\n        // throw (\"No graph assigned\");\n        this.background_image = LGraphCanvas.DEFAULT_BACKGROUND_IMAGE;\n\n        if (canvas && canvas.constructor === String) {\n            canvas = document.querySelector(canvas);\n        }\n\n        this.ds = new DragAndScale();\n        this.zoom_modify_alpha = true; // otherwise it generates ugly patterns when scaling down\n        // too much\n\n        this.title_text_font = `${defaultConfig.NODE_TEXT_SIZE}px Arial`;\n        this.inner_text_font = `normal ${defaultConfig.NODE_SUBTEXT_SIZE}px Arial`;\n        this.node_title_color = defaultConfig.NODE_TITLE_COLOR;\n        this.default_link_color = defaultConfig.LINK_COLOR;\n        this.default_connection_color = {\n            input_off: \"#778\",\n            input_on: \"#7F7\",\n            output_off: \"#778\",\n            output_on: \"#7F7\",\n        };\n\n        this.highquality_render = true;\n        this.use_gradients = false; // set to true to render titlebar with gradients\n        this.editor_alpha = 1; // used for transition\n        this.pause_rendering = false;\n        this.clear_background = true;\n\n        this.read_only = false; // if set to true users cannot modify the graph\n        this.render_only_selected = true;\n        this.live_mode = false;\n        this.show_info = true;\n        this.allow_dragcanvas = true;\n        this.allow_dragnodes = true;\n        this.allow_interaction = true; // allow to control widgets, buttons, collapse, etc\n        this.allow_searchbox = true;\n        this.allow_reconnect_links = false; // allows to change a connection with having to redo it\n        // again\n\n        this.drag_mode = false;\n        this.dragging_rectangle = null;\n\n        this.filter = null; // allows to filter to only accept some type of nodes in a graph\n\n        this.set_canvas_dirty_on_mouse_event = true; // forces to redraw the canvas if the mouse\n        // does anything\n        this.always_render_background = false;\n        this.render_shadows = true;\n        this.render_canvas_border = true;\n        this.render_connections_shadows = false; // too much cpu\n        this.render_connections_border = true;\n        this.render_curved_connections = false;\n        this.render_connection_arrows = false;\n        this.render_collapsed_slots = true;\n        this.render_execution_order = false;\n        this.render_title_colored = true;\n        this.render_link_tooltip = true;\n\n        this.links_render_mode = defaultConfig.SPLINE_LINK;\n\n        this.mouse = [0, 0]; // mouse in canvas coordinates, where 0,0 is the top-left corner of\n        // the blue rectangle\n        this.graph_mouse = [0, 0]; // mouse in graph coordinates, where 0,0 is the top-left corner\n        // of the blue rectangle\n        this.canvas_mouse = this.graph_mouse; // LEGACY: REMOVE THIS, USE GRAPH_MOUSE INSTEAD\n\n        // to personalize the search box\n        this.onSearchBox = null;\n        this.onSearchBoxSelection = null;\n\n        // callbacks\n        this.onMouse = null;\n        this.onDrawBackground = null; // to render background objects (behind nodes and\n        // connections) in the canvas affected by transform\n        this.onDrawForeground = null; // to render foreground objects (above nodes and connections)\n        // in the canvas affected by transform\n        this.onDrawOverlay = null; // to render foreground objects not affected by transform (for\n        // GUIs)\n        this.onDrawLinkTooltip = null; // called when rendering a tooltip\n        this.onNodeMoved = null; // called after moving a node\n        this.onSelectionChange = null; // called if the selection changes\n        this.onConnectingChange = null; // called before any link changes\n        this.onBeforeChange = null; // called before modifying the graph\n        this.onAfterChange = null; // called after modifying the graph\n\n        this.connections_width = 3;\n        this.round_radius = 8;\n\n        this.current_node = null;\n        this.node_widget = null; // used for widgets\n        this.over_link_center = null;\n        this.last_mouse_position = [0, 0];\n        this.visible_area = this.ds.visible_area;\n        this.visible_links = [];\n\n        // link canvas and graph\n        if (graph) {\n            graph.attachCanvas(this);\n        }\n\n        this.setCanvas(canvas);\n        this.clear();\n\n        if (!options.skip_render) {\n            this.startRendering();\n        }\n\n        this.autoresize = options.autoresize;\n    }\n\n    static DEFAULT_BACKGROUND_IMAGE = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQBJREFUeNrs1rEKwjAUhlETUkj3vP9rdmr1Ysammk2w5wdxuLgcMHyptfawuZX4pJSWZTnfnu/lnIe/jNNxHHGNn//HNbbv+4dr6V+11uF527arU7+u63qfa/bnmh8sWLBgwYJlqRf8MEptXPBXJXa37BSl3ixYsGDBMliwFLyCV/DeLIMFCxYsWLBMwSt4Be/NggXLYMGCBUvBK3iNruC9WbBgwYJlsGApeAWv4L1ZBgsWLFiwYJmCV/AK3psFC5bBggULloJX8BpdwXuzYMGCBctgwVLwCl7Be7MMFixYsGDBsu8FH1FaSmExVfAxBa/gvVmwYMGCZbBg/W4vAQYA5tRF9QYlv/QAAAAASUVORK5CYII=\";\n\n    static link_type_colors = {\n        \"-1\": defaultConfig.EVENT_LINK_COLOR,\n        number: \"#AAA\",\n        node: \"#DCA\",\n    }\n\n    static gradients = {}\n\n    /**\n     * clears all the data inside\n     *\n     * @method clear\n     */\n    clear() {\n        this.frame = 0;\n        this.last_draw_time = 0;\n        this.render_time = 0;\n        this.fps = 0;\n\n        // this.scale = 1;\n        // this.offset = [0,0];\n\n        this.dragging_rectangle = null;\n\n        this.selected_nodes = {};\n        this.selected_group = null;\n\n        this.visible_nodes = [];\n        this.node_dragged = null;\n        this.node_over = null;\n        this.node_capturing_input = null;\n        this.connecting_node = null;\n        this.highlighted_links = {};\n\n        this.dragging_canvas = false;\n\n        this.dirty_canvas = true;\n        this.dirty_bgcanvas = true;\n        this.dirty_area = null;\n\n        this.node_in_panel = null;\n        this.node_widget = null;\n\n        this.last_mouse = [0, 0];\n        this.last_mouseclick = 0;\n        this.visible_area.set([0, 0, 0, 0]);\n\n        if (this.onClear) this.onClear();\n    }\n\n    /**\n     * assigns a graph, you can reassign graphs to the same canvas\n     *\n     * @method setGraph\n     * @param {LGraph} graph\n     * @param {boolean=} skipClear\n     */\n    setGraph(graph, skipClear) {\n        if (this.graph === graph) {\n            return;\n        }\n\n        if (!skipClear) this.clear();\n\n        if (!graph && this.graph) {\n            this.graph.detachCanvas(this);\n            return;\n        }\n\n        graph.attachCanvas(this);\n\n        // remove the graph stack in case a subgraph was open\n        if (this._graph_stack) this._graph_stack = null;\n\n        this.setDirty(true, true);\n    }\n\n    /**\n     * returns the top level graph (in case there are subgraphs open on the canvas)\n     *\n     * @method getTopGraph\n     * @return {LGraph} graph\n     */\n    getTopGraph() {\n        if (this._graph_stack.length) return this._graph_stack[0];\n        return this.graph;\n    }\n\n    /**\n     * opens a graph contained inside a node in the current graph\n     *\n     * @method openSubgraph\n     * @param {LGraph} graph\n     */\n    openSubgraph(graph) {\n        if (!graph) {\n            throw new Error(\"graph cannot be null\");\n        }\n\n        if (this.graph === graph) {\n            throw new Error(\"graph cannot be the same\");\n        }\n\n        this.clear();\n\n        if (this.graph) {\n            if (!this._graph_stack) {\n                this._graph_stack = [];\n            }\n            this._graph_stack.push(this.graph);\n        }\n\n        graph.attachCanvas(this);\n        this.checkPanels();\n        this.setDirty(true, true);\n    }\n\n    /**\n     * closes a subgraph contained inside a node\n     *\n     * @method closeSubgraph\n     */\n    closeSubgraph() {\n        if (!this._graph_stack || this._graph_stack.length === 0) {\n            return;\n        }\n        const subgraphNode = this.graph._subgraph_node;\n        const graph = this._graph_stack.pop();\n        this.selected_nodes = {};\n        this.highlighted_links = {};\n        graph.attachCanvas(this);\n        this.setDirty(true, true);\n        if (subgraphNode) {\n            this.centerOnNode(subgraphNode);\n            this.selectNodes([subgraphNode]);\n        }\n    }\n\n    /**\n     * returns the visualy active graph (in case there are more in the stack)\n     * @method getCurrentGraph\n     * @return {LGraph} the active graph\n     */\n    getCurrentGraph() {\n        return this.graph;\n    }\n\n    /**\n     * assigns a canvas\n     *\n     * @method setCanvas\n     * @param {HTMLCanvasElement | string | HTMLElement} canvas assigns a canvas\n     *  (also accepts the ID of the element (not a selector))\n     * @param {boolean} skipEvents\n     */\n    setCanvas(canvas, skipEvents) {\n        if (canvas?.constructor === String) {\n            canvas = document.getElementById(canvas);\n            if (!canvas) {\n                throw new Error(\"Error creating LiteGraph canvas: Canvas not found\");\n            }\n        }\n\n        if (canvas === this.canvas) {\n            return;\n        }\n\n        if (!canvas && this.canvas) {\n            // maybe detach events from old_canvas\n            if (!skipEvents) {\n                this.unbindEvents();\n            }\n        }\n\n        this.canvas = canvas;\n        this.ds.element = canvas;\n\n        if (!canvas) return;\n\n        // this.canvas.tabindex = \"1000\";\n        canvas.className += \" lgraphcanvas\";\n        canvas.data = this;\n        canvas.tabindex = \"1\"; // to allow key events\n\n        // bg canvas: used for non changing stuff\n        this.bgcanvas = null;\n        this.bgcanvas = document.createElement(\"canvas\");\n        this.bgcanvas.width = this.canvas.width;\n        this.bgcanvas.height = this.canvas.height;\n\n        if (canvas.getContext === null) {\n            if (canvas.localName !== \"canvas\") {\n                throw new Error(`Element supplied for LGraphCanvas must be a <canvas> element, you passed a ${\n                    canvas.localName}`);\n            }\n            throw new Error(\"This browser doesn't support Canvas\");\n        }\n\n        this.ctx = canvas.getContext(\"2d\");\n        if (this.ctx == null) {\n            if (!canvas.webgl_enabled) {\n                console.warn(\n                    \"This canvas seems to be WebGL, enabling WebGL renderer\",\n                );\n            }\n            this.enableWebGL();\n        }\n\n        // input:  (move and up could be unbinded)\n        this._mousemove_callback = this.processMouseMove.bind(this);\n        this._mouseup_callback = this.processMouseUp.bind(this);\n\n        if (!skipEvents) this.bindEvents();\n    }\n\n    _doNothing(e) {\n        e.preventDefault();\n        return false;\n    }\n\n    _doReturnTrue(e) {\n        e.preventDefault();\n        return true;\n    }\n\n    /**\n     * binds mouse, keyboard, touch and drag events to the canvas\n     * @method bindEvents\n     * */\n    bindEvents() {\n        if (this._events_binded) {\n            console.warn(\"LGraphCanvas: events already binded\");\n            return;\n        }\n\n        const { canvas } = this;\n\n        const refWindow = this.getCanvasWindow();\n        const { document } = refWindow; // hack used when moving canvas between windows\n\n        this._mousedown_callback = this.processMouseDown.bind(this);\n        this._mousewheel_callback = this.processMouseWheel.bind(this);\n\n        canvas.addEventListener(\"mousedown\", this._mousedown_callback, true); // down do not need\n        // to store the binded\n        canvas.addEventListener(\"mousemove\", this._mousemove_callback);\n        canvas.addEventListener(\"mousewheel\", this._mousewheel_callback);\n\n        canvas.addEventListener(\"contextmenu\", this._doNothing);\n        canvas.addEventListener(\"DOMMouseScroll\", this._mousewheel_callback);\n\n        canvas.addEventListener(\"touchstart\", this.touchHandler, true);\n        canvas.addEventListener(\"touchmove\", this.touchHandler, true);\n        canvas.addEventListener(\"touchend\", this.touchHandler, true);\n        canvas.addEventListener(\"touchcancel\", this.touchHandler, true);\n\n        // Keyboard ******************\n        this._key_callback = this.processKey.bind(this);\n\n        canvas.addEventListener(\"keydown\", this._key_callback, true);\n        document.addEventListener(\"keyup\", this._key_callback, true); // in document, otherwise it\n        // doesn't fire keyup\n\n        // Dropping Stuff over nodes ************************************\n        this._ondrop_callback = this.processDrop.bind(this);\n\n        canvas.addEventListener(\"dragover\", this._doNothing, false);\n        canvas.addEventListener(\"dragend\", this._doNothing, false);\n        canvas.addEventListener(\"drop\", this._ondrop_callback, false);\n        canvas.addEventListener(\"dragenter\", this._doReturnTrue, false);\n\n        this._events_binded = true;\n    }\n\n    /**\n     * unbinds mouse events from the canvas\n     * @method unbindEvents\n     * */\n    unbindEvents() {\n        if (!this._events_binded) {\n            console.warn(\"LGraphCanvas: no events binded\");\n            return;\n        }\n\n        const refWindow = this.getCanvasWindow();\n        const { document } = refWindow;\n\n        this.canvas.removeEventListener(\"mousedown\", this._mousedown_callback);\n        this.canvas.removeEventListener(\n            \"mousewheel\",\n            this._mousewheel_callback,\n        );\n        this.canvas.removeEventListener(\n            \"DOMMouseScroll\",\n            this._mousewheel_callback,\n        );\n        this.canvas.removeEventListener(\"keydown\", this._key_callback);\n        document.removeEventListener(\"keyup\", this._key_callback);\n        this.canvas.removeEventListener(\"contextmenu\", this._doNothing);\n        this.canvas.removeEventListener(\"drop\", this._ondrop_callback);\n        this.canvas.removeEventListener(\"dragenter\", this._doReturnTrue);\n\n        this.canvas.removeEventListener(\"touchstart\", this.touchHandler);\n        this.canvas.removeEventListener(\"touchmove\", this.touchHandler);\n        this.canvas.removeEventListener(\"touchend\", this.touchHandler);\n        this.canvas.removeEventListener(\"touchcancel\", this.touchHandler);\n\n        this._mousedown_callback = null;\n        this._mousewheel_callback = null;\n        this._key_callback = null;\n        this._ondrop_callback = null;\n\n        this._events_binded = false;\n    }\n\n    /**\n     * this function allows to render the canvas using WebGL instead of Canvas2D\n     * this is useful if you plant to render 3D objects inside your nodes, it uses litegl.js for\n     * webgl and canvas2DtoWebGL to emulate the Canvas2D calls in webGL\n     * @method enableWebGL\n     * */\n    enableWebGL() {\n        if (!GL) throw new Error(\"litegl.js must be included to use a WebGL canvas\");\n        if (!enableWebGLCanvas) throw new Error(\"webglCanvas.js must be included to use this feature\");\n\n        this.ctx = enableWebGLCanvas(this.canvas);\n        this.gl = this.ctx;\n        this.ctx.webgl = true;\n        this.bgcanvas = this.canvas;\n        this.bgctx = this.gl;\n        this.canvas.webgl_enabled = true;\n    }\n\n    /**\n     * marks as dirty the canvas, this way it will be rendered again\n     *\n     * @class LGraphCanvas\n     * @method setDirty\n     * @param {boolean} [fgcanvas] if the foreground canvas is dirty (the one containing the nodes)\n     * @param {boolean} [bgcanvas] if the background canvas is dirty (the one containing the wires)\n     */\n    setDirty(fgcanvas, bgcanvas) {\n        if (fgcanvas) this.dirty_canvas = true;\n        if (bgcanvas) this.dirty_bgcanvas = true;\n    }\n\n    /**\n     * Used to attach the canvas in a popup\n     *\n     * @method getCanvasWindow\n     * @return {Window} returns the window where the canvas is attached (the DOM root node)\n     */\n    getCanvasWindow() {\n        if (!this.canvas) return window;\n        const doc = this.canvas.ownerDocument;\n        return doc.defaultView;\n    }\n\n    /**\n     * starts rendering the content of the canvas when needed\n     *\n     * @method startRendering\n     */\n    startRendering() {\n        if (this.is_rendering) return;\n\n        this.is_rendering = true;\n        this.renderFrame();\n    }\n\n    /**\n     * render a frame\n     *\n     * @method renderFrame\n     */\n    renderFrame() {\n        if (!this.pause_rendering) this.draw();\n\n        const window = this.getCanvasWindow();\n        if (this.is_rendering) window.requestAnimationFrame(this.renderFrame);\n    }\n\n    /**\n     * stops rendering the content of the canvas (to save resources)\n     *\n     * @method stopRendering\n     */\n    stopRendering() {\n        this.is_rendering = false;\n    }\n\n    /* LiteGraphCanvas input */\n\n    /**\n     * used to block future mouse events (because of im gui)\n     *\n     * @method blockClick\n     */\n    blockClick() {\n        this.block_click = true;\n        this.last_mouseclick = 0;\n    }\n\n    processMouseDown(e) {\n        if (this.set_canvas_dirty_on_mouse_event) this.dirty_canvas = true;\n\n        if (!this.graph) return;\n\n        this.adjustMouseEvent(e);\n\n        const refWindow = this.getCanvasWindow();\n        LGraphCanvas.active_canvas = this;\n\n        // move mouse move event to the window in case it drags outside of the canvas\n        this.canvas.removeEventListener(\"mousemove\", this._mousemove_callback);\n        refWindow.document.addEventListener(\"mousemove\", this._mousemove_callback, true); // catch for the entire window\n        refWindow.document.addEventListener(\"mouseup\", this._mouseup_callback, true);\n\n        const node = this.graph.getNodeOnPos(e.canvasX, e.canvasY, this.visible_nodes, 5);\n        let skipAction = false;\n        const now = getTime();\n        const isDoubleClick = now - this.last_mouseclick < 300;\n        this.mouse[0] = e.localX;\n        this.mouse[1] = e.localY;\n        this.graph_mouse[0] = e.canvasX;\n        this.graph_mouse[1] = e.canvasY;\n        this.last_click_position = [this.mouse[0], this.mouse[1]];\n\n        this.canvas.focus();\n\n        ContextMenu.closeAllContextMenus(refWindow);\n\n        if (this.onMouse) {\n            if (this.onMouse(e)) return;\n        }\n\n        // left button mouse\n        if (e.which === 1) {\n            if (e.ctrlKey) {\n                this.dragging_rectangle = new Float32Array(4);\n                this.dragging_rectangle[0] = e.canvasX;\n                this.dragging_rectangle[1] = e.canvasY;\n                this.dragging_rectangle[2] = 1;\n                this.dragging_rectangle[3] = 1;\n                skipAction = true;\n            }\n\n            let clickingCanvasBg = false;\n\n            // when clicked on top of a node\n            // and it is not interactive\n            if (node && this.allow_interaction && !skipAction && !this.read_only) {\n                if (!this.live_mode && !node.flags.pinned) {\n                    this.bringToFront(node);\n                } // if it wasn't selected?\n\n                // not dragging mouse to connect two slots\n                if (!this.connecting_node && !node.flags.collapsed && !this.live_mode) {\n                // Search for corner for resize\n                    if (!skipAction\n                    && node.resizable !== false\n                    && isInsideRectangle(\n                        e.canvasX,\n                        e.canvasY,\n                        node.pos[0] + node.size[0] - 5,\n                        node.pos[1] + node.size[1] - 5,\n                        1010,\n                    )\n                    ) {\n                        this.graph.beforeChange();\n                        this.resizing_node = node;\n                        this.canvas.style.cursor = \"se-resize\";\n                        skipAction = true;\n                    } else {\n                    // search for outputs\n                        if (node.outputs) {\n                            for (let i = 0, l = node.outputs.length; i < l; i++) {\n                                const output = node.outputs[i];\n                                const linkPos = node.getConnectionPos(false, i);\n                                if (isInsideRectangle(\n                                    e.canvasX,\n                                    e.canvasY,\n                                    linkPos[0] - 15,\n                                    linkPos[1] - 10,\n                                    30,\n                                    20,\n                                )) {\n                                    this.connecting_node = node;\n                                    this.connecting_output = output;\n                                    this.connecting_pos = node.getConnectionPos(false, i);\n                                    this.connecting_slot = i;\n                                    if (e.shiftKey) {\n                                        node.disconnectOutput(i);\n                                    }\n\n                                    if (isDoubleClick) {\n                                        if (node.onOutputDblClick) {\n                                            node.onOutputDblClick(i, e);\n                                        }\n                                    } else if (node.onOutputClick) {\n                                        node.onOutputClick(i, e);\n                                    }\n\n                                    skipAction = true;\n                                    break;\n                                }\n                            }\n                        }\n\n                        // search for inputs\n                        if (node.inputs) {\n                            for (let i = 0, l = node.inputs.length; i < l; i++) {\n                                const input = node.inputs[i];\n                                const linkPos = node.getConnectionPos(true, i);\n                                if (isInsideRectangle(\n                                    e.canvasX,\n                                    e.canvasY,\n                                    linkPos[0] - 15,\n                                    linkPos[1] - 10,\n                                    30, 20,\n                                )) {\n                                    if (isDoubleClick) {\n                                        if (node.onInputDblClick) {\n                                            node.onInputDblClick(i, e);\n                                        }\n                                    } else if (node.onInputClick) {\n                                        node.onInputClick(i, e);\n                                    }\n\n                                    if (input.link !== null) {\n                                        const linkInfo = this.graph.links[\n                                            input.link\n                                        ]; // before disconnecting\n                                        node.disconnectInput(i);\n\n                                        if (\n                                            this.allow_reconnect_links\n                                            || e.shiftKey\n                                        ) {\n                                            this.connecting_node = this.graph._nodes_by_id[\n                                                linkInfo.origin_id\n                                            ];\n                                            this.connecting_slot = linkInfo.origin_slot;\n                                            this.connecting_output = this.connecting_node.outputs[\n                                                this.connecting_slot\n                                            ];\n\n                                            this.connecting_pos = this.connecting_node\n                                                .getConnectionPos(false, this.connecting_slot);\n                                        }\n\n                                        this.dirty_bgcanvas = true;\n                                        skipAction = true;\n                                    }\n                                }\n                            }\n                        }\n                    } // not resizing\n                }\n\n                // it wasn't clicked on the links boxes\n                if (!skipAction) {\n                    let blockDragNote = false;\n                    const pos = [e.canvasX - node.pos[0], e.canvasY - node.pos[1]];\n\n                    // widgets\n                    const widget = this.processNodeWidgets(node, this.graph_mouse, e);\n                    if (widget) {\n                        blockDragNote = true;\n                        this.node_widget = [node, widget];\n                    }\n\n                    // double clicking\n                    if (isDoubleClick && this.selected_nodes[node.id]) {\n                        // double click node\n                        if (node.onDblClick) {\n                            node.onDblClick(e, pos, this);\n                        }\n                        this.processNodeDblClicked(node);\n                        blockDragNote = true;\n                    }\n\n                    // if do not capture mouse\n                    if (node.onMouseDown && node.onMouseDown(e, pos, this)) {\n                        blockDragNote = true;\n                    } else {\n                        // open subgraph button\n                        if (node.subgraph && !node.skip_subgraph_button) {\n                            if (!node.flags.collapsed && pos[0]\n                                > node.size[0] - defaultConfig.NODE_TITLE_HEIGHT\n                                && pos[1] < 0) {\n                                setTimeout(() => {\n                                    this.openSubgraph(node.subgraph);\n                                }, 10);\n                            }\n                        }\n\n                        if (this.live_mode) {\n                            clickingCanvasBg = true;\n                            blockDragNote = true;\n                        }\n                    }\n\n                    if (!blockDragNote) {\n                        if (this.allow_dragnodes) {\n                            this.graph.beforeChange();\n                            this.node_dragged = node;\n                        }\n                        if (!this.selected_nodes[node.id]) {\n                            this.processNodeSelected(node, e);\n                        }\n                    }\n\n                    this.dirty_canvas = true;\n                }\n            } else {\n                // search for link connector\n                if (!this.read_only) {\n                    for (const link of this.visible_links) {\n                        const center = link._pos;\n                        if (\n                            !center\n                            || e.canvasX < center[0] - 4\n                            || e.canvasX > center[0] + 4\n                            || e.canvasY < center[1] - 4\n                            || e.canvasY > center[1] + 4\n                        ) {\n                            continue;\n                        }\n                        // link clicked\n                        this.showLinkMenu(link, e);\n                        this.over_link_center = null; // clear tooltip\n                        break;\n                    }\n                }\n\n                this.selected_group = this.graph.getGroupOnPos(e.canvasX, e.canvasY);\n                this.selected_group_resizing = false;\n                if (this.selected_group && !this.read_only) {\n                    if (e.ctrlKey) this.dragging_rectangle = null;\n\n                    const dist = distance([e.canvasX, e.canvasY],\n                        [this.selected_group.pos[0] + this.selected_group.size[0],\n                            this.selected_group.pos[1] + this.selected_group.size[1]]);\n                    if (dist * this.ds.scale < 10) {\n                        this.selected_group_resizing = true;\n                    } else {\n                        this.selected_group.recomputeInsideNodes();\n                    }\n                }\n\n                if (isDoubleClick && !this.read_only && this.allow_searchbox) {\n                    this.showSearchBox(e);\n                }\n\n                clickingCanvasBg = true;\n            }\n\n            if (!skipAction && clickingCanvasBg && this.allow_dragcanvas) {\n                this.dragging_canvas = true;\n            }\n        } else if (e.which === 2) {\n            // middle button\n        } else if (e.which === 3) {\n            // right button\n            if (!this.read_only) this.processContextMenu(node, e);\n        }\n\n        // TODO\n        // if(this.node_selected != prev_selected)\n        //\tthis.onNodeSelectionChange(this.node_selected);\n\n        this.last_mouse[0] = e.localX;\n        this.last_mouse[1] = e.localY;\n        this.last_mouseclick = getTime();\n        this.last_mouse_dragging = true;\n\n        /*\n    if( (this.dirty_canvas || this.dirty_bgcanvas) && this.rendering_timer_id == null)\n    this.draw();\n    */\n\n        this.graph.change();\n\n        // this is to ensure to defocus(blur) if a text input element is on focus\n        if (\n            !refWindow.document.activeElement\n            || (refWindow.document.activeElement.nodeName.toLowerCase()\n            !== \"input\"\n            && refWindow.document.activeElement.nodeName.toLowerCase()\n            !== \"textarea\")) {\n            e.preventDefault();\n        }\n        e.stopPropagation();\n\n        if (this.onMouseDown) {\n            this.onMouseDown(e);\n        }\n\n        return false;\n    }\n\n    /**\n     * Called when a mouse move event has to be processed\n     * @method processMouseMove\n     * */\n    processMouseMove(e) {\n        if (this.autoresize) this.resize();\n\n        if (this.set_canvas_dirty_on_mouse_event) this.dirty_canvas = true;\n\n        if (!this.graph) return;\n\n        LGraphCanvas.active_canvas = this;\n        this.adjustMouseEvent(e);\n        const mouse = [e.localX, e.localY];\n        this.mouse[0] = mouse[0];\n        this.mouse[1] = mouse[1];\n        const delta = [\n            mouse[0] - this.last_mouse[0],\n            mouse[1] - this.last_mouse[1],\n        ];\n        this.last_mouse = mouse;\n        this.graph_mouse[0] = e.canvasX;\n        this.graph_mouse[1] = e.canvasY;\n\n        if (this.block_click) {\n            e.preventDefault();\n            return false;\n        }\n\n        e.dragging = this.last_mouse_dragging;\n\n        if (this.node_widget) {\n            this.processNodeWidgets(this.node_widget[0], this.graph_mouse, e, this.node_widget[1]);\n            this.dirty_canvas = true;\n        }\n\n        if (this.dragging_rectangle) {\n            this.dragging_rectangle[2] = e.canvasX - this.dragging_rectangle[0];\n            this.dragging_rectangle[3] = e.canvasY - this.dragging_rectangle[1];\n            this.dirty_canvas = true;\n        } else if (this.selected_group && !this.read_only) {\n            // moving/resizing a group\n            if (this.selected_group_resizing) {\n                this.selected_group.size = [\n                    e.canvasX - this.selected_group.pos[0],\n                    e.canvasY - this.selected_group.pos[1],\n                ];\n            } else {\n                const deltax = delta[0] / this.ds.scale;\n                const deltay = delta[1] / this.ds.scale;\n                this.selected_group.move(deltax, deltay, e.ctrlKey);\n                if (this.selected_group._nodes.length) this.dirty_canvas = true;\n            }\n            this.dirty_bgcanvas = true;\n        } else if (this.dragging_canvas) {\n            this.ds.offset[0] += delta[0] / this.ds.scale;\n            this.ds.offset[1] += delta[1] / this.ds.scale;\n            this.dirty_canvas = true;\n            this.dirty_bgcanvas = true;\n        } else if (this.allow_interaction && !this.read_only) {\n            if (this.connecting_node) this.dirty_canvas = true;\n\n            // get node over\n            const node = this.graph.getNodeOnPos(e.canvasX, e.canvasY, this.visible_nodes);\n\n            // remove mouseover flag\n            for (const _node of this.graph._nodes) {\n                if (_node.mouseOver && node !== _node) {\n                    // mouse leave\n                    _node.mouseOver = false;\n                    if (this.node_over && this.node_over.onMouseLeave) {\n                        this.node_over.onMouseLeave(e);\n                    }\n                    this.node_over = null;\n                    this.dirty_canvas = true;\n                }\n            }\n\n            // mouse over a node\n            if (node) {\n                if (node.redraw_on_mouse) this.dirty_canvas = true;\n\n                // this.canvas.style.cursor = \"move\";\n                if (!node.mouseOver) {\n                    // mouse enter\n                    node.mouseOver = true;\n                    this.node_over = node;\n                    this.dirty_canvas = true;\n\n                    if (node.onMouseEnter) node.onMouseEnter(e);\n                }\n\n                // in case the node wants to do something\n                if (node.onMouseMove) {\n                    node.onMouseMove(e, [e.canvasX - node.pos[0], e.canvasY - node.pos[1]], this);\n                }\n\n                // if dragging a link\n                if (this.connecting_node) {\n                    const pos = this._highlight_input || [0, 0];\n\n                    // on top of input\n                    if (this.isOverNodeBox(node, e.canvasX, e.canvasY)) {\n                        // mouse on top of the corner box, don't know what to do\n                    } else {\n                        // check if I have a slot below de mouse\n                        const slot = this.isOverNodeInput(node, e.canvasX, e.canvasY, pos);\n                        if (slot !== -1 && node.inputs[slot]) {\n                            const slotType = node.inputs[slot].type;\n                            if (isValidConnection(this.connecting_output.type, slotType)) {\n                                this._highlight_input = pos;\n                            }\n                        } else this._highlight_input = null;\n                    }\n                }\n\n                // Search for corner\n                if (this.canvas) {\n                    if (isInsideRectangle(\n                        e.canvasX,\n                        e.canvasY,\n                        node.pos[0] + node.size[0] - 5,\n                        node.pos[1] + node.size[1] - 5,\n                        5,\n                        5,\n                    )) {\n                        this.canvas.style.cursor = \"se-resize\";\n                    } else this.canvas.style.cursor = \"crosshair\";\n                }\n            } else { // not over a node\n                // search for link connector\n                let overLink = null;\n                for (const link of this.visible_links) {\n                    const center = link._pos;\n                    if (!center\n                        || e.canvasX < center[0] - 4\n                        || e.canvasX > center[0] + 4\n                        || e.canvasY < center[1] - 4\n                        || e.canvasY > center[1] + 4) {\n                        continue;\n                    }\n                    overLink = link;\n                    break;\n                }\n                if (overLink !== this.over_link_center) {\n                    this.over_link_center = overLink;\n                    this.dirty_canvas = true;\n                }\n\n                if (this.canvas) this.canvas.style.cursor = \"\";\n            } // end\n\n            // send event to node if capturing input (used with widgets that allow drag outside of\n            // the area of the node)\n            if (this.node_capturing_input && this.node_capturing_input !== node && this.node_capturing_input.onMouseMove) {\n                this.node_capturing_input.onMouseMove(e, [e.canvasX - this.node_capturing_input.pos[0], e.canvasY - this.node_capturing_input.pos[1]], this);\n            }\n\n            // node being dragged\n            if (this.node_dragged && !this.live_mode) {\n                // console.log(\"draggin!\",this.selected_nodes);\n                for (const n of this.selected_nodes) {\n                    n.pos[0] += delta[0] / this.ds.scale;\n                    n.pos[1] += delta[1] / this.ds.scale;\n                }\n\n                this.dirty_canvas = true;\n                this.dirty_bgcanvas = true;\n            }\n\n            if (this.resizing_node && !this.live_mode) {\n                // convert mouse to node space\n                const desiredSize = [\n                    e.canvasX - this.resizing_node.pos[0],\n                    e.canvasY - this.resizing_node.pos[1],\n                ];\n                const minSize = this.resizing_node.computeSize();\n                desiredSize[0] = Math.max(minSize[0], desiredSize[0]);\n                desiredSize[1] = Math.max(minSize[1], desiredSize[1]);\n                this.resizing_node.setSize(desiredSize);\n\n                this.canvas.style.cursor = \"se-resize\";\n                this.dirty_canvas = true;\n                this.dirty_bgcanvas = true;\n            }\n        }\n\n        e.preventDefault();\n        return false;\n    }\n\n    /**\n     * Called when a mouse up event has to be processed\n     * @method processMouseUp\n     * */\n    processMouseUp(e) {\n        if (this.set_canvas_dirty_on_mouse_event) this.dirty_canvas = true;\n\n        if (!this.graph) return;\n\n        const window = this.getCanvasWindow();\n        const { document } = window;\n        LGraphCanvas.active_canvas = this;\n\n        // restore the mousemove event back to the canvas\n        document.removeEventListener(\"mousemove\", this._mousemove_callback, true);\n        this.canvas.addEventListener(\"mousemove\", this._mousemove_callback, true);\n        document.removeEventListener(\"mouseup\", this._mouseup_callback, true);\n\n        this.adjustMouseEvent(e);\n        const now = getTime();\n        e.click_time = now - this.last_mouseclick;\n        this.last_mouse_dragging = false;\n        this.last_click_position = null;\n\n        if (this.block_click) this.block_click = false;\n        // used to avoid sending twice a click in a immediate button\n\n        if (e.which === 1) {\n            if (this.node_widget) this.processNodeWidgets(this.node_widget[0], this.graph_mouse, e);\n\n            // left button\n            this.node_widget = null;\n\n            if (this.selected_group) {\n                const diffx = this.selected_group.pos[0]\n                    - Math.round(this.selected_group.pos[0]);\n                const diffy = this.selected_group.pos[1]\n                    - Math.round(this.selected_group.pos[1]);\n\n                this.selected_group.move(diffx, diffy, e.ctrlKey);\n\n                this.selected_group.pos[0] = Math.round(this.selected_group.pos[0]);\n                this.selected_group.pos[1] = Math.round(this.selected_group.pos[1]);\n\n                if (this.selected_group._nodes.length) this.dirty_canvas = true;\n                this.selected_group = null;\n            }\n            this.selected_group_resizing = false;\n\n            if (this.dragging_rectangle) {\n                if (this.graph) {\n                    const nodes = this.graph._nodes;\n                    const nodeBounding = new Float32Array(4);\n                    this.deselectAllNodes();\n                    // compute bounding and flip if left to right\n                    const w = Math.abs(this.dragging_rectangle[2]);\n                    const h = Math.abs(this.dragging_rectangle[3]);\n                    const startx = this.dragging_rectangle[2] < 0\n                        ? this.dragging_rectangle[0] - w\n                        : this.dragging_rectangle[0];\n                    const starty = this.dragging_rectangle[3] < 0\n                        ? this.dragging_rectangle[1] - h\n                        : this.dragging_rectangle[1];\n                    this.dragging_rectangle[0] = startx;\n                    this.dragging_rectangle[1] = starty;\n                    this.dragging_rectangle[2] = w;\n                    this.dragging_rectangle[3] = h;\n\n                    // test against all nodes (not visible because the rectangle maybe start outside\n                    const toSelect = [];\n\n                    for (const node of nodes) {\n                        node.getBounding(nodeBounding);\n                        if (\n                            !overlapBounding(\n                                this.dragging_rectangle,\n                                nodeBounding,\n                            )\n                        ) {\n                            continue;\n                        } // out of the visible area\n                        toSelect.push(node);\n                    }\n                    if (toSelect.length) {\n                        this.selectNodes(toSelect);\n                    }\n                }\n                this.dragging_rectangle = null;\n            } else if (this.connecting_node) {\n                // dragging a connection\n                this.dirty_canvas = true;\n                this.dirty_bgcanvas = true;\n\n                const node = this.graph.getNodeOnPos(\n                    e.canvasX,\n                    e.canvasY,\n                    this.visible_nodes,\n                );\n\n                // node below mouse\n                if (node) {\n                    if (\n                        this.connecting_output.type === defaultConfig.EVENT\n                        && this.isOverNodeBox(node, e.canvasX, e.canvasY)\n                    ) {\n                        this.connecting_node.connect(this.connecting_slot, node, defaultConfig.EVENT);\n                    } else {\n                        // slot below mouse? connect\n                        const slot = this.isOverNodeInput(node, e.canvasX, e.canvasY);\n                        if (slot !== -1) {\n                            this.connecting_node.connect(this.connecting_slot, node, slot);\n                        } else {\n                            // not on top of an input\n                            const input = node.getInputInfo(0);\n                            // auto connect\n                            if (this.connecting_output.type === defaultConfig.EVENT) {\n                                this.connecting_node.connect(\n                                    this.connecting_slot, node,\n                                    defaultConfig.EVENT,\n                                );\n                            } else if (\n                                input\n                                && !input.link\n                                && isValidConnection(\n                                    input.type && this.connecting_output.type,\n                                )\n                            ) {\n                                this.connecting_node.connect(this.connecting_slot, node, 0);\n                            }\n                        }\n                    }\n                }\n\n                this.connecting_output = null;\n                this.connecting_pos = null;\n                this.connecting_node = null;\n                this.connecting_slot = -1;\n            } else if (this.resizing_node) {\n                this.dirty_canvas = true;\n                this.dirty_bgcanvas = true;\n                this.graph.afterChange(this.resizing_node);\n                this.resizing_node = null;\n            } else if (this.node_dragged) {\n                // node being dragged?\n                const node = this.node_dragged;\n                if (\n                    node\n                    && e.click_time < 300\n                    && isInsideRectangle(\n                        e.canvasX,\n                        e.canvasY,\n                        node.pos[0],\n                        node.pos[1] - defaultConfig.NODE_TITLE_HEIGHT,\n                    defaultConfig.NODE_TITLE_HEIGHT,\n                    defaultConfig.NODE_TITLE_HEIGHT,\n                    )\n                ) {\n                    node.collapse();\n                }\n\n                this.dirty_canvas = true;\n                this.dirty_bgcanvas = true;\n                this.node_dragged.pos[0] = Math.round(this.node_dragged.pos[0]);\n                this.node_dragged.pos[1] = Math.round(this.node_dragged.pos[1]);\n                if (this.graph.config.align_to_grid) {\n                    this.node_dragged.alignToGrid();\n                }\n                if (this.onNodeMoved) this.onNodeMoved(this.node_dragged);\n                this.graph.afterChange(this.node_dragged);\n                this.node_dragged = null;\n            } else {\n                // get node over\n                const node = this.graph.getNodeOnPos(\n                    e.canvasX,\n                    e.canvasY,\n                    this.visible_nodes,\n                );\n\n                if (!node && e.click_time < 300) {\n                    this.deselectAllNodes();\n                }\n\n                this.dirty_canvas = true;\n                this.dragging_canvas = false;\n\n                if (this.node_over && this.node_over.onMouseUp) {\n                    this.node_over.onMouseUp(e, [e.canvasX - this.node_over.pos[0], e.canvasY - this.node_over.pos[1]], this);\n                }\n                if (\n                    this.node_capturing_input\n                    && this.node_capturing_input.onMouseUp\n                ) {\n                    this.node_capturing_input.onMouseUp(e, [\n                        e.canvasX - this.node_capturing_input.pos[0],\n                        e.canvasY - this.node_capturing_input.pos[1],\n                    ]);\n                }\n            }\n        } else if (e.which === 2) {\n            // middle button\n            // trace(\"middle\");\n            this.dirty_canvas = true;\n            this.dragging_canvas = false;\n        } else if (e.which === 3) {\n            // right button\n            // trace(\"right\");\n            this.dirty_canvas = true;\n            this.dragging_canvas = false;\n        }\n\n        this.graph.change();\n\n        e.stopPropagation();\n        e.preventDefault();\n        return false;\n    }\n\n    /**\n     * Called when a mouse wheel event has to be processed\n     * @method processMouseWheel\n     * */\n    processMouseWheel(e) {\n        if (!this.graph || !this.allow_dragcanvas) {\n            return;\n        }\n\n        const delta = e.wheelDeltaY ?? e.detail * -60;\n\n        this.adjustMouseEvent(e);\n\n        let { scale } = this.ds;\n\n        if (delta > 0) {\n            scale *= 1.1;\n        } else if (delta < 0) {\n            scale *= 1 / 1.1;\n        }\n\n        // this.setZoom( scale, [ e.localX, e.localY ] );\n        this.ds.changeScale(scale, [e.localX, e.localY]);\n\n        this.graph.change();\n\n        e.preventDefault();\n        return false; // prevent default\n    }\n\n    /**\n     * returns true if a position (in graph space) is on top of a node little corner box\n     * @method isOverNodeBox\n     * */\n    isOverNodeBox(node, canvasx, canvasy) {\n        const titleHeight = defaultConfig.NODE_TITLE_HEIGHT;\n        return !!isInsideRectangle(\n            canvasx,\n            canvasy,\n            node.pos[0] + 2,\n            node.pos[1] + 2 - titleHeight,\n            titleHeight - 4,\n            titleHeight - 4,\n        );\n    }\n\n    /**\n     * returns true if a position (in graph space) is on top of a node input slot\n     * @method isOverNodeInput\n     * */\n    isOverNodeInput(\n        node,\n        canvasx,\n        canvasy,\n        slotPos,\n    ) {\n        if (node.inputs) {\n            for (let i = 0, l = node.inputs.length; i < l; ++i) {\n                const linkPos = node.getConnectionPos(true, i);\n                let isInside = false;\n                if (node.horizontal) {\n                    isInside = isInsideRectangle(\n                        canvasx,\n                        canvasy,\n                        linkPos[0] - 5,\n                        linkPos[1] - 10,\n                        10,\n                        20,\n                    );\n                } else {\n                    isInside = isInsideRectangle(\n                        canvasx,\n                        canvasy,\n                        linkPos[0] - 10,\n                        linkPos[1] - 5,\n                        40,\n                        10,\n                    );\n                }\n                if (isInside) {\n                    if (slotPos) {\n                        slotPos[0] = linkPos[0];\n                        slotPos[1] = linkPos[1];\n                    }\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * process a key event\n     * @method processKey\n     * */\n    processKey(e) {\n        if (!this.graph) return;\n\n        let blockDefault = false;\n\n        if (e.target.localName === \"input\") {\n            return;\n        }\n\n        if (e.type === \"keydown\") {\n            if (e.keyCode === 32) {\n                // esc\n                this.dragging_canvas = true;\n                blockDefault = true;\n            }\n\n            // select all Control A\n            if (e.keyCode === 65 && e.ctrlKey) {\n                this.selectNodes();\n                blockDefault = true;\n            }\n\n            if (e.code === \"KeyC\" && (e.metaKey || e.ctrlKey) && !e.shiftKey) {\n                // copy\n                if (this.selected_nodes) {\n                    this.copyToClipboard();\n                    blockDefault = true;\n                }\n            }\n\n            if (e.code === \"KeyV\" && (e.metaKey || e.ctrlKey) && !e.shiftKey) {\n                // paste\n                this.pasteFromClipboard();\n            }\n\n            // delete or backspace\n            if ((e.keyCode === 46 || e.keyCode === 8)\n                && (e.target.localName !== \"input\" && e.target.localName !== \"textarea\")) {\n                this.deleteSelectedNodes();\n                blockDefault = true;\n            }\n\n            // collapse\n            // ...\n\n            // TODO\n            if (this.selected_nodes) {\n                for (var i in this.selected_nodes) {\n                    if (this.selected_nodes[i].onKeyDown) {\n                        this.selected_nodes[i].onKeyDown(e);\n                    }\n                }\n            }\n        } else if (e.type == \"keyup\") {\n            if (e.keyCode == 32) {\n                this.dragging_canvas = false;\n            }\n\n            if (this.selected_nodes) {\n                for (var i in this.selected_nodes) {\n                    if (this.selected_nodes[i].onKeyUp) {\n                        this.selected_nodes[i].onKeyUp(e);\n                    }\n                }\n            }\n        }\n\n        this.graph.change();\n\n        if (blockDefault) {\n            e.preventDefault();\n            e.stopImmediatePropagation();\n            return false;\n        }\n    }\n\n    pasteFromClipboard() {\n        const data = localStorage.getItem(\"litegrapheditor_clipboard\");\n        if (!data) return;\n\n        this.graph.beforeChange();\n\n        // create nodes\n        const clipboardInfo = JSON.parse(data);\n        const nodes = [];\n        for (const node_data of clipboardInfo.nodes) {\n            const node = LGraphNode.createNode(node_data.type);\n            if (node) {\n                node.configure(node_data);\n                node.pos[0] += 5;\n                node.pos[1] += 5;\n                this.graph.add(node);\n                nodes.push(node);\n            }\n        }\n\n        for (const link_info of clipboardInfo.links) {\n            const origin_node = nodes[link_info[0]];\n            const target_node = nodes[link_info[2]];\n            if (origin_node && target_node) origin_node.connect(link_info[1], target_node, link_info[3]);\n            else console.warn(\"Warning, nodes missing on pasting\");\n        }\n\n        this.selectNodes(nodes);\n\n        this.graph.afterChange();\n    }\n\n    copyToClipboard() {\n        const clipboardInfo = {\n            nodes: [],\n            links: [],\n        };\n        let index = 0;\n        const selectedNodesArray = [];\n\n        for (const selectedNode of this.selected_nodes) {\n            node._relative_id = index;\n            selectedNodesArray.push(node);\n            index += 1;\n        }\n\n        for (const node of selectedNodesArray) {\n            const cloned = node.clone();\n            if (!cloned) {\n                console.warn(`node type not found: ${node.type}`);\n                continue;\n            }\n            clipboardInfo.nodes.push(cloned.serialize());\n            if (node.inputs && node.inputs.length) {\n                for (let j = 0; j < node.inputs.length; ++j) {\n                    const input = node.inputs[j];\n                    if (!input || input.link == null) {\n                        continue;\n                    }\n                    const link_info = this.graph.links[input.link];\n                    if (!link_info) {\n                        continue;\n                    }\n                    const target_node = this.graph.getNodeById(\n                        link_info.origin_id,\n                    );\n                    if (!target_node || !this.selected_nodes[target_node.id]) {\n                        // improve this by allowing connections to non-selected nodes\n                        continue;\n                    } // not selected\n                    clipboardInfo.links.push([\n                        target_node._relative_id,\n                        link_info.origin_slot, // j,\n                        node._relative_id,\n                        link_info.target_slot,\n                    ]);\n                }\n            }\n        }\n\n        localStorage.setItem(\"litegrapheditor_clipboard\", JSON.stringify(clipboardInfo));\n    }\n\n    /**\n     * process a item drop event on top the canvas\n     * @method processDrop\n     * */\n    processDrop(e) {\n        e.preventDefault();\n        this.adjustMouseEvent(e);\n\n        const pos = [e.canvasX, e.canvasY];\n        const node = this.graph ? this.graph.getNodeOnPos(pos[0], pos[1]) : null;\n\n        if (!node) {\n            let r = null;\n            if (this.onDropItem) r = this.onDropItem(e);\n            if (!r) {\n                this.checkDropItem(e);\n            }\n            return;\n        }\n\n        if (node.onDropFile || node.onDropData) {\n            const { files } = e.dataTransfer;\n            if (files && files.length) {\n                for (const file of files) {\n                    const filename = file.name;\n                    // console.log(file);\n\n                    if (node.onDropFile) {\n                        node.onDropFile(file);\n                    }\n\n                    if (node.onDropData) {\n                        // prepare reader\n                        const reader = new FileReader();\n                        reader.onload = (event) => {\n                            // console.log(event.target);\n                            const data = event.target.result;\n                            node.onDropData(data, filename, file);\n                        };\n\n                        // read data\n                        const type = file.type.split(\"/\")[0];\n                        if (type === \"text\" || type === \"\") {\n                            reader.readAsText(file);\n                        } else if (type === \"image\") {\n                            reader.readAsDataURL(file);\n                        } else {\n                            reader.readAsArrayBuffer(file);\n                        }\n                    }\n                }\n            }\n        }\n\n        if (node.onDropItem) {\n            if (node.onDropItem(e)) {\n                return true;\n            }\n        }\n\n        if (this.onDropItem) {\n            return this.onDropItem(e);\n        }\n\n        return false;\n    }\n\n    checkDropItem(e) {\n        if (e.dataTransfer.files.length) {\n            const file = e.dataTransfer.files[0];\n            const ext = getFileExtension(file.name).toLowerCase();\n            const nodetype = defaultConfig.node_types_by_file_extension[ext];\n            if (nodetype) {\n                this.graph.beforeChange();\n                const node = LGraphNode.createNode(nodetype.type);\n                node.pos = [e.canvasX, e.canvasY];\n                this.graph.add(node);\n                if (node.onDropFile) {\n                    node.onDropFile(file);\n                }\n                this.graph.afterChange();\n            }\n        }\n    }\n\n    processNodeDblClicked(n) {\n        if (this.onShowNodePanel) this.onShowNodePanel(n);\n        else this.showShowNodePanel(n);\n\n        if (this.onNodeDblClicked) this.onNodeDblClicked(n);\n\n        this.setDirty(true);\n    }\n\n    processNodeSelected(node, e) {\n        this.selectNode(node, e && e.shiftKey);\n        if (this.onNodeSelected) {\n            this.onNodeSelected(node);\n        }\n    }\n\n    /**\n     * selects a given node (or adds it to the current selection)\n     * @method selectNode\n     * @param {LGraphNode} node\n     * @param {boolean} addToCurrentSelection\n     * */\n    selectNode(node, addToCurrentSelection) {\n        if (node == null) {\n            this.deselectAllNodes();\n        } else {\n            this.selectNodes([node], addToCurrentSelection);\n        }\n    }\n\n    /**\n     * selects several nodes (or adds them to the current selection)\n     * @method selectNodes\n     * */\n    selectNodes(nodes = this.graph._nodes, addToCurrentSelection) {\n        if (!addToCurrentSelection) this.deselectAllNodes();\n\n        for (const node of nodes) {\n            if (node.is_selected) continue;\n\n            if (!node.is_selected && node.onSelected) node.onSelected();\n            node.is_selected = true;\n            this.selected_nodes[node.id] = node;\n\n            if (node.inputs) {\n                for (const input of node.inputs) this.highlighted_links[input.link] = true;\n            }\n\n            if (node.outputs) {\n                for (const out of node.outputs) {\n                    if (out.links) {\n                        for (const link of out.links) this.highlighted_links[link] = true;\n                    }\n                }\n            }\n        }\n\n        if (this.onSelectionChange) this.onSelectionChange(this.selected_nodes);\n\n        this.setDirty(true);\n    }\n\n    /**\n     * removes a node from the current selection\n     * @method deselectNode\n     * */\n    deselectNode(node) {\n        if (!node.is_selected) return;\n        if (node.onDeselected) {\n            node.onDeselected();\n        }\n        node.is_selected = false;\n\n        if (this.onNodeDeselected) {\n            this.onNodeDeselected(node);\n        }\n\n        // remove highlighted\n        if (node.inputs) {\n            for (const input of node.inputs) delete this.highlighted_links[input.link];\n        }\n        if (node.outputs) {\n            for (const out of node.outputs) {\n                if (out.links) {\n                    for (const link of out.links) delete this.highlighted_links[link];\n                }\n            }\n        }\n    }\n\n    /**\n     * removes all nodes from the current selection\n     * @method deselectAllNodes\n     * */\n    deselectAllNodes() {\n        if (!this.graph) return;\n        for (const node of this.graph._nodes) {\n            if (!node.is_selected) {\n                continue;\n            }\n            if (node.onDeselected) {\n                node.onDeselected();\n            }\n            node.is_selected = false;\n            if (this.onNodeDeselected) {\n                this.onNodeDeselected(node);\n            }\n        }\n        this.selected_nodes = {};\n        this.current_node = null;\n        this.highlighted_links = {};\n        if (this.onSelectionChange) this.onSelectionChange(this.selected_nodes);\n        this.setDirty(true);\n    }\n\n    /**\n     * deletes all nodes in the current selection from the graph\n     * @method deleteSelectedNodes\n     * */\n    deleteSelectedNodes() {\n        this.graph.beforeChange();\n\n        // eslint-disable-next-line guard-for-in, no-restricted-syntax\n        for (const i in this.selected_nodes) {\n            const node = this.selected_nodes[i];\n\n            if (node.block_delete) continue;\n\n            // autoconnect when possible (very basic, only takes into account first input-output)\n            if (node.inputs\n                && node.inputs.length\n                && node.outputs\n                && node.outputs.length\n                && isValidConnection(node.inputs[0].type, node.outputs[0].type)\n                && node.inputs[0].link\n                && node.outputs[0].links\n                && node.outputs[0].links.length) {\n                const inputLink = node.graph.links[node.inputs[0].link];\n                const outputLink = node.graph.links[node.outputs[0].links[0]];\n                const inputNode = node.getInputNode(0);\n                const outputNode = node.getOutputNodes(0)[0];\n                if (inputNode && outputNode) {\n                    inputNode.connect(inputLink.origin_slot, outputNode, outputLink.target_slot);\n                }\n            }\n            this.graph.remove(node);\n            if (this.onNodeDeselected) this.onNodeDeselected(node);\n        }\n\n        this.selected_nodes = {};\n        this.current_node = null;\n        this.highlighted_links = {};\n        this.setDirty(true);\n        this.graph.afterChange();\n    }\n\n    /**\n     * centers the camera on a given node\n     * @method centerOnNode\n     * */\n    centerOnNode(node) {\n        this.ds.offset[0] = -node.pos[0]\n            - node.size[0] * 0.5\n            + (this.canvas.width * 0.5) / this.ds.scale;\n        this.ds.offset[1] = -node.pos[1]\n            - node.size[1] * 0.5\n            + (this.canvas.height * 0.5) / this.ds.scale;\n        this.setDirty(true, true);\n    }\n\n    /**\n     * adds some useful properties to a mouse event, like the position in graph coordinates\n     * @method adjustMouseEvent\n     * */\n    adjustMouseEvent(e) {\n        if (this.canvas) {\n            const b = this.canvas.getBoundingClientRect();\n            e.localX = e.clientX - b.left;\n            e.localY = e.clientY - b.top;\n        } else {\n            e.localX = e.clientX;\n            e.localY = e.clientY;\n        }\n\n        e.deltaX = e.localX - this.last_mouse_position[0];\n        e.deltaY = e.localY - this.last_mouse_position[1];\n\n        this.last_mouse_position[0] = e.localX;\n        this.last_mouse_position[1] = e.localY;\n\n        e.canvasX = e.localX / this.ds.scale - this.ds.offset[0];\n        e.canvasY = e.localY / this.ds.scale - this.ds.offset[1];\n    }\n\n    /**\n     * changes the zoom level of the graph (default is 1), you can pass also a place used to pivot\n     * the zoom\n     * @method setZoom\n     * */\n    setZoom(value, zoomingCenter) {\n        this.ds.changeScale(value, zoomingCenter);\n        this.dirty_canvas = true;\n        this.dirty_bgcanvas = true;\n    }\n\n    /**\n     * converts a coordinate from graph coordinates to canvas2D coordinates\n     * @method convertOffsetToCanvas\n     * */\n    convertOffsetToCanvas(pos) {\n        return this.ds.convertOffsetToCanvas(pos);\n    }\n\n    /**\n     * converts a coordinate from Canvas2D coordinates to graph space\n     * @method convertCanvasToOffset\n     * */\n    convertCanvasToOffset(pos, out) {\n        return this.ds.convertCanvasToOffset(pos, out);\n    }\n\n    /**\n     * converts event coordinates from canvas2D to graph coordinates\n     * @method convertEventToCanvasOffset\n     * @param e\n     * @returns {Array}\n     */\n    convertEventToCanvasOffset(e) {\n        const rect = this.canvas.getBoundingClientRect();\n        return this.convertCanvasToOffset([e.clientX - rect.left, e.clientY - rect.top]);\n    }\n\n    /**\n     * brings a node to front (above all other nodes)\n     * @method bringToFront\n     * @param {LGraphNode} node\n     * */\n    bringToFront(node) {\n        const i = this.graph._nodes.indexOf(node);\n        if (i === -1) {\n            return;\n        }\n\n        this.graph._nodes.splice(i, 1);\n        this.graph._nodes.push(node);\n    }\n\n    /**\n     * sends a node to the back (below all other nodes)\n     * @method sendToBack\n     * @param {LGraphNode} node\n     * */\n    sendToBack(node) {\n        const i = this.graph._nodes.indexOf(node);\n        if (i === -1) {\n            return;\n        }\n\n        this.graph._nodes.splice(i, 1);\n        this.graph._nodes.unshift(node);\n    }\n\n    /**\n     * checks which nodes are visible (inside the camera area)\n     * @method computeVisibleNodes\n     * @param {LGraphNode[]} [nodes]\n     * @param {LGraphNode[]} [out]\n     * @return {LGraphNode[]}\n     * */\n    computeVisibleNodes(nodes = this.graph._nodes, out) {\n        const visibleNodes = out || [];\n        visibleNodes.length = 0;\n        for (const n of nodes) {\n            console.log(nodes, this.graph._nodes)\n            // skip rendering nodes in live mode\n            if (this.live_mode && !n.onDrawBackground && !n.onDrawForeground) {\n                continue;\n            }\n\n            if (!overlapBounding(this.visible_area, n.getBounding(temp))) {\n                continue;\n            } // out of the visible area\n\n            visibleNodes.push(n);\n        }\n        return visibleNodes;\n    }\n\n    /**\n     * renders the whole canvas content, by rendering in two separated canvas, one containing the\n     * background grid and the connections, and one containing the nodes)\n     * @method draw\n     * @param {boolean} [force_canvas]\n     * @param {boolean} [force_bgcanvas]\n     * */\n    draw(force_canvas, force_bgcanvas) {\n        if (!this.canvas || this.canvas.width === 0 || this.canvas.height === 0) return;\n\n        // fps counting\n        const now = getTime();\n        this.render_time = (now - this.last_draw_time) * 0.001;\n        this.last_draw_time = now;\n\n        if (this.graph) this.ds.computeVisibleArea();\n\n        if (\n            this.dirty_bgcanvas\n            || force_bgcanvas\n            || this.always_render_background\n            || (this.graph\n            && this.graph._last_trigger_time\n            && now - this.graph._last_trigger_time < 1000)\n        ) this.drawBackCanvas();\n\n        if (this.dirty_canvas || force_canvas) this.drawFrontCanvas();\n\n        this.fps = this.render_time ? 1.0 / this.render_time : 0;\n        this.frame += 1;\n    }\n\n    /**\n     * draws the front canvas (the one containing all the nodes)\n     * @method drawFrontCanvas\n     * */\n    drawFrontCanvas() {\n        this.dirty_canvas = false;\n\n        if (!this.ctx) this.ctx = this.bgcanvas.getContext(\"2d\");\n        const { ctx } = this;\n        if (!ctx) return;\n\n        if (ctx.start2D) {\n            ctx.start2D();\n        }\n\n        const { canvas } = this;\n\n        // reset in case of error\n        ctx.restore();\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n\n        // clip dirty area if there is one, otherwise work in full canvas\n        if (this.dirty_area) {\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect(\n                this.dirty_area[0],\n                this.dirty_area[1],\n                this.dirty_area[2],\n                this.dirty_area[3],\n            );\n            ctx.clip();\n        }\n\n        if (this.clear_background) ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n        // draw bg canvas\n        if (this.bgcanvas === this.canvas) {\n            this.drawBackCanvas();\n        } else {\n            ctx.drawImage(this.bgcanvas, 0, 0);\n        }\n\n        // rendering\n        if (this.onRender) this.onRender(canvas, ctx);\n\n        // info widget\n        if (this.show_info) this.renderInfo(ctx);\n\n        if (this.graph) {\n            // apply transformations\n            ctx.save();\n            this.ds.toCanvasContext(ctx);\n\n            // draw nodes\n            let drawnNodes = 0;\n            const visibleNodes = this.computeVisibleNodes(null, this.visible_nodes);\n\n            for (const node of visibleNodes) {\n                // transform coords system\n                ctx.save();\n                ctx.translate(node.pos[0], node.pos[1]);\n\n                // Draw\n                this.drawNode(node, ctx);\n                drawnNodes += 1;\n\n                // Restore\n                ctx.restore();\n            }\n\n            // on top (debug)\n            if (this.render_execution_order) this.drawExecutionOrder(ctx);\n\n            // connections ontop?\n            if (this.graph.config.links_ontop && !this.live_mode) this.drawConnections(ctx);\n\n            // current connection (the one being dragged by the mouse)\n            if (this.connecting_pos !== null) {\n                ctx.lineWidth = this.connections_width;\n                let linkColor = null;\n\n                switch (this.connecting_output.type) {\n                    case defaultConfig.EVENT:\n                        linkColor = defaultConfig.EVENT_LINK_COLOR;\n                        break;\n                    default:\n                        linkColor = defaultConfig.CONNECTING_LINK_COLOR;\n                }\n\n                // the connection being dragged by the mouse\n                this.renderLink(\n                    ctx,\n                    this.connecting_pos,\n                    [this.graph_mouse[0], this.graph_mouse[1]],\n                    null,\n                    false,\n                    null,\n                    linkColor,\n                    this.connecting_output.dir\n                    || (this.connecting_node.horizontal ? defaultConfig.DOWN : defaultConfig.RIGHT),\n                    defaultConfig.CENTER,\n                );\n\n                ctx.beginPath();\n                if (\n                    this.connecting_output.type === defaultConfig.EVENT\n                    || this.connecting_output.shape === defaultConfig.BOX_SHAPE\n                ) {\n                    ctx.rect(\n                        this.connecting_pos[0] - 6 + 0.5,\n                        this.connecting_pos[1] - 5 + 0.5,\n                        14,\n                        10,\n                    );\n                } else {\n                    ctx.arc(\n                        this.connecting_pos[0],\n                        this.connecting_pos[1],\n                        4,\n                        0,\n                        Math.PI * 2,\n                    );\n                }\n                ctx.fill();\n\n                ctx.fillStyle = \"#ffcc00\";\n                if (this._highlight_input) {\n                    ctx.beginPath();\n                    ctx.arc(\n                        this._highlight_input[0],\n                        this._highlight_input[1],\n                        6,\n                        0,\n                        Math.PI * 2,\n                    );\n                    ctx.fill();\n                }\n            }\n\n            // the selection rectangle\n            if (this.dragging_rectangle) {\n                ctx.strokeStyle = \"#FFF\";\n                ctx.strokeRect(\n                    this.dragging_rectangle[0],\n                    this.dragging_rectangle[1],\n                    this.dragging_rectangle[2],\n                    this.dragging_rectangle[3],\n                );\n            }\n\n            // on top of link center\n            if (this.over_link_center && this.render_link_tooltip) {\n                this.drawLinkTooltip(ctx, this.over_link_center);\n            } else if (this.onDrawLinkTooltip) {\n                this.onDrawLinkTooltip(ctx, null);\n            }\n\n            // custom info\n            if (this.onDrawForeground) {\n                this.onDrawForeground(ctx, this.visible_rect);\n            }\n\n            ctx.restore();\n        }\n\n        // draws panel in the corner\n        if (this._graph_stack && this._graph_stack.length) this.drawSubgraphPanel(ctx);\n\n        if (this.onDrawOverlay) this.onDrawOverlay(ctx);\n\n        if (this.dirty_area) ctx.restore();\n\n        if (ctx.finish2D) ctx.finish2D();\n    }\n\n    /**\n     * draws the panel in the corner that shows subgraph properties\n     * @method drawSubgraphPanel\n     * */\n    drawSubgraphPanel(ctx) {\n        const subgraph = this.graph;\n        const subnode = subgraph._subgraph_node;\n        if (!subnode) {\n            console.warn(\"subgraph without subnode\");\n            return;\n        }\n\n        const num = subnode.inputs ? subnode.inputs.length : 0;\n        const w = 300;\n        const h = Math.floor(defaultConfig.NODE_SLOT_HEIGHT * 1.6);\n\n        ctx.fillStyle = \"#111\";\n        ctx.globalAlpha = 0.8;\n        ctx.beginPath();\n        ctx.roundRect(10, 10, w, (num + 1) * h + 50, 8);\n        ctx.fill();\n        ctx.globalAlpha = 1;\n\n        ctx.fillStyle = \"#888\";\n        ctx.font = \"14px Arial\";\n        ctx.textAlign = \"left\";\n        ctx.fillText(\"Graph Inputs\", 20, 34);\n\n        if (this.drawButton(w - 20, 20, 20, 20, \"X\", \"#151515\")) {\n            this.closeSubgraph();\n            return;\n        }\n\n        let y = 50;\n        ctx.font = \"20px Arial\";\n        if (subnode.inputs) {\n            for (const input of subnode.inputs) {\n                if (input.not_subgraph_input) continue;\n\n                // input button clicked\n                if (this.drawButton(20, y + 2, w - 20, h - 2)) {\n                    const type = subnode.constructor.input_node_type || \"graph/input\";\n                    this.graph.beforeChange();\n                    const newnode = createNode(type);\n                    if (newnode) {\n                        subgraph.add(newnode);\n                        this.block_click = false;\n                        this.last_click_position = null;\n                        this.selectNodes([newnode]);\n                        this.node_dragged = newnode;\n                        this.dragging_canvas = false;\n                        newnode.setProperty(\"name\", input.name);\n                        newnode.setProperty(\"type\", input.type);\n                        this.node_dragged.pos[0] = this.graph_mouse[0] - 5;\n                        this.node_dragged.pos[1] = this.graph_mouse[1] - 5;\n                        this.graph.afterChange();\n                    } else {\n                        console.error(\"graph input node not found:\", type);\n                    }\n                }\n\n                ctx.fillStyle = \"#9C9\";\n                ctx.beginPath();\n                ctx.arc(w - 16, y + h * 0.5, 5, 0, 2 * Math.PI);\n                ctx.fill();\n\n                ctx.fillStyle = \"#AAA\";\n                ctx.fillText(input.name, 50, y + h * 0.75);\n                const tw = ctx.measureText(input.name);\n                ctx.fillStyle = \"#777\";\n                ctx.fillText(input.type, 50 + tw.width + 10, y + h * 0.75);\n\n                y += h;\n            }\n        }\n\n        // add + button\n        if (this.drawButton(20, y + 2, w - 20, h - 2, \"+\", \"#151515\", \"#222\")) {\n            this.showSubgraphPropertiesDialog(subnode);\n        }\n    }\n\n    /**\n     * Draws a button into the canvas overlay and computes if it was clicked using the immediate\n     * gui paradigm\n     * @method drawButton\n     * @param x\n     * @param y\n     * @param w\n     * @param h\n     * @param text\n     * @param [bgcolor]\n     * @param [hovercolor]\n     * @param [textcolor]\n     * @returns {*|boolean}\n     */\n    drawButton(x, y, w, h, text, bgcolor = defaultConfig.NODE_DEFAULT_COLOR, hovercolor = \"#555\", textcolor = defaultConfig.NODE_TEXT_COLOR) {\n        const { ctx } = this;\n\n        let pos = this.mouse;\n        const hover = isInsideRectangle(pos[0], pos[1], x, y, w, h);\n        pos = this.last_click_position;\n        const clicked = pos && isInsideRectangle(pos[0], pos[1], x, y, w, h);\n\n        ctx.fillStyle = hover ? hovercolor : bgcolor;\n        if (clicked) ctx.fillStyle = \"#AAA\";\n        ctx.beginPath();\n        ctx.roundRect(x, y, w, h, 4);\n        ctx.fill();\n\n        if (text !== null) {\n            if (text.constructor === String) {\n                ctx.fillStyle = textcolor;\n                ctx.textAlign = \"center\";\n                // eslint-disable-next-line\n                ctx.font = `${(h * 0.65) | 0}px Arial`;\n                ctx.fillText(text, x + w * 0.5, y + h * 0.75);\n                ctx.textAlign = \"left\";\n            }\n        }\n\n        if (clicked) this.blockClick();\n        return clicked && !this.block_click;\n    }\n\n    isAreaClicked(x, y, w, h, holdClick) {\n        const pos = this.last_click_position;\n        const clicked = pos && isInsideRectangle(pos[0], pos[1], x, y, w, h);\n        if (clicked && holdClick) this.blockClick();\n        return clicked && !this.block_click;\n    }\n\n    /**\n     * draws some useful stats in the corner of the canvas\n     * @method renderInfo\n     * */\n    renderInfo(ctx, x = 10, y = this.canvas.height - 80) {\n        ctx.save();\n        ctx.translate(x, y);\n\n        ctx.font = \"10px Arial\";\n        ctx.fillStyle = \"#888\";\n        if (this.graph) {\n            ctx.fillText(`T: ${this.graph.globaltime.toFixed(2)}s`, 5, 13);\n            ctx.fillText(`I: ${this.graph.iteration}`, 5, 13 * 2);\n            ctx.fillText(`N: ${this.graph._nodes.length} [${this.visible_nodes.length}]`, 5, 13 * 3);\n            ctx.fillText(`V: ${this.graph._version}`, 5, 13 * 4);\n            ctx.fillText(`FPS:${this.fps.toFixed(2)}`, 5, 13 * 5);\n        } else {\n            ctx.fillText(\"No graph selected\", 5, 13);\n        }\n        ctx.restore();\n    }\n\n    /**\n     * draws the back canvas (the one containing the background and the connections)\n     * @method drawBackCanvas\n     * */\n    drawBackCanvas() {\n        const canvas = this.bgcanvas;\n        if (canvas.width !== this.canvas.width || canvas.height !== this.canvas.height) {\n            canvas.width = this.canvas.width;\n            canvas.height = this.canvas.height;\n        }\n\n        if (!this.bgctx) this.bgctx = this.bgcanvas.getContext(\"2d\");\n        const ctx = this.bgctx;\n        if (ctx.start) ctx.start();\n\n        // clear\n        if (this.clear_background) ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n        if (this._graph_stack && this._graph_stack.length) {\n            ctx.save();\n            const subgraphNode = this.graph._subgraph_node;\n            ctx.strokeStyle = subgraphNode.bgcolor;\n            ctx.lineWidth = 10;\n            ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);\n            ctx.lineWidth = 1;\n            ctx.font = \"40px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.fillStyle = subgraphNode.bgcolor || \"#AAA\";\n            let title = \"\";\n\n            for (const g of this._graph_stack) title += `${g._subgraph_node.getTitle()} >> `;\n\n            ctx.fillText(\n                title + subgraphNode.getTitle(),\n                canvas.width * 0.5,\n                40,\n            );\n            ctx.restore();\n        }\n\n        let bgAlreadyPainted = false;\n        if (this.onRenderBackground) {\n            bgAlreadyPainted = this.onRenderBackground(canvas, ctx);\n        }\n\n        // reset in case of error\n        ctx.restore();\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        this.visible_links.length = 0;\n\n        if (this.graph) {\n            // apply transformations\n            ctx.save();\n            this.ds.toCanvasContext(ctx);\n\n            // render BG\n            if (this.background_image && this.ds.scale > 0.5 && !bgAlreadyPainted) {\n                ctx.globalAlpha = this.zoom_modify_alpha\n                    ? (1.0 - 0.5 / this.ds.scale) * this.editor_alpha\n                    : this.editor_alpha;\n\n                ctx.imageSmoothingEnabled = false;\n                ctx.mozImageSmoothingEnabled = false;\n                ctx.imageSmoothingEnabled = false;\n                if (\n                    !this._bg_img\n                    || this._bg_img.id !== this.background_image\n                ) {\n                    this._bg_img = new Image();\n                    this._bg_img.id = this.background_image;\n                    this._bg_img.src = this.background_image;\n                    this._bg_img.onload = () => this.draw(true, true);\n                }\n\n                let pattern = null;\n                if (this._pattern == null && this._bg_img.width > 0) {\n                    pattern = ctx.createPattern(this._bg_img, \"repeat\");\n                    this._pattern_img = this._bg_img;\n                    this._pattern = pattern;\n                } else {\n                    pattern = this._pattern;\n                }\n                if (pattern) {\n                    ctx.fillStyle = pattern;\n                    ctx.fillRect(\n                        this.visible_area[0],\n                        this.visible_area[1],\n                        this.visible_area[2],\n                        this.visible_area[3],\n                    );\n                    ctx.fillStyle = \"transparent\";\n                }\n\n                ctx.globalAlpha = 1.0;\n                ctx.imageSmoothingEnabled = true;\n                ctx.mozImageSmoothingEnabled = true;\n                ctx.imageSmoothingEnabled = true;\n            }\n\n            // groups\n            if (this.graph._groups.length && !this.live_mode) this.drawGroups(canvas, ctx);\n\n            if (this.onDrawBackground) this.onDrawBackground(ctx, this.visible_area);\n\n            // bg\n            if (this.render_canvas_border) {\n                ctx.strokeStyle = \"#235\";\n                ctx.strokeRect(0, 0, canvas.width, canvas.height);\n            }\n\n            if (this.render_connections_shadows) {\n                ctx.shadowColor = \"#000\";\n                ctx.shadowOffsetX = 0;\n                ctx.shadowOffsetY = 0;\n                ctx.shadowBlur = 6;\n            } else {\n                ctx.shadowColor = \"rgba(0,0,0,0)\";\n            }\n\n            // draw connections\n            if (!this.live_mode) this.drawConnections(ctx);\n\n            ctx.shadowColor = \"rgba(0,0,0,0)\";\n\n            ctx.restore();\n        }\n\n        if (ctx.finish) ctx.finish();\n\n        this.dirty_bgcanvas = false;\n        this.dirty_canvas = true; // to force to repaint the front canvas with the bgcanvas\n    }\n\n    /**\n     * draws the given node inside the canvas\n     * @method drawNode\n     * */\n    drawNode(node, ctx) {\n        let glow = false;\n        this.current_node = node;\n\n        const color = node.color || node.constructor.color || defaultConfig.NODE_DEFAULT_COLOR;\n        let bgcolor = node.bgcolor || node.constructor.bgcolor || defaultConfig.NODE_DEFAULT_BGCOLOR;\n\n        // shadow and glow\n        if (node.mouseOver) glow = true;\n\n        const lowQuality = this.ds.scale < 0.6; // zoomed out\n\n        // only render if it forces it to do it\n        if (this.live_mode) {\n            if (!node.flags.collapsed) {\n                ctx.shadowColor = \"transparent\";\n                if (node.onDrawForeground) {\n                    node.onDrawForeground(ctx, this, this.canvas);\n                }\n            }\n            return;\n        }\n\n        ctx.globalAlpha = this.editor_alpha;\n\n        if (this.render_shadows && !lowQuality) {\n            ctx.shadowColor = defaultConfig.DEFAULT_SHADOW_COLOR;\n            ctx.shadowOffsetX = 2 * this.ds.scale;\n            ctx.shadowOffsetY = 2 * this.ds.scale;\n            ctx.shadowBlur = 3 * this.ds.scale;\n        } else {\n            ctx.shadowColor = \"transparent\";\n        }\n\n        // custom draw collapsed method (draw after shadows because they are affected)\n        if (node.flags.collapsed\n            && node.onDrawCollapsed\n            && node.onDrawCollapsed(ctx, this) == true\n        ) {\n            return;\n        }\n\n        // clip if required (mask)\n        const shape = node._shape || defaultConfig.BOX_SHAPE;\n        const size = tempVC2;\n        tempVC2.set(node.size);\n        const { horizontal } = node; // || node.flags.horizontal;\n\n        if (node.flags.collapsed) {\n            ctx.font = this.inner_text_font;\n            const title = node.getTitle ? node.getTitle() : node.title;\n            if (title !== null) {\n                node._collapsed_width = Math.min(\n                    node.size[0],\n                    ctx.measureText(title).width\n                    + defaultConfig.NODE_TITLE_HEIGHT * 2,\n                ); // LiteGraph.NODE_COLLAPSED_WIDTH;\n                size[0] = node._collapsed_width;\n                size[1] = 0;\n            }\n        }\n\n        if (node.clip_area) {\n            // Start clipping\n            ctx.save();\n            ctx.beginPath();\n            if (shape === defaultConfig.BOX_SHAPE) ctx.rect(0, 0, size[0], size[1]);\n            else if (shape === defaultConfig.ROUND_SHAPE) ctx.roundRect(0, 0, size[0], size[1], 10);\n            else if (shape === defaultConfig.CIRCLE_SHAPE) {\n                ctx.arc(\n                    size[0] * 0.5,\n                    size[1] * 0.5,\n                    size[0] * 0.5,\n                    0,\n                    Math.PI * 2,\n                );\n            }\n            ctx.clip();\n        }\n\n        // draw shape\n        if (node.has_errors) bgcolor = \"red\";\n        this.drawNodeShape(\n            node,\n            ctx,\n            size,\n            color,\n            bgcolor,\n            node.is_selected,\n            node.mouseOver,\n        );\n        ctx.shadowColor = \"transparent\";\n\n        // draw foreground\n        if (node.onDrawForeground) {\n            node.onDrawForeground(ctx, this, this.canvas);\n        }\n\n        // connection slots\n        ctx.textAlign = horizontal ? \"center\" : \"left\";\n        ctx.font = this.inner_text_font;\n\n        const renderText = !lowQuality;\n\n        const outSlot = this.connecting_output;\n        ctx.lineWidth = 1;\n\n        let maxY = 0;\n        const slotPos = new Float32Array(2); // to reuse\n\n        // render inputs and outputs\n        if (!node.flags.collapsed) {\n            // input connection slots\n            if (node.inputs) {\n                for (let i = 0; i < node.inputs.length; i++) {\n                    const slot = node.inputs[i];\n\n                    ctx.globalAlpha = this.editor_alpha;\n                    // change opacity of incompatible slots when dragging a connection\n                    if (this.connecting_node\n                        && !isValidConnection(slot.type, outSlot.type)) {\n                        ctx.globalAlpha = 0.4 * this.editor_alpha;\n                    }\n\n                    ctx.fillStyle = slot.link\n                        ? slot.color_on\n                        || this.default_connection_color.input_on\n                        : slot.color_off\n                        || this.default_connection_color.input_off;\n\n                    const pos = node.getConnectionPos(true, i, slotPos);\n                    pos[0] -= node.pos[0];\n                    pos[1] -= node.pos[1];\n                    if (maxY < pos[1] + defaultConfig.NODE_SLOT_HEIGHT * 0.5) {\n                        maxY = pos[1] + defaultConfig.NODE_SLOT_HEIGHT * 0.5;\n                    }\n\n                    ctx.beginPath();\n\n                    if (slot.type === defaultConfig.EVENT || slot.shape === defaultConfig.BOX_SHAPE) {\n                        if (horizontal) ctx.rect(pos[0] - 5 + 0.5, pos[1] - 8 + 0.5, 10, 14);\n                        else ctx.rect(pos[0] - 6 + 0.5, pos[1] - 5 + 0.5, 14, 10);\n                    } else if (slot.shape === defaultConfig.ARROW_SHAPE) {\n                        ctx.moveTo(pos[0] + 8, pos[1] + 0.5);\n                        ctx.lineTo(pos[0] - 4, pos[1] + 6 + 0.5);\n                        ctx.lineTo(pos[0] - 4, pos[1] - 6 + 0.5);\n                        ctx.closePath();\n                    } else if (lowQuality) {\n                        ctx.rect(pos[0] - 4, pos[1] - 4, 8, 8);\n                    } else {\n                        ctx.arc(pos[0], pos[1], 4, 0, Math.PI * 2);\n                    }\n                    ctx.fill();\n\n                    // render name\n                    if (renderText) {\n                        const text = slot.label !== null ? slot.label : slot.name;\n                        if (text) {\n                            ctx.fillStyle = defaultConfig.NODE_TEXT_COLOR;\n                            if (horizontal || slot.dir === defaultConfig.UP) {\n                                ctx.fillText(text, pos[0], pos[1] - 10);\n                            } else {\n                                ctx.fillText(text, pos[0] + 10, pos[1] + 5);\n                            }\n                        }\n                    }\n                }\n            }\n\n            // output connection slots\n            if (this.connecting_node) {\n                ctx.globalAlpha = 0.4 * this.editor_alpha;\n            }\n\n            ctx.textAlign = horizontal ? \"center\" : \"right\";\n            ctx.strokeStyle = \"black\";\n            if (node.outputs) {\n                for (let i = 0; i < node.outputs.length; i++) {\n                    const slot = node.outputs[i];\n\n                    const pos = node.getConnectionPos(false, i, slotPos);\n                    pos[0] -= node.pos[0];\n                    pos[1] -= node.pos[1];\n                    if (maxY < pos[1] + defaultConfig.NODE_SLOT_HEIGHT * 0.5) {\n                        maxY = pos[1] + defaultConfig.NODE_SLOT_HEIGHT * 0.5;\n                    }\n\n                    ctx.fillStyle = slot.links && slot.links.length\n                        ? slot.color_on\n                        || this.default_connection_color.output_on\n                        : slot.color_off\n                        || this.default_connection_color.output_off;\n                    ctx.beginPath();\n                    // ctx.rect( node.size[0] - 14,i*14,10,10);\n\n                    if (\n                        slot.type === defaultConfig.EVENT\n                        || slot.shape === defaultConfig.BOX_SHAPE\n                    ) {\n                        if (horizontal) {\n                            ctx.rect(\n                                pos[0] - 5 + 0.5,\n                                pos[1] - 8 + 0.5,\n                                10,\n                                14,\n                            );\n                        } else {\n                            ctx.rect(\n                                pos[0] - 6 + 0.5,\n                                pos[1] - 5 + 0.5,\n                                14,\n                                10,\n                            );\n                        }\n                    } else if (slot.shape === defaultConfig.ARROW_SHAPE) {\n                        ctx.moveTo(pos[0] + 8, pos[1] + 0.5);\n                        ctx.lineTo(pos[0] - 4, pos[1] + 6 + 0.5);\n                        ctx.lineTo(pos[0] - 4, pos[1] - 6 + 0.5);\n                        ctx.closePath();\n                    } else if (lowQuality) {\n                        ctx.rect(pos[0] - 4, pos[1] - 4, 8, 8);\n                    } else {\n                        ctx.arc(pos[0], pos[1], 4, 0, Math.PI * 2);\n                    }\n\n                    ctx.fill();\n                    if (!lowQuality) ctx.stroke();\n\n                    // render output name\n                    if (renderText) {\n                        const text = slot.label != null ? slot.label : slot.name;\n                        if (text) {\n                            ctx.fillStyle = defaultConfig.NODE_TEXT_COLOR;\n                            if (horizontal || slot.dir === defaultConfig.DOWN) {\n                                ctx.fillText(text, pos[0], pos[1] - 8);\n                            } else {\n                                ctx.fillText(text, pos[0] - 10, pos[1] + 5);\n                            }\n                        }\n                    }\n                }\n            }\n\n            ctx.textAlign = \"left\";\n            ctx.globalAlpha = 1;\n\n            if (node.widgets) {\n                let widgetsY = maxY;\n                if (horizontal || node.widgets_up) widgetsY = 2;\n                if (node.widgets_start_y !== null) widgetsY = node.widgets_start_y;\n                this.drawNodeWidgets(\n                    node,\n                    widgetsY,\n                    ctx,\n                    this.node_widget && this.node_widget[0] === node ? this.node_widget[1] : null,\n                );\n            }\n        } else if (this.render_collapsed_slots) {\n            // if collapsed\n            let inputSlot = null;\n            let outputSlot = null;\n            let storedSlot;\n\n            // get first connected slot to render\n            if (node.inputs) {\n                for (const slot of node.inputs) {\n                    if (slot.link == null) continue;\n                    inputSlot = slot;\n                    storedSlot = slot;\n                    break;\n                }\n            }\n            if (node.outputs) {\n                for (const slot of node.outputs) {\n                    if (!slot.links || !slot.links.length) continue;\n                    outputSlot = slot;\n                    storedSlot = slot;\n                }\n            }\n\n            if (inputSlot) {\n                let x = 0;\n                let y = defaultConfig.NODE_TITLE_HEIGHT * -0.5; // center\n                if (horizontal) {\n                    x = node._collapsed_width * 0.5;\n                    y = -defaultConfig.NODE_TITLE_HEIGHT;\n                }\n                ctx.fillStyle = \"#686\";\n                ctx.beginPath();\n                if (storedSlot.type === defaultConfig.EVENT\n                    || storedSlot.shape === defaultConfig.BOX_SHAPE) {\n                    ctx.rect(x - 7 + 0.5, y - 4, 14, 8);\n                } else if (storedSlot.shape === defaultConfig.ARROW_SHAPE) {\n                    ctx.moveTo(x + 8, y);\n                    ctx.lineTo(x + -4, y - 4);\n                    ctx.lineTo(x + -4, y + 4);\n                    ctx.closePath();\n                } else ctx.arc(x, y, 4, 0, Math.PI * 2);\n                ctx.fill();\n            }\n\n            if (outputSlot) {\n                let x = node._collapsed_width;\n                let y = defaultConfig.NODE_TITLE_HEIGHT * -0.5; // center\n                if (horizontal) {\n                    x = node._collapsed_width * 0.5;\n                    y = 0;\n                }\n                ctx.fillStyle = \"#686\";\n                ctx.strokeStyle = \"black\";\n                ctx.beginPath();\n                if (\n                    storedSlot.type === defaultConfig.EVENT\n                    || storedSlot.shape === defaultConfig.BOX_SHAPE\n                ) {\n                    ctx.rect(x - 7 + 0.5, y - 4, 14, 8);\n                } else if (slot.shape === defaultConfig.ARROW_SHAPE) {\n                    ctx.moveTo(x + 6, y);\n                    ctx.lineTo(x - 6, y - 4);\n                    ctx.lineTo(x - 6, y + 4);\n                    ctx.closePath();\n                } else ctx.arc(x, y, 4, 0, Math.PI * 2);\n                ctx.fill();\n                // ctx.stroke();\n            }\n        }\n\n        if (node.clip_area) ctx.restore();\n\n        ctx.globalAlpha = 1.0;\n    }\n\n    // used by this.over_link_center\n    drawLinkTooltip(ctx, link) {\n        const pos = link._pos;\n        ctx.fillStyle = \"black\";\n        ctx.beginPath();\n        ctx.arc(pos[0], pos[1], 3, 0, Math.PI * 2);\n        ctx.fill();\n\n        if (link.data == null) return;\n\n        if (this.onDrawLinkTooltip && this.onDrawLinkTooltip(ctx, link, this)) return;\n\n        const { data } = link;\n        let text;\n\n        if (data.constructor === Number) text = data.toFixed(2);\n        else if (data.constructor === String) text = `\"${data}\"`;\n        else if (data.constructor === Boolean) text = String(data);\n        else if (data.toToolTip) text = data.toToolTip();\n        else text = `[${data.constructor.name}]`;\n\n        if (!text) return;\n        text = text.substr(0, 30); // avoid weird\n\n        ctx.font = \"14px Courier New\";\n        const info = ctx.measureText(text);\n        const w = info.width + 20;\n        const h = 24;\n        ctx.shadowColor = \"black\";\n        ctx.shadowOffsetX = 2;\n        ctx.shadowOffsetY = 2;\n        ctx.shadowBlur = 3;\n        ctx.fillStyle = \"#454\";\n        ctx.beginPath();\n        ctx.roundRect(pos[0] - w * 0.5, pos[1] - 15 - h, w, h, 3, 3);\n        ctx.moveTo(pos[0] - 10, pos[1] - 15);\n        ctx.lineTo(pos[0] + 10, pos[1] - 15);\n        ctx.lineTo(pos[0], pos[1] - 5);\n        ctx.fill();\n        ctx.shadowColor = \"transparent\";\n        ctx.textAlign = \"center\";\n        ctx.fillStyle = \"#CEC\";\n        ctx.fillText(text, pos[0], pos[1] - 15 - h * 0.3);\n    }\n\n    /**\n     * draws the shape of the given node in the canvas\n     * @method drawNodeShape\n     * */\n    drawNodeShape(\n        node,\n        ctx,\n        size,\n        fgcolor,\n        bgcolor,\n        selected,\n        mouseHover,\n    ) {\n        // bg rect\n        ctx.strokeStyle = fgcolor;\n        ctx.fillStyle = bgcolor;\n\n        const titleHeight = defaultConfig.NODE_TITLE_HEIGHT;\n        const lowQuality = this.ds.scale < 0.5;\n\n        // render node area depending on shape\n        const shape = node._shape || node.constructor.shape || defaultConfig.ROUND_SHAPE;\n\n        const { title_mode } = node.constructor;\n\n        let renderTitle = true;\n        if (title_mode === defaultConfig.TRANSPARENT_TITLE) renderTitle = false;\n        else if (title_mode === defaultConfig.AUTOHIDE_TITLE && mouseHover) renderTitle = true;\n\n        const area = tempArea;\n        area[0] = 0; // x\n        area[1] = renderTitle ? -titleHeight : 0; // y\n        area[2] = size[0] + 1; // w\n        area[3] = renderTitle ? size[1] + titleHeight : size[1]; // h\n\n        const oldAlpha = ctx.globalAlpha;\n\n        ctx.beginPath();\n        if (shape === defaultConfig.BOX_SHAPE || lowQuality) {\n            ctx.fillRect(area[0], area[1], area[2], area[3]);\n        } else if (shape === defaultConfig.ROUND_SHAPE || shape === defaultConfig.CARD_SHAPE) {\n            ctx.roundRect(\n                area[0],\n                area[1],\n                area[2],\n                area[3],\n                this.round_radius,\n                shape === defaultConfig.CARD_SHAPE ? 0 : this.round_radius,\n            );\n        } else if (shape === defaultConfig.CIRCLE_SHAPE) {\n            ctx.arc(\n                size[0] * 0.5,\n                size[1] * 0.5,\n                size[0] * 0.5,\n                0,\n                Math.PI * 2,\n            );\n        }\n        ctx.fill();\n\n        // separator\n        if (!node.flags.collapsed) {\n            ctx.shadowColor = \"transparent\";\n            ctx.fillStyle = \"rgba(0,0,0,0.2)\";\n            ctx.fillRect(0, -1, area[2], 2);\n        }\n        ctx.shadowColor = \"transparent\";\n\n        if (node.onDrawBackground) node.onDrawBackground(ctx, this, this.canvas, this.graph_mouse);\n\n        // title bg (remember, it is rendered ABOVE the node)\n        if (renderTitle || title_mode === defaultConfig.TRANSPARENT_TITLE) {\n            // title bar\n            if (node.onDrawTitleBar) {\n                node.onDrawTitleBar(ctx, titleHeight, size, this.ds.scale, fgcolor);\n            } else if (\n                title_mode !== defaultConfig.TRANSPARENT_TITLE\n                && (node.constructor.title_color || this.render_title_colored)\n            ) {\n                const titleColor = node.constructor.title_color || fgcolor;\n\n                if (node.flags.collapsed) {\n                    ctx.shadowColor = defaultConfig.DEFAULT_SHADOW_COLOR;\n                }\n\n                //* gradient test\n                if (this.use_gradients) {\n                    let grad = LGraphCanvas.gradients[titleColor];\n                    if (!grad) {\n                        grad = ctx.createLinearGradient(0, 0, 400, 0);\n                        LGraphCanvas.gradients[titleColor] = grad;\n                        grad.addColorStop(0, titleColor);\n                        grad.addColorStop(1, \"#000\");\n                    }\n                    ctx.fillStyle = grad;\n                } else {\n                    ctx.fillStyle = titleColor;\n                }\n\n                // ctx.globalAlpha = 0.5 * old_alpha;\n                ctx.beginPath();\n                if (shape === defaultConfig.BOX_SHAPE || lowQuality) {\n                    ctx.rect(0, -titleHeight, size[0] + 1, titleHeight);\n                } else if (shape === defaultConfig.ROUND_SHAPE || shape === defaultConfig.CARD_SHAPE) {\n                    ctx.roundRect(\n                        0,\n                        -titleHeight,\n                        size[0] + 1,\n                        titleHeight,\n                        this.round_radius,\n                        node.flags.collapsed ? this.round_radius : 0,\n                    );\n                }\n                ctx.fill();\n                ctx.shadowColor = \"transparent\";\n            }\n\n            // title box\n            const boxSize = 10;\n            if (node.onDrawTitleBox) {\n                node.onDrawTitleBox(ctx, titleHeight, size, this.ds.scale);\n            } else if ([defaultConfig.ROUND_SHAPE, defaultConfig.CIRCLE_SHAPE, defaultConfig.CARD_SHAPE].includes(shape)) {\n                if (lowQuality) {\n                    ctx.fillStyle = \"black\";\n                    ctx.beginPath();\n                    ctx.arc(\n                        titleHeight * 0.5,\n                        titleHeight * -0.5,\n                        boxSize * 0.5 + 1,\n                        0,\n                        Math.PI * 2,\n                    );\n                    ctx.fill();\n                }\n\n                ctx.fillStyle = node.boxcolor || defaultConfig.NODE_DEFAULT_BOXCOLOR;\n                if (lowQuality) ctx.fillRect(titleHeight * 0.5 - boxSize * 0.5, titleHeight * -0.5 - boxSize * 0.5, boxSize, boxSize);\n                else {\n                    ctx.beginPath();\n                    ctx.arc(\n                        titleHeight * 0.5,\n                        titleHeight * -0.5,\n                        boxSize * 0.5,\n                        0,\n                        Math.PI * 2,\n                    );\n                    ctx.fill();\n                }\n            } else {\n                if (lowQuality) {\n                    ctx.fillStyle = \"black\";\n                    ctx.fillRect(\n                        (titleHeight - boxSize) * 0.5 - 1,\n                        (titleHeight + boxSize) * -0.5 - 1,\n                        boxSize + 2,\n                        boxSize + 2,\n                    );\n                }\n                ctx.fillStyle = node.boxcolor || defaultConfig.NODE_DEFAULT_BOXCOLOR;\n                ctx.fillRect(\n                    (titleHeight - boxSize) * 0.5,\n                    (titleHeight + boxSize) * -0.5,\n                    boxSize,\n                    boxSize,\n                );\n            }\n            ctx.globalAlpha = oldAlpha;\n\n            // title text\n            if (node.onDrawTitleText) {\n                node.onDrawTitleText(\n                    ctx,\n                    titleHeight,\n                    size,\n                    this.ds.scale,\n                    this.title_text_font,\n                    selected,\n                );\n            }\n            if (!lowQuality) {\n                ctx.font = this.title_text_font;\n                const title = String(node.getTitle());\n                if (title) {\n                    if (selected) ctx.fillStyle = defaultConfig.NODE_SELECTED_TITLE_COLOR;\n                    else ctx.fillStyle = node.constructor.title_text_color || this.node_title_color;\n                    if (node.flags.collapsed) {\n                        ctx.textAlign = \"left\";\n                        const measure = ctx.measureText(title);\n                        ctx.fillText(\n                            title.substr(0, 20), // avoid urls too long\n                            titleHeight, // + measure.width * 0.5,\n                            defaultConfig.NODE_TITLE_TEXT_Y - titleHeight,\n                        );\n                        ctx.textAlign = \"left\";\n                    } else {\n                        ctx.textAlign = \"left\";\n                        ctx.fillText(\n                            title,\n                            titleHeight,\n                            defaultConfig.NODE_TITLE_TEXT_Y - titleHeight,\n                        );\n                    }\n                }\n            }\n\n            // subgraph box\n            if (!node.flags.collapsed && node.subgraph && !node.skip_subgraph_button) {\n                const w = defaultConfig.NODE_TITLE_HEIGHT;\n                const x = node.size[0] - w;\n                const over = isInsideRectangle(\n                    this.graph_mouse[0] - node.pos[0],\n                    this.graph_mouse[1] - node.pos[1],\n                    x + 2,\n                    -w + 2,\n                    w - 4,\n                    w - 4,\n                );\n                ctx.fillStyle = over ? \"#888\" : \"#555\";\n                if (shape === defaultConfig.BOX_SHAPE || lowQuality) {\n                    ctx.fillRect(x + 2, -w + 2, w - 4, w - 4);\n                } else {\n                    ctx.beginPath();\n                    ctx.roundRect(x + 2, -w + 2, w - 4, w - 4, 4);\n                    ctx.fill();\n                }\n                ctx.fillStyle = \"#333\";\n                ctx.beginPath();\n                ctx.moveTo(x + w * 0.2, -w * 0.6);\n                ctx.lineTo(x + w * 0.8, -w * 0.6);\n                ctx.lineTo(x + w * 0.5, -w * 0.3);\n                ctx.fill();\n            }\n\n            // custom title render\n            if (node.onDrawTitle) node.onDrawTitle(ctx);\n        }\n\n        // render selection marker\n        if (selected) {\n            if (node.onBounding) node.onBounding(area);\n\n            if (title_mode === defaultConfig.TRANSPARENT_TITLE) {\n                area[1] -= titleHeight;\n                area[3] += titleHeight;\n            }\n            ctx.lineWidth = 1;\n            ctx.globalAlpha = 0.8;\n            ctx.beginPath();\n            if (shape === defaultConfig.BOX_SHAPE) {\n                ctx.rect(\n                    -6 + area[0],\n                    -6 + area[1],\n                    12 + area[2],\n                    12 + area[3],\n                );\n            } else if (\n                shape === defaultConfig.ROUND_SHAPE\n                || (shape === defaultConfig.CARD_SHAPE && node.flags.collapsed)\n            ) {\n                ctx.roundRect(\n                    -6 + area[0],\n                    -6 + area[1],\n                    12 + area[2],\n                    12 + area[3],\n                    this.round_radius * 2,\n                );\n            } else if (shape === defaultConfig.CARD_SHAPE) {\n                ctx.roundRect(\n                    -6 + area[0],\n                    -6 + area[1],\n                    12 + area[2],\n                    12 + area[3],\n                    this.round_radius * 2,\n                    2,\n                );\n            } else if (shape === defaultConfig.CIRCLE_SHAPE) {\n                ctx.arc(\n                    size[0] * 0.5,\n                    size[1] * 0.5,\n                    size[0] * 0.5 + 6,\n                    0,\n                    Math.PI * 2,\n                );\n            }\n            ctx.strokeStyle = defaultConfig.NODE_BOX_OUTLINE_COLOR;\n            ctx.stroke();\n            ctx.strokeStyle = fgcolor;\n            ctx.globalAlpha = 1;\n        }\n    }\n\n    /**\n     * draws every connection visible in the canvas\n     * OPTIMIZE THIS: pre-catch connections position instead of recomputing them every time\n     * @method drawConnections\n     * */\n    drawConnections(ctx) {\n        const now = getTime();\n        const { visible_area } = this;\n        marginArea[0] = visible_area[0] - 20;\n        marginArea[1] = visible_area[1] - 20;\n        marginArea[2] = visible_area[2] + 40;\n        marginArea[3] = visible_area[3] + 40;\n\n        // draw connections\n        ctx.lineWidth = this.connections_width;\n\n        ctx.fillStyle = \"#AAA\";\n        ctx.strokeStyle = \"#AAA\";\n        ctx.globalAlpha = this.editor_alpha;\n        // for every node\n        const nodes = this.graph._nodes;\n        for (const node of nodes) {\n            // for every input (we render just inputs because it is easier as every slot can only\n            // have one input)\n            if (!node.inputs || !node.inputs.length) {\n                continue;\n            }\n\n            for (let i = 0; i < node.inputs.length; ++i) {\n                const input = node.inputs[i];\n                if (!input || input.link == null) continue;\n\n                const linkId = input.link;\n                const link = this.graph.links[linkId];\n                if (!link) continue;\n\n                // find link info\n                const startNode = this.graph.getNodeById(link.origin_id);\n                if (!startNode) continue;\n\n                const startNodeSlot = link.origin_slot;\n                let startNodeSlotPos = null;\n                if (startNodeSlot === -1) {\n                    startNodeSlotPos = [\n                        startNode.pos[0] + 10,\n                        startNode.pos[1] + 10,\n                    ];\n                } else {\n                    startNodeSlotPos = startNode.getConnectionPos(\n                        false,\n                        startNodeSlot,\n                        tempA,\n                    );\n                }\n\n                const endNodeSlotPos = node.getConnectionPos(true, i, tempB);\n\n                // compute link bounding\n                linkBounding[0] = startNodeSlotPos[0];\n                linkBounding[1] = startNodeSlotPos[1];\n                linkBounding[2] = endNodeSlotPos[0] - startNodeSlotPos[0];\n                linkBounding[3] = endNodeSlotPos[1] - startNodeSlotPos[1];\n\n                if (linkBounding[2] < 0) {\n                    linkBounding[0] += linkBounding[2];\n                    linkBounding[2] = Math.abs(linkBounding[2]);\n                }\n                if (linkBounding[3] < 0) {\n                    linkBounding[1] += linkBounding[3];\n                    linkBounding[3] = Math.abs(linkBounding[3]);\n                }\n\n                // skip links outside of the visible area of the canvas\n                if (!overlapBounding(linkBounding, marginArea)) {\n                    continue;\n                }\n\n                const startSlot = startNode.outputs[startNodeSlot];\n                const endSlot = node.inputs[i];\n                if (!startSlot || !endSlot) continue;\n                const startDir = startSlot.dir\n                    || (startNode.horizontal ? defaultConfig.DOWN : defaultConfig.RIGHT);\n                const endDir = endSlot.dir\n                    || (node.horizontal ? defaultConfig.UP : defaultConfig.LEFT);\n\n                this.renderLink(\n                    ctx,\n                    startNodeSlotPos,\n                    endNodeSlotPos,\n                    link,\n                    false,\n                    0,\n                    null,\n                    startDir,\n                    endDir,\n                );\n\n                // event triggered rendered on top\n                if (link && link._last_time && now - link._last_time < 1000) {\n                    const f = 2.0 - (now - link._last_time) * 0.002;\n                    const tmp = ctx.globalAlpha;\n                    ctx.globalAlpha = tmp * f;\n                    this.renderLink(\n                        ctx,\n                        startNodeSlotPos,\n                        endNodeSlotPos,\n                        link,\n                        true,\n                        f,\n                        \"white\",\n                        startDir,\n                        endDir,\n                    );\n                    ctx.globalAlpha = tmp;\n                }\n            }\n        }\n        ctx.globalAlpha = 1;\n    }\n\n    /**\n     * draws a link between two points\n     * @method renderLink\n     * @param {vec2} a start pos\n     * @param {vec2} b end pos\n     * @param {Object} link the link object with all the link info\n     * @param {boolean} skipBorder ignore the shadow of the link\n     * @param {boolean} flow show flow animation (for events)\n     * @param {string} color the color for the link\n     * @param {number} startDir the direction enum\n     * @param {number} endDir the direction enum\n     * @param {number} numSubline number of sublines (useful to represent vec3 or rgb)\n     * */\n    renderLink(\n        ctx,\n        a,\n        b,\n        link,\n        skipBorder,\n        flow,\n        color,\n        startDir,\n        endDir,\n        numSubline,\n    ) {\n        if (link) this.visible_links.push(link);\n\n        // choose color\n        if (!color && link) color = link.color || LGraphCanvas.link_type_colors[link.type];\n        if (!color) color = this.default_link_color;\n        if (link != null && this.highlighted_links[link.id]) color = \"#FFF\";\n\n        startDir = startDir || defaultConfig.RIGHT;\n        endDir = endDir || defaultConfig.LEFT;\n\n        const dist = distance(a, b);\n\n        if (this.render_connections_border && this.ds.scale > 0.6) {\n            ctx.lineWidth = this.connections_width + 4;\n        }\n        ctx.lineJoin = \"round\";\n        numSubline = numSubline || 1;\n        if (numSubline > 1) ctx.lineWidth = 0.5;\n\n        // begin line shape\n        ctx.beginPath();\n        for (let i = 0; i < numSubline; i += 1) {\n            const offsety = (i - (numSubline - 1) * 0.5) * 5;\n\n            if (this.links_render_mode === defaultConfig.SPLINE_LINK) {\n                ctx.moveTo(a[0], a[1] + offsety);\n                let startOffsetX = 0;\n                let startOffsetY = 0;\n                let endOffsetX = 0;\n                let endOffsetY = 0;\n                switch (startDir) {\n                    case defaultConfig.LEFT:\n                        startOffsetX = dist * -0.25;\n                        break;\n                    case defaultConfig.RIGHT:\n                        startOffsetX = dist * 0.25;\n                        break;\n                    case defaultConfig.UP:\n                        startOffsetY = dist * -0.25;\n                        break;\n                    case defaultConfig.DOWN:\n                        startOffsetY = dist * 0.25;\n                        break;\n                    default:\n                        break;\n                }\n                switch (endDir) {\n                    case defaultConfig.LEFT:\n                        endOffsetX = dist * -0.25;\n                        break;\n                    case defaultConfig.RIGHT:\n                        endOffsetX = dist * 0.25;\n                        break;\n                    case defaultConfig.UP:\n                        endOffsetY = dist * -0.25;\n                        break;\n                    case defaultConfig.DOWN:\n                        endOffsetY = dist * 0.25;\n                        break;\n                    default:\n                        break;\n                }\n                ctx.bezierCurveTo(\n                    a[0] + startOffsetX,\n                    a[1] + startOffsetY + offsety,\n                    b[0] + endOffsetX,\n                    b[1] + endOffsetY + offsety,\n                    b[0],\n                    b[1] + offsety,\n                );\n            } else if (this.links_render_mode === defaultConfig.LINEAR_LINK) {\n                ctx.moveTo(a[0], a[1] + offsety);\n                let startOffsetX = 0;\n                let startOffsetY = 0;\n                let endOffsetX = 0;\n                let endOffsetY = 0;\n                switch (startDir) {\n                    case defaultConfig.LEFT:\n                        startOffsetX = -1;\n                        break;\n                    case defaultConfig.RIGHT:\n                        startOffsetX = 1;\n                        break;\n                    case defaultConfig.UP:\n                        startOffsetY = -1;\n                        break;\n                    case defaultConfig.DOWN:\n                        startOffsetY = 1;\n                        break;\n                    default:\n                        break;\n                }\n                switch (endDir) {\n                    case defaultConfig.LEFT:\n                        endOffsetX = -1;\n                        break;\n                    case defaultConfig.RIGHT:\n                        endOffsetX = 1;\n                        break;\n                    case defaultConfig.UP:\n                        endOffsetY = -1;\n                        break;\n                    case defaultConfig.DOWN:\n                        endOffsetY = 1;\n                        break;\n                    default:\n                        break;\n                }\n                const l = 15;\n                ctx.lineTo(\n                    a[0] + startOffsetX * l,\n                    a[1] + startOffsetY * l + offsety,\n                );\n                ctx.lineTo(\n                    b[0] + endOffsetX * l,\n                    b[1] + endOffsetY * l + offsety,\n                );\n                ctx.lineTo(b[0], b[1] + offsety);\n            } else if (this.links_render_mode === defaultConfig.STRAIGHT_LINK) {\n                ctx.moveTo(a[0], a[1]);\n                let startX = a[0];\n                let startY = a[1];\n                let endX = b[0];\n                let endY = b[1];\n\n                if (startDir === defaultConfig.RIGHT) startX += 10;\n                else startY += 10;\n                if (endDir === defaultConfig.LEFT) endX -= 10;\n                else endY -= 10;\n\n                ctx.lineTo(startX, startY);\n                ctx.lineTo((startX + endX) * 0.5, startY);\n                ctx.lineTo((startX + endX) * 0.5, endY);\n                ctx.lineTo(endX, endY);\n                ctx.lineTo(b[0], b[1]);\n            } else return;\n        }\n\n        // rendering the outline of the connection can be a little bit slow\n        if (this.render_connections_border && this.ds.scale > 0.6 && !skipBorder) {\n            ctx.strokeStyle = \"rgba(0,0,0,0.5)\";\n            ctx.stroke();\n        }\n\n        ctx.lineWidth = this.connections_width;\n        ctx.fillStyle = color;\n        ctx.strokeStyle = color;\n        ctx.stroke();\n        // end line shape\n\n        const posConnectionPoint = this.computeConnectionPoint(a, b, 0.5, startDir, endDir);\n        if (link && link._pos) {\n            link._pos[0] = posConnectionPoint[0];\n            link._pos[1] = posConnectionPoint[1];\n        }\n\n        // render arrow in the middle\n        if (this.ds.scale >= 0.6 && this.highquality_render && endDir !== defaultConfig.CENTER) {\n            // render arrow\n            if (this.render_connection_arrows) {\n                // compute two points in the connection\n                const posA = this.computeConnectionPoint(a, b, 0.25, startDir, endDir);\n                const posB = this.computeConnectionPoint(a, b, 0.26, startDir, endDir);\n                const posC = this.computeConnectionPoint(a, b, 0.75, startDir, endDir);\n                const posD = this.computeConnectionPoint(a, b, 0.76, startDir, endDir);\n\n                // compute the angle between them so the arrow points in the right direction\n                let angleA = 0;\n                let angleB = 0;\n                if (this.render_curved_connections) {\n                    angleA = -Math.atan2(posB[0] - posA[0], posB[1] - posA[1]);\n                    angleB = -Math.atan2(posD[0] - posC[0], posD[1] - posC[1]);\n                } else angleB = angleA = b[1] > a[1] ? 0 : Math.PI;\n\n                // render arrow\n                ctx.save();\n                ctx.translate(posA[0], posA[1]);\n                ctx.rotate(angleA);\n                ctx.beginPath();\n                ctx.moveTo(-5, -3);\n                ctx.lineTo(0, 7);\n                ctx.lineTo(5, -3);\n                ctx.fill();\n                ctx.restore();\n                ctx.save();\n                ctx.translate(posC[0], posC[1]);\n                ctx.rotate(angleB);\n                ctx.beginPath();\n                ctx.moveTo(-5, -3);\n                ctx.lineTo(0, 7);\n                ctx.lineTo(5, -3);\n                ctx.fill();\n                ctx.restore();\n            }\n\n            // circle\n            ctx.beginPath();\n            ctx.arc(pos[0], pos[1], 5, 0, Math.PI * 2);\n            ctx.fill();\n        }\n\n        // render flowing points\n        if (flow) {\n            ctx.fillStyle = color;\n            for (let i = 0; i < 5; ++i) {\n                const f = (getTime() * 0.001 + i * 0.2) % 1;\n                const pos = this.computeConnectionPoint(a, b, f, startDir, endDir);\n                ctx.beginPath();\n                ctx.arc(pos[0], pos[1], 5, 0, 2 * Math.PI);\n                ctx.fill();\n            }\n        }\n    }\n\n    /**\n     * returns the link center point based on curvature\n     * @method computeConnectionPoint\n     * @param a\n     * @param b\n     * @param t\n     * @param [startDir]\n     * @param [endDir]\n     * @returns {number[]}\n     */\n    computeConnectionPoint(a, b, t, startDir = defaultConfig.RIGHT, endDir = defaultConfig.LEFT) {\n        const dist = distance(a, b);\n        const p0 = a;\n        const p1 = [a[0], a[1]];\n        const p2 = [b[0], b[1]];\n        const p3 = b;\n\n        switch (startDir) {\n            case defaultConfig.LEFT:\n                p1[0] += dist * -0.25;\n                break;\n            case defaultConfig.RIGHT:\n                p1[0] += dist * 0.25;\n                break;\n            case defaultConfig.UP:\n                p1[1] += dist * -0.25;\n                break;\n            case defaultConfig.DOWN:\n                p1[1] += dist * 0.25;\n                break;\n            default:\n                break;\n        }\n        switch (endDir) {\n            case defaultConfig.LEFT:\n                p2[0] += dist * -0.25;\n                break;\n            case defaultConfig.RIGHT:\n                p2[0] += dist * 0.25;\n                break;\n            case defaultConfig.UP:\n                p2[1] += dist * -0.25;\n                break;\n            case defaultConfig.DOWN:\n                p2[1] += dist * 0.25;\n                break;\n            default:\n                break;\n        }\n\n        const c1 = (1 - t) * (1 - t) * (1 - t);\n        const c2 = 3 * ((1 - t) * (1 - t)) * t;\n        const c3 = 3 * (1 - t) * (t * t);\n        const c4 = t * t * t;\n\n        const x = c1 * p0[0] + c2 * p1[0] + c3 * p2[0] + c4 * p3[0];\n        const y = c1 * p0[1] + c2 * p1[1] + c3 * p2[1] + c4 * p3[1];\n        return [x, y];\n    }\n\n    drawExecutionOrder(ctx) {\n        ctx.shadowColor = \"transparent\";\n        ctx.globalAlpha = 0.25;\n\n        ctx.textAlign = \"center\";\n        ctx.strokeStyle = \"white\";\n        ctx.globalAlpha = 0.75;\n\n        const { visible_nodes } = this;\n        for (const node of visible_nodes) {\n            ctx.fillStyle = \"black\";\n            ctx.fillRect(\n                node.pos[0] - defaultConfig.NODE_TITLE_HEIGHT,\n                node.pos[1] - defaultConfig.NODE_TITLE_HEIGHT,\n                defaultConfig.NODE_TITLE_HEIGHT,\n                defaultConfig.NODE_TITLE_HEIGHT,\n            );\n            if (node.order === 0) {\n                ctx.strokeRect(\n                    node.pos[0] - defaultConfig.NODE_TITLE_HEIGHT + 0.5,\n                    node.pos[1] - defaultConfig.NODE_TITLE_HEIGHT + 0.5,\n                    defaultConfig.NODE_TITLE_HEIGHT,\n                    defaultConfig.NODE_TITLE_HEIGHT,\n                );\n            }\n            ctx.fillStyle = \"#FFF\";\n            ctx.fillText(\n                node.order,\n                node.pos[0] + defaultConfig.NODE_TITLE_HEIGHT * -0.5,\n                node.pos[1] - 6,\n            );\n        }\n        ctx.globalAlpha = 1;\n    }\n\n    /**\n     * draws the widgets stored inside a node\n     * @method drawNodeWidgets\n     * */\n    drawNodeWidgets(node, posY, ctx, active_widget) {\n        if (!node.widgets || !node.widgets.length) return 0;\n        const width = node.size[0];\n        const { widgets } = node;\n        posY += 2;\n        const H = defaultConfig.NODE_WIDGET_HEIGHT;\n        const showText = this.ds.scale > 0.5;\n        ctx.save();\n        ctx.globalAlpha = this.editor_alpha;\n        const outlineColor = defaultConfig.WIDGET_OUTLINE_COLOR;\n        const backgroundColor = defaultConfig.WIDGET_BGCOLOR;\n        const textColor = defaultConfig.WIDGET_TEXT_COLOR;\n        const secondaryTextColor = defaultConfig.WIDGET_SECONDARY_TEXT_COLOR;\n        const margin = 15;\n\n        for (const w of widgets) {\n            let y = posY;\n            if (w.y) y = w.y;\n            w.last_y = y;\n            ctx.strokeStyle = outlineColor;\n            ctx.fillStyle = \"#222\";\n            ctx.textAlign = \"left\";\n            // ctx.lineWidth = 2;\n            if (w.disabled) ctx.globalAlpha *= 0.5;\n            const widgetWidth = w.width || width;\n\n            switch (w.type) {\n                case \"button\":\n                    if (w.clicked) {\n                        ctx.fillStyle = \"#AAA\";\n                        w.clicked = false;\n                        this.dirty_canvas = true;\n                    }\n                    ctx.fillRect(margin, y, widgetWidth - margin * 2, H);\n                    if (showText && !w.disabled) ctx.strokeRect(margin, y, widgetWidth - margin * 2, H);\n                    if (showText) {\n                        ctx.textAlign = \"center\";\n                        ctx.fillStyle = textColor;\n                        ctx.fillText(w.name, widgetWidth * 0.5, y + H * 0.7);\n                    }\n                    break;\n                case \"toggle\":\n                    ctx.textAlign = \"left\";\n                    ctx.strokeStyle = outlineColor;\n                    ctx.fillStyle = backgroundColor;\n                    ctx.beginPath();\n\n                    if (showText) ctx.roundRect(margin, posY, widgetWidth - margin * 2, H, H * 0.5);\n                    else ctx.rect(margin, posY, widgetWidth - margin * 2, H);\n\n                    ctx.fill();\n                    if (showText && !w.disabled) ctx.stroke();\n                    ctx.fillStyle = w.value ? \"#89A\" : \"#333\";\n                    ctx.beginPath();\n                    ctx.arc(widgetWidth - margin * 2, y + H * 0.5, H * 0.36, 0, Math.PI * 2);\n                    ctx.fill();\n                    if (showText) {\n                        ctx.fillStyle = secondaryTextColor;\n                        if (w.name) ctx.fillText(w.name, margin * 2, y + H * 0.7);\n                        ctx.fillStyle = w.value ? textColor : secondaryTextColor;\n                        ctx.textAlign = \"right\";\n                        ctx.fillText(\n                            w.value\n                                ? w.options.on || \"true\"\n                                : w.options.off || \"false\",\n                            widgetWidth - 40,\n                            y + H * 0.7,\n                        );\n                    }\n                    break;\n                case \"slider\":\n                    ctx.fillStyle = backgroundColor;\n                    ctx.fillRect(margin, y, widgetWidth - margin * 2, H);\n                    var range = w.options.max - w.options.min;\n                    var nvalue = (w.value - w.options.min) / range;\n                    ctx.fillStyle = active_widget === w ? \"#89A\" : \"#678\";\n                    ctx.fillRect(margin, y, nvalue * (widgetWidth - margin * 2), H);\n                    if (showText && !w.disabled) ctx.strokeRect(margin, y, widgetWidth - margin * 2, H);\n                    if (w.marker) {\n                        const marker_nvalue = (w.marker - w.options.min) / range;\n                        ctx.fillStyle = \"#AA9\";\n                        ctx.fillRect(margin + marker_nvalue * (widgetWidth - margin * 2), y, 2, H);\n                    }\n                    if (showText) {\n                        ctx.textAlign = \"center\";\n                        ctx.fillStyle = textColor;\n                        ctx.fillText(\n                            `${w.name}  ${Number(w.value)\n                                .toFixed(3)}`,\n                            widgetWidth * 0.5,\n                            y + H * 0.7,\n                        );\n                    }\n                    break;\n                case \"number\":\n                case \"combo\":\n                    ctx.textAlign = \"left\";\n                    ctx.strokeStyle = outlineColor;\n                    ctx.fillStyle = backgroundColor;\n                    ctx.beginPath();\n                    if (showText) ctx.roundRect(margin, posY, widgetWidth - margin * 2, H, H * 0.5);\n                    else ctx.rect(margin, posY, widgetWidth - margin * 2, H);\n                    ctx.fill();\n                    if (showText) {\n                        if (!w.disabled) ctx.stroke();\n                        ctx.fillStyle = textColor;\n                        if (!w.disabled) {\n                            ctx.beginPath();\n                            ctx.moveTo(margin + 16, posY + 5);\n                            ctx.lineTo(margin + 6, posY + H * 0.5);\n                            ctx.lineTo(margin + 16, posY + H - 5);\n                            ctx.fill();\n                            ctx.beginPath();\n                            ctx.moveTo(widgetWidth - margin - 16, posY + 5);\n                            ctx.lineTo(widgetWidth - margin - 6, posY + H * 0.5);\n                            ctx.lineTo(widgetWidth - margin - 16, posY + H - 5);\n                            ctx.fill();\n                        }\n                        ctx.fillStyle = secondaryTextColor;\n                        ctx.fillText(w.name, margin * 2 + 5, y + H * 0.7);\n                        ctx.fillStyle = textColor;\n                        ctx.textAlign = \"right\";\n                        if (w.type === \"number\") {\n                            ctx.fillText(\n                                Number(w.value)\n                                    .toFixed(\n                                        w.options.precision !== undefined\n                                            ? w.options.precision\n                                            : 3,\n                                    ),\n                                widgetWidth - margin * 2 - 20,\n                                y + H * 0.7,\n                            );\n                        } else {\n                            let v = w.value;\n                            if (w.options.values) {\n                                let { values } = w.options;\n                                if (values.constructor === Function) values = values();\n                                if (values && values.constructor !== Array) v = values[w.value];\n                            }\n                            ctx.fillText(\n                                v,\n                                widgetWidth - margin * 2 - 20,\n                                y + H * 0.7,\n                            );\n                        }\n                    }\n                    break;\n                case \"string\":\n                case \"text\":\n                    ctx.textAlign = \"left\";\n                    ctx.strokeStyle = outlineColor;\n                    ctx.fillStyle = backgroundColor;\n                    ctx.beginPath();\n\n                    if (showText) ctx.roundRect(margin, posY, widgetWidth - margin * 2, H, H * 0.5);\n                    else ctx.rect(margin, posY, widgetWidth - margin * 2, H);\n\n                    ctx.fill();\n                    if (showText) {\n                        if (!w.disabled) ctx.stroke();\n                        ctx.save();\n                        ctx.beginPath();\n                        ctx.rect(margin, posY, widgetWidth - margin * 2, H);\n                        ctx.clip();\n\n                        // ctx.stroke();\n                        ctx.fillStyle = secondaryTextColor;\n                        if (w.name) ctx.fillText(w.name, margin * 2, y + H * 0.7);\n                        ctx.fillStyle = textColor;\n                        ctx.textAlign = \"right\";\n                        ctx.fillText(String(w.value)\n                            .substr(0, 30), widgetWidth - margin * 2, y + H * 0.7); // 30 chars max\n                        ctx.restore();\n                    }\n                    break;\n                default:\n                    if (w.draw) w.draw(ctx, node, widgetWidth, y, H);\n                    break;\n            }\n            posY += (w.computeSize ? w.computeSize(widgetWidth)[1] : H) + 4;\n            ctx.globalAlpha = this.editor_alpha;\n        }\n        ctx.restore();\n        ctx.textAlign = \"left\";\n    }\n\n    /**\n     * process an event on widgets\n     * @method processNodeWidgets\n     * */\n    processNodeWidgets(node, pos, event, activeWidget) {\n        if (!node.widgets || !node.widgets.length) return null;\n\n        const x = pos[0] - node.pos[0];\n        const y = pos[1] - node.pos[1];\n        const width = node.size[0];\n        const refWindow = this.getCanvasWindow();\n\n        for (const w of node.widgets) {\n            if (!w || w.disabled) continue;\n            const widgetHeight = w.computeSize ? w.computeSize(width)[1] : defaultConfig.NODE_WIDGET_HEIGHT;\n            const widgetWidth = w.width || width;\n            // outside\n            if (w !== activeWidget\n                && (x < 6 || x > widgetWidth - 12 || y < w.last_y || y > w.last_y + widgetHeight)) {\n                continue;\n            }\n\n            const oldValue = w.value;\n\n            // if ( w == active_widget || (x > 6 && x < widget_width - 12 && y > w.last_y && y <\n            // w.last_y + widget_height) ) { inside widget\n            switch (w.type) {\n                case \"button\":\n                    if (event.type === \"mousemove\") {\n                        break;\n                    }\n                    if (w.callback) {\n                        setTimeout(() => w.callback(w, this, node, pos, event), 20);\n                    }\n                    w.clicked = true;\n                    this.dirty_canvas = true;\n                    break;\n                case \"slider\":\n                    const range = w.options.max - w.options.min;\n                    const nvalue = Math.clamp((x - 15) / (widgetWidth - 30), 0, 1);\n                    w.value = w.options.min + (w.options.max - w.options.min) * nvalue;\n                    if (w.callback) {\n                        setTimeout(() => innerValueChange(w, w.value), 20);\n                    }\n                    this.dirty_canvas = true;\n                    break;\n                case \"number\":\n                case \"combo\":\n                    const oldValue = w.value;\n                    if (event.type === \"mousemove\" && w.type === \"number\") {\n                        w.value += event.deltaX * 0.1 * (w.options.step || 1);\n                        if (w.options.min && w.value < w.options.min) w.value = w.options.min;\n                        if (w.options.max && w.value > w.options.max) w.value = w.options.max;\n                    } else if (event.type === \"mousedown\") {\n                        let { values } = w.options;\n                        if (values && values.constructor === Function) {\n                            values = w.options.values(w, node);\n                        }\n                        let valuesList = [];\n\n                        if (w.type !== \"number\") valuesList = values.constructor === Array ? values : Object.keys(values);\n\n                        const delta = x < 40 ? -1 : x > widgetWidth - 40 ? 1 : 0;\n                        if (w.type === \"number\") {\n                            w.value += delta * 0.1 * (w.options.step || 1);\n                            if (w.options.min != null && w.value < w.options.min) {\n                                w.value = w.options.min;\n                            }\n                            if (w.options.max != null && w.value > w.options.max) {\n                                w.value = w.options.max;\n                            }\n                        } else if (delta) { // clicked in arrow, used for combos\n                            let index = -1;\n                            this.last_mouseclick = 0; // avoids dobl click event\n                            if (values.constructor === Object) {\n                                index = valuesList.indexOf(String(w.value)) + delta;\n                            } else {\n                                index = valuesList.indexOf(w.value) + delta;\n                            }\n                            if (index >= valuesList.length) {\n                                index = valuesList.length - 1;\n                            }\n                            if (index < 0) {\n                                index = 0;\n                            }\n                            if (values.constructor === Array) {\n                                w.value = values[index];\n                            } else {\n                                w.value = index;\n                            }\n                        } else { // combo clicked\n                            const textValues = values !== valuesList\n                                ? Object.values(values)\n                                : values;\n                            const menu = new ContextMenu(textValues, {\n                                scale: Math.max(1, this.ds.scale),\n                                event,\n                                className: \"dark\",\n                                callback: innerClicked.bind(w),\n                            },\n                            refWindow);\n\n                            function innerClicked(v, option, event) {\n                                if (values != valuesList) v = textValues.indexOf(v);\n                                this.value = v;\n                                innerValueChange(this, v);\n                                that.dirty_canvas = true;\n                                return false;\n                            }\n                        }\n                    } else if (event.type === \"mouseup\" && w.type === \"number\") {\n                        const delta = x < 40 ? -1 : x > widgetWidth - 40 ? 1 : 0;\n                        if (event.click_time < 200 && delta == 0) {\n                            this.prompt(\"Value\", w.value, (v) => {\n                                this.value = Number(v);\n                                innerValueChange(this, this.value);\n                            }, event);\n                        }\n                    }\n\n                    if (oldValue !== w.value) {\n                        setTimeout(\n                            () => {\n                                innerValueChange(this, this.value);\n                            },\n                            20,\n                        );\n                    }\n                    this.dirty_canvas = true;\n                    break;\n                case \"toggle\":\n                    if (event.type === \"mousedown\") {\n                        w.value = !w.value;\n                        setTimeout(() => {\n                            innerValueChange(w, w.value);\n                        }, 20);\n                    }\n                    break;\n                case \"string\":\n                case \"text\":\n                    if (event.type === \"mousedown\") {\n                        this.prompt(\"Value\", w.value, (v) => {\n                            this.value = v;\n                            innerValueChange(this, v);\n                        }, event, w.options ? w.options.multiline : false);\n                    }\n                    break;\n                default:\n                    if (w.mouse) {\n                        this.dirty_canvas = w.mouse(event, [x, y], node);\n                    }\n                    break;\n            } // end switch\n\n            // value changed\n            if (oldValue !== w.value) {\n                if (node.onWidgetChanged) node.onWidgetChanged(w.name, w.value, oldValue, w);\n                node.graph._version++;\n            }\n\n            return w;\n        }\n\n        const that = this;\n        function innerValueChange(widget, value) {\n            widget.value = value;\n            if (widget.options && widget.options.property && node.properties[widget.options.property] !== undefined) {\n                node.setProperty(widget.options.property, value);\n            }\n            if (widget.callback) {\n                widget.callback(widget.value, that, node, pos, event);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * draws every group area in the background\n     * @method drawGroups\n     * */\n    drawGroups(canvas, ctx) {\n        if (!this.graph) return;\n\n        const groups = this.graph._groups;\n\n        ctx.save();\n        ctx.globalAlpha = 0.5 * this.editor_alpha;\n\n        for (const group of groups) {\n            if (!overlapBounding(this.visible_area, group._bounding)) {\n                continue;\n            } // out of the visible area\n\n            ctx.fillStyle = group.color || \"#335\";\n            ctx.strokeStyle = group.color || \"#335\";\n            const pos = group._pos;\n            const size = group._size;\n            ctx.globalAlpha = 0.25 * this.editor_alpha;\n            ctx.beginPath();\n            ctx.rect(pos[0] + 0.5, pos[1] + 0.5, size[0], size[1]);\n            ctx.fill();\n            ctx.globalAlpha = this.editor_alpha;\n            ctx.stroke();\n\n            ctx.beginPath();\n            ctx.moveTo(pos[0] + size[0], pos[1] + size[1]);\n            ctx.lineTo(pos[0] + size[0] - 10, pos[1] + size[1]);\n            ctx.lineTo(pos[0] + size[0], pos[1] + size[1] - 10);\n            ctx.fill();\n\n            const fontSize = group.font_size || defaultConfig.DEFAULT_GROUP_FONT_SIZE;\n            ctx.font = `${fontSize}px Arial`;\n            ctx.fillText(group.title, pos[0] + 4, pos[1] + fontSize);\n        }\n\n        ctx.restore();\n    }\n\n    adjustNodesSize() {\n        const nodes = this.graph._nodes;\n        for (const node of nodes) node.size = node.computeSize();\n        this.setDirty(true, true);\n    }\n\n    /**\n     * resizes the canvas to a given size, if no size is passed, then it tries to fill the\n     * parentNode\n     * @method resize\n     * */\n    resize(width, height) {\n        if (!width && !height) {\n            const parent = this.canvas.parentNode;\n            width = parent.offsetWidth;\n            height = parent.offsetHeight;\n        }\n\n        if (this.canvas.width === width && this.canvas.height === height) {\n            return;\n        }\n\n        this.canvas.width = width;\n        this.canvas.height = height;\n        this.bgcanvas.width = this.canvas.width;\n        this.bgcanvas.height = this.canvas.height;\n        this.setDirty(true, true);\n    }\n\n    /**\n     * switches to live mode (node shapes are not rendered, only the content)\n     * this feature was designed when graphs where meant to create user interfaces\n     * @method switchLiveMode\n     * */\n    switchLiveMode(transition) {\n        if (!transition) {\n            this.live_mode = !this.live_mode;\n            this.dirty_canvas = true;\n            this.dirty_bgcanvas = true;\n            return;\n        }\n\n        const delta = this.live_mode ? 1.1 : 0.9;\n        if (this.live_mode) {\n            this.live_mode = false;\n            this.editor_alpha = 0.1;\n        }\n\n        const t = setInterval(() => {\n            this.editor_alpha *= delta;\n            this.dirty_canvas = true;\n            this.dirty_bgcanvas = true;\n\n            if (delta < 1 && this.editor_alpha < 0.01) {\n                clearInterval(t);\n                if (delta < 1) {\n                    this.live_mode = true;\n                }\n            }\n            if (delta > 1 && this.editor_alpha > 0.99) {\n                clearInterval(t);\n                this.editor_alpha = 1;\n            }\n        }, 1);\n    }\n\n    /**\n     * @method onNodeSelectionChange\n     * @param node\n     * @todo\n     */\n    onNodeSelectionChange(node) {\n        // disabled\n    }\n\n    /**\n     * @method touchHandler\n     * @param {TouchEvent} event\n     */\n    touchHandler(event) {\n        // alert(\"foo\");\n        const touches = event.changedTouches;\n        const first = touches[0];\n        let type = \"\";\n\n        switch (event.type) {\n            case \"touchstart\":\n                type = \"mousedown\";\n                break;\n            case \"touchmove\":\n                type = \"mousemove\";\n                break;\n            case \"touchend\":\n                type = \"mouseup\";\n                break;\n            default:\n                return;\n        }\n\n        // initMouseEvent(type, canBubble, cancelable, view, clickCount,\n        //           screenX, screenY, clientX, clientY, ctrlKey,\n        //           altKey, shiftKey, metaKey, button, relatedTarget);\n\n        const window = this.getCanvasWindow();\n        const { document } = window;\n\n        const simulatedEvent = document.createEvent(\"MouseEvent\");\n        simulatedEvent.initMouseEvent(\n            type,\n            true,\n            true,\n            window,\n            1,\n            first.screenX,\n            first.screenY,\n            first.clientX,\n            first.clientY,\n            false,\n            false,\n            false,\n            false,\n            0 /* left */,\n            null,\n        );\n        first.target.dispatchEvent(simulatedEvent);\n        event.preventDefault();\n    }\n\n    /**\n     * @method onGroupAdd\n     * @param info\n     * @param entry\n     * @param {MouseEvent} mouseEvent\n     */\n    static onGroupAdd(info, entry, mouseEvent) {\n        const canvas = LGraphCanvas.active_canvas;\n\n        const group = new LGraphGroup();\n        group.pos = canvas.convertEventToCanvasOffset(mouseEvent);\n        canvas.graph.add(group);\n    }\n\n    static onMenuAdd(node, options, e, previousMenu, callback) {\n        const canvas = LGraphCanvas.active_canvas;\n        const refWindow = canvas.getCanvasWindow();\n        const { graph } = canvas;\n        if (!graph) return;\n\n        function inner_onMenuAdded(base_category, prev_menu) {\n            const categories = registry.getNodeTypesCategories(canvas.filter || graph.filter)\n                .filter((category) => category.startsWith(base_category));\n            const entries = [];\n\n            categories.forEach((category) => {\n                if (!category) {\n                    return;\n                }\n\n                const base_category_regex = new RegExp(`^(${base_category})`);\n                const category_name = category.replace(base_category_regex, \"\").split(\"/\")[0];\n                const category_path = base_category === \"\" ? `${category_name}/` : `${base_category + category_name}/`;\n\n                let name = category_name;\n                if (name.indexOf(\"::\") != -1) {\n                    name = name.split(\"::\")[1];\n                }\n\n                const index = entries.findIndex((entry) => entry.value === category_path);\n                if (index === -1) {\n                    entries.push({\n                        value: category_path,\n                        content: name,\n                        has_submenu: true,\n                        callback(value, event, mouseEvent, contextMenu) {\n                            inner_onMenuAdded(value.value, contextMenu);\n                        },\n                    });\n                }\n            });\n\n            const nodes = registry.getNodeTypesInCategory(base_category.slice(0, -1), canvas.filter || graph.filter);\n            nodes.forEach((node) => {\n                if (node.skip_list) return;\n\n                const entry = {\n                    value: node.type,\n                    content: node.title,\n                    has_submenu: false,\n                    callback(value, event, mouseEvent, contextMenu) {\n                        const first_event = contextMenu.getFirstEvent();\n                        canvas.graph.beforeChange();\n                        const node = LGraphNode.createNode(value.value);\n                        if (node) {\n                            node.pos = canvas.convertEventToCanvasOffset(first_event);\n                            canvas.graph.add(node);\n                        }\n                        if (callback) callback(node);\n                        canvas.graph.afterChange();\n                    },\n                };\n\n                entries.push(entry);\n            });\n\n            new ContextMenu(entries, {\n                event: e,\n                parentMenu: prev_menu,\n            }, refWindow);\n        }\n\n        inner_onMenuAdded(\"\", previousMenu);\n        return false;\n    }\n\n    /**\n     * @method onMenuCollapseAll\n     * @todo\n     */\n    static onMenuCollapseAll() {\n    }\n\n    /**\n     * @method onMenuNodeEdit\n     * @todo\n     */\n    static onMenuNodeEdit() {\n    }\n\n    static showMenuNodeOptionalInputs(v, optionsParam, e, previousMenu, node) {\n        if (!node) return;\n\n        const that = this;\n        const canvas = LGraphCanvas.active_canvas;\n        const refWindow = canvas.getCanvasWindow();\n\n        let options = node.optional_inputs;\n        if (node.onGetInputs) options = node.onGetInputs();\n\n        let entries = [];\n        if (options) {\n            for (const entry of options) {\n                if (!entry) {\n                    entries.push(null);\n                    continue;\n                }\n                let label = entry[0];\n                if (entry[2] && entry[2].label) {\n                    label = entry[2].label;\n                }\n                const data = {\n                    content: label,\n                    value: entry,\n                };\n                if (entry[1] === defaultConfig.ACTION) {\n                    data.className = \"event\";\n                }\n                entries.push(data);\n            }\n        }\n\n        if (this.onMenuNodeInputs) entries = this.onMenuNodeInputs(entries);\n\n        if (!entries.length) {\n            console.log(\"no input entries\");\n            return;\n        }\n\n        const menu = new ContextMenu(\n            entries,\n            {\n                event: e,\n                callback: innerClicked,\n                parentMenu: previousMenu,\n                node,\n            },\n            refWindow,\n        );\n\n        function innerClicked(v, e, prev) {\n            if (!node) {\n                return;\n            }\n\n            if (v.callback) {\n                v.callback.call(that, node, v, e, prev);\n            }\n\n            if (v.value) {\n                node.graph.beforeChange();\n                node.addInput(v.value[0], v.value[1], v.value[2]);\n                node.setDirtyCanvas(true, true);\n                node.graph.afterChange();\n            }\n        }\n\n        return false;\n    }\n\n    static showMenuNodeOptionalOutputs(v, optionsParam, e, previousMenu, node) {\n        if (!node) return;\n\n        const that = this;\n        const canvas = LGraphCanvas.active_canvas;\n        const refWindow = canvas.getCanvasWindow();\n\n        let options = node.optional_outputs;\n        if (node.onGetOutputs) {\n            options = node.onGetOutputs();\n        }\n\n        let entries = [];\n        if (options) {\n            for (const entry of options) {\n                if (!entry) {\n                    // separator?\n                    entries.push(null);\n                    continue;\n                }\n\n                if (node.flags\n                    && node.flags.skip_repeated_outputs\n                    && node.findOutputSlot(entry[0]) !== -1) {\n                    continue;\n                } // skip the ones already on\n                let label = entry[0];\n                if (entry[2] && entry[2].label) label = entry[2].label;\n                const data = {\n                    content: label,\n                    value: entry,\n                };\n                if (entry[1] === defaultConfig.EVENT) data.className = \"event\";\n                entries.push(data);\n            }\n        }\n\n        if (this.onMenuNodeOutputs) entries = this.onMenuNodeOutputs(entries);\n\n        if (!entries.length) return;\n\n        const menu = new ContextMenu(\n            entries,\n            {\n                event: e,\n                callback: innerClicked,\n                parentMenu: previousMenu,\n                node,\n            },\n            refWindow,\n        );\n\n        function innerClicked(v, e, prev) {\n            if (!node) return;\n\n            if (v.callback) v.callback.call(that, node, v, e, prev);\n\n            if (!v.value) {\n                return;\n            }\n\n            const value = v.value[1];\n\n            if (\n                value\n                && (value.constructor === Object || value.constructor === Array)\n            ) {\n                // submenu why?\n                const entries = [];\n                for (const i in value) {\n                    entries.push({\n                        content: i,\n                        value: value[i],\n                    });\n                }\n                new ContextMenu(entries, {\n                    event: e,\n                    callback: innerClicked,\n                    parentMenu: previousMenu,\n                    node,\n                });\n                return false;\n            }\n            node.graph.beforeChange();\n            node.addOutput(v.value[0], v.value[1], v.value[2]);\n            node.setDirtyCanvas(true, true);\n            node.graph.afterChange();\n        }\n\n        return false;\n    }\n\n    static onShowMenuNodeProperties(value, options, e, previousMenu, node) {\n        if (!node || !node.properties) {\n            return;\n        }\n\n        const canvas = LGraphCanvas.active_canvas;\n        const refWindow = canvas.getCanvasWindow();\n\n        const entries = [];\n        // eslint-disable-next-line\n        for (const i in node.properties) {\n            let value = node.properties[i] !== undefined ? node.properties[i] : \" \";\n            if (typeof value === \"object\") value = JSON.stringify(value);\n            const info = node.getPropertyInfo(i);\n            if (info.type == \"enum\" || info.type == \"combo\") value = LGraphCanvas.getPropertyPrintableValue(value, info.values);\n\n            // value could contain invalid html characters, clean that\n            value = LGraphCanvas.decodeHTML(value);\n            entries.push({\n                content:\n                    `<span class=\"property_name\">${\n                        info.label ? info.label : i\n                    }</span>`\n                    + `<span class=\"property_value\">${\n                        value\n                    }</span>`,\n                value: i,\n            });\n        }\n        if (!entries.length) {\n            return;\n        }\n\n        const menu = new ContextMenu(\n            entries,\n            {\n                event: e,\n                callback: innerClicked,\n                parentMenu: previousMenu,\n                allow_html: true,\n                node,\n            },\n            refWindow,\n        );\n\n        function innerClicked(v) {\n            if (!node) {\n                return;\n            }\n            const rect = this.getBoundingClientRect();\n            canvas.showEditPropertyValue(node, v.value, {\n                position: [rect.left, rect.top],\n            });\n        }\n\n        return false;\n    }\n\n    static decodeHTML(str) {\n        const e = document.createElement(\"div\");\n        e.innerText = str;\n        return e.innerHTML;\n    }\n\n    static onResizeNode(value, options, e, menu, node) {\n        if (!node) return;\n        node.size = node.computeSize();\n        if (node.onResize) node.onResize(node.size);\n        node.setDirtyCanvas(true, true);\n    }\n\n    showLinkMenu(link, e) {\n        const that = this;\n        const options = [\"Add Node\", null, \"Delete\"];\n        const menu = new ContextMenu(options, {\n            event: e,\n            title: link.data != null ? link.data.constructor.name : null,\n            callback: innerClicked,\n        });\n\n        function innerClicked(v, options, e) {\n            switch (v) {\n                case \"Add Node\":\n                    LGraphCanvas.onMenuAdd(null, null, e, menu, (node) => {\n                        console.log(\"node autoconnect\");\n                        const nodeLeft = that.graph.getNodeById(link.origin_id);\n                        const nodeRight = that.graph.getNodeById(link.target_id);\n                        if (!node.inputs\n                            || !node.inputs.length\n                            || !node.outputs\n                            || !node.outputs.length) return;\n                        if (nodeLeft.outputs[link.origin_slot].type === node.inputs[0].type && node.outputs[0].type === nodeRight.inputs[0].type) {\n                            nodeLeft.connect(link.origin_slot, node, 0);\n                            node.connect(0, nodeRight, link.target_slot);\n                            node.pos[0] -= node.size[0] * 0.5;\n                        }\n                    });\n                    break;\n                case \"Delete\":\n                    that.graph.removeLink(link.id);\n                    break;\n                default:\n            }\n        }\n\n        return false;\n    }\n\n    static onShowPropertyEditor(item, options, e, menu, node) {\n        const property = item.property || \"title\";\n        const value = node[property];\n\n        const dialog = document.createElement(\"div\");\n        dialog.className = \"graphdialog\";\n        dialog.innerHTML = \"<span class='name'></span><input autofocus type='text' class='value'/><button>OK</button>\";\n\n        const title = dialog.querySelector(\".name\");\n        title.innerText = property;\n\n        const input = dialog.querySelector(\".value\");\n        if (input) {\n            input.value = value;\n            input.addEventListener(\"blur\", (e) => {\n                input.focus();\n            });\n            input.addEventListener(\"keydown\", (e) => {\n                if (e.keyCode !== 13 && e.target.localName !== \"textarea\") return;\n                setValue(input.value);\n                e.preventDefault();\n                e.stopPropagation();\n            });\n        }\n\n        const graphcanvas = LGraphCanvas.active_canvas;\n        const { canvas } = graphcanvas;\n\n        const rect = canvas.getBoundingClientRect();\n        let offsetx = -20;\n        let offsety = -20;\n        if (rect) {\n            offsetx -= rect.left;\n            offsety -= rect.top;\n        }\n\n        if (e) {\n            dialog.style.left = `${e.clientX + offsetx}px`;\n            dialog.style.top = `${e.clientY + offsety}px`;\n        } else {\n            dialog.style.left = `${canvas.width * 0.5 + offsetx}px`;\n            dialog.style.top = `${canvas.height * 0.5 + offsety}px`;\n        }\n\n        const button = dialog.querySelector(\"button\");\n        button.addEventListener(\"click\", () => setValue(input.value));\n        canvas.parentNode.appendChild(dialog);\n\n        function setValue(value) {\n            if (item.type === \"Number\") {\n                value = Number(value);\n            } else if (item.type === \"Boolean\") {\n                value = Boolean(value);\n            }\n            node[property] = value;\n            if (dialog.parentNode) {\n                dialog.parentNode.removeChild(dialog);\n            }\n            node.setDirtyCanvas(true, true);\n        }\n    }\n\n    prompt(title = \"\", value, callback, event, multiline) {\n        const that = this;\n\n        let modified = false;\n\n        const dialog = document.createElement(\"div\");\n        dialog.className = \"graphdialog rounded\";\n        if (multiline) {\n            dialog.innerHTML = \"<span class='name'></span> <textarea autofocus class='value'></textarea><button class='rounded'>OK</button>\";\n        } else {\n            dialog.innerHTML = \"<span class='name'></span> <input autofocus type='text' class='value'/><button class='rounded'>OK</button>\";\n        }\n        dialog.close = () => {\n            this.prompt_box = null;\n            if (dialog.parentNode) dialog.parentNode.removeChild(dialog);\n        };\n\n        if (this.ds.scale > 1) {\n            dialog.style.transform = `scale(${this.ds.scale})`;\n        }\n\n        dialog.addEventListener(\"mouseleave\", (e) => {\n            if (!modified) dialog.close();\n        });\n\n        if (this.prompt_box) {\n            this.prompt_box.close();\n        }\n        this.prompt_box = dialog;\n\n        const first = null;\n        const timeout = null;\n        const selected = null;\n\n        const nameElement = dialog.querySelector(\".name\");\n        nameElement.innerText = title;\n        const valueElement = dialog.querySelector(\".value\");\n        valueElement.value = value;\n\n        const input = valueElement;\n        input.addEventListener(\"keydown\", (e) => {\n            modified = true;\n            if (e.keyCode === 27) dialog.close();\n            else if (e.keyCode === 13 && e.target.localName !== \"textarea\") {\n                if (callback) {\n                    callback(input.value);\n                }\n                dialog.close();\n            } else {\n                return;\n            }\n            e.preventDefault();\n            e.stopPropagation();\n        });\n\n        const button = dialog.querySelector(\"button\");\n        button.addEventListener(\"click\", () => {\n            if (callback) callback(input.value);\n            this.setDirty(true);\n            dialog.close();\n        });\n\n        const graphcanvas = LGraphCanvas.active_canvas;\n        const { canvas } = graphcanvas;\n\n        const rect = canvas.getBoundingClientRect();\n        let offsetx = -20;\n        let offsety = -20;\n        if (rect) {\n            offsetx -= rect.left;\n            offsety -= rect.top;\n        }\n\n        if (event) {\n            dialog.style.left = `${event.clientX + offsetx}px`;\n            dialog.style.top = `${event.clientY + offsety}px`;\n        } else {\n            dialog.style.left = `${canvas.width * 0.5 + offsetx}px`;\n            dialog.style.top = `${canvas.height * 0.5 + offsety}px`;\n        }\n\n        canvas.parentNode.appendChild(dialog);\n        setTimeout(() => input.focus(), 10);\n\n        return dialog;\n    }\n\n    static search_limit = -1\n\n    showSearchBox = function (event) {\n        const that = this;\n        const graphcanvas = LGraphCanvas.active_canvas;\n        const { canvas } = graphcanvas;\n        const rootDocument = canvas.ownerDocument || document;\n\n        const dialog = document.createElement(\"div\");\n        dialog.className = \"litegraph litesearchbox graphdialog rounded\";\n        dialog.innerHTML = \"<span class='name'>Search</span> <input autofocus type='text' class='value rounded'/><div class='helper'></div>\";\n        dialog.close = () => {\n            this.search_box = null;\n            rootDocument.body.focus();\n            rootDocument.body.style.overflow = \"\";\n\n            setTimeout(() => {\n                this.canvas.focus();\n            }, 20); // important, if canvas loses focus keys wont be captured\n            if (dialog.parentNode) {\n                dialog.parentNode.removeChild(dialog);\n            }\n        };\n\n        let timeoutClose = null;\n\n        if (this.ds.scale > 1) dialog.style.transform = `scale(${this.ds.scale})`;\n\n        dialog.addEventListener(\"mouseenter\", () => {\n            if (timeoutClose) {\n                clearTimeout(timeoutClose);\n                timeoutClose = null;\n            }\n        });\n\n        dialog.addEventListener(\"mouseleave\", () => {\n            // dialog.close();\n            timeoutClose = setTimeout(() => dialog.close(), 500);\n        });\n\n        if (this.search_box) this.search_box.close();\n        this.search_box = dialog;\n\n        const helper = dialog.querySelector(\".helper\");\n\n        let first = null;\n        let timeout = null;\n        let selected = null;\n\n        const input = dialog.querySelector(\"input\");\n        if (input) {\n            input.addEventListener(\"blur\", () => input.focus());\n            input.addEventListener(\"keydown\", (e) => {\n                if (e.keyCode === 38) {\n                    // UP\n                    changeSelection(false);\n                } else if (e.keyCode === 40) {\n                    // DOWN\n                    changeSelection(true);\n                } else if (e.keyCode === 27) {\n                    // ESC\n                    dialog.close();\n                } else if (e.keyCode === 13) {\n                    if (selected) {\n                        select(selected.innerHTML);\n                    } else if (first) {\n                        select(first);\n                    } else {\n                        dialog.close();\n                    }\n                } else {\n                    if (timeout) {\n                        clearInterval(timeout);\n                    }\n                    timeout = setTimeout(refreshHelper, 10);\n                    return;\n                }\n                e.preventDefault();\n                e.stopPropagation();\n                e.stopImmediatePropagation();\n                return true;\n            });\n        }\n\n        if (rootDocument.fullscreenElement) rootDocument.fullscreenElement.appendChild(dialog);\n        else {\n            rootDocument.body.appendChild(dialog);\n            rootDocument.body.style.overflow = \"hidden\";\n        }\n\n        // compute best position\n        const rect = canvas.getBoundingClientRect();\n\n        const left = (event ? event.clientX : (rect.left + rect.width * 0.5)) - 80;\n        const top = (event ? event.clientY : (rect.top + rect.height * 0.5)) - 20;\n        dialog.style.left = `${left}px`;\n        dialog.style.top = `${top}px`;\n\n        // To avoid out of screen problems\n        if (event.layerY > (rect.height - 200)) {\n            helper.style.maxHeight = `${rect.height - event.layerY - 20}px`;\n        }\n\n        input.focus();\n\n        function select(name) {\n            if (name) {\n                if (that.onSearchBoxSelection) {\n                    that.onSearchBoxSelection(name, event, graphcanvas);\n                } else {\n                    const extra = defaultConfig.searchbox_extras[name.toLowerCase()];\n                    if (extra) {\n                        name = extra.type;\n                    }\n\n                    graphcanvas.graph.beforeChange();\n                    const node = LGraphNode.createNode(name);\n                    if (node) {\n                        node.pos = graphcanvas.convertEventToCanvasOffset(\n                            event,\n                        );\n                        graphcanvas.graph.add(node);\n                    }\n\n                    if (extra && extra.data) {\n                        if (extra.data.properties) {\n                            // eslint-disable-next-line\n                            for (const i in extra.data.properties) {\n                                node.addProperty(i, extra.data.properties[i]);\n                            }\n                        }\n                        if (extra.data.inputs) {\n                            node.inputs = [];\n                            // eslint-disable-next-line\n                            for (const i in extra.data.inputs) {\n                                node.addOutput(\n                                    extra.data.inputs[i][0],\n                                    extra.data.inputs[i][1],\n                                );\n                            }\n                        }\n                        if (extra.data.outputs) {\n                            node.outputs = [];\n                            // eslint-disable-next-line\n                            for (const i in extra.data.outputs) {\n                                node.addOutput(\n                                    extra.data.outputs[i][0],\n                                    extra.data.outputs[i][1],\n                                );\n                            }\n                        }\n                        if (extra.data.title) node.title = extra.data.title;\n                        if (extra.data.json) node.configure(extra.data.json);\n\n                        graphcanvas.graph.afterChange();\n                    }\n                }\n            }\n\n            dialog.close();\n        }\n\n        function changeSelection(forward) {\n            const prev = selected;\n            if (selected) selected.classList.remove(\"selected\");\n            if (!selected) {\n                selected = forward\n                    ? helper.childNodes[0]\n                    : helper.childNodes[helper.childNodes.length];\n            } else {\n                selected = forward\n                    ? selected.nextSibling\n                    : selected.previousSibling;\n                if (!selected) selected = prev;\n            }\n            if (!selected) return;\n            selected.classList.add(\"selected\");\n            selected.scrollIntoView({\n                block: \"end\",\n                behavior: \"smooth\",\n            });\n        }\n\n        function refreshHelper() {\n            timeout = null;\n            let str = input.value;\n            first = null;\n            helper.innerHTML = \"\";\n            if (!str) return;\n\n            if (that.onSearchBox) {\n                const list = that.onSearchBox(helper, str, graphcanvas);\n                if (list) {\n                    for (const l of list) addResult(l);\n                }\n            } else {\n                let c = 0;\n                str = str.toLowerCase();\n                const filter = graphcanvas.filter || graphcanvas.graph.filter;\n\n                // extras\n                // eslint-disable-next-line\n                for (const i in defaultConfig.searchbox_extras) {\n                    const extra = defaultConfig.searchbox_extras[i];\n                    if (extra.desc.toLowerCase().indexOf(str) === -1) {\n                        continue;\n                    }\n                    const ctor = defaultConfig.registered_node_types[extra.type];\n                    if (ctor && ctor.filter !== filter) continue;\n                    addResult(extra.desc, \"searchbox_extra\");\n                    if (LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit) {\n                        break;\n                    }\n                }\n\n                const keys = Object.keys(defaultConfig.registered_node_types); // types\n                const filtered = keys.filter((type) => {\n                    const ctor = defaultConfig.registered_node_types[type];\n                    if (filter && ctor.filter !== filter) return false;\n                    return type.toLowerCase().indexOf(str) !== -1;\n                });\n\n                for (const filteredItem of filtered) {\n                    addResult(filteredItem);\n                    if (LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit) {\n                        break;\n                    }\n                }\n            }\n\n            function addResult(type, className) {\n                const help = document.createElement(\"div\");\n                if (!first) first = type;\n                help.innerText = type;\n                help.dataset.type = escape(type);\n                help.className = \"litegraph lite-search-item\";\n                if (className) help.className += ` ${className}`;\n                help.addEventListener(\"click\", () => {\n                    select(unescape(help.dataset.type));\n                });\n                helper.appendChild(help);\n            }\n        }\n\n        return dialog;\n    }\n\n    showEditPropertyValue(node, property, options = {}) {\n        if (!node || node.properties[property] === undefined) return;\n\n        const info = node.getPropertyInfo(property);\n        const { type } = info;\n\n        let inputHTML = \"\";\n\n        if ([\"sring\", \"number\", \"array\", \"object\"].includes(type)) {\n            inputHTML = \"<input autofocus type='text' class='value'/>\";\n        } else if ([\"enum\", \"combo\"].includes(type) && info.values) {\n            inputHTML = \"<select autofocus type='text' class='value'>\";\n            // eslint-disable-next-line\n            for (const i in info.values) {\n                let value = i;\n                if (info.values.constructor === Array) value = info.values[i];\n\n                inputHTML += `<option value=\"${value}\" ${value == node.properties[property] ? \"selected\" : \"\"}>${info.values[i]}</option>`;\n            }\n            inputHTML += \"</select>\";\n        } else if (type === \"boolean\") {\n            inputHTML = `<input autofocus type=\"checkbox\" class=\"value\" ${\n                node.properties[property] ? \"checked\" : \"\"\n            }/>`;\n        } else {\n            console.warn(`unknown type: ${type}`);\n            return;\n        }\n\n        const dialog = this.createDialog(\n            `<span class=\"name\">${\n                info.label ? info.label : property\n            }</span>${\n                inputHTML\n            }<button>OK</button>`,\n            options,\n        );\n\n        if ([\"enum\", \"combo\"].includes(type) && info.values) {\n            const input = dialog.querySelector(\"select\");\n            input.addEventListener(\"change\", (e) => {\n                setValue(e.target.value);\n            });\n        } else if (type === \"boolean\") {\n            const input = dialog.querySelector(\"input\");\n            if (input) {\n                input.addEventListener(\"click\", () => setValue(!!input.checked));\n            }\n        } else {\n            const input = dialog.querySelector(\"input\");\n            if (input) {\n                input.addEventListener(\"blur\", () => { input.focus(); });\n\n                let v = node.properties[property] !== undefined ? node.properties[property] : \"\";\n                if (type !== \"string\") {\n                    v = JSON.stringify(v);\n                }\n\n                input.value = v;\n                input.addEventListener(\"keydown\", (e) => {\n                    if (e.keyCode != 13) return;\n                    setValue(input.value);\n                    e.preventDefault();\n                    e.stopPropagation();\n                });\n            }\n        }\n\n        const button = dialog.querySelector(\"button\");\n        button.addEventListener(\"click\", () => setValue(input.value));\n        function setValue(value) {\n            if (info\n                && info.values\n                && info.values.constructor === Object\n                && info.values[value] !== undefined) value = info.values[value];\n\n            if (typeof node.properties[property] === \"number\") {\n                value = Number(value);\n            }\n            if ([\"array\", \"object\"].includes(type)) {\n                value = JSON.parse(value);\n            }\n            node.properties[property] = value;\n            if (node.graph) {\n                node.graph._version++;\n            }\n            if (node.onPropertyChanged) {\n                node.onPropertyChanged(property, value);\n            }\n            if (options.onclose) options.onclose();\n            dialog.close();\n            node.setDirtyCanvas(true, true);\n        }\n\n        return dialog;\n    }\n\n    createDialog(html, options = {}) {\n        const dialog = document.createElement(\"div\");\n        dialog.className = \"graphdialog\";\n        dialog.innerHTML = html;\n\n        const rect = this.canvas.getBoundingClientRect();\n        let offsetx = -20;\n        let offsety = -20;\n        if (rect) {\n            offsetx -= rect.left;\n            offsety -= rect.top;\n        }\n\n        if (options.position) {\n            offsetx += options.position[0];\n            offsety += options.position[1];\n        } else if (options.event) {\n            offsetx += options.event.clientX;\n            offsety += options.event.clientY;\n        } // centered\n        else {\n            offsetx += this.canvas.width * 0.5;\n            offsety += this.canvas.height * 0.5;\n        }\n\n        dialog.style.left = `${offsetx}px`;\n        dialog.style.top = `${offsety}px`;\n\n        this.canvas.parentNode.appendChild(dialog);\n\n        dialog.close = () => {\n            if (dialog.parentNode) dialog.parentNode.removeChild(this);\n        };\n\n        return dialog;\n    }\n\n    createPanel(title, options = {}) {\n        const refWindow = options.window || window;\n\n        const root = document.createElement(\"div\");\n        root.className = \"litegraph dialog\";\n        root.innerHTML = \"<div class='dialog-header'><span class='dialog-title'></span></div><div class='dialog-content'></div><div class='dialog-footer'></div>\";\n        root.header = root.querySelector(\".dialog-header\");\n\n        if (options.width) root.style.width = options.width + (options.width.constructor === Number ? \"px\" : \"\");\n        if (options.height) root.style.height = options.height + (options.height.constructor === Number ? \"px\" : \"\");\n        if (options.closable) {\n            const close = document.createElement(\"span\");\n            close.innerHTML = \"&#10005;\";\n            close.classList.add(\"close\");\n            close.addEventListener(\"click\", () => root.close());\n            root.header.appendChild(close);\n        }\n        root.title_element = root.querySelector(\".dialog-title\");\n        root.title_element.innerText = title;\n        root.content = root.querySelector(\".dialog-content\");\n        root.footer = root.querySelector(\".dialog-footer\");\n\n        root.close = () => root.parentNode.removeChild(this);\n\n        root.clear = () => root.content.innerHTML = \"\";\n\n        root.addHTML = (code, classname, onFooter) => {\n            const elem = document.createElement(\"div\");\n            if (classname) elem.className = classname;\n            elem.innerHTML = code;\n            if (onFooter) root.footer.appendChild(elem);\n            else root.content.appendChild(elem);\n            return elem;\n        };\n\n        root.addButton = (name, callback, options) => {\n            const elem = document.createElement(\"button\");\n            elem.innerText = name;\n            elem.options = options;\n            elem.classList.add(\"btn\");\n            elem.addEventListener(\"click\", callback);\n            root.footer.appendChild(elem);\n            return elem;\n        };\n\n        root.addSeparator = () => {\n            const elem = document.createElement(\"div\");\n            elem.className = \"separator\";\n            root.content.appendChild(elem);\n        };\n\n        root.addWidget = (type, name, value, options = {}, callback) => {\n            type = type.toLowerCase();\n\n            let strValue = type === \"number\" ? value.toFixed(3) : value.toString();\n            const elem = document.createElement(\"div\");\n            elem.className = \"property\";\n            elem.innerHTML = \"<span class='property_name'></span><span class='property_value'></span>\";\n            elem.querySelector(\".property_name\").innerText = name;\n            const valueElement = elem.querySelector(\".property_value\");\n            valueElement.innerText = strValue;\n            elem.dataset.property = name;\n            elem.dataset.type = options.type || type;\n            elem.options = options;\n            elem.value = strValue;\n\n            if (type === \"boolean\") {\n                elem.classList.add(\"boolean\");\n                if (value) elem.classList.add(\"bool-on\");\n                elem.addEventListener(\"click\", () => {\n                    // var v = node.properties[this.dataset[\"property\"]];\n                    // node.setProperty(this.dataset[\"property\"],!v); this.innerText = v ? \"true\" :\n                    // \"false\";\n                    const propname = elem.dataset.property;\n                    this.value = !elem.value;\n                    this.classList.toggle(\"bool-on\");\n                    this.querySelector(\".property_value\").innerText = this.value ? \"true\" : \"false\";\n                    innerChange(propname, this.value);\n                });\n            } else if ([\"string\", \"number\"].includes(type)) {\n                valueElement.setAttribute(\"contenteditable\", true);\n                valueElement.addEventListener(\"keydown\", (e) => {\n                    if (e.code === \"Enter\") {\n                        e.preventDefault();\n                        valueElement.blur();\n                    }\n                });\n                valueElement.addEventListener(\"blur\", () => {\n                    let v = this.innerText;\n                    const propname = valueElement.parentNode.dataset.property;\n                    const proptype = valueElement.parentNode.dataset.type;\n                    if (proptype === \"number\") v = Number(v);\n                    innerChange(propname, v);\n                });\n            } else if ([\"enum\", \"combo\"].includes(type)) strValue = LGraphCanvas.getPropertyPrintableValue(value, options.values);\n            valueElement.innerText = strValue;\n\n            valueElement.addEventListener(\"click\", (event) => {\n                const values = options.values || [];\n                const propname = valueElement.parentNode.dataset.property;\n                const menu = new ContextMenu(values, {\n                    event,\n                    className: \"dark\",\n                    callback: (v, option, event) => {\n                        this.innerText = v;\n                        innerChange(propname, v);\n                        return false;\n                    },\n                },\n                refWindow);\n            });\n\n            root.content.appendChild(elem);\n\n            function innerChange(name, value) {\n                console.log(\"change\", name, value);\n                // that.dirty_canvas = true;\n                if (options.callback) options.callback(name, value);\n                if (callback) callback(name, value);\n            }\n\n            return elem;\n        };\n\n        return root;\n    }\n\n    static getPropertyPrintableValue(value, values) {\n        if (!values) return String(value);\n        if (values.constructor === Array) return String(value);\n\n        if (values.constructor === Object) {\n            let desc_value = \"\";\n            for (const k in values) {\n                if (values[k] !== value) continue;\n                desc_value = k;\n                break;\n            }\n            return `${String(value)} (${desc_value})`;\n        }\n    }\n\n    showShowNodePanel = function (node) {\n        window.SELECTED_NODE = node;\n        let panel = document.querySelector(\"#node-panel\");\n        if (panel) panel.close();\n        const refWindow = this.getCanvasWindow();\n        panel = this.createPanel(node.title || \"\", {\n            closable: true,\n            window: refWindow,\n        });\n        panel.id = \"node-panel\";\n        panel.node = node;\n        panel.classList.add(\"settings\");\n        const that = this;\n        const graphcanvas = this;\n\n        const inner_refresh = () => {\n            panel.content.innerHTML = \"\"; // clear\n            panel.addHTML(`<span class=\"node_type\">${node.type}</span><span class=\"node_desc\">${node.constructor.desc || \"\"}</span><span class=\"separator\"></span>`);\n\n            panel.addHTML(\"<h3>Properties</h3>\");\n\n            for (const i in node.properties) {\n                const value = node.properties[i];\n                const info = node.getPropertyInfo(i);\n\n                if (node.onAddPropertyToPanel && node.onAddPropertyToPanel(i, panel)) continue;\n\n                panel.addWidget(info.widget || info.type, i, value, info, (name, value) => {\n                    graphcanvas.graph.beforeChange(node);\n                    node.setProperty(name, value);\n                    graphcanvas.graph.afterChange();\n                    graphcanvas.dirty_canvas = true;\n                });\n            }\n\n            panel.addSeparator();\n\n            if (node.onShowCustomPanelInfo) node.onShowCustomPanelInfo(panel);\n            panel.addButton(\"Delete\", () => {\n                if (node.block_delete) return;\n                node.graph.remove(node);\n                panel.close();\n            })\n                .classList\n                .add(\"delete\");\n        };\n\n        function inner_showCodePad(node, propname) {\n            panel.style.top = \"calc( 50% - 250px)\";\n            panel.style.left = \"calc( 50% - 400px)\";\n            panel.style.width = \"800px\";\n            panel.style.height = \"500px\";\n\n            panel.content.innerHTML = \"<textarea class='code'></textarea>\";\n            const textarea = panel.content.querySelector(\"textarea\");\n            textarea.value = node.properties[propname];\n            textarea.addEventListener(\"keydown\", (e) => {\n                if (e.code === \"Enter\" && e.ctrlKey) {\n                    console.log(\"Assigned\");\n                    node.setProperty(propname, textarea.value);\n                }\n            });\n            textarea.style.height = \"calc(100% - 40px)\";\n\n            const assign = that.createButton(\"Assign\", null, () => {\n                node.setProperty(propname, textarea.value);\n            });\n            panel.content.appendChild(assign);\n            const button = that.createButton(\"Close\", null, () => {\n                panel.style.height = \"\";\n                inner_refresh();\n            });\n            button.style.float = \"right\";\n            panel.content.appendChild(button);\n        }\n\n        inner_refresh();\n\n        this.canvas.parentNode.appendChild(panel);\n    }\n\n    showSubgraphPropertiesDialog(node) {\n        console.log(\"showing subgraph properties dialog\");\n\n        const old_panel = this.canvas.parentNode.querySelector(\".subgraph_dialog\");\n        if (old_panel) old_panel.close();\n\n        const panel = this.createPanel(\"Subgraph Inputs\", {\n            closable: true,\n            width: 500,\n        });\n        panel.node = node;\n        panel.classList.add(\"subgraph_dialog\");\n\n        function inner_refresh() {\n            panel.clear();\n\n            // show currents\n            if (node.inputs) {\n                for (const input of node.inputs) {\n                    if (input.not_subgraph_input) continue;\n                    const html = \"<button>&#10005;</button> <span class='bullet_icon'></span><span class='name'></span><span class='type'></span>\";\n                    const elem = panel.addHTML(html, \"subgraph_property\");\n                    elem.dataset.name = input.name;\n                    elem.dataset.slot = i;\n                    elem.querySelector(\".name\").innerText = input.name;\n                    elem.querySelector(\".type\").innerText = input.type;\n                    elem.querySelector(\"button\")\n                        .addEventListener(\"click\", () => {\n                            node.removeInput(Number(elem.parentNode.dataset.slot));\n                            inner_refresh();\n                        });\n                }\n            }\n        }\n\n        // add extra\n        const html = \" + <span class='label'>Name</span><input class='name'/><span class='label'>Type</span><input class='type'/><button>+</button>\";\n        const elem = panel.addHTML(html, \"subgraph_property extra\", true);\n        elem.querySelector(\"button\")\n            .addEventListener(\"click\", function (e) {\n                const elem = this.parentNode;\n                const name = elem.querySelector(\".name\").value;\n                const type = elem.querySelector(\".type\").value;\n                if (!name || node.findInputSlot(name) !== -1) return;\n                node.addInput(name, type);\n                elem.querySelector(\".name\").value = \"\";\n                elem.querySelector(\".type\").value = \"\";\n                inner_refresh();\n            });\n\n        inner_refresh();\n        this.canvas.parentNode.appendChild(panel);\n        return panel;\n    }\n\n    checkPanels() {\n        if (!this.canvas) return;\n        const panels = this.canvas.parentNode.querySelectorAll(\".litegraph.dialog\");\n        for (const panel of panels) {\n            if (!panel.node) continue;\n            if (!panel.node.graph || panel.graph !== this.graph) panel.close();\n        }\n    }\n\n    static onMenuNodeCollapse(value, options, e, menu, node) {\n        node.graph.beforeChange(node);\n        node.collapse();\n        node.graph.afterChange(node);\n    }\n\n    static onMenuNodePin(value, options, e, menu, node) {\n        node.pin();\n    }\n\n    static onMenuNodeMode = function (value, options, e, menu, node) {\n        new ContextMenu(\n            [\"Always\", \"On Event\", \"On Trigger\", \"Never\"],\n            {\n                event: e,\n                callback: (v) => {\n                    if (!node) {\n                        return;\n                    }\n                    switch (v) {\n                        case \"On Event\":\n                            node.mode = defaultConfig.ON_EVENT;\n                            break;\n                        case \"On Trigger\":\n                            node.mode = defaultConfig.ON_TRIGGER;\n                            break;\n                        case \"Never\":\n                            node.mode = defaultConfig.NEVER;\n                            break;\n                        case \"Always\":\n                        default:\n                            node.mode = defaultConfig.ALWAYS;\n                            break;\n                    }\n                },\n                parentMenu: menu,\n                node,\n            },\n        );\n        return false;\n    }\n\n    static onMenuNodeColors(value, options, e, menu, node) {\n        if (!node) throw new Error(\"no node for color\");\n        const values = [];\n        values.push({\n            value: null,\n            content:\n                \"<span style='display: block; padding-left: 4px;'>No color</span>\",\n        });\n\n        // eslint-disable-next-line\n        for (const i in LGraphCanvas.node_colors) {\n            const color = LGraphCanvas.node_colors[i];\n            values.push({\n                value: i,\n                content: `<span style=\"display: block; color: #999; padding-left: 4px; border-left: 8px solid ${color.color}; background-color:${color.bgcolor}\">${i}</span>`,\n            });\n        }\n        new ContextMenu(values, {\n            event: e,\n            callback: (v) => {\n                if (!node) {\n                    return;\n                }\n\n                const color = v.value ? LGraphCanvas.node_colors[v.value] : null;\n                if (color) {\n                    if (node.constructor.name === \"LGraphGroup\") {\n                        node.color = color.groupcolor;\n                    } else {\n                        node.color = color.color;\n                        node.bgcolor = color.bgcolor;\n                    }\n                } else {\n                    delete node.color;\n                    delete node.bgcolor;\n                }\n                node.setDirtyCanvas(true, true);\n            },\n            parentMenu: menu,\n            node,\n        });\n\n        return false;\n    }\n\n    static onMenuNodeShapes(value, options, e, menu, node) {\n        if (!node) {\n            throw new Error(\"no node passed\");\n        }\n\n        new ContextMenu(defaultConfig.VALID_SHAPES, {\n            event: e,\n            callback: (v) => {\n                if (!node) return;\n                node.graph.beforeChange(node);\n                node.shape = v;\n                node.graph.afterChange(node);\n                node.setDirtyCanvas(true);\n            },\n        }, {\n            parentMenu: menu,\n            node,\n        });\n\n        return false;\n    }\n\n    static onMenuNodeRemove(value, options, e, menu, node) {\n        if (!node) throw new Error(\"no node passed\");\n        if (node.removable === false) return;\n\n        const { graph } = node;\n        graph.beforeChange();\n        graph.remove(node);\n        graph.afterChange();\n        node.setDirtyCanvas(true, true);\n    }\n\n    static onMenuNodeToSubgraph(value, options, e, menu, node) {\n        const { graph } = node;\n        const graphcanvas = LGraphCanvas.active_canvas;\n        if (!graphcanvas) return;\n\n        let nodesList = Object.values(graphcanvas.selected_nodes || {});\n        if (!nodesList.length) nodesList = [node];\n\n        const subgraphNode = LGraphNode.createNode(\"graph/subgraph\");\n        subgraphNode.pos = node.pos.concat();\n        graph.add(subgraphNode);\n\n        subgraphNode.buildFromNodes(nodesList);\n\n        graphcanvas.deselectAllNodes();\n        node.setDirtyCanvas(true, true);\n    }\n\n    static onMenuNodeClone(value, options, e, menu, node) {\n        if (node.clonable === false) return;\n        const newnode = node.clone();\n        if (!newnode) return;\n        newnode.pos = [node.pos[0] + 5, node.pos[1] + 5];\n\n        node.graph.beforeChange();\n        node.graph.add(newnode);\n        node.graph.afterChange();\n\n        node.setDirtyCanvas(true, true);\n    }\n\n    static node_colors = {\n        red: {\n            color: \"#322\",\n            bgcolor: \"#533\",\n            groupcolor: \"#A88\",\n        },\n        brown: {\n            color: \"#332922\",\n            bgcolor: \"#593930\",\n            groupcolor: \"#b06634\",\n        },\n        green: {\n            color: \"#232\",\n            bgcolor: \"#353\",\n            groupcolor: \"#8A8\",\n        },\n        blue: {\n            color: \"#223\",\n            bgcolor: \"#335\",\n            groupcolor: \"#88A\",\n        },\n        pale_blue: {\n            color: \"#2a363b\",\n            bgcolor: \"#3f5159\",\n            groupcolor: \"#3f789e\",\n        },\n        cyan: {\n            color: \"#233\",\n            bgcolor: \"#355\",\n            groupcolor: \"#8AA\",\n        },\n        purple: {\n            color: \"#323\",\n            bgcolor: \"#535\",\n            groupcolor: \"#a1309b\",\n        },\n        yellow: {\n            color: \"#432\",\n            bgcolor: \"#653\",\n            groupcolor: \"#b58b2a\",\n        },\n        black: {\n            color: \"#222\",\n            bgcolor: \"#000\",\n            groupcolor: \"#444\",\n        },\n    }\n\n    getCanvasMenuOptions() {\n        let options = null;\n        if (this.getMenuOptions) {\n            options = this.getMenuOptions();\n        } else {\n            options = [\n                {\n                    content: \"Add Node\",\n                    has_submenu: true,\n                    callback: LGraphCanvas.onMenuAdd,\n                },\n                {\n                    content: \"Add Group\",\n                    callback: LGraphCanvas.onGroupAdd,\n                },\n                // {content:\"Collapse All\", callback: LGraphCanvas.onMenuCollapseAll }\n            ];\n\n            if (this._graph_stack && this._graph_stack.length > 0) {\n                options.push(null, {\n                    content: \"Close subgraph\",\n                    callback: this.closeSubgraph.bind(this),\n                });\n            }\n        }\n\n        if (this.getExtraMenuOptions) {\n            const extra = this.getExtraMenuOptions(this, options);\n            if (extra) options = options.concat(extra);\n        }\n\n        return options;\n    }\n\n    getNodeMenuOptions(node) {\n        let options = null;\n\n        if (node.getMenuOptions) options = node.getMenuOptions(this);\n        else {\n            options = [\n                {\n                    content: \"Inputs\",\n                    has_submenu: true,\n                    disabled: true,\n                    callback: LGraphCanvas.showMenuNodeOptionalInputs,\n                },\n                {\n                    content: \"Outputs\",\n                    has_submenu: true,\n                    disabled: true,\n                    callback: LGraphCanvas.showMenuNodeOptionalOutputs,\n                },\n                null,\n                {\n                    content: \"Properties\",\n                    has_submenu: true,\n                    callback: LGraphCanvas.onShowMenuNodeProperties,\n                },\n                null,\n                {\n                    content: \"Title\",\n                    callback: LGraphCanvas.onShowPropertyEditor,\n                },\n                {\n                    content: \"Mode\",\n                    has_submenu: true,\n                    callback: LGraphCanvas.onMenuNodeMode,\n                },\n                {\n                    content: \"Resize\",\n                    callback() {\n                        if (node.resizable) {\n                            return LGraphCanvas.onResizeNode;\n                        }\n                    },\n                },\n                {\n                    content: \"Collapse\",\n                    callback: LGraphCanvas.onMenuNodeCollapse,\n                },\n                {\n                    content: \"Pin\",\n                    callback: LGraphCanvas.onMenuNodePin,\n                },\n                {\n                    content: \"Colors\",\n                    has_submenu: true,\n                    callback: LGraphCanvas.onMenuNodeColors,\n                },\n                {\n                    content: \"Shapes\",\n                    has_submenu: true,\n                    callback: LGraphCanvas.onMenuNodeShapes,\n                },\n                null,\n            ];\n        }\n\n        if (node.onGetInputs) {\n            const inputs = node.onGetInputs();\n            if (inputs && inputs.length) options[0].disabled = false;\n        }\n\n        if (node.onGetOutputs) {\n            const outputs = node.onGetOutputs();\n            if (outputs && outputs.length) options[1].disabled = false;\n        }\n\n        if (node.getExtraMenuOptions) {\n            const extra = node.getExtraMenuOptions(this, options);\n            if (extra) {\n                extra.push(null);\n                options = extra.concat(options);\n            }\n        }\n\n        if (node.clonable !== false) {\n            options.push({\n                content: \"Clone\",\n                callback: LGraphCanvas.onMenuNodeClone,\n            });\n        }\n\n        options.push(null, {\n            content: \"Remove\",\n            disabled: !(node.removable !== false && !node.block_delete),\n            callback: LGraphCanvas.onMenuNodeRemove,\n        });\n\n        if (node.graph && node.graph.onGetNodeMenuOptions) {\n            node.graph.onGetNodeMenuOptions(options, node);\n        }\n\n        return options;\n    }\n\n    getGroupMenuOptions() {\n        return [\n            {\n                content: \"Title\",\n                callback: LGraphCanvas.onShowPropertyEditor,\n            },\n            {\n                content: \"Color\",\n                has_submenu: true,\n                callback: LGraphCanvas.onMenuNodeColors,\n            },\n            {\n                content: \"Font size\",\n                property: \"font_size\",\n                type: \"Number\",\n                callback: LGraphCanvas.onShowPropertyEditor,\n            },\n            null,\n            {\n                content: \"Remove\",\n                callback: LGraphCanvas.onMenuNodeRemove,\n            },\n        ];\n    }\n\n    processContextMenu(node, event) {\n        const that = this;\n        const canvas = LGraphCanvas.active_canvas;\n        const refWindow = canvas.getCanvasWindow();\n\n        let menuInfo = null;\n        const options = {\n            event,\n            callback: inner_option_clicked,\n            extra: node,\n        };\n\n        if (node) options.title = node.type;\n\n        // check if mouse is in input\n        let slot = null;\n        if (node) {\n            slot = node.getSlotInPosition(event.canvasX, event.canvasY);\n            LGraphCanvas.active_node = node;\n        }\n\n        if (slot) {\n            // on slot\n            menuInfo = [];\n            if (node.getSlotMenuOptions) menuInfo = node.getSlotMenuOptions(slot);\n            else {\n                if (slot && slot.output && slot.output.links && slot.output.links.length) {\n                    menuInfo.push({\n                        content: \"Disconnect Links\",\n                        slot,\n                    });\n                }\n                const _slot = slot.input || slot.output;\n                menuInfo.push(_slot.locked ? \"Cannot remove\" : { content: \"Remove Slot\", slot });\n                menuInfo.push(_slot.nameLocked ? \"Cannot rename\" : { content: \"Rename Slot\", slot });\n            }\n            options.title = (slot.input ? slot.input.type : slot.output.type) || \"*\";\n            if (slot.input && slot.input.type === defaultConfig.ACTION) options.title = \"Action\";\n            if (slot.output && slot.output.type === defaultConfig.EVENT) options.title = \"Event\";\n        } else if (node) {\n            menuInfo = this.getNodeMenuOptions(node);\n        } else {\n            menuInfo = this.getCanvasMenuOptions();\n            const group = this.graph.getGroupOnPos(event.canvasX, event.canvasY);\n            if (group) {\n                // on group\n                menuInfo.push(null, {\n                    content: \"Edit Group\",\n                    has_submenu: true,\n                    submenu: {\n                        title: \"Group\",\n                        extra: group,\n                        options: this.getGroupMenuOptions(group),\n                    },\n                });\n            }\n        }\n\n        // show menu\n        if (!menuInfo) return;\n\n        const menu = new ContextMenu(menuInfo, options, refWindow);\n\n        function inner_option_clicked(v, options, e) {\n            if (!v) {\n                return;\n            }\n\n            if (v.content === \"Remove Slot\") {\n                const info = v.slot;\n                if (info.input) node.removeInput(info.slot);\n                else if (info.output) node.removeOutput(info.slot);\n            } else if (v.content === \"Disconnect Links\") {\n                const info = v.slot;\n                if (info.output) node.disconnectOutput(info.slot);\n                else if (info.input) node.disconnectInput(info.slot);\n            } else if (v.content === \"Rename Slot\") {\n                const info = v.slot;\n                const slotInfo = info.input\n                    ? node.getInputInfo(info.slot) : node.getOutputInfo(info.slot);\n                const dialog = that.createDialog(\n                    \"<span class='name'>Name</span><input autofocus type='text'/><button>OK</button>\",\n                    options,\n                );\n                const input = dialog.querySelector(\"input\");\n                if (input && slotInfo) input.value = slotInfo.label || \"\";\n                dialog.querySelector(\"button\")\n                    .addEventListener(\"click\", () => {\n                        if (input.value) {\n                            if (slotInfo) slotInfo.label = input.value;\n                            that.setDirty(true);\n                        }\n                        dialog.close();\n                    });\n            }\n        }\n    }\n}\n","import defaultConfig from \"./defaultConfig\";\n\nexport function getFileExtension(url) {\n    const question = url.indexOf(\"?\");\n    if (question !== -1) {\n        url = url.substr(0, question);\n    }\n    const point = url.lastIndexOf(\".\");\n    if (point === -1) {\n        return \"\";\n    }\n    return url.substr(point + 1).toLowerCase();\n}\n\n/**\n * Wrapper to load files (from url using fetch or from file using FileReader)\n * @method fetchFile\n * @param {String|File|Blob} url the url of the file (or the file itself)\n * @param {String} type an string to know how to fetch it:\n *     \"text\",\"arraybuffer\",\"json\",\"blob\"\n * @param {Function} onComplete callback(data)\n * @param {Function} onError in case of an error\n * @return {FileReader|Promise|void} returns the object used to\n */\nexport function fetchFile(url, type = \"text\", onComplete, onError) {\n    if (!url) return null;\n\n    if (url.constructor === String) {\n        if (url.substr(0, 4) === \"http\" && defaultConfig.proxy) {\n            url = defaultConfig.proxy + url.substr(url.indexOf(\":\") + 3);\n        }\n        return fetch(url)\n            .then((response) => {\n                if (!response.ok) throw new Error(\"File not found\"); // it will be catch\n                // below\n                if (type === \"arraybuffer\") return response.arrayBuffer();\n                if ([\"string\", \"text\"].includes(type)) return response.text();\n                if (type === \"json\") return response.json();\n                if (type === \"blob\") return response.blob();\n            })\n            .then((data) => {\n                if (onComplete) onComplete(data);\n            })\n            .catch((error) => {\n                console.error(\"error fetching file:\", url);\n                if (onError) onError(error);\n            });\n    }\n    if (url.constructor === File || url.constructor === Blob) {\n        const reader = new FileReader();\n        reader.onload = (e) => {\n            let v = e.target.result;\n            if (type === \"json\") v = JSON.parse(v);\n            if (onComplete) onComplete(v);\n        };\n        if (type === \"arraybuffer\") return reader.readAsArrayBuffer(url);\n        if ([\"string\", \"text\"].includes(type)) return reader.readAsText(url);\n        if (type === \"blob\") return reader.readAsBinaryString(url);\n    }\n    return null;\n}\n","import defaultConfig from \"./utils/defaultConfig\";\nimport getTime from \"./utils/time\";\nimport LGraphNode from \"./LGraphNode\";\nimport LGraphGroup from \"./LGraphGroup\";\nimport LGraphCanvas from \"./LGraphCanvas\";\n\n/**\n * LGraph is the class that contain a full graph.\n * We instantiate one and add nodes to it, and then we can run the execution loop.\n * supported callbacks:\n + onNodeAdded: when a new node is added to the graph\n + onNodeRemoved: when a node inside this graph is removed\n + onNodeConnectionChange: some connection has changed in the graph (connected or disconnected)\n *\n * @class LGraph\n * @constructor\n * @param {Object} o data from previous serialization [optional]\n */\nexport default class LGraph {\n    constructor(o) {\n        if (defaultConfig.debug) {\n            console.log(\"Graph created\");\n        }\n        this.list_of_graphcanvas = null;\n        this.clear();\n\n        if (o) {\n            this.configure(o);\n        }\n    }\n\n    getSupportedTypes() {\n        return this.supportedTypes || LGraph.supportedTypes;\n    }\n\n    STATUS_STOPPED = 1;\n\n    STATUS_RUNNING = 2;\n\n    supportedTypes = [\"number\", \"string\", \"boolean\"];\n\n    static supportedTypes = [\"number\", \"string\", \"boolean\"];\n    // used to know which types of connections support this graph (some graphs do not allow certain\n    // types)\n\n    /**\n     * Removes all nodes from this graph\n     * @method clear\n     */\n    clear() {\n        this.stop();\n        this.status = LGraph.STATUS_STOPPED;\n\n        this.last_node_id = 0;\n        this.last_link_id = 0;\n\n        this._version = -1; // used to detect changes\n\n        // safe clear\n        if (this._nodes) {\n            for (const node of this._nodes) {\n                if (node.onRemoved) node.onRemoved();\n            }\n        }\n\n        // nodes\n        this._nodes = [];\n        this._nodes_by_id = {};\n        this._nodes_in_order = []; // nodes sorted in execution order\n        this._nodes_executable = null; // nodes that contain onExecute sorted in execution order\n\n        // other scene stuff\n        this._groups = [];\n\n        // links\n        this.links = {}; // container with all the links\n\n        // iterations\n        this.iteration = 0;\n\n        // custom data\n        this.config = {};\n        this.vars = {};\n        this.extra = {}; // to store custom data\n\n        // timing\n        this.globaltime = 0;\n        this.runningtime = 0;\n        this.fixedtime = 0;\n        this.fixedtime_lapse = 0.01;\n        this.elapsed_time = 0.01;\n        this.last_update_time = 0;\n        this.starttime = 0;\n\n        this.catch_errors = true;\n\n        // subgraph_data\n        this.inputs = {};\n        this.outputs = {};\n\n        // notify canvas to redraw\n        this.change();\n\n        this.sendActionToCanvas(\"clear\");\n    }\n\n    /**\n     * Attach Canvas to this graph\n     * @method attachCanvas\n     * @param {GraphCanvas} graphcanvas\n     */\n    attachCanvas(graphcanvas) {\n        if (graphcanvas.constructor !== LGraphCanvas) {\n            throw new Error(\"attachCanvas expects a LGraphCanvas instance\");\n        }\n        if (graphcanvas.graph && graphcanvas.graph !== this) {\n            graphcanvas.graph.detachCanvas(graphcanvas);\n        }\n\n        graphcanvas.graph = this;\n\n        if (!this.list_of_graphcanvas) this.list_of_graphcanvas = [];\n        this.list_of_graphcanvas.push(graphcanvas);\n    }\n\n    /**\n     * Detach Canvas from this graph\n     * @method detachCanvas\n     * @param {GraphCanvas} graphcanvas\n     */\n    detachCanvas(graphcanvas) {\n        if (!this.list_of_graphcanvas) {\n            return;\n        }\n\n        const pos = this.list_of_graphcanvas.indexOf(graphcanvas);\n        if (pos === -1) {\n            return;\n        }\n        graphcanvas.graph = null;\n        this.list_of_graphcanvas.splice(pos, 1);\n    }\n\n    /**\n     * Starts running this graph every interval milliseconds.\n     * @method start\n     * @param {number} interval amount of milliseconds between executions, if 0 then it renders to\n     *     the monitor refresh rate\n     */\n    start(interval) {\n        if (this.status === LGraph.STATUS_RUNNING) {\n            return;\n        }\n        this.status = LGraph.STATUS_RUNNING;\n\n        if (this.onPlayEvent) {\n            this.onPlayEvent();\n        }\n\n        this.sendEventToAllNodes(\"onStart\");\n\n        // launch\n        this.starttime = getTime();\n        this.last_update_time = this.starttime;\n        interval = interval || 0;\n        const that = this;\n\n        // execute once per frame\n        if (interval === 0 && typeof window !== \"undefined\" && window.requestAnimationFrame) {\n            // eslint-disable-next-line no-inner-declarations\n            function onFrame() {\n                if (that.execution_timer_id !== -1) {\n                    return;\n                }\n                window.requestAnimationFrame(onFrame);\n                if (that.onBeforeStep) that.onBeforeStep();\n                that.runStep(1, !that.catch_errors);\n                if (that.onAfterStep) that.onAfterStep();\n            }\n\n            this.execution_timer_id = -1;\n            onFrame();\n        } else { // execute every 'interval' ms\n            this.execution_timer_id = setInterval(() => {\n                // execute\n                if (that.onBeforeStep) that.onBeforeStep();\n                that.runStep(1, !that.catch_errors);\n                if (that.onAfterStep) that.onAfterStep();\n            }, interval);\n        }\n    }\n\n    /**\n     * Stops the execution loop of the graph\n     * @method stop execution\n     */\n    stop() {\n        if (this.status === LGraph.STATUS_STOPPED) {\n            return;\n        }\n\n        this.status = LGraph.STATUS_STOPPED;\n\n        if (this.onStopEvent) {\n            this.onStopEvent();\n        }\n\n        if (this.execution_timer_id !== null) {\n            if (this.execution_timer_id !== -1) {\n                clearInterval(this.execution_timer_id);\n            }\n            this.execution_timer_id = null;\n        }\n\n        this.sendEventToAllNodes(\"onStop\");\n    }\n\n    /**\n     * Run N steps (cycles) of the graph\n     * @method runStep\n     * @param {number} num number of steps to run, default is 1\n     * @param {Boolean} doNotCatchError [optional] if you want to try/catch errors\n     * @param {number} limit max number of nodes to execute (used to execute from start to a node)\n     */\n    runStep(num, doNotCatchError, limit) {\n        num = num || 1;\n\n        const start = getTime();\n        this.globaltime = 0.001 * (start - this.starttime);\n\n        const nodes = this._nodes_executable\n            ? this._nodes_executable\n            : this._nodes;\n        if (!nodes) {\n            return;\n        }\n\n        limit = limit || nodes.length;\n\n        if (doNotCatchError) {\n            // iterations\n            for (let i = 0; i < num; i++) {\n                for (let j = 0; j < limit; j++) {\n                    const node = nodes[j];\n                    if (node.mode === defaultConfig.ALWAYS && node.onExecute) {\n                        node.onExecute(); // hard to send elapsed time\n                    }\n                }\n\n                this.fixedtime += this.fixedtime_lapse;\n                if (this.onExecuteStep) {\n                    this.onExecuteStep();\n                }\n            }\n\n            if (this.onAfterExecute) {\n                this.onAfterExecute();\n            }\n        } else {\n            try {\n                // iterations\n                for (let i = 0; i < num; i++) {\n                    for (let j = 0; j < limit; ++j) {\n                        const node = nodes[j];\n                        if (node.mode === defaultConfig.ALWAYS && node.onExecute) {\n                            node.onExecute();\n                        }\n                    }\n\n                    this.fixedtime += this.fixedtime_lapse;\n                    if (this.onExecuteStep) {\n                        this.onExecuteStep();\n                    }\n                }\n\n                if (this.onAfterExecute) {\n                    this.onAfterExecute();\n                }\n                this.errors_in_execution = false;\n            } catch (err) {\n                this.errors_in_execution = true;\n                if (defaultConfig.throw_errors) {\n                    throw err;\n                }\n                if (defaultConfig.debug) {\n                    console.log(`Error during execution: ${err}`);\n                }\n                this.stop();\n            }\n        }\n\n        const now = getTime();\n        let elapsed = now - start;\n        if (elapsed === 0) {\n            elapsed = 1;\n        }\n        this.execution_time = 0.001 * elapsed;\n        this.globaltime += 0.001 * elapsed;\n        this.iteration += 1;\n        this.elapsed_time = (now - this.last_update_time) * 0.001;\n        this.last_update_time = now;\n    }\n\n    /**\n     * Updates the graph execution order according to relevance of the nodes (nodes with only\n     * outputs have more relevance than nodes with only inputs.\n     * @method updateExecutionOrder\n     */\n    updateExecutionOrder() {\n        this._nodes_in_order = this.computeExecutionOrder(false);\n        this._nodes_executable = [];\n        for (const node of this._nodes_in_order) {\n            if (node.onExecute) {\n                this._nodes_executable.push(node);\n            }\n        }\n    }\n\n    /**\n     * It computes the executable nodes in order and returns it\n     * @param onlyOnExecute\n     * @param setLevel\n     * @returns {this}\n     * @internal\n     */\n    computeExecutionOrder(onlyOnExecute, setLevel) {\n        let L = [];\n        const S = [];\n        const M = {};\n        const visitedLinks = {}; // to avoid repeating links\n        const remainingLinks = {}; // to a\n\n        // search for the nodes without inputs (starting nodes)\n        for (const node of this._nodes) {\n            if (onlyOnExecute && !node.onExecute) {\n                continue;\n            }\n\n            M[node.id] = node; // add to pending nodes\n\n            let num = 0; // num of input connections\n            if (node.inputs) {\n                for (let j = 0, l2 = node.inputs.length; j < l2; j++) {\n                    if (node.inputs[j] && node.inputs[j].link != null) {\n                        num += 1;\n                    }\n                }\n            }\n\n            if (num === 0) {\n                // is a starting node\n                S.push(node);\n                if (setLevel) {\n                    node._level = 1;\n                }\n            } else {\n                if (setLevel) {\n                    node._level = 0;\n                }\n                remainingLinks[node.id] = num;\n            }\n        }\n\n        while (true) {\n            if (S.length === 0) {\n                break;\n            }\n\n            // get an starting node\n            const node = S.shift();\n            L.push(node); // add to ordered list\n            delete M[node.id]; // remove from the pending nodes\n\n            if (!node.outputs) {\n                continue;\n            }\n\n            // for every output\n            for (const output of node.outputs) {\n                if (\n                    output == null\n                    || output.links == null\n                    || output.links.length === 0\n                ) {\n                    continue;\n                }\n\n                // for every connection\n                for (const linkId of output.links) {\n                    const link = this.links[linkId];\n                    if (!link) {\n                        continue;\n                    }\n\n                    // already visited link (ignore it)\n                    if (visitedLinks[link.id]) {\n                        continue;\n                    }\n\n                    const targetNode = this.getNodeById(link.target_id);\n                    if (targetNode == null) {\n                        visitedLinks[link.id] = true;\n                        continue;\n                    }\n\n                    if (\n                        setLevel\n                        && (!targetNode._level\n                        || targetNode._level <= node._level)\n                    ) {\n                        targetNode._level = node._level + 1;\n                    }\n\n                    visitedLinks[link.id] = true; // mark as visited\n                    remainingLinks[targetNode.id] -= 1; // reduce the number of links remaining\n                    if (remainingLinks[targetNode.id] === 0) {\n                        S.push(targetNode);\n                    } // if no more links, then add to starters array\n                }\n            }\n        }\n\n        // the remaining ones (loops)\n        // eslint-disable-next-line guard-for-in,no-restricted-syntax\n        for (const i in M) L.push(M[i]);\n\n        if (L.length !== this._nodes.length && defaultConfig.debug) {\n            console.warn(\"something went wrong, nodes missing\");\n        }\n\n        const l = L.length;\n\n        // save order number in the node\n        for (let i = 0; i < l; i++) L[i].order = i;\n\n        // sort now by priority\n        L = L.sort((A, B) => {\n            const Ap = A.constructor.priority || A.priority || 0;\n            const Bp = B.constructor.priority || B.priority || 0;\n            if (Ap === Bp) {\n                // if same priority, sort by order\n                return A.order - B.order;\n            }\n            return Ap - Bp; // sort by priority\n        });\n\n        // save order number in the node, again...\n        for (let i = 0; i < l; ++i) L[i].order = i;\n\n        return L;\n    }\n\n    /**\n     * Returns all the nodes that could affect this one (ancestors) by crawling all the inputs\n     * recursively. It doesn't include the node itself\n     * @method getAncestors\n     * @return {Array} an array with all the LGraphNodes that affect this node, in order of\n     *     execution\n     */\n    // eslint-disable-next-line class-methods-use-this\n    getAncestors(node) {\n        const ancestors = [];\n        const pending = [node];\n        const visited = {};\n\n        while (pending.length) {\n            const current = pending.shift();\n            if (!current.inputs) {\n                continue;\n            }\n            if (!visited[current.id] && current !== node) {\n                visited[current.id] = true;\n                ancestors.push(current);\n            }\n\n            for (let i = 0; i < current.inputs.length; ++i) {\n                const input = current.getInputNode(i);\n                if (input && ancestors.indexOf(input) === -1) {\n                    pending.push(input);\n                }\n            }\n        }\n\n        ancestors.sort((a, b) => a.order - b.order);\n        return ancestors;\n    }\n\n    /**\n     * Positions every node in a more readable manner\n     * @method arrange\n     */\n    arrange(margin) {\n        margin = margin || 100;\n\n        const nodes = this.computeExecutionOrder(false, true);\n        const columns = [];\n        for (const node of nodes) {\n            const col = node._level || 1;\n            if (!columns[col]) {\n                columns[col] = [];\n            }\n            columns[col].push(node);\n        }\n\n        let x = margin;\n\n        for (const column of columns) {\n            if (!column) {\n                continue;\n            }\n            let maxSize = 100;\n            let y = margin + defaultConfig.NODE_TITLE_HEIGHT;\n            for (const node of column) {\n                node.pos[0] = x;\n                node.pos[1] = y;\n                if (node.size[0] > maxSize) maxSize = node.size[0];\n                y += node.size[1] + margin + defaultConfig.NODE_TITLE_HEIGHT;\n            }\n            x += maxSize + margin;\n        }\n\n        this.setDirtyCanvas(true, true);\n    }\n\n    /**\n     * Returns the amount of time the graph has been running in milliseconds\n     * @method getTime\n     * @return {number} number of milliseconds the graph has been running\n     */\n    getTime() {\n        return this.globaltime;\n    }\n\n    /**\n     * Returns the amount of time accumulated using the fixedtime_lapse var. This is used in\n     * context where the time increments should be constant\n     * @method getFixedTime\n     * @return {number} number of milliseconds the graph has been running\n     */\n\n    getFixedTime() {\n        return this.fixedtime;\n    }\n\n    /**\n     * Returns the amount of time it took to compute the latest iteration. Take into account that\n     * this number could be not correct if the nodes are using graphical actions\n     * @method getElapsedTime\n     * @return {number} number of milliseconds it took the last cycle\n     */\n\n    getElapsedTime() {\n        return this.elapsed_time;\n    }\n\n    /**\n     * Sends an event to all the nodes, useful to trigger stuff\n     * @method sendEventToAllNodes\n     * @param {String} eventname the name of the event (function to be called)\n     * @param {Array} params parameters in array format\n     */\n    sendEventToAllNodes(eventname, params, mode) {\n        mode = mode || defaultConfig.ALWAYS;\n\n        const nodes = this._nodes_in_order ? this._nodes_in_order : this._nodes;\n        if (!nodes) {\n            return;\n        }\n\n        for (let j = 0, l = nodes.length; j < l; ++j) {\n            const node = nodes[j];\n\n            if (\n                node.constructor.name === \"Subgraph\"\n                && eventname !== \"onExecute\"\n            ) {\n                if (node.mode === mode) {\n                    node.sendEventToAllNodes(eventname, params, mode);\n                }\n                continue;\n            }\n\n            if (!node[eventname] || node.mode !== mode) {\n                continue;\n            }\n            if (params === undefined) {\n                node[eventname]();\n            } else if (params && params.constructor === Array) {\n                node[eventname](...params);\n            } else {\n                node[eventname](params);\n            }\n        }\n    }\n\n    sendActionToCanvas(action, params) {\n        if (!this.list_of_graphcanvas) {\n            return;\n        }\n\n        for (let i = 0; i < this.list_of_graphcanvas.length; ++i) {\n            const c = this.list_of_graphcanvas[i];\n            if (c[action]) {\n                c[action](...params);\n            }\n        }\n    }\n\n    /**\n     * Adds a new node instance to this graph\n     * @method add\n     * @param {LGraphNode} node the instance of the node\n     * @param {boolean} skipComputeOrder\n     */\n\n    add(node, skipComputeOrder) {\n        if (!node) {\n            return;\n        }\n\n        // groups\n        if (node.constructor === LGraphGroup) {\n            this._groups.push(node);\n            this.setDirtyCanvas(true);\n            this.change();\n            node.graph = this;\n            this._version++;\n            return;\n        }\n\n        // nodes\n        if (node.id !== -1 && this._nodes_by_id[node.id] != null) {\n            console.warn(\n                \"LiteGraph: there is already a node with this ID, changing it\",\n            );\n            node.id = ++this.last_node_id;\n        }\n\n        if (this._nodes.length >= defaultConfig.MAX_NUMBER_OF_NODES) {\n            throw new Error(\"LiteGraph: max number of nodes in a graph reached\");\n        }\n\n        // give him an id\n        if (node.id == null || node.id === -1) {\n            node.id = ++this.last_node_id;\n        } else if (this.last_node_id < node.id) {\n            this.last_node_id = node.id;\n        }\n\n        node.graph = this;\n        this._version++;\n\n        this._nodes.push(node);\n        this._nodes_by_id[node.id] = node;\n\n        if (node.onAdded) node.onAdded(this);\n\n        if (this.config.align_to_grid) node.alignToGrid();\n\n        if (!skipComputeOrder) this.updateExecutionOrder();\n\n        if (this.onNodeAdded) this.onNodeAdded(node);\n\n        this.setDirtyCanvas(true);\n        this.change();\n\n        return node; // to chain actions\n    }\n\n    /**\n     * Removes a node from the graph\n     * @method remove\n     * @param {LGraphNode} node the instance of the node\n     */\n\n    remove(node) {\n        if (node.constructor.name === \"LGraphGroup\") {\n            const index = this._groups.indexOf(node);\n            if (index !== -1) {\n                this._groups.splice(index, 1);\n            }\n            node.graph = null;\n            this._version++;\n            this.setDirtyCanvas(true, true);\n            this.change();\n            return;\n        }\n\n        if (this._nodes_by_id[node.id] == null) {\n            return;\n        } // not found\n\n        if (node.ignore_remove) {\n            return;\n        } // cannot be removed\n\n        this.beforeChange(); // sure?\n\n        // disconnect inputs\n        if (node.inputs) {\n            for (let i = 0; i < node.inputs.length; i++) {\n                const slot = node.inputs[i];\n                if (slot.link != null) {\n                    node.disconnectInput(i);\n                }\n            }\n        }\n\n        // disconnect outputs\n        if (node.outputs) {\n            for (let i = 0; i < node.outputs.length; i++) {\n                const slot = node.inputs[i];\n                if (slot.links != null && slot.links.length) {\n                    node.disconnectOutput(i);\n                }\n            }\n        }\n\n        // node.id = -1; //why?\n\n        // callback\n        if (node.onRemoved) {\n            node.onRemoved();\n        }\n\n        node.graph = null;\n        this._version++;\n\n        // remove from canvas render\n        if (this.list_of_graphcanvas) {\n            for (const canvas of this.list_of_graphcanvas) {\n                if (canvas.selected_nodes[node.id]) {\n                    delete canvas.selected_nodes[node.id];\n                }\n                if (canvas.node_dragged === node) {\n                    canvas.node_dragged = null;\n                }\n            }\n        }\n\n        // remove from containers\n        const pos = this._nodes.indexOf(node);\n        if (pos !== -1) {\n            this._nodes.splice(pos, 1);\n        }\n        delete this._nodes_by_id[node.id];\n\n        if (this.onNodeRemoved) {\n            this.onNodeRemoved(node);\n        }\n\n        // close panels\n        this.sendActionToCanvas(\"checkPanels\");\n\n        this.setDirtyCanvas(true, true);\n        this.afterChange(); // sure?\n        this.change();\n\n        this.updateExecutionOrder();\n    }\n\n    /**\n     * Returns a node by its id.\n     * @method getNodeById\n     * @param {Number} id\n     */\n\n    getNodeById(id) {\n        if (id == null) {\n            return null;\n        }\n        return this._nodes_by_id[id];\n    }\n\n    /**\n     * Returns a list of nodes that matches a class\n     * @method findNodesByClass\n     * @param {Class} classObject the class itself (not an string)\n     * @param {Array} result\n     * @return {Array} a list with all the nodes of this type\n     */\n    findNodesByClass(classObject, result = []) {\n        result.length = 0;\n        for (const node of this._nodes) {\n            if (node.constructor === classObject) result.push(node);\n        }\n        return result;\n    }\n\n    /**\n     * Returns a list of nodes that matches a type\n     * @method findNodesByType\n     * @param {String} type the name of the node type\n     * @param {Array} result\n     * @return {Array} a list with all the nodes of this type\n     */\n    findNodesByType(type, result = []) {\n        type = type.toLowerCase();\n        result = result || [];\n        result.length = 0;\n        for (const node of this._nodes) {\n            if (node.type.toLowerCase() === type) result.push(node);\n        }\n        return result;\n    }\n\n    /**\n     * Returns the first node that matches a name in its title\n     * @method findNodeByTitle\n     * @param {String} title the name of the node to search\n     * @return {Node} the node or null\n     */\n    findNodeByTitle(title) {\n        for (const node of this._nodes) {\n            if (node.title === title) return node;\n        }\n        return null;\n    }\n\n    /**\n     * Returns a list of nodes that matches a name\n     * @method findNodesByTitle\n     * @param {String} title the name of the node to search\n     * @return {Array} a list with all the nodes with this name\n     */\n    findNodesByTitle(title) {\n        const result = [];\n        for (const node of this._nodes) {\n            if (node.title === title) result.push(node);\n        }\n        return result;\n    }\n\n    /**\n     * Returns the top-most node in this position of the canvas\n     * @method getNodeOnPos\n     * @param {number} x the x coordinate in canvas space\n     * @param {number} y the y coordinate in canvas space\n     * @param {Array} nodesList a list with all the nodes to search from, by default is all the\n     *     nodes in the graph\n     * @param {number} margin\n     * @return {LGraphNode} the node at this position or null\n     */\n    getNodeOnPos(x, y, nodesList = this._nodes, margin) {\n        for (const n of nodesList) {\n            if (n.isPointInside(x, y, margin)) return n;\n        }\n        return null;\n    }\n\n    /**\n     * Returns the top-most group in that position\n     * @method getGroupOnPos\n     * @param {number} x the x coordinate in canvas space\n     * @param {number} y the y coordinate in canvas space\n     * @return {LGraphGroup} the group or null\n     */\n    getGroupOnPos(x, y) {\n        for (const g of this._groups) {\n            if (g.isPointInside(x, y, 2, true)) return g;\n        }\n        return null;\n    }\n\n    /**\n     * Checks that the node type matches the node type registered, used when replacing a nodetype\n     * by a newer version during execution this replaces the ones using the old version with the\n     * new version\n     * @method checkNodeTypes\n     */\n    checkNodeTypes() {\n        for (let node of this._nodes) {\n            const ctor = defaultConfig.registered_node_types[node.type];\n            if (node.constructor === ctor) {\n                continue;\n            }\n            console.log(`node being replaced by newer version: ${node.type}`);\n            const newnode = LGraphNode.createNode(node.type);\n            node = newnode;\n            newnode.configure(node.serialize());\n            newnode.graph = this;\n            this._nodes_by_id[newnode.id] = newnode;\n            if (node.inputs) {\n                newnode.inputs = node.inputs.concat();\n            }\n            if (node.outputs) {\n                newnode.outputs = node.outputs.concat();\n            }\n        }\n        this.updateExecutionOrder();\n    }\n\n    // ********** GLOBALS *****************\n\n    onAction(action, param) {\n        this._input_nodes = this.findNodesByClass(\n            LiteGraph.GraphInput,\n            this._input_nodes,\n        );\n        for (const node of this._input_nodes) {\n            if (node.properties.name !== action) {\n                continue;\n            }\n            node.onAction(action, param);\n            break;\n        }\n    }\n\n    trigger(action, param) {\n        if (this.onTrigger) {\n            this.onTrigger(action, param);\n        }\n    }\n\n    /**\n     * Tell this graph it has a global graph input of this type\n     * @method addGlobalInput\n     * @param {String} name\n     * @param {String} type\n     * @param {*} value [optional]\n     */\n    addInput(name, type, value) {\n        const input = this.inputs[name];\n        if (input) {\n            // already exist\n            return;\n        }\n\n        this.beforeChange();\n        this.inputs[name] = {\n            name,\n            type,\n            value,\n        };\n        this._version++;\n        this.afterChange();\n\n        if (this.onInputAdded) {\n            this.onInputAdded(name, type);\n        }\n\n        if (this.onInputsOutputsChange) {\n            this.onInputsOutputsChange();\n        }\n    }\n\n    /**\n     * Assign a data to the global graph input\n     * @method setGlobalInputData\n     * @param {String} name\n     * @param {*} data\n     */\n    setInputData(name, data) {\n        const input = this.inputs[name];\n        if (!input) {\n            return;\n        }\n        input.value = data;\n    }\n\n    /**\n     * Returns the current value of a global graph input\n     * @method getInputData\n     * @param {String} name\n     * @return {*} the data\n     */\n    getInputData(name) {\n        const input = this.inputs[name];\n        if (!input) {\n            return null;\n        }\n        return input.value;\n    }\n\n    /**\n     * Changes the newName of a global graph input\n     * @method renameInput\n     * @param {String} oldName\n     * @param {String} new_name\n     */\n    renameInput(oldName, newName) {\n        if (newName === oldName) {\n            return;\n        }\n\n        if (!this.inputs[oldName]) {\n            return false;\n        }\n\n        if (this.inputs[newName]) {\n            console.error(\"there is already one input with that newName\");\n            return false;\n        }\n\n        this.inputs[newName] = this.inputs[oldName];\n        delete this.inputs[oldName];\n        this._version++;\n\n        if (this.onInputRenamed) {\n            this.onInputRenamed(oldName, newName);\n        }\n\n        if (this.onInputsOutputsChange) {\n            this.onInputsOutputsChange();\n        }\n    }\n\n    /**\n     * Changes the type of a global graph input\n     * @method changeInputType\n     * @param {String} name\n     * @param {String} type\n     */\n    changeInputType(name, type) {\n        if (!this.inputs[name]) {\n            return false;\n        }\n\n        if (\n            this.inputs[name].type\n            && String(this.inputs[name].type).toLowerCase()\n            === String(type).toLowerCase()\n        ) {\n            return;\n        }\n\n        this.inputs[name].type = type;\n        this._version++;\n        if (this.onInputTypeChanged) {\n            this.onInputTypeChanged(name, type);\n        }\n    }\n\n    /**\n     * Removes a global graph input\n     * @method removeInput\n     * @param {String} name\n     */\n    removeInput(name) {\n        if (!this.inputs[name]) {\n            return false;\n        }\n\n        delete this.inputs[name];\n        this._version++;\n\n        if (this.onInputRemoved) {\n            this.onInputRemoved(name);\n        }\n\n        if (this.onInputsOutputsChange) {\n            this.onInputsOutputsChange();\n        }\n        return true;\n    }\n\n    /**\n     * Creates a global graph output\n     * @method addOutput\n     * @param {String} name\n     * @param {String} type\n     * @param {*} value\n     */\n    addOutput(name, type, value) {\n        this.outputs[name] = {\n            name,\n            type,\n            value,\n        };\n        this._version++;\n\n        if (this.onOutputAdded) {\n            this.onOutputAdded(name, type);\n        }\n\n        if (this.onInputsOutputsChange) {\n            this.onInputsOutputsChange();\n        }\n    }\n\n    /**\n     * Assign a data to the global output\n     * @method setOutputData\n     * @param {String} name\n     * @param {String} value\n     */\n    setOutputData(name, value) {\n        const output = this.outputs[name];\n        if (!output) {\n            return;\n        }\n        output.value = value;\n    }\n\n    /**\n     * Returns the current value of a global graph output\n     * @method getOutputData\n     * @param {String} name\n     * @return {*} the data\n     */\n    getOutputData(name) {\n        const output = this.outputs[name];\n        if (!output) {\n            return null;\n        }\n        return output.value;\n    }\n\n    /**\n     * Renames a global graph output\n     * @method renameOutput\n     * @param {String} oldName\n     * @param {String} newName\n     */\n    renameOutput(oldName, newName) {\n        if (!this.outputs[oldName]) {\n            return false;\n        }\n\n        if (this.outputs[newName]) {\n            console.error(\"there is already one output with that newName\");\n            return false;\n        }\n\n        this.outputs[newName] = this.outputs[oldName];\n        delete this.outputs[oldName];\n        this._version++;\n\n        if (this.onOutputRenamed) {\n            this.onOutputRenamed(oldName, newName);\n        }\n\n        if (this.onInputsOutputsChange) {\n            this.onInputsOutputsChange();\n        }\n    }\n\n    /**\n     * Changes the type of a global graph output\n     * @method changeOutputType\n     * @param {String} name\n     * @param {String} type\n     */\n    changeOutputType(name, type) {\n        if (!this.outputs[name]) {\n            return false;\n        }\n\n        if (\n            this.outputs[name].type\n            && String(this.outputs[name].type).toLowerCase()\n            === String(type).toLowerCase()\n        ) {\n            return;\n        }\n\n        this.outputs[name].type = type;\n        this._version++;\n        if (this.onOutputTypeChanged) {\n            this.onOutputTypeChanged(name, type);\n        }\n    }\n\n    /**\n     * Removes a global graph output\n     * @method removeOutput\n     * @param {String} name\n     */\n    removeOutput(name) {\n        if (!this.outputs[name]) {\n            return false;\n        }\n        delete this.outputs[name];\n        this._version++;\n\n        if (this.onOutputRemoved) {\n            this.onOutputRemoved(name);\n        }\n\n        if (this.onInputsOutputsChange) {\n            this.onInputsOutputsChange();\n        }\n        return true;\n    }\n\n    triggerInput(name, value) {\n        const nodes = this.findNodesByTitle(name);\n        for (let i = 0; i < nodes.length; ++i) {\n            nodes[i].onTrigger(value);\n        }\n    }\n\n    setCallback(name, func) {\n        const nodes = this.findNodesByTitle(name);\n        for (let i = 0; i < nodes.length; ++i) {\n            nodes[i].setTrigger(func);\n        }\n    }\n\n    // used for undo, called before any change is made to the graph\n    beforeChange(info) {\n        if (this.onBeforeChange) {\n            this.onBeforeChange(this, info);\n        }\n        this.sendActionToCanvas(\"onBeforeChange\", this);\n    }\n\n    // used to resend actions, called after any change is made to the graph\n    afterChange(info) {\n        if (this.onAfterChange) {\n            this.onAfterChange(this, info);\n        }\n        this.sendActionToCanvas(\"onAfterChange\", this);\n    }\n\n    connectionChange(node) {\n        this.updateExecutionOrder();\n        if (this.onConnectionChange) {\n            this.onConnectionChange(node);\n        }\n        this._version++;\n        this.sendActionToCanvas(\"onConnectionChange\");\n    }\n\n    /**\n     * returns if the graph is in live mode\n     * @method isLive\n     */\n\n    isLive() {\n        if (!this.list_of_graphcanvas) {\n            return false;\n        }\n\n        for (let i = 0; i < this.list_of_graphcanvas.length; ++i) {\n            const c = this.list_of_graphcanvas[i];\n            if (c.live_mode) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * clears the triggered slot animation in all links (stop visual animation)\n     * @method clearTriggeredSlots\n     */\n    clearTriggeredSlots() {\n        // eslint-disable-next-line guard-for-in,no-restricted-syntax\n        for (const i in this.links) {\n            const linkInfo = this.links[i];\n            if (!linkInfo) {\n                continue;\n            }\n            if (linkInfo._last_time) {\n                linkInfo._last_time = 0;\n            }\n        }\n    }\n\n    /* Called when something visually changed (not the graph!) */\n    change() {\n        if (defaultConfig.debug) {\n            console.log(\"Graph changed\");\n        }\n        this.sendActionToCanvas(\"setDirty\", [true, true]);\n        if (this.on_change) {\n            this.on_change(this);\n        }\n    }\n\n    setDirtyCanvas(fg, bg) {\n        this.sendActionToCanvas(\"setDirty\", [fg, bg]);\n    }\n\n    /**\n     * Destroys a link\n     * @method removeLink\n     * @param {Number} linkId\n     */\n    removeLink(linkId) {\n        const link = this.links[linkId];\n        if (!link) {\n            return;\n        }\n        const node = this.getNodeById(link.target_id);\n        if (node) {\n            node.disconnectInput(link.target_slot);\n        }\n    }\n\n    // save and recover app state ***************************************\n    /**\n     * Creates a Object containing all the info about this graph, it can be serialized\n     * @method serialize\n     * @return {Object} value of the node\n     */\n    serialize() {\n        const nodesInfo = [];\n        for (const node of this._nodes) {\n            nodesInfo.push(node.serialize());\n        }\n\n        // pack link info into a non-verbose format\n        const links = [];\n        // eslint-disable-next-line guard-for-in,no-restricted-syntax\n        for (const i in this.links) {\n            // links is an OBJECT\n            let link = this.links[i];\n            if (!link.serialize) {\n                // weird bug I havent solved yet\n                console.warn(\n                    \"weird LLink bug, link info is not a LLink but a regular object\",\n                );\n                const link2 = new LLink();\n                // eslint-disable-next-line guard-for-in,no-restricted-syntax\n                for (const j in link) {\n                    link2[j] = link[j];\n                }\n                this.links[i] = link2;\n                link = link2;\n            }\n\n            links.push(link.serialize());\n        }\n\n        const groupsInfo = [];\n        for (const group of this._groups) groupsInfo.push(group.serialize());\n\n        const data = {\n            last_node_id: this.last_node_id,\n            last_link_id: this.last_link_id,\n            nodes: nodesInfo,\n            links,\n            groups: groupsInfo,\n            config: this.config,\n            extra: this.extra,\n            version: defaultConfig.VERSION,\n        };\n\n        if (this.onSerialize) this.onSerialize(data);\n\n        return data;\n    }\n\n    /**\n     * Configure a graph from a JSON string\n     * @method configure\n     * @param {String} str configure a graph from a JSON string\n     * @param {Boolean} returns if there was any error parsing\n     */\n    configure(data, keepOld) {\n        if (!data) {\n            return;\n        }\n\n        if (!keepOld) this.clear();\n\n        const { nodes } = data;\n\n        // decode links info (they are very verbose)\n        if (data.links && data.links.constructor === Array) {\n            const links = [];\n            for (const linkData of data.links) {\n                if (!linkData) {\n                    console.warn(\"serialized graph link data contains errors, skipping.\");\n                    continue;\n                }\n                const link = new LLink();\n                link.configure(linkData);\n                links[link.id] = link;\n            }\n            data.links = links;\n        }\n\n        // copy all stored fields\n        // eslint-disable-next-line guard-for-in,no-restricted-syntax\n        for (const i in data) {\n            if (i === \"nodes\" || i === \"groups\") {\n                continue;\n            }\n            this[i] = data[i];\n        }\n\n        let error = false;\n\n        // create nodes\n        this._nodes = [];\n        if (nodes) {\n            for (const nInfo of nodes) {\n                let node = LGraphNode.createNode(nInfo.type, nInfo.title);\n                if (!node) {\n                    if (defaultConfig.debug) {\n                        console.log(\n                            `Node not found or has errors: ${nInfo.type}`,\n                        );\n                    }\n\n                    // in case of error we create a replacement node to avoid losing info\n                    node = new LGraphNode();\n                    node.last_serialization = nInfo;\n                    node.has_errors = true;\n                    error = true;\n                    // continue;\n                }\n\n                node.id = nInfo.id; // id it or it will create a new id\n                this.add(node, true); // add before configure, otherwise configure cannot create\n                // links\n            }\n\n            // configure nodes afterwards so they can reach each other\n            for (const nInfo of nodes) {\n                const node = this.getNodeById(nInfo.id);\n                if (node) {\n                    node.configure(nInfo);\n                }\n            }\n        }\n\n        // groups\n        this._groups.length = 0;\n        if (data.groups) {\n            for (const dataGroup of data.groups) {\n                const group = new LGraphGroup();\n                group.configure(dataGroup);\n                this.add(group);\n            }\n        }\n\n        this.updateExecutionOrder();\n\n        this.extra = data.extra || {};\n\n        if (this.onConfigure) this.onConfigure(data);\n\n        this._version++;\n        this.setDirtyCanvas(true, true);\n        return error;\n    }\n\n    load(url, callback) {\n        const that = this;\n\n        // from file\n        if (url.constructor === File || url.constructor === Blob) {\n            const reader = new FileReader();\n            reader.addEventListener(\"load\", (event) => {\n                const data = JSON.parse(event.target.result);\n                that.configure(data);\n                if (callback) callback();\n            });\n\n            reader.readAsText(url);\n            return;\n        }\n\n        // is a string, then an URL\n        const req = new XMLHttpRequest();\n        req.open(\"GET\", url, true);\n        req.send(null);\n        req.onload(() => {\n            if (req.status !== 200) {\n                console.error(\"Error loading graph:\", req.status, req.response);\n                return;\n            }\n            const data = JSON.parse(req.response);\n            that.configure(data);\n            if (callback) callback();\n        });\n        req.onerror((err) => {\n            console.error(\"Error loading graph:\", err);\n        });\n    }\n\n    /**\n     * Node event manager\n     * @todo\n     * @param node\n     * @param msg\n     * @param color\n     */\n    onNodeTrace(node, msg, color) {\n        // TODO\n    }\n}\n","export default class LLink {\n    constructor(id, type, origin_id, origin_slot, target_id, target_slot) {\n        this.id = id;\n        this.type = type;\n        this.origin_id = origin_id;\n        this.origin_slot = origin_slot;\n        this.target_id = target_id;\n        this.target_slot = target_slot;\n\n        this._data = null;\n        this._pos = new Float32Array(2); // center\n    }\n\n    configure(o) {\n        if (o.constructor === Array) {\n            this.id = o[0];\n            this.origin_id = o[1];\n            this.origin_slot = o[2];\n            this.target_id = o[3];\n            this.target_slot = o[4];\n            this.type = o[5];\n        } else {\n            this.id = o.id;\n            this.type = o.type;\n            this.origin_id = o.origin_id;\n            this.origin_slot = o.origin_slot;\n            this.target_id = o.target_id;\n            this.target_slot = o.target_slot;\n        }\n    }\n\n    serialize() {\n        return [\n            this.id,\n            this.origin_id,\n            this.origin_slot,\n            this.target_id,\n            this.target_slot,\n            this.type,\n        ];\n    }\n}\n","export default class CurveEditor {\n    constructor(points) {\n        this.points = points;\n        this.selected = -1;\n        this.nearest = -1;\n        this.size = null; // stores last size used\n        this.must_update = true;\n        this.margin = 5;\n    }\n\n    sampleCurve(f, points) {\n        if (!points) return;\n        for (let i = 0; i < points.length - 1; ++i) {\n            const p = points[i];\n            const pn = points[i + 1];\n            if (pn[0] < f) continue;\n            const r = (pn[0] - p[0]);\n            if (Math.abs(r) < 0.00001) return p[1];\n            const localF = (f - p[0]) / r;\n            return p[1] * (1.0 - localF) + pn[1] * localF;\n        }\n        return 0;\n    }\n\n    draw(ctx, size, graphcanvas, backgroundColor, lineColor = \"#666\", inactive) {\n        const { points } = this;\n        if (!points) return;\n        this.size = size;\n        const w = size[0] - this.margin * 2;\n        const h = size[1] - this.margin * 2;\n\n        ctx.save();\n        ctx.translate(this.margin, this.margin);\n\n        if (backgroundColor) {\n            ctx.fillStyle = \"#111\";\n            ctx.fillRect(0, 0, w, h);\n            ctx.fillStyle = \"#222\";\n            ctx.fillRect(w * 0.5, 0, 1, h);\n            ctx.strokeStyle = \"#333\";\n            ctx.strokeRect(0, 0, w, h);\n        }\n        ctx.strokeStyle = lineColor;\n        if (inactive) ctx.globalAlpha = 0.5;\n        ctx.beginPath();\n        for (const point of points) {\n            ctx.lineTo(point[0] * w, (1.0 - point[1]) * h);\n        }\n        ctx.stroke();\n        ctx.globalAlpha = 1;\n        if (!inactive) {\n            for (let i = 0; i < points.length; ++i) {\n                const p = points[i];\n                if (this.selected === i) ctx.fillStyle = \"#FFF\";\n                else if (this.nearest === i) ctx.fillStyle = \"#DDD\";\n                else ctx.fillStyle = \"#AAA\";\n                ctx.beginPath();\n                ctx.arc(p[0] * w, (1.0 - p[1]) * h, 2, 0, Math.PI * 2);\n                ctx.fill();\n            }\n        }\n        ctx.restore();\n    }\n\n    onMouseDown(localpos, graphcanvas) {\n        const { points } = this;\n        if (!points) return;\n        if (localpos[1] < 0) return;\n\n        // this.captureInput(true);\n        const w = this.size[0] - this.margin * 2;\n        const h = this.size[1] - this.margin * 2;\n        const x = localpos[0] - this.margin;\n        const y = localpos[1] - this.margin;\n        const pos = [x, y];\n        const maxDist = 30 / graphcanvas.ds.scale;\n        // search closer one\n        this.selected = this.getCloserPoint(pos, maxDist);\n        // create one\n        if (this.selected === -1) {\n            const point = [x / w, 1 - y / h];\n            points.push(point);\n            points.sort((a, b) => a[0] - b[0]);\n            this.selected = points.indexOf(point);\n            this.must_update = true;\n        }\n        if (this.selected !== -1) return true;\n    }\n\n    onMouseMove(localpos, graphcanvas) {\n        const { points } = this;\n        if (!points) return;\n        const s = this.selected;\n        if (s < 0) return;\n        const x = (localpos[0] - this.margin) / (this.size[0] - this.margin * 2);\n        const y = (localpos[1] - this.margin) / (this.size[1] - this.margin * 2);\n        const curvepos = [(localpos[0] - this.margin), (localpos[1] - this.margin)];\n        const maxDist = 30 / graphcanvas.ds.scale;\n        this._nearest = this.getCloserPoint(curvepos, maxDist);\n        const point = points[s];\n        if (point) {\n            const isEdgePoint = s === 0 || s === points.length - 1;\n            if (!isEdgePoint\n                && (localpos[0] < -10\n                    || localpos[0] > this.size[0] + 10\n                    || localpos[1] < -10\n                    || localpos[1] > this.size[1] + 10)) {\n                points.splice(s, 1);\n                this.selected = -1;\n                return;\n            }\n            if (!isEdgePoint) {\n                point[0] = Math.clamp(x, 0, 1);\n            } else {\n                point[0] = s === 0 ? 0 : 1;\n            }\n            point[1] = 1.0 - Math.clamp(y, 0, 1);\n            points.sort((a, b) => a[0] - b[0]);\n            this.selected = points.indexOf(point);\n            this.must_update = true;\n        }\n    }\n\n    onMouseUp() {\n        this.selected = -1;\n        return false;\n    }\n\n    getCloserPoint(pos, maxDist = 30) {\n        const { points } = this;\n        if (!points) return -1;\n        const w = (this.size[0] - this.margin * 2);\n        const h = (this.size[1] - this.margin * 2);\n        const num = points.length;\n        const p2 = [0, 0];\n        let minDist = 1000000;\n        let closest = -1;\n        let lastValid = -1;\n        for (let i = 0; i < num; ++i) {\n            const p = points[i];\n            p2[0] = p[0] * w;\n            p2[1] = (1.0 - p[1]) * h;\n            // eslint-disable-next-line no-unused-vars\n            if (p2[0] < pos[0]) lastValid = i;\n            const dist = vec2.distance(pos, p2);\n            if (dist > minDist || dist > maxDist) continue;\n            closest = i;\n            minDist = dist;\n        }\n        return closest;\n    }\n}\n","// Creates an interface to access extra features from a graph (like play, stop, live, etc)\nimport LGraph from \"./LGraph\";\nimport LGraphCanvas from \"./LGraphCanvas\";\n\nexport default class Editor {\n    constructor(containerId, options) {\n        options = options || {};\n\n        // fill container\n        const html = \"<div class='content'><div class='editor-area'><canvas class='graphcanvas' width='1000' height='500' tabindex=10></canvas></div></div>\";\n\n        const root = document.createElement(\"div\");\n        this.root = root;\n        root.className = \"litegraph litegraph-editor\";\n        root.innerHTML = html;\n\n        this.content = root.querySelector(\".content\");\n        this.footer = root.querySelector(\".footer\");\n\n        const canvas = root.querySelector(\".graphcanvas\");\n\n        // create graph\n        const graph = (this.graph = new LGraph());\n        const graphcanvas = (this.graphcanvas = new LGraphCanvas(canvas, graph));\n        graphcanvas.background_image = \"imgs/grid.png\";\n        graph.onAfterExecute = function () {\n            graphcanvas.draw(true);\n        };\n\n        graphcanvas.onDropItem = this.onDropItem.bind(this);\n\n        if (options.miniwindow) {\n            this.addMiniWindow(300, 200);\n        }\n\n        // append to DOM\n        const parent = document.getElementById(containerId);\n        if (parent) {\n            parent.appendChild(root);\n        }\n\n        graphcanvas.resize();\n        // graphcanvas.draw(true,true);\n    }\n\n    onDropItem(e) {\n        for (const file of e.dataTransfer.files) {\n            const ext = LGraphCanvas.getFileExtension(file.name);\n            const reader = new FileReader();\n            if (ext === \"json\") {\n                reader.onload = (event) => {\n                    this.graph.configure(JSON.parse(event.target.result));\n                };\n                reader.readAsText(file);\n            }\n        }\n    }\n\n    addMiniWindow(w, h) {\n        const miniwindow = document.createElement(\"div\");\n        miniwindow.className = \"litegraph miniwindow\";\n        miniwindow.innerHTML = `<canvas class='graphcanvas' width='${\n            w\n        }' height='${\n            h\n        }' tabindex=10></canvas>`;\n        const canvas = miniwindow.querySelector(\"canvas\");\n        const that = this;\n\n        const graphcanvas = new LGraphCanvas(canvas, this.graph);\n        graphcanvas.show_info = false;\n        graphcanvas.background_image = \"imgs/grid.png\";\n        graphcanvas.scale = 0.25;\n        graphcanvas.allow_dragnodes = false;\n        graphcanvas.allow_interaction = false;\n        graphcanvas.render_shadows = false;\n        graphcanvas.max_zoom = 0.25;\n        this.miniwindow_graphcanvas = graphcanvas;\n        graphcanvas.onClear = function () {\n            graphcanvas.scale = 0.25;\n            graphcanvas.allow_dragnodes = false;\n            graphcanvas.allow_interaction = false;\n        };\n        graphcanvas.onRenderBackground = function (canvas, ctx) {\n            ctx.strokeStyle = \"#567\";\n            let tl = that.graphcanvas.convertOffsetToCanvas([0, 0]);\n            let br = that.graphcanvas.convertOffsetToCanvas([\n                that.graphcanvas.canvas.width,\n                that.graphcanvas.canvas.height,\n            ]);\n            tl = this.convertCanvasToOffset(tl);\n            br = this.convertCanvasToOffset(br);\n            ctx.lineWidth = 1;\n            ctx.strokeRect(\n                Math.floor(tl[0]) + 0.5,\n                Math.floor(tl[1]) + 0.5,\n                Math.floor(br[0] - tl[0]),\n                Math.floor(br[1] - tl[1]),\n            );\n        };\n\n        miniwindow.style.position = \"absolute\";\n        miniwindow.style.top = \"4px\";\n        miniwindow.style.right = \"4px\";\n\n        const close_button = document.createElement(\"div\");\n        close_button.className = \"corner-button\";\n        close_button.innerHTML = \"&#10060;\";\n        close_button.addEventListener(\"click\", (e) => {\n            graphcanvas.setGraph(null);\n            miniwindow.parentNode.removeChild(miniwindow);\n        });\n        miniwindow.appendChild(close_button);\n\n        this.root.querySelector(\".content\").appendChild(miniwindow);\n    }\n}\n","export { default as LGraph } from \"./LGraph\";\nexport { default as LLink } from \"./LLink\";\nexport { default as LGraphNode } from \"./LGraphNode\";\nexport { default as LGraphGroup } from \"./LGraphGroup\";\nexport { default as DragAndScale } from \"./DragAndScale\";\nexport { default as CurveEditor } from \"./CurveEditor\";\nexport { default as LGraphCanvas } from \"./LGraphCanvas\";\nexport { default as ContextMenu } from \"./ContextMenu\";\n\nexport { default as Editor } from \"./litegraph-editor\";\n\nexport { default as defaultConfig } from \"./utils/defaultConfig\";\nexport * from \"./utils/registry\";\nexport * from \"./utils/function\";\n\nif (window && window.CanvasRenderingContext2D) {\n    window.CanvasRenderingContext2D.prototype.roundRect = function roundRect(\n        x,\n        y,\n        width,\n        height,\n        radius = 5,\n        radiusLow = radius,\n    ) {\n        this.moveTo(x + radius, y);\n        this.lineTo(x + width - radius, y);\n        this.quadraticCurveTo(x + width, y, x + width, y + radius);\n\n        this.lineTo(x + width, y + height - radiusLow);\n        this.quadraticCurveTo(\n            x + width,\n            y + height,\n            x + width - radiusLow,\n            y + height,\n        );\n        this.lineTo(x + radiusLow, y + height);\n        this.quadraticCurveTo(x, y + height, x, y + height - radiusLow);\n        this.lineTo(x, y + radius);\n        this.quadraticCurveTo(x, y, x + radius, y);\n    };\n}\n"],"names":["VERSION","CANVAS_GRID_SIZE","NODE_TITLE_HEIGHT","NODE_TITLE_TEXT_Y","NODE_SLOT_HEIGHT","NODE_WIDGET_HEIGHT","NODE_WIDTH","NODE_MIN_WIDTH","NODE_COLLAPSED_RADIUS","NODE_COLLAPSED_WIDTH","NODE_TITLE_COLOR","NODE_SELECTED_TITLE_COLOR","NODE_TEXT_SIZE","NODE_TEXT_COLOR","NODE_SUBTEXT_SIZE","NODE_DEFAULT_COLOR","NODE_DEFAULT_BGCOLOR","NODE_DEFAULT_BOXCOLOR","NODE_DEFAULT_SHAPE","NODE_BOX_OUTLINE_COLOR","DEFAULT_SHADOW_COLOR","DEFAULT_GROUP_FONT","WIDGET_BGCOLOR","WIDGET_OUTLINE_COLOR","WIDGET_TEXT_COLOR","WIDGET_SECONDARY_TEXT_COLOR","LINK_COLOR","EVENT_LINK_COLOR","CONNECTING_LINK_COLOR","MAX_NUMBER_OF_NODES","DEFAULT_POSITION","VALID_SHAPES","BOX_SHAPE","ROUND_SHAPE","CIRCLE_SHAPE","CARD_SHAPE","ARROW_SHAPE","INPUT","OUTPUT","EVENT","ACTION","ALWAYS","ON_EVENT","NEVER","ON_TRIGGER","UP","DOWN","LEFT","RIGHT","CENTER","STRAIGHT_LINK","LINEAR_LINK","SPLINE_LINK","NORMAL_TITLE","NO_TITLE","TRANSPARENT_TITLE","AUTOHIDE_TITLE","proxy","node_images_path","debug","catch_exceptions","throw_errors","allow_scripts","registered_node_types","node_types_by_file_extension","Nodes","Globals","searchbox_extras","auto_sort_node_types","getTime","performance","now","Date","process","t","hrtime","cloneObject","obj","target","r","JSON","parse","stringify","i","registerNodeType","type","baseClass","prototype","TypeError","defaultConfig","console","log","classname","name","pos","lastIndexOf","category","substr","title","prev","Object","hasOwnProperty","call","defineProperty","set","v","this","_shape","get","enumerable","configurable","onPropertyChange","warn","supported_extensions","ext","constructor","String","toLowerCase","onNodeTypeRegistered","onNodeTypeReplaced","getNodeTypesInCategory","filter","push","sort","getNodeTypesCategories","categories","skip_list","result","getParameterNames","func","replace","split","Boolean","isValidConnection","typeA","typeB","indexOf","supportedTypesA","supportedTypesB","length","j","LGraphNode","Float32Array","_ctor","size","graph","id","inputs","outputs","connections","properties","properties_info","flags","_pos","info","_version","_typeof","configure","k","onPropertyChanged","onConnectionsChange","input","linkInfo","links","link","output","widgets","widget","options","property","value","widgets_values","onConfigure","o","order","mode","last_serialization","_data","serialize_widgets","color","bgcolor","boxcolor","shape","onSerialize","node","createNode","data","serialize","prevValue","w","slot","output_info","link_id","force_update","getNodeById","origin_id","updateOutputData","origin_slot","onExecute","slot_name","findInputSlot","getInputData","slot_info","link_info","l","input_info","target_node","target_id","action","param","_last_trigger_time","triggerSlot","_last_time","target_connection","target_slot","onAction","onResize","default_value","extra_info","onOutputAdded","setSize","computeSize","setDirtyCanvas","array","disconnectOutput","splice","onOutputRemoved","onInputAdded","disconnectInput","onInputRemoved","direction","out","concat","rows","Math","max","font_size","title_width","compute_text_size","input_width","output_width","text_width","label","slot_start_y","widgets_height","text","widgets_up","widgets_start_y","min_height","widgets_info","onGetPropertyInfo","callback","Function","undefined","y","values","custom_widget","onBounding","x","margin","skip_title","margin_top","isLive","collapsed","isInsideRectangle","_collapsed_width","link_pos","getConnectionPos","findOutputSlot","Number","changed","beforeChange","onConnectInput","LLink","last_link_id","onNodeConnectionChange","afterChange","connectionChange","is_input","slot_number","num_slots","offset","horizontal","round","msg","MAX_CONSOLE","shift","onNodeTrace","dirty_foreground","dirty_background","sendActionToCanvas","url","img","Image","src","ready","onload","_this","list_of_graphcanvas","list","c","node_capturing_input","force","collapsable","pinned","graphcanvas","scale","err","error","folderWildcard","scriptFiles","document","getElementsByTagName","docHeadObj","location","href","dynamicScript","createElement","appendChild","removeChild","LGraphGroup","isPointInside","LGraphCanvas","node_colors","pale_blue","groupcolor","_bounding","subarray","_size","_nodes","nodes","node_bounding","getBounding","overlapBounding","deltax","deltay","ignore_nodes","b","bounding","font","DragAndScale","element","skipEvents","max_scale","min_scale","onredraw","enabled","last_mouse","visible_area","bindEvents","_binded_mouse_callback","onMouse","bind","addEventListener","width","height","startx","starty","endx","endy","e","canvas","rect","getBoundingClientRect","clientX","left","clientY","top","canvasx","canvasy","dragging","ignore","onmouse","removeEventListener","body","mouseDrag","eventType","wheel","deltaY","wheelDeltaY","detail","wheelDelta","delta","changeDeltaScale","preventDefault","stopPropagation","ctx","translate","zoomingCenter","center","convertCanvasToOffset","abs","newCenter","deltaOffset","changeScale","ContextMenu","that","parentMenu","lock","current_submenu","eventClass","event","root","on_mouse_wheel","parseInt","style","scroll_speed","toFixed","className","minWidth","minHeight","pointerEvents","setTimeout","button","close","innerHTML","Array","content","addItem","closing_timer","clearTimeout","rootDocument","ownerDocument","fullscreenElement","bodyRect","rootRect","transform","disabled","inner_over","has_submenu","inner_onclick","closeParent","ignore_item_callbacks","extra","submenu","Error","autoopen","classList","add","dataset","onclick_callback","ignoreParentMenu","parentNode","isCursorOverElement","trigger","getTopMenu","getFirstEvent","eventName","params","origin","evt","createEvent","initCustomEvent","dispatchEvent","__events","ref_window","window","elements","querySelectorAll","el","re","a","AEndX","AEndY","BEndX","BEndY","temp","tempVC2","tempArea","marginArea","linkBounding","tempA","tempB","active_canvas","dialog","search_box","focus","overflow","timeoutClose","ds","helper","querySelector","first","timeout","selected","keyCode","changeSelection","clearInterval","refreshHelper","select","stopImmediatePropagation","onSearchBoxSelection","convertEventToCanvasOffset","addProperty","addOutput","json","forward","remove","nextSibling","previousSibling","childNodes","scrollIntoView","block","behavior","str","onSearchBox","addResult","desc","ctor","search_limit","keys","help","innerText","escape","unescape","layerY","maxHeight","SELECTED_NODE","panel","refWindow","getCanvasWindow","createPanel","closable","addHTML","getPropertyInfo","onAddPropertyToPanel","addWidget","setProperty","dirty_canvas","addSeparator","onShowCustomPanelInfo","addButton","block_delete","inner_refresh","background_image","DEFAULT_BACKGROUND_IMAGE","zoom_modify_alpha","title_text_font","inner_text_font","node_title_color","default_link_color","default_connection_color","input_off","input_on","output_off","output_on","highquality_render","use_gradients","editor_alpha","pause_rendering","clear_background","read_only","render_only_selected","live_mode","show_info","allow_dragcanvas","allow_dragnodes","allow_interaction","allow_searchbox","allow_reconnect_links","drag_mode","dragging_rectangle","set_canvas_dirty_on_mouse_event","always_render_background","render_shadows","render_canvas_border","render_connections_shadows","render_connections_border","render_curved_connections","render_connection_arrows","render_collapsed_slots","render_execution_order","render_title_colored","render_link_tooltip","links_render_mode","mouse","graph_mouse","canvas_mouse","onDrawBackground","onDrawForeground","onDrawOverlay","onDrawLinkTooltip","onNodeMoved","onSelectionChange","onConnectingChange","onBeforeChange","onAfterChange","connections_width","round_radius","current_node","node_widget","over_link_center","last_mouse_position","visible_links","attachCanvas","setCanvas","clear","skip_render","startRendering","autoresize","frame","last_draw_time","render_time","fps","selected_nodes","selected_group","visible_nodes","node_dragged","node_over","connecting_node","highlighted_links","dragging_canvas","dirty_bgcanvas","dirty_area","node_in_panel","last_mouseclick","onClear","skipClear","_graph_stack","setDirty","detachCanvas","checkPanels","subgraphNode","_subgraph_node","pop","centerOnNode","selectNodes","getElementById","unbindEvents","tabindex","bgcanvas","getContext","localName","webgl_enabled","enableWebGL","_mousemove_callback","processMouseMove","_mouseup_callback","processMouseUp","_events_binded","_mousedown_callback","processMouseDown","_mousewheel_callback","processMouseWheel","_doNothing","touchHandler","_key_callback","processKey","_ondrop_callback","processDrop","_doReturnTrue","GL","enableWebGLCanvas","gl","webgl","bgctx","fgcanvas","defaultView","is_rendering","renderFrame","draw","requestAnimationFrame","block_click","adjustMouseEvent","getNodeOnPos","canvasX","canvasY","skipAction","isDoubleClick","localX","localY","last_click_position","closeAllContextMenus","which","ctrlKey","clickingCanvasBg","bringToFront","resizable","resizing_node","cursor","linkPos","connecting_output","connecting_pos","connecting_slot","shiftKey","onOutputDblClick","onOutputClick","onInputDblClick","onInputClick","_nodes_by_id","blockDragNote","processNodeWidgets","onDblClick","processNodeDblClicked","onMouseDown","subgraph","skip_subgraph_button","_this2","openSubgraph","processNodeSelected","showLinkMenu","getGroupOnPos","selected_group_resizing","distance","recomputeInsideNodes","showSearchBox","processContextMenu","last_mouse_dragging","change","activeElement","nodeName","resize","move","_node","mouseOver","onMouseLeave","redraw_on_mouse","onMouseEnter","onMouseMove","_highlight_input","isOverNodeBox","isOverNodeInput","slotType","overLink","n","desiredSize","minSize","click_time","diffx","diffy","nodeBounding","deselectAllNodes","h","toSelect","connect","getInputInfo","collapse","config","align_to_grid","alignToGrid","onMouseUp","titleHeight","slotPos","blockDefault","code","metaKey","copyToClipboard","pasteFromClipboard","deleteSelectedNodes","onKeyDown","onKeyUp","localStorage","getItem","clipboardInfo","node_data","origin_node","index","selectedNodesArray","_relative_id","cloned","clone","setItem","onDropItem","checkDropItem","onDropFile","onDropData","files","dataTransfer","file","filename","reader","FileReader","readAsText","readAsDataURL","readAsArrayBuffer","question","point","getFileExtension","nodetype","onShowNodePanel","showShowNodePanel","onNodeDblClicked","selectNode","onNodeSelected","addToCurrentSelection","is_selected","onSelected","onDeselected","onNodeDeselected","inputLink","outputLink","inputNode","getInputNode","outputNode","getOutputNodes","deltaX","convertOffsetToCanvas","unshift","visibleNodes","force_canvas","force_bgcanvas","computeVisibleArea","drawBackCanvas","drawFrontCanvas","start2D","restore","setTransform","save","beginPath","clip","clearRect","drawImage","onRender","renderInfo","toCanvasContext","computeVisibleNodes","drawNode","drawExecutionOrder","links_ontop","drawConnections","lineWidth","linkColor","renderLink","dir","arc","PI","fill","fillStyle","strokeStyle","strokeRect","drawLinkTooltip","visible_rect","drawSubgraphPanel","finish2D","subnode","num","floor","globalAlpha","roundRect","textAlign","fillText","drawButton","closeSubgraph","not_subgraph_input","input_node_type","newnode","tw","measureText","showSubgraphPropertiesDialog","hovercolor","textcolor","hover","clicked","blockClick","holdClick","globaltime","iteration","start","g","getTitle","bgAlreadyPainted","onRenderBackground","imageSmoothingEnabled","mozImageSmoothingEnabled","_bg_img","_this3","pattern","_pattern","createPattern","_pattern_img","fillRect","_groups","drawGroups","shadowColor","shadowOffsetX","shadowOffsetY","shadowBlur","finish","lowQuality","onDrawCollapsed","min","clip_area","has_errors","drawNodeShape","renderText","outSlot","maxY","storedSlot","inputSlot","outputSlot","moveTo","lineTo","closePath","color_on","color_off","stroke","widgetsY","drawNodeWidgets","toToolTip","fgcolor","mouseHover","title_mode","renderTitle","area","oldAlpha","onDrawTitleBar","title_color","titleColor","grad","gradients","createLinearGradient","addColorStop","boxSize","onDrawTitleBox","includes","onDrawTitleText","title_text_color","over","onDrawTitle","linkId","startNode","startNodeSlot","startNodeSlotPos","endNodeSlotPos","startSlot","endSlot","startDir","endDir","f","tmp","skipBorder","flow","numSubline","link_type_colors","dist","lineJoin","offsety","startOffsetX","startOffsetY","endOffsetX","endOffsetY","bezierCurveTo","startX","startY","endX","endY","posConnectionPoint","computeConnectionPoint","posA","posB","posC","posD","angleA","angleB","atan2","rotate","p0","p1","p2","p3","c1","c2","c3","c4","posY","active_widget","H","showText","outlineColor","backgroundColor","textColor","secondaryTextColor","last_y","widgetWidth","on","off","range","nvalue","marker","marker_nvalue","precision","activeWidget","widgetHeight","oldValue","_this4","clamp","innerValueChange","step","valuesList","textValues","option","prompt","multiline","onWidgetChanged","groups","group","fontSize","DEFAULT_GROUP_FONT_SIZE","parent","offsetWidth","offsetHeight","transition","setInterval","_this5","changedTouches","simulatedEvent","initMouseEvent","screenX","screenY","menu","onMenuAdd","nodeLeft","nodeRight","removeLink","modified","_this6","prompt_box","nameElement","valueElement","offsetx","inputHTML","createDialog","setValue","checked","onclose","html","position","_this7","header","title_element","footer","_this8","onFooter","elem","strValue","toString","innerChange","propname","toggle","setAttribute","blur","getPropertyPrintableValue","old_panel","removeInput","addInput","getMenuOptions","onGroupAdd","getExtraMenuOptions","showMenuNodeOptionalInputs","showMenuNodeOptionalOutputs","onShowMenuNodeProperties","onShowPropertyEditor","onMenuNodeMode","onResizeNode","onMenuNodeCollapse","onMenuNodePin","onMenuNodeColors","onMenuNodeShapes","onGetInputs","onGetOutputs","clonable","onMenuNodeClone","removable","onMenuNodeRemove","onGetNodeMenuOptions","menuInfo","removeOutput","slotInfo","getOutputInfo","getSlotInPosition","active_node","getSlotMenuOptions","_slot","locked","nameLocked","getNodeMenuOptions","getCanvasMenuOptions","getGroupMenuOptions","entry","mouseEvent","previousMenu","inner_onMenuAdded","base_category","prev_menu","registry","startsWith","entries","forEach","base_category_regex","RegExp","category_name","category_path","findIndex","contextMenu","slice","first_event","optionsParam","optional_inputs","onMenuNodeInputs","optional_outputs","skip_repeated_outputs","onMenuNodeOutputs","innerClicked","decodeHTML","showEditPropertyValue","allow_html","item","desc_value","pin","nodesList","buildFromNodes","number","red","brown","green","blue","cyan","purple","yellow","black","LGraph","supportedTypes","stop","status","STATUS_STOPPED","last_node_id","onRemoved","_nodes_in_order","_nodes_executable","vars","runningtime","fixedtime","fixedtime_lapse","elapsed_time","last_update_time","starttime","catch_errors","interval","STATUS_RUNNING","onPlayEvent","sendEventToAllNodes","execution_timer_id","onFrame","onBeforeStep","runStep","onAfterStep","onStopEvent","doNotCatchError","limit","onExecuteStep","onAfterExecute","errors_in_execution","elapsed","execution_time","computeExecutionOrder","onlyOnExecute","setLevel","L","S","M","visitedLinks","remainingLinks","l2","_level","targetNode","A","B","Ap","priority","Bp","ancestors","pending","visited","current","columns","col","column","maxSize","eventname","skipComputeOrder","onAdded","updateExecutionOrder","onNodeAdded","ignore_remove","onNodeRemoved","classObject","_input_nodes","findNodesByClass","LiteGraph","GraphInput","onTrigger","onInputsOutputsChange","oldName","newName","onInputRenamed","onInputTypeChanged","onOutputRenamed","onOutputTypeChanged","findNodesByTitle","setTrigger","onConnectionChange","on_change","fg","bg","nodesInfo","link2","groupsInfo","version","keepOld","linkData","nInfo","dataGroup","File","Blob","req","XMLHttpRequest","open","send","response","onerror","CurveEditor","points","nearest","must_update","p","pn","localF","lineColor","inactive","localpos","maxDist","getCloserPoint","s","curvepos","_nearest","isEdgePoint","minDist","closest","vec2","Editor","containerId","miniwindow","addMiniWindow","max_zoom","miniwindow_graphcanvas","tl","br","right","close_button","setGraph","CanvasRenderingContext2D","radius","radiusLow","quadraticCurveTo","nodeType","description","paramType","returnType","names","classobj","apply","setOutputData"],"mappings":"siEAAe,CACXA,QAAS,GAETC,iBAAkB,GAElBC,kBAAmB,GACnBC,kBAAmB,GACnBC,iBAAkB,GAClBC,mBAAoB,GACpBC,WAAY,IACZC,eAAgB,GAChBC,sBAAuB,GACvBC,qBAAsB,GACtBC,iBAAkB,OAClBC,0BAA2B,OAC3BC,eAAgB,GAChBC,gBAAiB,OACjBC,kBAAmB,GACnBC,mBAAoB,OACpBC,qBAAsB,UACtBC,sBAAuB,OACvBC,mBAAoB,MACpBC,uBAAwB,OACxBC,qBAAsB,kBACtBC,mBAAoB,GAEpBC,eAAgB,OAChBC,qBAAsB,OACtBC,kBAAmB,OACnBC,4BAA6B,OAE7BC,WAAY,OACZC,iBAAkB,OAClBC,sBAAuB,OAEvBC,oBAAqB,IACrBC,iBAAkB,CAAC,IAAK,KACxBC,aAAc,CAAC,UAAW,MAAO,QAAS,QAG1CC,UAAW,EACXC,YAAa,EACbC,aAAc,EACdC,WAAY,EACZC,YAAa,EAGbC,MAAO,EACPC,OAAQ,EAERC,OAAQ,EACRC,QAAS,EAETC,OAAQ,EACRC,SAAU,EACVC,MAAO,EACPC,WAAY,EAEZC,GAAI,EACJC,KAAM,EACNC,KAAM,EACNC,MAAO,EACPC,OAAQ,EAERC,cAAe,EACfC,YAAa,EACbC,YAAa,EAEbC,aAAc,EACdC,SAAU,EACVC,kBAAmB,EACnBC,eAAgB,EAEhBC,MAAO,KACPC,iBAAkB,GAElBC,OAAO,EACPC,kBAAkB,EAClBC,cAAc,EACdC,eAAe,EAIfC,sBAAuB,GACvBC,6BAA8B,GAC9BC,MAAO,GACPC,QAAS,GAETC,iBAAkB,GAClBC,sBAAsB,GCzFX,SAASC,OAChBC,YAAa,OAAOA,YAAYC,SAChCC,MAAQA,KAAKD,IAAK,OAAOC,KAAKD,OAC9BE,QAAS,KACHC,EAAID,QAAQE,eACJ,KAAPD,EAAE,GAAoB,KAAPA,EAAE,UAErB,IAAIF,MAAOH,UCNP,SAASO,EAAYC,EAAKC,MAC1B,MAAPD,EAAa,OAAO,SAClBE,EAAIC,KAAKC,MAAMD,KAAKE,UAAUL,QAC/BC,EAAQ,OAAOC,MAGf,IAAMI,KAAKJ,EAAGD,EAAOK,GAAKJ,EAAEI,UAC1BL,ECYJ,SAASM,EAAiBC,EAAMC,OAC9BA,EAAUC,gBACL,IAAIC,UAAU,wEAExBF,EAAUD,KAAOA,EAEbI,EAAc9B,OACd+B,QAAQC,+BAAwBN,QAG9BO,EAAYN,EAAUO,KAEtBC,EAAMT,EAAKU,YAAY,KAC7BT,EAAUU,SAAWX,EAAKY,OAAO,EAAGH,GAE/BR,EAAUY,QACXZ,EAAUY,MAAQN,OAIhBO,EAAOV,EAAc1B,sBAAsBsB,MAC7Cc,EACAT,QAAQC,mCAA4BN,YAE/Be,OAAOC,eAAeC,KAAKhB,EAAUC,UAAW,UACjDa,OAAOG,eAAejB,EAAUC,UAAW,QAAS,CAChDiB,aAAIC,UACQA,OACC,iBACMC,KAAKC,iBAEX,WACIA,OAASlB,EAAczD,oBAE3B,aACI2E,OAASlB,EAAcxD,sBAE3B,cACI0E,OAASlB,EAAcvD,uBAE3B,YACIyE,OAASlB,EAActD,8BAGvBwE,OAASF,IAG1BG,sBACWF,KAAKC,QAEhBE,YAAY,EACZC,cAAc,IAKlBxB,EAAUC,UAAUwB,kBACpBrB,QAAQsB,oCAEA3B,0FAMRC,EAAU2B,qBAAsB,WACd3B,EAAU2B,qDAAsB,KAAvCC,UACHA,GAAOA,EAAIC,cAAgBC,SAC3B3B,EAAczB,6BAA6BkD,EAAIG,eAAiB/B,sCAMhFG,EAAc1B,sBAAsBsB,GAAQC,EACxCA,EAAU6B,YAAYtB,OAAMJ,EAAcxB,MAAM2B,GAAaN,GAE7DG,EAAc6B,sBAAsB7B,EAAc6B,qBAAqBjC,EAAMC,GAC7Ea,GAAQV,EAAc8B,oBACtB9B,EAAc8B,mBAAmBlC,EAAMC,EAAWa,GAIlDb,EAAUC,UAAUwB,kBACpBrB,QAAQsB,oCAEA3B,0FAMRC,EAAU2B,qBAAsB,WACd3B,EAAU2B,qDAAsB,KAAvCC,UACHA,GAAOA,EAAIC,cAAgBC,SAC3B3B,EAAczB,6BAA6BkD,EAAIG,eAAiB/B,oCAgCzE,SAASkC,EAAuBxB,EAAUyB,OACvC1C,EAAI,OAEL,IAAMI,KAAKuB,KAAK3C,sBAAuB,KAClCsB,EAAOqB,KAAK3C,sBAAsBoB,GACpCE,EAAKoC,SAAWA,IAEH,KAAbzB,EACKX,EAAKW,UAAUjB,EAAE2C,KAAKrC,GACpBA,EAAKW,WAAaA,GACzBjB,EAAE2C,KAAKrC,WAIRqB,KAAKtC,qBAAuBW,EAAE4C,OAAS5C,EAwB3C,SAAS6C,EAAuBH,SAC7BI,EAAa,IAAM,OACNnB,KAAK3C,sDAAuB,KAApCsB,aACHA,EAAKW,WAAaX,EAAKyC,UAAW,IAC9BzC,EAAKoC,SAAWA,EAAQ,SAC5BI,EAAWxC,EAAKW,UAAY,sCAG9B+B,EAAS,OAEV,IAAM5C,KAAK0C,EAAYE,EAAOL,KAAKvC,UACjCuB,KAAKtC,qBAAuB2D,EAAOJ,OAASI,EChMhD,SAASC,EAAkBC,SACvB,UAAIA,GACNC,QAAQ,cAAe,IACvBA,QAAQ,OAAQ,IAChBA,QAAQ,sBAAuB,IAC/BC,MAAM,KAAM,GAAG,GACfD,QAAQ,YAAa,IACrBA,QAAQ,UAAW,IACnBC,MAAM,KACNV,OAAOW,SAmDT,SAASC,EAAkBC,EAAOC,OAEhCD,IACGC,GACDD,IAAUC,GACTD,IAAU7C,EAAclD,OAASgG,IAAU9C,EAAcjD,cAEtD,KAIX8F,EAAQlB,OAAOkB,GACfC,EAAQnB,OAAOmB,GACfD,EAAQA,EAAMjB,cACdkB,EAAQA,EAAMlB,eAGc,IAAxBiB,EAAME,QAAQ,OAAuC,IAAxBD,EAAMC,QAAQ,KAAa,OAAOF,IAAUC,UAGvEE,EAAkBH,EAAMH,MAAM,KAC9BO,EAAkBH,EAAMJ,MAAM,KAC3BhD,EAAI,EAAGA,EAAIsD,EAAgBE,SAAUxD,MACrC,IAAIyD,EAAI,EAAGA,EAAIF,EAAgBC,SAAUC,KACtCH,EAAgBtD,KAAOuD,EAAgBE,UAChC,SAKZ,MCtCUC,wBAML3C,2BAyBL,IAAI4C,aAAa,GAAI,UAxBnBC,MAAM7C,QACNA,MAAQA,GAAS,eACjB8C,KAAO,CAACvD,EAAcnF,WAAY,SAClC2I,MAAQ,UACRC,IAAM,OACN7D,KAAO,UAEP8D,OAAS,QACTC,QAAU,QACVC,YAAc,QAGdC,WAAa,QACbC,gBAAkB,QAElBC,MAAQ,8BAmBjB,kBACW9C,KAAK+C,UAThB,SAAQhD,IACCA,GAAKA,EAAEkC,OAAS,SAGhBc,KAAK,GAAKhD,EAAE,QACZgD,KAAK,GAAKhD,EAAE,6BAWrB,SAAUiD,OAKD,IAAMd,KAJPlC,KAAKuC,YACAA,MAAMU,WAGCD,KACF,eAANd,EAYW,MAAXc,EAAKd,KAEqB,WAAnBgB,EAAOF,EAAKd,IAEflC,KAAKkC,IAAMlC,KAAKkC,GAAGiB,eACdjB,GAAGiB,UAAUH,EAAKd,SAElBA,GAAKhE,EAAY8E,EAAKd,GAAIlC,KAAKkC,SAGnCA,GAAKc,EAAKd,aAnBV,IAAMkB,KAAKJ,EAAKJ,gBACZA,WAAWQ,GAAKJ,EAAKJ,WAAWQ,GACjCpD,KAAKqD,wBACAA,kBAAkBD,EAAGJ,EAAKJ,WAAWQ,OAoBrDJ,EAAKxD,aACDA,MAAQQ,KAAKS,YAAYjB,OAG9BQ,KAAKsD,oBAAqB,IACtBtD,KAAKyC,WACA,IAAIhE,EAAI,EAAGA,EAAIuB,KAAKyC,OAAOR,SAAUxD,EAAG,KACnC8E,EAAQvD,KAAKyC,OAAOhE,GACpB+E,EAAWxD,KAAKuC,MAChBvC,KAAKuC,MAAMkB,MAAMF,EAAMG,MACvB,UACDJ,oBACDvE,EAAcpD,MACd8C,GACA,EACA+E,EACAD,MAKRvD,KAAK0C,YACA,IAAIjE,EAAI,EAAGA,EAAIuB,KAAK0C,QAAQT,SAAUxD,EAAG,KACpCkF,EAAS3D,KAAK0C,QAAQjE,MACvBkF,EAAOF,UAGP,IAAIvB,EAAI,EAAGA,EAAIyB,EAAOF,MAAMxB,SAAUC,EAAG,KACpCsB,EAAWxD,KAAKuC,MAChBvC,KAAKuC,MAAMkB,MAAME,EAAOF,MAAMvB,IAC9B,UACDoB,oBACDvE,EAAcnD,OACd6C,GACA,EACA+E,EACAG,QAOhB3D,KAAK4D,QAAS,WACO5D,KAAK4D,wCAAS,KAAxBC,UACFA,IACDA,EAAOC,SACJD,EAAOC,QAAQC,UAEf/D,KAAK4C,WAAWiB,EAAOC,QAAQC,YAAWF,EAAOG,MAAQ1F,KAAKC,MAAMD,KAAKE,UAAUwB,KAAK4C,WAAWiB,EAAOC,QAAQC,gDAEzHf,EAAKiB,mBACA,IAAIxF,EAAI,EAAGA,EAAIuE,EAAKiB,eAAehC,SAAUxD,EAC1CuB,KAAK4D,QAAQnF,UACRmF,QAAQnF,GAAGuF,MAAQhB,EAAKiB,eAAexF,IAMxDuB,KAAKkE,kBACAA,YAAYlB,4BASzB,eAEUmB,EAAI,CACN3B,GAAIxC,KAAKwC,GACT7D,KAAMqB,KAAKrB,KACXS,IAAKY,KAAKZ,IACVkD,KAAMtC,KAAKsC,KACXQ,MAAO5E,EAAY8B,KAAK8C,OACxBsB,MAAOpE,KAAKoE,MACZC,KAAMrE,KAAKqE,SAIXrE,KAAKS,cAAgB0B,GAAcnC,KAAKsE,0BACjCtE,KAAKsE,sBAGZtE,KAAKyC,SACL0B,EAAE1B,OAASzC,KAAKyC,QAGhBzC,KAAK0C,QAAS,KAGT,IAAIjE,EAAI,EAAGA,EAAIuB,KAAK0C,QAAQT,OAAQxD,WAC9BuB,KAAK0C,QAAQjE,GAAG8F,MAE3BJ,EAAEzB,QAAU1C,KAAK0C,WAGjB1C,KAAKR,OAASQ,KAAKR,OAASQ,KAAKS,YAAYjB,QAC7C2E,EAAE3E,MAAQQ,KAAKR,OAGfQ,KAAK4C,aACLuB,EAAEvB,WAAa1E,EAAY8B,KAAK4C,aAGhC5C,KAAK4D,SAAW5D,KAAKwE,kBAAmB,CACxCL,EAAEF,eAAiB,OACd,IAAIxF,EAAI,EAAGA,EAAIuB,KAAK4D,QAAQ3B,SAAUxD,EACnCuB,KAAK4D,QAAQnF,GACb0F,EAAEF,eAAexF,GAAKuB,KAAK4D,QAAQnF,GAAGuF,MAEtCG,EAAEF,eAAexF,GAAK,YAK7B0F,EAAExF,OAAMwF,EAAExF,KAAOqB,KAAKS,YAAY9B,MAEnCqB,KAAKyE,QAAON,EAAEM,MAAQzE,KAAKyE,OAC3BzE,KAAK0E,UAASP,EAAEO,QAAU1E,KAAK0E,SAC/B1E,KAAK2E,WAAUR,EAAEQ,SAAW3E,KAAK2E,UACjC3E,KAAK4E,QAAOT,EAAES,MAAQ5E,KAAK4E,OAE3B5E,KAAK6E,aACD7E,KAAK6E,YAAYV,IACjBnF,QAAQsB,KACJ,8GAKL6D,uBAIX,eACUW,EAAO3C,EAAW4C,WAAW/E,KAAKrB,UACnCmG,SACM,SAILE,EAAO7C,EAAWjE,YAAY8B,KAAKiF,gBAGrCD,EAAKvC,WACA,IAAIhE,EAAI,EAAGA,EAAIuG,EAAKvC,OAAOR,SAAUxD,EACtCuG,EAAKvC,OAAOhE,GAAGiF,KAAO,QAI1BsB,EAAKtC,YACA,IAAIjE,EAAI,EAAGA,EAAIuG,EAAKtC,QAAQT,SAAUxD,EACnCuG,EAAKtC,QAAQjE,GAAGgF,QAChBuB,EAAKtC,QAAQjE,GAAGgF,MAAMxB,OAAS,iBAKpC+C,EAAKxC,GAEZsC,EAAK3B,UAAU6B,GAERF,0BAQX,kBACWxG,KAAKE,UAAUwB,KAAKiF,qCAW/B,kBACWjF,KAAKR,OAASQ,KAAKS,YAAYjB,iCAS1C,SAAYL,EAAM6E,MACThE,KAAK4C,kBACDA,WAAa,IAElBoB,IAAUhE,KAAK4C,WAAWzD,QACxB+F,EAAYlF,KAAK4C,WAAWzD,WAC7ByD,WAAWzD,GAAQ6E,EACpBhE,KAAKqD,oBACkD,IAAnDrD,KAAKqD,kBAAkBlE,EAAM6E,EAAOkB,UAC/BtC,WAAWzD,GAAQ+F,GAG5BlF,KAAK4D,YACA,IAAInF,EAAI,EAAGA,EAAIuB,KAAK4D,QAAQ3B,SAAUxD,EAAG,KACpC0G,EAAInF,KAAK4D,QAAQnF,MAClB0G,GACDA,EAAErB,QAAQC,UAAY5E,EAAM,CAC5BgG,EAAEnB,MAAQA,wCAc1B,SAAcoB,EAAMJ,MACXhF,KAAK0C,YAQG,GAAT0C,GAAcA,GAAQpF,KAAK0C,QAAQT,aAIjCoD,EAAcrF,KAAK0C,QAAQ0C,MAC5BC,IAKLA,EAAYd,MAAQS,EAGhBhF,KAAK0C,QAAQ0C,GAAM3B,WACd,IAAIhF,EAAI,EAAGA,EAAIuB,KAAK0C,QAAQ0C,GAAM3B,MAAMxB,OAAQxD,IAAK,KAChD6G,EAAUtF,KAAK0C,QAAQ0C,GAAM3B,MAAMhF,GACnCiF,EAAO1D,KAAKuC,MAAMkB,MAAM6B,GAC1B5B,IAAMA,EAAKsB,KAAOA,sCAWlC,SAAkBI,EAAMzG,MACfqB,KAAK0C,YAGG,GAAT0C,GAAcA,GAAQpF,KAAK0C,QAAQT,aAGjCoD,EAAcrF,KAAK0C,QAAQ0C,MAC5BC,IAILA,EAAY1G,KAAOA,EAGfqB,KAAK0C,QAAQ0C,GAAM3B,WACd,IAAIhF,EAAI,EAAGA,EAAIuB,KAAK0C,QAAQ0C,GAAM3B,MAAMxB,OAAQxD,IAAK,KAChD6G,EAAUtF,KAAK0C,QAAQ0C,GAAM3B,MAAMhF,QACpC8D,MAAMkB,MAAM6B,GAAS3G,KAAOA,gCAa7C,SAAayG,EAAMG,MACVvF,KAAKyC,UAIN2C,GAAQpF,KAAKyC,OAAOR,QAAoC,MAA1BjC,KAAKyC,OAAO2C,GAAM1B,WAI9C4B,EAAUtF,KAAKyC,OAAO2C,GAAM1B,KAC5BA,EAAO1D,KAAKuC,MAAMkB,MAAM6B,OACzB5B,SAEM,SAGN6B,SACM7B,EAAKsB,SAKVF,EAAO9E,KAAKuC,MAAMiD,YAAY9B,EAAK+B,kBACpCX,GAIDA,EAAKY,iBACLZ,EAAKY,iBAAiBhC,EAAKiC,aACpBb,EAAKc,WACZd,EAAKc,YAGFlC,EAAKsB,MATDtB,EAAKsB,sCAkBpB,SAAiBI,OACRpF,KAAKyC,cACC,QAGP2C,GAAQpF,KAAKyC,OAAOR,QAAoC,MAA1BjC,KAAKyC,OAAO2C,GAAM1B,YACzC,SAEL4B,EAAUtF,KAAKyC,OAAO2C,GAAM1B,KAC5BA,EAAO1D,KAAKuC,MAAMkB,MAAM6B,OACzB5B,SAEM,SAELoB,EAAO9E,KAAKuC,MAAMiD,YAAY9B,EAAK+B,eACpCX,SACMpB,EAAK/E,SAEV0G,EAAcP,EAAKpC,QAAQgB,EAAKiC,oBAClCN,EACOA,EAAY1G,KAEhB,uCAWX,SACIkH,EACAN,OAEMH,EAAOpF,KAAK8F,cAAcD,UACnB,GAATT,EACO,KAEJpF,KAAK+F,aAAaX,EAAMG,mCASnC,SAAiBH,WACRpF,KAAKyC,SAGH2C,EAAOpF,KAAKyC,OAAOR,QAAoC,MAA1BjC,KAAKyC,OAAO2C,GAAM1B,kCAS1D,SAAa0B,UACJpF,KAAKyC,QAGN2C,EAAOpF,KAAKyC,OAAOR,OACZjC,KAAKyC,OAAO2C,GAHZ,iCAcf,SAAaA,OACJpF,KAAKyC,cACC,QAEP2C,EAAOpF,KAAKyC,OAAOR,OAAQ,KACrB+D,EAAYhG,KAAKyC,OAAO2C,UACvBpF,KAAKuC,MAAMkB,MAAMuC,EAAUtC,aAE/B,iCASX,SAAa0B,OACJpF,KAAKyC,cACC,QAEP2C,GAAQpF,KAAKyC,OAAOR,cACb,SAELsB,EAAQvD,KAAKyC,OAAO2C,OACrB7B,GAAwB,OAAfA,EAAMG,YACT,SAELuC,EAAYjG,KAAKuC,MAAMkB,MAAMF,EAAMG,aACpCuC,EAGEjG,KAAKuC,MAAMiD,YAAYS,EAAUR,WAF7B,uCAYf,SAAmBtG,OACVa,KAAKyC,SAAWzC,KAAKyC,OAAOR,cACtBjC,KAAK4C,WAAa5C,KAAK4C,WAAWzD,GAAQ,SAGhD,IAAIV,EAAI,EAAGyH,EAAIlG,KAAKyC,OAAOR,OAAQxD,EAAIyH,IAAKzH,EAAG,KAC1C0H,EAAanG,KAAKyC,OAAOhE,MAC3BU,GAAQgH,EAAWhH,MAA2B,MAAnBgH,EAAWzC,KAAc,KAC9CA,EAAO1D,KAAKuC,MAAMkB,MAAM0C,EAAWzC,SACrCA,SACOA,EAAKsB,aAIjBhF,KAAK4C,WAAWzD,gCAS3B,SAAciG,UACLpF,KAAK0C,QAGN0C,GAAQpF,KAAK0C,QAAQT,OACd,KAGEjC,KAAK0C,QAAQ0C,GACdb,MAPD,kCAiBf,SAAca,UACLpF,KAAK0C,SAGN0C,EAAOpF,KAAK0C,QAAQT,OACbjC,KAAK0C,QAAQ0C,GAHb,sCAcf,SAAkBA,WACTpF,KAAK0C,UAIN0C,EAAOpF,KAAK0C,QAAQT,QACjBjC,KAAK0C,QAAQ0C,GAAM3B,OACnBzD,KAAK0C,QAAQ0C,GAAM3B,MAAMxB,4CASpC,eACSjC,KAAK0C,eACC,MAEN,IAAIjE,EAAI,EAAGA,EAAIuB,KAAK0C,QAAQT,SAAUxD,KACnCuB,KAAK0C,QAAQjE,GAAGgF,OAASzD,KAAK0C,QAAQjE,GAAGgF,MAAMxB,cACxC,SAGR,gCASX,SAAemD,OACNpF,KAAK0C,SAAkC,GAAvB1C,KAAK0C,QAAQT,cACvB,QAGPmD,GAAQpF,KAAK0C,QAAQT,cACd,SAGL0B,EAAS3D,KAAK0C,QAAQ0C,OACvBzB,EAAOF,OAAgC,GAAvBE,EAAOF,MAAMxB,cACvB,aAGL5D,EAAI,GACDI,EAAI,EAAGA,EAAIkF,EAAOF,MAAMxB,OAAQxD,IAAK,KACpC6G,EAAU3B,EAAOF,MAAMhF,GACvBiF,EAAO1D,KAAKuC,MAAMkB,MAAM6B,MAC1B5B,EAAM,KACA0C,EAAcpG,KAAKuC,MAAMiD,YAAY9B,EAAK2C,WAC5CD,GACA/H,EAAE2C,KAAKoF,WAIZ/H,yBAUX,SAAQiI,EAAQC,MACPvG,KAAK0C,SAAY1C,KAAK0C,QAAQT,QAI/BjC,KAAKuC,QAAOvC,KAAKuC,MAAMiE,mBAAqB7I,SAE3C,IAAIc,EAAI,EAAGA,EAAIuB,KAAK0C,QAAQT,SAAUxD,EAAG,KACpCkF,EAAS3D,KAAK0C,QAAQjE,IACvBkF,GAAUA,EAAOhF,OAASI,EAAclD,OAAUyK,GAAU3C,EAAOxE,MAAQmH,QAC3EG,YAAYhI,EAAG8H,gCAY5B,SAAYnB,EAAMmB,EAAOjB,MAChBtF,KAAK0C,aAIJiB,EAAS3D,KAAK0C,QAAQ0C,MACvBzB,OAIGF,EAAUE,EAAVF,SACHA,GAAUA,EAAMxB,QAIjBjC,KAAKuC,aACAA,MAAMiE,mBAAqB7I,SAI/B,IAAIyF,EAAI,EAAGA,EAAIK,EAAMxB,SAAUmB,EAAG,KAC7BZ,EAAKiB,EAAML,MACF,MAAXkC,GAAmBA,GAAW9C,OAI5ByD,EAAYjG,KAAKuC,MAAMkB,MAAMA,EAAML,OACpC6C,GAILA,EAAUS,WAAa/I,QACjBmH,EAAO9E,KAAKuC,MAAMiD,YAAYS,EAAUI,cACzCvB,OAMC6B,EAAoB7B,EAAKrC,OAAOwD,EAAUW,aAE5C9B,EAAKT,OAAStF,EAAc7C,WACxB4I,EAAKc,WACLd,EAAKc,UAAUW,GAEZzB,EAAK+B,UACZ/B,EAAK+B,SAASF,EAAkBxH,KAAMoH,4CAYlD,SAAmBnB,EAAME,MAChBtF,KAAK0C,aAIJiB,EAAS3D,KAAK0C,QAAQ0C,MACvBzB,OAIGF,EAAUE,EAAVF,SACHA,GAAUA,EAAMxB,WAKhB,IAAImB,EAAI,EAAGA,EAAIK,EAAMxB,SAAUmB,EAAG,KAC7BZ,EAAKiB,EAAML,MACF,MAAXkC,GAAmBA,GAAW9C,OAI5ByD,EAAYjG,KAAKuC,MAAMkB,MAAMA,EAAML,IACpC6C,IAILA,EAAUS,WAAa,8BAS/B,SAAQpE,QACCA,KAAOA,EACRtC,KAAK8G,UAAU9G,KAAK8G,SAAS9G,KAAKsC,iCAY1C,SACInD,EACA4H,EACApI,EACAqI,OAEM7C,EAAI,CACNhF,KAAAA,EACAR,KAAAA,EACAoI,cAAAA,MAEAC,MACK,IAAMvI,KAAKuI,EACZ7C,EAAE1F,GAAKuI,EAAWvI,UAGrBuB,KAAK6C,uBACDA,gBAAkB,SAEtBA,gBAAgB7B,KAAKmD,GACrBnE,KAAK4C,kBACDA,WAAa,SAEjBA,WAAWzD,GAAQ4H,EACjB5C,2BAaX,SAAUhF,EAAMR,EAAMqI,OACZ7C,EAAI,CACNhF,KAAAA,EACAR,KAAAA,EACA8E,MAAO,SAEPuD,MACK,IAAMvI,KAAKuI,EACZ7C,EAAE1F,GAAKuI,EAAWvI,UAIrBuB,KAAK0C,eACDA,QAAU,SAEdA,QAAQ1B,KAAKmD,GACdnE,KAAKiH,oBACAA,cAAc9C,QAElB+C,QAAQlH,KAAKmH,oBACbC,gBAAe,GAAM,GACnBjD,4BAQX,SAAWkD,OACF,IAAI5I,EAAI,EAAGA,EAAI4I,EAAMpF,SAAUxD,EAAG,KAC7BuE,EAAOqE,EAAM5I,GACb0F,EAAI,CACNhF,KAAM6D,EAAK,GACXrE,KAAMqE,EAAK,GACXU,KAAM,SAEN2D,EAAM,OACD,IAAMnF,KAAKc,EAAK,GACjBmB,EAAEjC,GAAKc,EAAK,GAAGd,GAIlBlC,KAAK0C,eACDA,QAAU,SAEdA,QAAQ1B,KAAKmD,GACdnE,KAAKiH,oBACAA,cAAc9C,QAItB+C,QAAQlH,KAAKmH,oBACbC,gBAAe,GAAM,+BAQ9B,SAAahC,QACJkC,iBAAiBlC,QACjB1C,QAAQ6E,OAAOnC,EAAM,OACrB,IAAI3G,EAAI2G,EAAM3G,EAAIuB,KAAK0C,QAAQT,SAAUxD,KACrCuB,KAAK0C,QAAQjE,IAAOuB,KAAK0C,QAAQjE,GAAGgF,cAGjCA,EAAUzD,KAAK0C,QAAQjE,GAAvBgF,MACCvB,EAAI,EAAGA,EAAIuB,EAAMxB,SAAUC,EAAG,KAC7BwB,EAAO1D,KAAKuC,MAAMkB,MAAMA,EAAMvB,IAC/BwB,IAGLA,EAAKiC,aAAe,QAIvBuB,QAAQlH,KAAKmH,eACdnH,KAAKwH,sBACAA,gBAAgBpC,QAEpBgC,gBAAe,GAAM,2BAY9B,SAASjI,EAAMR,EAAMqI,OAEX7C,EAAI,CACNhF,KAAAA,EACAR,KAHJA,EAAOA,GAAQ,EAIX+E,KAAM,SAENsD,MACK,IAAMvI,KAAKuI,EACZ7C,EAAE1F,GAAKuI,EAAWvI,UAIrBuB,KAAKyC,cACDA,OAAS,SAGbA,OAAOzB,KAAKmD,QACZ+C,QAAQlH,KAAKmH,eAEdnH,KAAKyH,mBACAA,aAAatD,QAGjBiD,gBAAe,GAAM,GACnBjD,2BAQX,SAAUkD,OACD,IAAI5I,EAAI,EAAGA,EAAI4I,EAAMpF,SAAUxD,EAAG,KAC7BuE,EAAOqE,EAAM5I,GACb0F,EAAI,CACNhF,KAAM6D,EAAK,GACXrE,KAAMqE,EAAK,GACXU,KAAM,SAEN2D,EAAM,OACD,IAAMnF,KAAKc,EAAK,GACjBmB,EAAEjC,GAAKc,EAAK,GAAGd,GAIlBlC,KAAKyC,cACDA,OAAS,SAEbA,OAAOzB,KAAKmD,GACbnE,KAAKyH,mBACAA,aAAatD,QAIrB+C,QAAQlH,KAAKmH,oBACbC,gBAAe,GAAM,8BAQ9B,SAAYhC,QACHsC,gBAAgBtC,WACfY,EAAYhG,KAAKyC,OAAO8E,OAAOnC,EAAM,GAClC3G,EAAI2G,EAAM3G,EAAIuB,KAAKyC,OAAOR,SAAUxD,KACpCuB,KAAKyC,OAAOhE,QAGXiF,EAAO1D,KAAKuC,MAAMkB,MAAMzD,KAAKyC,OAAOhE,GAAGiF,MACxCA,IAGLA,EAAKkD,aAAe,QAEnBM,QAAQlH,KAAKmH,eACdnH,KAAK2H,qBACAA,eAAevC,EAAMY,EAAU,SAEnCoB,gBAAe,GAAM,gCAW9B,SAAcjI,EAAMR,EAAMS,EAAKwI,OACrBzD,EAAI,CACNhF,KAAAA,EACAR,KAAAA,EACAS,IAAAA,EACAwI,UAAAA,EACAnE,MAAO,kBAENd,YAAY3B,KAAKmD,GACfA,6BASX,SAAY0D,MACJ7H,KAAKS,YAAY6B,YACVtC,KAAKS,YAAY6B,KAAKwF,aAG7BC,EAAOC,KAAKC,IACZjI,KAAKyC,OAASzC,KAAKyC,OAAOR,OAAS,EACnCjC,KAAK0C,QAAU1C,KAAK0C,QAAQT,OAAS,GAEnCK,EAAOuF,GAAO,IAAIzF,aAAa,CAAC,EAAG,IACzC2F,EAAOC,KAAKC,IAAIF,EAAM,OAIlBG,EAHAA,EAAYnJ,EAAc7E,eAIxBiO,EAAcC,EAAkBpI,KAAKR,OACvC6I,EAAc,EACdC,EAAe,KAEftI,KAAKyC,WACA,IAAIhE,EAAI,EAAGyH,EAAIlG,KAAKyC,OAAOR,OAAQxD,EAAIyH,IAAKzH,EAAG,KAC1C8E,EAAQvD,KAAKyC,OAAOhE,GAGtB4J,GADAE,EAAaH,EADN7E,EAAMiF,OAASjF,EAAMpE,MAAQ,OAGpCkJ,EAAcE,MAKtBvI,KAAK0C,YACIjE,EAAI,EAAGyH,EAAIlG,KAAK0C,QAAQT,OAAQxD,EAAIyH,IAAKzH,EAAG,KAG7C8J,EAFE5E,EAAS3D,KAAK0C,QAAQjE,GAGxB6J,GADAC,EAAaH,EADNzE,EAAO6E,OAAS7E,EAAOxE,MAAQ,OAGtCmJ,EAAeC,GAK3BjG,EAAK,GAAK0F,KAAKC,IAAII,EAAcC,EAAe,GAAIH,GACpD7F,EAAK,GAAK0F,KAAKC,IAAI3F,EAAK,GAAIvD,EAAcnF,YACtCoG,KAAK4D,SAAW5D,KAAK4D,QAAQ3B,SAC7BK,EAAK,GAAK0F,KAAKC,IAAI3F,EAAK,GAA+B,IAA3BvD,EAAcnF,aAG9C0I,EAAK,IAAMtC,KAAKS,YAAYgI,cAAgB,GAAKV,EAAOhJ,EAAcrF,qBAElEgP,EAAiB,KACjB1I,KAAK4D,SAAW5D,KAAK4D,QAAQ3B,OAAQ,KAC5BxD,EAAI,EAAGyH,EAAIlG,KAAK4D,QAAQ3B,OAAQxD,EAAIyH,IAAKzH,EAC1CuB,KAAK4D,QAAQnF,GAAG0I,YAChBuB,GAAkB1I,KAAK4D,QAAQnF,GAAG0I,YAAY7E,EAAK,IAAI,GAAK,EAE5DoG,GAAkB3J,EAAcpF,mBAAqB,EAG7D+O,GAAkB,WAYbN,EAAkBO,UAClBA,EAGET,EAAYS,EAAK1G,OAAS,GAFtB,SAVXjC,KAAK4I,WACLtG,EAAK,GAAK0F,KAAKC,IAAI3F,EAAK,GAAIoG,GACG,MAAxB1I,KAAK6I,gBACZvG,EAAK,GAAK0F,KAAKC,IAAI3F,EAAK,GAAIoG,EAAiB1I,KAAK6I,iBAElDvG,EAAK,IAAMoG,EAWX1I,KAAKS,YAAYqI,YACdxG,EAAK,GAAKtC,KAAKS,YAAYqI,aAE9BxG,EAAK,GAAKtC,KAAKS,YAAYqI,YAG/BxG,EAAK,IAAM,EAEJA,iCAUX,SAAgByB,OACRf,EAAO,QAIPhD,KAAK6C,oBACA,IAAIpE,EAAI,EAAGA,EAAIuB,KAAK6C,gBAAgBZ,SAAUxD,KAC3CuB,KAAK6C,gBAAgBpE,GAAGU,MAAQ4E,EAAU,CAC1Cf,EAAOhD,KAAK6C,gBAAgBpE,gBAMpCuB,KAAKS,uBAAgBsD,MAAaf,EAAOhD,KAAKS,uBAAgBsD,KAE9D/D,KAAKS,YAAYsI,cAAgB/I,KAAKS,YAAYsI,aAAahF,KAAWf,EAAOhD,KAAKS,YAAYsI,aAAahF,KAG9Gf,GAAQhD,KAAKgJ,oBACdhG,EAAOhD,KAAKgJ,kBAAkBjF,IAG7Bf,IAAMA,EAAO,IACbA,EAAKrE,OAAMqE,EAAKrE,OAAcqB,KAAK4C,WAAWmB,KAChC,SAAff,EAAKa,SAAmBb,EAAKrE,KAAO,QAEjCqE,2BAgBX,SAAUrE,EAAMQ,EAAM6E,EAAOiF,EAAUnF,GAC9B9D,KAAK4D,eACDA,QAAU,KAGdE,GAAWmF,GAAYA,EAASxI,cAAgBf,SACjDoE,EAAUmF,EACVA,EAAW,MAGXnF,GAAWA,EAAQrD,cAAgBC,SAEnCoD,EAAU,CAAEC,SAAUD,IAGtBmF,GAAYA,EAASxI,cAAgBC,SAEhCoD,IAASA,EAAU,IACxBA,EAAQC,SAAWkF,EACnBA,EAAW,MAGXA,GAAYA,EAASxI,cAAgByI,WACrClK,QAAQsB,KAAK,0CACb2I,EAAW,UAGT9D,EAAI,CACNxG,KAAMA,EAAKgC,cACXxB,KAAAA,EACA6E,MAAAA,EACAiF,SAAAA,EACAnF,QAASA,GAAW,YAGJqF,IAAhBhE,EAAErB,QAAQsF,IACVjE,EAAEiE,EAAIjE,EAAErB,QAAQsF,GAGfH,GAAa9D,EAAErB,QAAQmF,UAAa9D,EAAErB,QAAQC,UAC/C/E,QAAQsB,KAAK,oEAEL,SAAR3B,IAAoBwG,EAAErB,QAAQuF,YACxB,6GAELzF,QAAQ5C,KAAKmE,QACb+B,QAAQlH,KAAKmH,eACXhC,iCAGX,SAAgBmE,UACPtJ,KAAK4D,eACDA,QAAU,SAEdA,QAAQ5C,KAAKsI,GACXA,6BASX,SAAYzB,UACRA,EAAMA,GAAO,IAAIzF,aAAa,IAC1B,GAAKpC,KAAKZ,IAAI,GAAK,EACvByI,EAAI,GAAK7H,KAAKZ,IAAI,GAAKL,EAAcvF,kBACrCqO,EAAI,GAAK7H,KAAKsC,KAAK,GAAK,EACxBuF,EAAI,GAAK7H,KAAKsC,KAAK,GAAKvD,EAAcvF,kBAElCwG,KAAKuJ,iBACAA,WAAW1B,GAEbA,+BAUX,SAAc2B,EAAGJ,EAAGK,EAAQC,GACxBD,EAASA,GAAU,MAEfE,EAAa3J,KAAKuC,OAASvC,KAAKuC,MAAMqH,SAAW,EAAI7K,EAAcvF,qBACnEkQ,IACAC,EAAa,GAEb3J,KAAK8C,OAAS9C,KAAK8C,MAAM+G,cAIrBC,kBACIN,EACAJ,EACApJ,KAAKZ,IAAI,GAAKqK,EACdzJ,KAAKZ,IAAI,GAAKL,EAAcvF,kBAAoBiQ,GAC/CzJ,KAAK+J,kBAAoBhL,EAAchF,sBACtC,EAAI0P,EACN1K,EAAcvF,kBAAoB,EAAIiQ,UAGnC,OAER,GACHzJ,KAAKZ,IAAI,GAAK,EAAIqK,EAASD,GACxBxJ,KAAKZ,IAAI,GAAKY,KAAKsC,KAAK,GAAK,EAAImH,EAASD,GAC1CxJ,KAAKZ,IAAI,GAAKuK,EAAaF,EAASL,GACpCpJ,KAAKZ,IAAI,GAAKY,KAAKsC,KAAK,GAAKmH,EAASL,SAElC,SAEJ,mCAWX,SAAkBI,EAAGJ,OAEXY,EAAW,IAAI5H,aAAa,MAC9BpC,KAAKyC,WACA,IAAIhE,EAAI,EAAGyH,EAAIlG,KAAKyC,OAAOR,OAAQxD,EAAIyH,IAAKzH,EAAG,KAC1C8E,EAAQvD,KAAKyC,OAAOhE,WACrBwL,kBAAiB,EAAMxL,EAAGuL,GAE3BF,kBACIN,EACAJ,EACAY,EAAS,GAAK,GACdA,EAAS,GAAK,EACd,GACA,UAGG,CACHzG,MAAAA,EACA6B,KAAM3G,EACNuL,SAAAA,MAMZhK,KAAK0C,YACIjE,EAAI,EAAGyH,EAAIlG,KAAK0C,QAAQT,OAAQxD,EAAIyH,IAAKzH,EAAG,KAC3CkF,EAAS3D,KAAK0C,QAAQjE,WACvBwL,kBAAiB,EAAOxL,EAAGuL,GAE5BF,kBACIN,EACAJ,EACAY,EAAS,GAAK,GACdA,EAAS,GAAK,EACd,GACA,UAGG,CACHrG,OAAAA,EACAyB,KAAM3G,EACNuL,SAAAA,UAMT,kCASX,SAAc7K,OACLa,KAAKyC,cACE,MAEP,IAAIhE,EAAI,EAAGyH,EAAIlG,KAAKyC,OAAOR,OAAQxD,EAAIyH,IAAKzH,KACzCU,GAAQa,KAAKyC,OAAOhE,GAAGU,YAChBV,SAGP,gCASZ,SAAeU,OACNa,KAAK0C,eACE,MAEP,IAAIjE,EAAI,EAAGyH,EAAIlG,KAAK0C,QAAQT,OAAQxD,EAAIyH,IAAKzH,KAC1CU,GAAQa,KAAK0C,QAAQjE,GAAGU,YACjBV,SAGP,yBAaZ,SAAQ2G,EAAMgB,EAAaQ,MACvBA,EAAcA,GAAe,GAExB5G,KAAKuC,aAENvD,QAAQC,IACJ,kHAEG,QAIPmG,EAAK3E,cAAgBC,YAER,IADb0E,EAAOpF,KAAKkK,eAAe9E,WAEnBrG,EAAc9B,OACd+B,QAAQC,8CAAuCmG,IAE5C,UAER,IAAKpF,KAAK0C,SAAW0C,GAAQpF,KAAK0C,QAAQT,cACzClD,EAAc9B,OACd+B,QAAQC,IAAI,yCAET,QAGPmH,GAAeA,EAAY3F,cAAgB0J,SAC3C/D,EAAcpG,KAAKuC,MAAMiD,YAAYY,KAEpCA,OACK,yBAINA,GAAepG,YACR,QAIP4G,EAAYnG,cAAgBC,YAER,IADpBkG,EAAcR,EAAYN,cAAcc,WAEhC7H,EAAc9B,OACd+B,QAAQC,8CAC+B2H,IAGpC,SAER,CAAA,GAAIA,IAAgB7H,EAAclD,aAQ9B,KACJ,IACFuK,EAAY3D,QACVmE,GAAeR,EAAY3D,OAAOR,cAEjClD,EAAc9B,OACd+B,QAAQC,IAAI,yCAET,SAGPmL,GAAU,EAG8B,MAAxChE,EAAY3D,OAAOmE,GAAalD,YAC3BnB,MAAM8H,eACXjE,EAAYsB,gBAAgBd,GAC5BwD,GAAU,OAORzG,EAAS3D,KAAK0C,QAAQ0C,MAGxBgB,EAAYkE,iBACqE,IAA7ElE,EAAYkE,eAAe1D,EAAajD,EAAOhF,KAAMgF,EAAQ3D,KAAMoF,UAC5D,SAIT7B,EAAQ6C,EAAY3D,OAAOmE,GAC7BX,EAAY,YAGXtE,EAAkBgC,EAAOhF,KAAM4E,EAAM5E,OAMrCyL,GAASpK,KAAKuC,MAAM8H,eAGzBpE,EAAY,IAAIsE,QACVvK,KAAKuC,MAAMiI,aACbjH,EAAM5E,KACNqB,KAAKwC,GACL4C,EACAgB,EAAY5D,GACZoE,QAICrE,MAAMkB,MAAMwC,EAAUzD,IAAMyD,EAGb,MAAhBtC,EAAOF,QACPE,EAAOF,MAAQ,IAEnBE,EAAOF,MAAMzC,KAAKiF,EAAUzD,IAE5B4D,EAAY3D,OAAOmE,GAAalD,KAAOuC,EAAUzD,GAC7CxC,KAAKuC,YACAA,MAAMU,WAEXjD,KAAKsD,0BACAA,oBACDvE,EAAcnD,OACdwJ,GACA,EACAa,EACAtC,GAGJyC,EAAY9C,qBACZ8C,EAAY9C,oBACRvE,EAAcpD,MACdiL,GACA,EACAX,EACA1C,GAGJvD,KAAKuC,OAASvC,KAAKuC,MAAMkI,8BACpBlI,MAAMkI,uBACP1L,EAAcpD,MACdyK,EACAQ,EACA5G,KACAoF,QAEC7C,MAAMkI,uBACP1L,EAAcnD,OACdoE,KACAoF,EACAgB,EACAQ,SAIHQ,gBAAe,GAAO,QACtB7E,MAAMmI,mBACNnI,MAAMoI,iBAAiB3K,KAAMiG,GAE3BA,SArEEmB,gBAAe,GAAO,GACvBgD,GAASpK,KAAKuC,MAAMoI,iBAAiB3K,KAAMiG,GACxC,sCA+Ef,SAAiBb,EAAMgB,MACfhB,EAAK3E,cAAgBC,YAER,IADb0E,EAAOpF,KAAKkK,eAAe9E,WAEnBrG,EAAc9B,OACd+B,QAAQC,8CAAuCmG,KAE5C,OAER,IAAKpF,KAAK0C,SAAW0C,GAAQpF,KAAK0C,QAAQT,cACzClD,EAAc9B,OACd+B,QAAQC,IAAI,0CAET,MAIL0E,EAAS3D,KAAK0C,QAAQ0C,OACvBzB,IAAWA,EAAOF,OAAgC,GAAvBE,EAAOF,MAAMxB,cAClC,KAIPmE,EAAa,IACTA,EAAY3F,cAAgB0J,SAC5B/D,EAAcpG,KAAKuC,MAAMiD,YAAYY,KAEpCA,OACK,4BAGL,IAAI3H,EAAI,EAAGyH,EAAIvC,EAAOF,MAAMxB,OAAQxD,EAAIyH,EAAGzH,IAAK,KAC7C6G,EAAU3B,EAAOF,MAAMhF,OACvBwH,EAAYjG,KAAKuC,MAAMkB,MAAM6B,IAGnBe,WAAaD,EAAY5D,GAAI,CACvCmB,EAAOF,MAAM8D,OAAO9I,EAAG,IACnB8E,EAAQ6C,EAAY3D,OAAOwD,EAAUW,cACnClD,KAAO,YACN1D,KAAKuC,MAAMkB,MAAM6B,GACpBtF,KAAKuC,YACAA,MAAMU,WAEXmD,EAAY9C,qBACZ8C,EAAY9C,oBACRvE,EAAcpD,MACdsK,EAAUW,aACV,EACAX,EACA1C,GAGJvD,KAAKsD,0BACAA,oBACDvE,EAAcnD,OACdwJ,GACA,EACAa,EACAtC,GAGJ3D,KAAKuC,OAASvC,KAAKuC,MAAMkI,6BACpBlI,MAAMkI,uBACP1L,EAAcnD,OACdoE,KACAoF,GAGJpF,KAAKuC,OAASvC,KAAKuC,MAAMkI,8BACpBlI,MAAMkI,uBACP1L,EAAcnD,OACdoE,KACAoF,QAEC7C,MAAMkI,uBACP1L,EAAcpD,MACdyK,EACAH,EAAUW,0BAOzB,KACQnI,EAAI,EAAGyH,EAAIvC,EAAOF,MAAMxB,OAAQxD,EAAIyH,EAAGzH,IAAK,KAE7CwH,EADAX,EAAU3B,EAAOF,MAAMhF,MACvBwH,EAAYjG,KAAKuC,MAAMkB,MAAM6B,IAM7Bc,EAAcpG,KAAKuC,MAAMiD,YAAYS,EAAUI,eAC/C9C,EAAQ,KACRvD,KAAKuC,YACAA,MAAMU,WAEXmD,KACA7C,EAAQ6C,EAAY3D,OAAOwD,EAAUW,cAC/BlD,KAAO,KACT0C,EAAY9C,qBACZ8C,EAAY9C,oBACRvE,EAAcpD,MACdsK,EAAUW,aACV,EACAX,EACA1C,GAGJvD,KAAKuC,OAASvC,KAAKuC,MAAMkI,6BACpBlI,MAAMkI,uBACP1L,EAAcpD,MACdyK,EACAH,EAAUW,qBAIf5G,KAAKuC,MAAMkB,MAAM6B,GACpBtF,KAAKsD,0BACAA,oBACDvE,EAAcnD,OACdwJ,GACA,EACAa,EACAtC,GAGJ3D,KAAKuC,OAASvC,KAAKuC,MAAMkI,8BACpBlI,MAAMkI,uBACP1L,EAAcnD,OACdoE,KACAoF,QAEC7C,MAAMkI,uBACP1L,EAAcpD,MACdyK,EACAH,EAAUW,eAItBjD,EAAOF,MAAQ,iBAGd2D,gBAAe,GAAO,QACtB7E,MAAMoI,iBAAiB3K,OACrB,iCAUX,SAAgBoF,MAERA,EAAK3E,cAAgBC,YAER,IADb0E,EAAOpF,KAAK8F,cAAcV,WAElBrG,EAAc9B,OACd+B,QAAQC,8CAAuCmG,KAE5C,OAER,IAAKpF,KAAKyC,QAAU2C,GAAQpF,KAAKyC,OAAOR,cACvClD,EAAc9B,OACd+B,QAAQC,IAAI,0CAET,MAGLsE,EAAQvD,KAAKyC,OAAO2C,OACrB7B,SACM,MAGL+B,EAAUtF,KAAKyC,OAAO2C,GAAM1B,QACnB,MAAX4B,EAAiB,MACZ7C,OAAO2C,GAAM1B,KAAO,SAGnBuC,EAAYjG,KAAKuC,MAAMkB,MAAM6B,MAC/BW,EAAW,KACLG,EAAcpG,KAAKuC,MAAMiD,YAAYS,EAAUR,eAChDW,SACM,MAGLzC,EAASyC,EAAY1D,QAAQuD,EAAUN,iBACxChC,IAAWA,EAAOF,OAAgC,GAAvBE,EAAOF,MAAMxB,cAClC,MAIN,IAAIxD,EAAI,EAAGyH,EAAIvC,EAAOF,MAAMxB,OAAQxD,EAAIyH,EAAGzH,OACxCkF,EAAOF,MAAMhF,IAAM6G,EAAS,CAC5B3B,EAAOF,MAAM8D,OAAO9I,EAAG,gBAKxBuB,KAAKuC,MAAMkB,MAAM6B,GACpBtF,KAAKuC,YACAA,MAAMU,WAEXjD,KAAKsD,0BACAA,oBACDvE,EAAcpD,MACdyJ,GACA,EACAa,EACA1C,GAGJ6C,EAAY9C,qBACZ8C,EAAY9C,oBACRvE,EAAcnD,OACd6C,GACA,EACAwH,EACAtC,GAGJ3D,KAAKuC,OAASvC,KAAKuC,MAAMkI,8BACpBlI,MAAMkI,uBACP1L,EAAcnD,OACdwK,EACA3H,QAEC8D,MAAMkI,uBAAuB1L,EAAcpD,MAAOqE,KAAMoF,iBAKpEgC,gBAAe,GAAO,GACvBpH,KAAKuC,OAAOvC,KAAKuC,MAAMoI,iBAAiB3K,OACrC,kCAYX,SACI4K,EACAC,EACAhD,GAEAA,EAAMA,GAAO,IAAIzF,aAAa,OAC1B0I,EAAY,EACZF,GAAY5K,KAAKyC,SACjBqI,EAAY9K,KAAKyC,OAAOR,SAEvB2I,GAAY5K,KAAK0C,UAClBoI,EAAY9K,KAAK0C,QAAQT,YAGvB8I,EAA0C,GAAjChM,EAAcrF,oBAEzBsG,KAAK8C,MAAM+G,UAAW,KAChB1E,EAAInF,KAAK+J,kBAAoBhL,EAAchF,4BAC7CiG,KAAKgL,YACLnD,EAAI,GAAK7H,KAAKZ,IAAI,GAAS,GAAJ+F,EAEnB0C,EAAI,GADJ+C,EACS5K,KAAKZ,IAAI,GAAKL,EAAcvF,kBAE5BwG,KAAKZ,IAAI,KAIlByI,EAAI,GADJ+C,EACS5K,KAAKZ,IAAI,GAETY,KAAKZ,IAAI,GAAK+F,EAE3B0C,EAAI,GAAK7H,KAAKZ,IAAI,GAAuC,GAAlCL,EAAcvF,mBAElCqO,SAIP+C,IAA4B,GAAhBC,GACZhD,EAAI,GAAK7H,KAAKZ,IAAI,GAAuC,GAAlCL,EAAcvF,kBACrCqO,EAAI,GAAK7H,KAAKZ,IAAI,GAAuC,GAAlCL,EAAcvF,kBAC9BqO,GAKP+C,GACGE,EAAYD,GACZ7K,KAAKyC,OAAOoI,GAAazL,KAE5ByI,EAAI,GAAK7H,KAAKZ,IAAI,GAAKY,KAAKyC,OAAOoI,GAAazL,IAAI,GACpDyI,EAAI,GAAK7H,KAAKZ,IAAI,GAAKY,KAAKyC,OAAOoI,GAAazL,IAAI,GAC7CyI,IAGN+C,GACEE,EAAYD,GACZ7K,KAAK0C,QAAQmI,GAAazL,KAE7ByI,EAAI,GAAK7H,KAAKZ,IAAI,GAAKY,KAAK0C,QAAQmI,GAAazL,IAAI,GACrDyI,EAAI,GAAK7H,KAAKZ,IAAI,GAAKY,KAAK0C,QAAQmI,GAAazL,IAAI,GAC9CyI,GAIP7H,KAAKgL,YACLnD,EAAI,GAAK7H,KAAKZ,IAAI,IAAMyL,EAAc,KAAQ7K,KAAKsC,KAAK,GAAKwI,GAEzDjD,EAAI,GADJ+C,EACS5K,KAAKZ,IAAI,GAAKL,EAAcvF,kBAE5BwG,KAAKZ,IAAI,GAAKY,KAAKsC,KAAK,GAE9BuF,IAKPA,EAAI,GADJ+C,EACS5K,KAAKZ,IAAI,GAAK2L,EAEd/K,KAAKZ,IAAI,GAAKY,KAAKsC,KAAK,GAAK,EAAIyI,EAE9ClD,EAAI,GAAK7H,KAAKZ,IAAI,IACXyL,EAAc,IAAO9L,EAAcrF,kBACnCsG,KAAKS,YAAYgI,cAAgB,GACjCZ,8BAIX,gBACSzI,IAAI,GAAKL,EAAcxF,iBACtByO,KAAKiD,MAAMjL,KAAKZ,IAAI,GAAKL,EAAcxF,uBACxC6F,IAAI,GAAKL,EAAcxF,iBACtByO,KAAKiD,MAAMjL,KAAKZ,IAAI,GAAKL,EAAcxF,uCAIjD,SAAM2R,GACGlL,KAAKhB,eACDA,QAAU,SAGdA,QAAQgC,KAAKkK,GACdlL,KAAKhB,QAAQiD,OAASE,EAAWgJ,kBAC5BnM,QAAQoM,QAGbpL,KAAKuC,MAAM8I,aAAarL,KAAKuC,MAAM8I,YAAYrL,KAAMkL,iCAI7D,SACII,EACAC,GAEKvL,KAAKuC,YAGLA,MAAMiJ,mBAAmB,WAAY,CACtCF,EACAC,6BAIR,SAAUE,cACAC,EAAM,IAAIC,aAChBD,EAAIE,IAAM7M,EAAc/B,iBAAmByO,EAC3CC,EAAIG,OAAQ,EAEZH,EAAII,OAAS,WACTJ,EAAIG,OAAQ,EACZE,EAAK3E,gBAAe,IAEjBsE,8BA2CX,SAAa3L,MACJC,KAAKuC,OAAUvC,KAAKuC,MAAMyJ,4BAIzBC,EAAOjM,KAAKuC,MAAMyJ,oBAEfvN,EAAI,EAAGA,EAAIwN,EAAKhK,SAAUxD,EAAG,KAC5ByN,EAAID,EAAKxN,IAEVsB,GAAKmM,EAAEC,sBAAwBnM,QAKpCkM,EAAEC,qBAAuBpM,EAAIC,KAAO,+BAQ5C,SAASoM,QACA7J,MAAMU,aAC0B,IAAjCjD,KAAKS,YAAY4L,aAA0BD,UAG1CtJ,MAAM+G,WAAa7J,KAAK8C,MAAM+G,eAC9BzC,gBAAe,GAAM,uBAQ9B,SAAIrH,QACKwC,MAAMU,gBAEFH,MAAMwJ,YADLnD,IAANpJ,GACqBC,KAAK8C,MAAMwJ,OAEZvM,+BAI5B,SAAcyJ,EAAGJ,EAAGmD,SACT,EACF/C,EAAIxJ,KAAKZ,IAAI,IAAMmN,EAAYC,MAAQD,EAAYxB,OAAO,IAC1D3B,EAAIpJ,KAAKZ,IAAI,IAAMmN,EAAYC,MAAQD,EAAYxB,OAAO,gCAWnE,SAAkBpM,EAAMa,EAAOsE,OACrBlF,EAAYoB,KAAK3C,sBAAsBsB,OACxCC,SACGG,EAAc9B,OAAO+B,QAAQC,8BAAuBN,wBACjD,KAGOC,EAAUC,UAE5BW,EAAQA,GAASZ,EAAUY,OAASb,MAEhCmG,EAAO,QAEP/F,EAAc7B,qBAEV4H,EAAO,IAAIlG,EAAUY,GACvB,MAAOiN,UACLzN,QAAQ0N,MAAMD,GACP,UAGX3H,EAAO,IAAIlG,EAAUY,MAGzBsF,EAAKnG,KAAOA,GAEPmG,EAAKtF,OAASA,IACfsF,EAAKtF,MAAQA,GAEZsF,EAAKlC,aACNkC,EAAKlC,WAAa,IAEjBkC,EAAKjC,kBACNiC,EAAKjC,gBAAkB,IAEtBiC,EAAKhC,QACNgC,EAAKhC,MAAQ,IAEZgC,EAAKxC,OACNwC,EAAKxC,KAAOwC,EAAKqC,eAGhBrC,EAAK1F,MACN0F,EAAK1F,IAAML,EAAc3D,iBAAiB0M,UAEzChD,EAAKT,OACNS,EAAKT,KAAOtF,EAAchD,QAI1B+H,MAEK,IAAMrF,KAAKqF,EAASgB,EAAKrG,GAAKqF,EAAQrF,UAGxCqG,6BAIX,SAAmB6H,SAGTC,EAAc,OAFRC,SAASC,qBAAqB,+CAG/B9O,UAAU4O,EAAY5L,KAAKhD,sCAEhC+O,EAAaF,SAASC,qBAAqB,QAAQ,GACzDH,EAAiBE,SAASG,SAASC,KAAON,gBAErBC,iBAAa,KACtBhB,OAAAA,OAEHA,GACEA,EAAIrM,OAAO,EAAGoN,EAAe1K,UAAY0K,MAIxC5N,EAAc9B,OACd+B,QAAQC,yBAAkB2M,QAExBsB,EAAgBL,SAASM,cAAc,UAC7CD,EAAcvO,KAAO,kBACrBuO,EAActB,IAAMA,EACpBmB,EAAWK,YAAYF,GACvBH,EAAWM,YAAYT,EAAYnO,IACrC,MAAOgO,MACD1N,EAAc5B,mBACRsP,EAEN1N,EAAc9B,OAAO+B,QAAQC,oCAA6B2M,KAIlE7M,EAAc9B,OACd+B,QAAQC,IAAI,+CAUpB,SAAqBE,EAAMoC,OAElB,IAAM9C,KADX0D,EAAWtD,UAAUM,GAAQoC,EACbvB,KAAK3C,sBAAuB,KAClCsB,EAAOqB,KAAK3C,sBAAsBoB,GACpCE,EAAKE,UAAUM,KAAOR,EAAKE,qBAAcM,IAAUR,EAAKE,UAAUM,IACtER,EAAKE,UAAUM,GAAQoC,YChrEd+L,wBACL9N,oCA+FI2C,EAAWtD,UAAU0O,uCAEpBpL,EAAWtD,UAAUuI,qBAhG7B/E,MAAM7C,kCAGf,SAAMA,cACGA,MAAQA,GAAS,aACjB0I,UAAY,QACZzD,gBAAQ+I,6BAAcC,YAAYC,UACjCF,aAAaC,YAAYC,UAAUC,WACnC,YACDC,UAAY,IAAIxL,aAAa,CAAC,GAAI,GAAI,IAAK,UAC3CW,KAAO/C,KAAK4N,UAAUC,SAAS,EAAG,QAClCC,MAAQ9N,KAAK4N,UAAUC,SAAS,EAAG,QACnCE,OAAS,QACTxL,MAAQ,KAEb7C,OAAOG,eAAeG,KAAM,MAAO,CAC/BF,aAAIC,IACKA,GAAKA,EAAEkC,OAAS,SAGhBc,KAAK,GAAKhD,EAAE,QACZgD,KAAK,GAAKhD,EAAE,KAErBG,sBACWF,KAAK+C,MAEhB5C,YAAY,IAGhBT,OAAOG,eAAeG,KAAM,OAAQ,CAChCF,aAAIC,IACKA,GAAKA,EAAEkC,OAAS,SAGhB6L,MAAM,GAAK9F,KAAKC,IAAI,IAAKlI,EAAE,SAC3B+N,MAAM,GAAK9F,KAAKC,IAAI,GAAIlI,EAAE,MAEnCG,sBACWF,KAAK8N,OAEhB3N,YAAY,wCAIpB,gBACS4N,OAAO9L,OAAS,UACf+L,EAAQhO,KAAKuC,MAAMwL,OACnBE,EAAgB,IAAI7L,aAAa,GAE9B3D,EAAI,EAAGA,EAAIuP,EAAM/L,SAAUxD,EAAG,KAC7BqG,EAAOkJ,EAAMvP,GACnBqG,EAAKoJ,YAAYD,GACZE,gBAAgBnO,KAAK4N,UAAWK,SAGhCF,OAAO/M,KAAK8D,wBAIzB,SAAKsJ,EAAQC,EAAQC,WACZvL,KAAK,IAAMqL,OACXrL,KAAK,IAAMsL,GACZC,MAGC,IAAI7P,EAAI,EAAGA,EAAIuB,KAAK+N,OAAO9L,SAAUxD,EAAG,KACnCqG,EAAO9E,KAAK+N,OAAOtP,GACzBqG,EAAK1F,IAAI,IAAMgP,EACftJ,EAAK1F,IAAI,IAAMiP,4BAIvB,eACUE,EAAIvO,KAAK4N,gBACR,CACHpO,MAAOQ,KAAKR,MACZgP,SAAU,CACNxG,KAAKiD,MAAMsD,EAAE,IACbvG,KAAKiD,MAAMsD,EAAE,IACbvG,KAAKiD,MAAMsD,EAAE,IACbvG,KAAKiD,MAAMsD,EAAE,KAEjB9J,MAAOzE,KAAKyE,MACZgK,KAAMzO,KAAKyO,+BAInB,SAAUtK,QACD3E,MAAQ2E,EAAE3E,WACVoO,UAAU9N,IAAIqE,EAAEqK,eAChB/J,MAAQN,EAAEM,WACVgK,KAAOtK,EAAEsK,cChGDC,wBACLC,EAASC,kBACZ7D,OAAS,IAAI3I,aAAa,CAAC,EAAG,SAC9BoK,MAAQ,OACRqC,UAAY,QACZC,UAAY,QACZC,SAAW,UACXC,SAAU,OACVC,WAAa,CAAC,EAAG,QACjBN,QAAU,UACVO,aAAe,IAAI9M,aAAa,GAEjCuM,SACKA,QAAUA,EACVC,QACIO,WAAWR,wCAK5B,SAAWA,QACFM,WAAa,IAAI7M,aAAa,QAE9BgN,uBAAyBpP,KAAKqP,QAAQC,KAAKtP,MAEhD2O,EAAQY,iBAAiB,YAAavP,KAAKoP,wBAC3CT,EAAQY,iBAAiB,YAAavP,KAAKoP,wBAE3CT,EAAQY,iBACJ,aACAvP,KAAKoP,wBACL,GAEJT,EAAQY,iBAAiB,QAASvP,KAAKoP,wBAAwB,qCAGnE,cACSpP,KAAK2O,aAKFa,EAAUxP,KAAK2O,QAAfa,MACAC,EAAWzP,KAAK2O,QAAhBc,OACFC,GAAU1P,KAAK+K,OAAO,GACtB4E,GAAU3P,KAAK+K,OAAO,GACtB6E,EAAOF,EAASF,EAAQxP,KAAKwM,MAC7BqD,EAAOF,EAASF,EAASzP,KAAKwM,WAC/B0C,aAAa,GAAKQ,OAClBR,aAAa,GAAKS,OAClBT,aAAa,GAAKU,EAAOF,OACzBR,aAAa,GAAKW,EAAOF,YAZrBT,aAAa,GAAKlP,KAAKkP,aAAa,GAAKlP,KAAKkP,aAAa,GAAKlP,KAAKkP,aAAa,GAAK,yBAepG,SAAQY,MACC9P,KAAKgP,aAIJe,EAAS/P,KAAK2O,QACdqB,EAAOD,EAAOE,wBACdzG,EAAIsG,EAAEI,QAAUF,EAAKG,KACrB/G,EAAI0G,EAAEM,QAAUJ,EAAKK,IAC3BP,EAAEQ,QAAU9G,EACZsG,EAAES,QAAUnH,EACZ0G,EAAEU,SAAWxQ,KAAKwQ,aAEdC,GAAS,KACTzQ,KAAK0Q,UACLD,EAASzQ,KAAK0Q,QAAQZ,IAGX,cAAXA,EAAEnR,UACG6R,UAAW,EAChBT,EAAOY,oBACH,YACA3Q,KAAKoP,wBAETvC,SAAS+D,KAAKrB,iBACV,YACAvP,KAAKoP,wBAETvC,SAAS+D,KAAKrB,iBACV,UACAvP,KAAKoP,6BAEN,GAAe,cAAXU,EAAEnR,UACJ8R,EAAQ,KACHrC,EAAS5E,EAAIxJ,KAAKiP,WAAW,GAC7BZ,EAASjF,EAAIpJ,KAAKiP,WAAW,GAC/BjP,KAAKwQ,eACAK,UAAUzC,EAAQC,QAGb,YAAXyB,EAAEnR,WACJ6R,UAAW,EAChB3D,SAAS+D,KAAKD,oBACV,YACA3Q,KAAKoP,wBAETvC,SAAS+D,KAAKD,oBACV,UACA3Q,KAAKoP,wBAETW,EAAOR,iBAAiB,YAAavP,KAAKoP,yBAE/B,eAAXU,EAAEnR,MACY,UAAXmR,EAAEnR,MACS,mBAAXmR,EAAEnR,OAELmR,EAAEgB,UAAY,aACC,UAAXhB,EAAEnR,KACFmR,EAAEiB,OAASjB,EAAEkB,OAEblB,EAAEiB,MAAyB,MAAjBjB,EAAEmB,YAAsBnB,EAAEmB,aAA0B,GAAZnB,EAAEoB,OAIpDpB,EAAEqB,WACFrB,EAAEsB,MAAQtB,EAAEqB,WAAa,GAClBrB,EAAEkB,OACTlB,EAAEsB,OAAStB,EAAEkB,OAAS,EAEtBlB,EAAEsB,MAAQ,OAETC,iBAAiB,EAAgB,IAAVvB,EAAEsB,oBAG7BnC,WAAW,GAAKzF,OAChByF,WAAW,GAAK7F,EAErB0G,EAAEwB,iBACFxB,EAAEyB,mBACK,kCAGX,SAAgBC,GACZA,EAAIhF,MAAMxM,KAAKwM,MAAOxM,KAAKwM,OAC3BgF,EAAIC,UAAUzR,KAAK+K,OAAO,GAAI/K,KAAK+K,OAAO,yCAG9C,SAAsB3L,SAEX,EACFA,EAAI,GAAKY,KAAK+K,OAAO,IAAM/K,KAAKwM,OAChCpN,EAAI,GAAKY,KAAK+K,OAAO,IAAM/K,KAAKwM,4CAIzC,SAAsBpN,EAAKyI,UACvBA,EAAMA,GAAO,CAAC,EAAG,IACb,GAAKzI,EAAI,GAAKY,KAAKwM,MAAQxM,KAAK+K,OAAO,GAC3ClD,EAAI,GAAKzI,EAAI,GAAKY,KAAKwM,MAAQxM,KAAK+K,OAAO,GACpClD,2BAGX,SAAU2B,EAAGJ,QACJ2B,OAAO,IAAMvB,EAAIxJ,KAAKwM,WACtBzB,OAAO,IAAM3B,EAAIpJ,KAAKwM,MAEvBxM,KAAK+O,eACAA,SAAS/O,iCAItB,SAAYgE,EAAO0N,MACX1N,EAAQhE,KAAK8O,UACb9K,EAAQhE,KAAK8O,UACN9K,EAAQhE,KAAK6O,YACpB7K,EAAQhE,KAAK6O,WAGb7K,IAAUhE,KAAKwM,OAIdxM,KAAK2O,aAIJqB,EAAOhQ,KAAK2O,QAAQsB,2BACrBD,GAIL0B,EAAgBA,GAAiB,CAChB,GAAb1B,EAAKR,MACS,GAAdQ,EAAKP,YAEHkC,EAAS3R,KAAK4R,sBAAsBF,QACrClF,MAAQxI,EACTgE,KAAK6J,IAAI7R,KAAKwM,MAAQ,GAAK,WACtBA,MAAQ,OAGXsF,EAAY9R,KAAK4R,sBAAsBF,GACvCK,EAAc,CAChBD,EAAU,GAAKH,EAAO,GACtBG,EAAU,GAAKH,EAAO,SAGrB5G,OAAO,IAAMgH,EAAY,QACzBhH,OAAO,IAAMgH,EAAY,GAE1B/R,KAAK+O,eACAA,SAAS/O,wCAItB,SAAiBgE,EAAO0N,QACfM,YAAYhS,KAAKwM,MAAQxI,EAAO0N,wBAGzC,gBACSlF,MAAQ,OACRzB,OAAO,GAAK,OACZA,OAAO,GAAK,eCxNJkH,wBAcL5I,OAAQvF,yDAAU,kBACrBA,QAAUA,MACToO,EAAOlS,KAGT8D,EAAQqO,aACJrO,EAAQqO,WAAW1R,cAAgBT,KAAKS,aACxCzB,QAAQ0N,MAAM,wDACd5I,EAAQqO,WAAa,YAEhBA,WAAarO,EAAQqO,gBACrBA,WAAWC,MAAO,OAClBD,WAAWE,gBAAkBrS,WAItCsS,EAAa,KACbxO,EAAQyO,QAAOD,EAAaxO,EAAQyO,MAAM9R,YAAYtB,MACvC,eAAfmT,GACkB,gBAAfA,GACe,iBAAfA,IAEHtT,QAAQ0N,MACJ,sFAEJ5I,EAAQyO,MAAQ,UAGdC,EAAO3F,SAASM,cAAc,gBA0C3BsF,EAAe3C,OACd1Q,EAAMsT,SAASF,EAAKG,MAAMtC,IAAK,WACrCmC,EAAKG,MAAMtC,eAAUjR,EAAM0Q,EAAEkB,OAASlN,EAAQ8O,cAAcC,gBAC5D/C,EAAEwB,kBACK,KA7CXkB,EAAKM,UAAY,8CACbhP,EAAQgP,YAAWN,EAAKM,sBAAiBhP,EAAQgP,YACrDN,EAAKG,MAAMI,SAAW,IACtBP,EAAKG,MAAMK,UAAY,IACvBR,EAAKG,MAAMM,cAAgB,OAC3BC,YAAW,WACPV,EAAKG,MAAMM,cAAgB,SAC5B,KAIHT,EAAKjD,iBAAiB,WAAW,SAACO,UAC9BA,EAAEwB,kBACK,KAEX,GACAkB,EAAKjD,iBACD,eACA,SAACO,UACoB,IAAbA,EAAEqD,QAINrD,EAAEwB,kBAFS,KAKf,GAGJkB,EAAKjD,iBACD,aACA,SAACO,MACoB,IAAbA,EAAEqD,cACFjB,EAAKkB,QACLtD,EAAEwB,kBACK,KAGf,GAUCxN,EAAQ8O,eAAc9O,EAAQ8O,aAAe,IAElDJ,EAAKjD,iBAAiB,QAASkD,GAAgB,GAC/CD,EAAKjD,iBAAiB,aAAckD,GAAgB,QAE/CD,KAAOA,EAGR1O,EAAQtE,MAAO,KACTmP,EAAU9B,SAASM,cAAc,OACvCwB,EAAQmE,UAAY,iBACpBnE,EAAQ0E,UAAYvP,EAAQtE,MAC5BgT,EAAKpF,YAAYuB,OAIhB,IAAIlQ,EAAI,EAAGA,EAAI4K,EAAOpH,OAAQxD,IAAK,KAChCU,EAAOkK,EAAO5I,cAAgB6S,MAAQjK,EAAO5K,GAAKA,EAClDU,GAAQA,EAAKsB,cAAgBC,SAC7BvB,OAAwBgK,IAAjBhK,EAAKoU,QAAwB7S,OAAOvB,GAAQA,EAAKoU,aAEtDvP,EAAQqF,EAAO5K,QAChB+U,QAAQrU,EAAM6E,EAAOF,GAI9B0O,EAAKjD,iBAAiB,cAAc,SAACO,GAC7BoC,EAAKE,OACLI,EAAKiB,eAAeC,aAAalB,EAAKiB,eAC1CjB,EAAKiB,cAAgBP,WAAWhB,EAAKkB,MAAM9D,KAAK4C,EAAMpC,GAAI,SAI9D0C,EAAKjD,iBAAiB,cAAc,SAACO,GAC7B0C,EAAKiB,eAAeC,aAAalB,EAAKiB,sBAI1CE,EAAe9G,SACf/I,EAAQyO,QACRoB,EAAe7P,EAAQyO,MAAMnU,OAAOwV,eAGnCD,IACDA,EAAe9G,UAGf8G,EAAaE,kBACbF,EAAaE,kBAAkBzG,YAAYoF,GAE3CmB,EAAa/C,KAAKxD,YAAYoF,OAI9BrC,EAAOrM,EAAQqM,MAAQ,EACvBE,EAAMvM,EAAQuM,KAAO,KACrBvM,EAAQyO,MAAO,IACfpC,EAAOrM,EAAQyO,MAAMrC,QAAU,GAC/BG,EAAMvM,EAAQyO,MAAMnC,QAAU,GAC1BtM,EAAQtE,QAAO6Q,GAAO,IAEtBvM,EAAQqO,WAAY,KACdnC,EAAOlM,EAAQqO,WAAWK,KAAKvC,wBACrCE,EAAOH,EAAKG,KAAOH,EAAKR,UAGtBsE,EAAWjH,SAAS+D,KAAKX,wBACzB8D,EAAWvB,EAAKvC,wBACE,IAApB6D,EAASrE,QAAczQ,QAAQ0N,MAAM,iFAErCoH,EAAStE,OAASW,EAAO2D,EAAStE,MAAQuE,EAASvE,MAAQ,KAC3DW,EAAO2D,EAAStE,MAAQuE,EAASvE,MAAQ,IAEzCsE,EAASrE,QAAUY,EAAMyD,EAASrE,OAASsE,EAAStE,OAAS,KAC7DY,EAAMyD,EAASrE,OAASsE,EAAStE,OAAS,IAIlD+C,EAAKG,MAAMxC,eAAUA,QACrBqC,EAAKG,MAAMtC,cAASA,QAEhBvM,EAAQ0I,QAAOgG,EAAKG,MAAMqB,0BAAqBlQ,EAAQ0I,6CAG/D,SAAQrN,EAAM6E,OAAOF,yDAAU,GACrBoO,EAAOlS,KAEP2O,EAAU9B,SAASM,cAAc,OACvCwB,EAAQmE,UAAY,6BAEhBmB,GAAW,WA2BNC,EAAWpE,OACR9L,EAAUhE,KAAVgE,MACHA,GAAUA,EAAMmQ,aAErBC,EAAcxU,KAAKI,KAAM8P,YAIpBsE,EAActE,OACX9L,EAAUhE,KAAVgE,MACJqQ,GAAc,GAEdnC,EAAKG,iBAAiBH,EAAKG,gBAAgBe,MAAMtD,GAGjDhM,EAAQmF,aASE,IARAnF,EAAQmF,SAASrJ,KACvBI,KACAgE,EACAF,EACAgM,EACAoC,EACApO,EAAQgB,QAEIuP,GAAc,OAI9BrQ,EAAO,IAEHA,EAAMiF,WACFnF,EAAQwQ,wBACU,IAAnBtQ,EAAMiQ,UAWC,IARAjQ,EAAMiF,SAASrJ,KACrBI,KACAgE,EACAF,EACAgM,EACAoC,EACApO,EAAQyQ,SAEIF,GAAc,MAE9BrQ,EAAMwQ,QAAS,KACVxQ,EAAMwQ,QAAQ1Q,cACT,IAAI2Q,MAAM,qCAEJ,IAAIvC,EAAKzR,YAAYuD,EAAMwQ,QAAQ1Q,QAAS,CACxDmF,SAAUjF,EAAMwQ,QAAQvL,SACxBsJ,MAAOzC,EACPqC,WAAYD,EACZoC,sBACAtQ,EAAMwQ,QAAQF,sBACd9U,MAAOwE,EAAMwQ,QAAQhV,MACrB+U,MAAOvQ,EAAMwQ,QAAQD,MACrBG,SAAU5Q,EAAQ4Q,WAEtBL,GAAc,GAIlBA,IAAgBnC,EAAKE,MAAMF,EAAKkB,eAxF1B,OAAVpP,EAAgB2K,EAAQgG,UAAUC,IAAI,cAEtCjG,EAAQ0E,UAAYrP,GAASA,EAAMxE,MAAQwE,EAAMxE,MAAQL,EACzDwP,EAAQ3K,MAAQA,EAEZA,IACIA,EAAMiQ,WACNA,GAAW,EACXtF,EAAQgG,UAAUC,IAAI,cAEtB5Q,EAAMwQ,SAAWxQ,EAAMmQ,cAAaxF,EAAQgG,UAAUC,IAAI,gBAG7C,mBAAV5Q,GACP2K,EAAQkG,QAAQ7Q,MAAQ7E,EACxBwP,EAAQmG,iBAAmB9Q,GACxB2K,EAAQkG,QAAQ7Q,MAAQA,EAE3BA,EAAM8O,YAAWnE,EAAQmE,sBAAiB9O,EAAM8O,kBAGnDN,KAAKpF,YAAYuB,GACjBsF,GAAUtF,EAAQY,iBAAiB,QAAS6E,GAC7CtQ,EAAQ4Q,UAAU/F,EAAQY,iBAAiB,aAAc2E,GAoEtDvF,uBAGX,SAAMmB,EAAGiF,GACD/U,KAAKwS,KAAKwC,iBACLxC,KAAKwC,WAAW3H,YAAYrN,KAAKwS,MAEtCxS,KAAKmS,aAAe4C,SACf5C,WAAWC,MAAO,OAClBD,WAAWE,gBAAkB,UACxBlJ,IAAN2G,EAAiB9P,KAAKmS,WAAWiB,QAC5BtD,IAAMmC,EAAYgD,oBAAoBnF,EAAG9P,KAAKmS,WAAWK,OAC9DP,EAAYiD,QAAQlV,KAAKmS,WAAWK,KAAM,aAAc1C,IAG5D9P,KAAKqS,iBAAiBrS,KAAKqS,gBAAgBe,MAAMtD,GAAG,GAEpD9P,KAAKwS,KAAKiB,eAAeC,aAAa1T,KAAKwS,KAAKiB,2DAgBhDzT,KAAK8D,QAAQqO,WAAmBnS,KAAK8D,QAAQqO,WAAWgD,aACrDnV,kCAGX,kBACQA,KAAK8D,QAAQqO,WAAmBnS,KAAK8D,QAAQqO,WAAWiD,gBACrDpV,KAAK8D,QAAQyO,+BAlBxB,SAAe5D,EAAS0G,EAAWC,EAAQC,OACjCC,EAAM3I,SAAS4I,YAAY,sBACjCD,EAAIE,gBAAgBL,GAAW,GAAM,EAAMC,GAC3CE,EAAIpX,OAASmX,EACT5G,EAAQgH,cAAehH,EAAQgH,cAAcH,GACxC7G,EAAQiH,UAAUjH,EAAQiH,SAASD,cAAcH,GAEnDA,sCAcX,eAA4BK,yDAAaC,OAC/BC,EAAWF,EAAWhJ,SAASmJ,iBAAiB,uBACjDD,EAAS9T,cAIRZ,EAAS,OACE0U,uCAANE,UAAgB5U,EAAOL,KAAKiV,gDACtB5U,iBAAQ,KAAd6U,OACHA,EAAG9C,MAAO8C,EAAG9C,QACR8C,EAAGlB,YAAYkB,EAAGlB,WAAW3H,YAAYhM,EAAO5C,yCAIjE,SAA2B8T,EAAO5D,OACxBwB,EAAOoC,EAAMrC,QACbG,EAAMkC,EAAMnC,QACZJ,EAAOrB,EAAQsB,gCAChBD,IACEK,EAAML,EAAKK,KACXA,EAAML,EAAKK,IAAML,EAAKP,QACtBU,EAAOH,EAAKG,MACZA,EAAOH,EAAKG,KAAOH,EAAKR,gBC5UhC,SAAS1F,EAAkBN,EAAGJ,EAAG+G,EAAME,EAAKb,EAAOC,UAC/CU,EAAO3G,GAAK2G,EAAOX,EAAQhG,GAAK6G,EAAMjH,GAAKiH,EAAMZ,EAASrG,EAI9D,SAAS+E,EAAgBgI,EAAG5H,OACzB6H,EAAQD,EAAE,GAAKA,EAAE,GACjBE,EAAQF,EAAE,GAAKA,EAAE,GACjBG,EAAQ/H,EAAE,GAAKA,EAAE,GACjBgI,EAAQhI,EAAE,GAAKA,EAAE,WAEd4H,EAAE,GAAKG,GACTH,EAAE,GAAKI,GACPH,EAAQ7H,EAAE,IACV8H,EAAQ9H,EAAE,ICTrB,IAAMiI,EAAO,IAAIpU,aAAa,GACxBqU,EAAU,IAAIrU,aAAa,GAC3BsU,EAAW,IAAItU,aAAa,GAC5BuU,EAAa,IAAIvU,aAAa,GAC9BwU,EAAe,IAAIxU,aAAa,GAChCyU,EAAQ,IAAIzU,aAAa,GACzB0U,EAAQ,IAAI1U,aAAa,GAEVoL,wBAaLuC,EAAQxN,OAAOuB,yDAAU,qCAm7IrB,SAAUyO,cAChBL,EAAOlS,KACPuM,EAAciB,EAAauJ,cACzBhH,EAAWxD,EAAXwD,OACF4D,EAAe5D,EAAO6D,eAAiB/G,SAEvCmK,EAASnK,SAASM,cAAc,OACtC6J,EAAOlE,UAAY,8CACnBkE,EAAO3D,UAAY,kHACnB2D,EAAO5D,MAAQ,WACXrH,EAAKkL,WAAa,KAClBtD,EAAa/C,KAAKsG,QAClBvD,EAAa/C,KAAK+B,MAAMwE,SAAW,GAEnCjE,YAAW,WACPnH,EAAKgE,OAAOmH,UACb,IACCF,EAAOhC,YACPgC,EAAOhC,WAAW3H,YAAY2J,QAIlCI,EAAe,KAEfpX,KAAKqX,GAAG7K,MAAQ,IAAGwK,EAAOrE,MAAMqB,0BAAqBhU,KAAKqX,GAAG7K,YAEjEwK,EAAOzH,iBAAiB,cAAc,WAC9B6H,IACA1D,aAAa0D,GACbA,EAAe,SAIvBJ,EAAOzH,iBAAiB,cAAc,WAElC6H,EAAelE,YAAW,kBAAM8D,EAAO5D,UAAS,QAGhDpT,KAAKiX,YAAYjX,KAAKiX,WAAW7D,aAChC6D,WAAaD,MAEZM,EAASN,EAAOO,cAAc,WAEhCC,EAAQ,KACRC,EAAU,KACVC,EAAW,KAETnU,EAAQyT,EAAOO,cAAc,SAC/BhU,IACAA,EAAMgM,iBAAiB,QAAQ,kBAAMhM,EAAM2T,WAC3C3T,EAAMgM,iBAAiB,WAAW,SAACO,MACb,KAAdA,EAAE6H,QAEFC,GAAgB,QACb,GAAkB,KAAd9H,EAAE6H,QAETC,GAAgB,QACb,GAAkB,KAAd9H,EAAE6H,QAETX,EAAO5D,YACJ,CAAA,GAAkB,KAAdtD,EAAE6H,eASLF,GACAI,cAAcJ,QAElBA,EAAUvE,WAAW4E,EAAe,KAXhCJ,EACAK,EAAOL,EAASrE,WACTmE,EACPO,EAAOP,GAEPR,EAAO5D,eASftD,EAAEwB,iBACFxB,EAAEyB,kBACFzB,EAAEkI,4BACK,MAIXrE,EAAaE,kBAAmBF,EAAaE,kBAAkBzG,YAAY4J,IAE3ErD,EAAa/C,KAAKxD,YAAY4J,GAC9BrD,EAAa/C,KAAK+B,MAAMwE,SAAW,cAIjCnH,EAAOD,EAAOE,wBAEdE,GAAQoC,EAAQA,EAAMrC,QAAWF,EAAKG,KAAoB,GAAbH,EAAKR,OAAgB,GAClEa,GAAOkC,EAAQA,EAAMnC,QAAWJ,EAAKK,IAAoB,GAAdL,EAAKP,QAAiB,YAW9DsI,EAAO5Y,MACRA,KACI+S,EAAK+F,qBACL/F,EAAK+F,qBAAqB9Y,EAAMoT,EAAOhG,OACpC,KACGgI,EAAQxV,EAActB,iBAAiB0B,EAAKwB,eAC9C4T,IACApV,EAAOoV,EAAM5V,MAGjB4N,EAAYhK,MAAM8H,mBACZvF,EAAO3C,EAAW4C,WAAW5F,MAC/B2F,IACAA,EAAK1F,IAAMmN,EAAY2L,2BACnB3F,GAEJhG,EAAYhK,MAAMqS,IAAI9P,IAGtByP,GAASA,EAAMvP,KAAM,IACjBuP,EAAMvP,KAAKpC,eAEN,IAAMnE,KAAK8V,EAAMvP,KAAKpC,WACvBkC,EAAKqT,YAAY1Z,EAAG8V,EAAMvP,KAAKpC,WAAWnE,OAG9C8V,EAAMvP,KAAKvC,WAGN,IAAMhE,KAFXqG,EAAKrC,OAAS,GAEE8R,EAAMvP,KAAKvC,OACvBqC,EAAKsT,UACD7D,EAAMvP,KAAKvC,OAAOhE,GAAG,GACrB8V,EAAMvP,KAAKvC,OAAOhE,GAAG,OAI7B8V,EAAMvP,KAAKtC,YAGN,IAAMjE,KAFXqG,EAAKpC,QAAU,GAEC6R,EAAMvP,KAAKtC,QACvBoC,EAAKsT,UACD7D,EAAMvP,KAAKtC,QAAQjE,GAAG,GACtB8V,EAAMvP,KAAKtC,QAAQjE,GAAG,IAI9B8V,EAAMvP,KAAKxF,QAAOsF,EAAKtF,MAAQ+U,EAAMvP,KAAKxF,OAC1C+U,EAAMvP,KAAKqT,MAAMvT,EAAK3B,UAAUoR,EAAMvP,KAAKqT,MAE/C9L,EAAYhK,MAAMmI,eAK9BsM,EAAO5D,iBAGFwE,EAAgBU,OACf7Y,EAAOiY,EACTA,GAAUA,EAAS/C,UAAU4D,OAAO,YACnCb,GAKDA,EAAWY,EACLZ,EAASc,YACTd,EAASe,mBACAf,EAAWjY,GAP1BiY,EAAWY,EACLhB,EAAOoB,WAAW,GAClBpB,EAAOoB,WAAWpB,EAAOoB,WAAWzW,QAOzCyV,IACLA,EAAS/C,UAAUC,IAAI,YACvB8C,EAASiB,eAAe,CACpBC,MAAO,MACPC,SAAU,qBAITf,IACLL,EAAU,SACNqB,EAAMvV,EAAMS,SAChBwT,EAAQ,KACRF,EAAOjE,UAAY,GACdyF,KAED5G,EAAK6G,YAAa,KACZ9M,EAAOiG,EAAK6G,YAAYzB,EAAQwB,EAAKvM,MACvCN,EAAM,WACUA,mCAAM+M,gDAEvB,KACC9M,EAAI,EACR4M,EAAMA,EAAInY,kBACJI,EAASwL,EAAYxL,QAAUwL,EAAYhK,MAAMxB,WAIlD,IAAMtC,KAAKM,EAActB,iBAAkB,KACtC8W,EAAQxV,EAActB,iBAAiBgB,OACE,IAA3C8V,EAAM0E,KAAKtY,cAAcmB,QAAQgX,QAG/BI,EAAOna,EAAc1B,sBAAsBkX,EAAM5V,WACnDua,GAAQA,EAAKnY,SAAWA,KAC5BiY,EAAUzE,EAAM0E,KAAM,oBACa,IAA/BzL,EAAa2L,cAAuBjN,IAAMsB,EAAa2L,+BAKlDzZ,OAAO0Z,KAAKra,EAAc1B,uBACjB0D,QAAO,SAACpC,OACpBua,EAAOna,EAAc1B,sBAAsBsB,WAC7CoC,GAAUmY,EAAKnY,SAAWA,KACc,IAArCpC,EAAKgC,cAAcmB,QAAQgX,sCAGD,IACjCE,YACmC,IAA/BxL,EAAa2L,cAAuBjN,IAAMsB,EAAa2L,4DAM1DH,EAAUra,EAAMmU,OACfuG,EAAOxM,SAASM,cAAc,OAC/BqK,IAAOA,EAAQ7Y,GACpB0a,EAAKC,UAAY3a,EACjB0a,EAAKxE,QAAQlW,KAAO4a,OAAO5a,GAC3B0a,EAAKvG,UAAY,6BACbA,IAAWuG,EAAKvG,sBAAiBA,IACrCuG,EAAK9J,iBAAiB,SAAS,WAC3BwI,EAAOyB,SAASH,EAAKxE,QAAQlW,UAEjC2Y,EAAOlK,YAAYiM,WAjJ3BrC,EAAOrE,MAAMxC,eAAUA,QACvB6G,EAAOrE,MAAMtC,cAASA,QAGlBkC,EAAMkH,OAAUzJ,EAAKP,OAAS,MAC9B6H,EAAO3E,MAAM+G,oBAAe1J,EAAKP,OAAS8C,EAAMkH,OAAS,UAG7DlW,EAAM2T,QA6ICF,iCAuRS,SAAUlS,GAC1BgR,OAAO6D,cAAgB7U,MACnB8U,EAAQ/M,SAAS0K,cAAc,eAC/BqC,GAAOA,EAAMxG,YACXyG,EAAY7Z,KAAK8Z,mBACvBF,EAAQ5Z,KAAK+Z,YAAYjV,EAAKtF,OAAS,GAAI,CACvCwa,UAAU,EACVlE,OAAQ+D,KAENrX,GAAK,aACXoX,EAAM9U,KAAOA,EACb8U,EAAMjF,UAAUC,IAAI,gBAEdrI,EAAcvM,MAEE,eAMb,IAAMvB,KALXmb,EAAMrG,QAAQF,UAAY,GAC1BuG,EAAMK,0CAAmCnV,EAAKnG,+CAAsCmG,EAAKrE,YAAYwY,MAAQ,8CAE7GW,EAAMK,QAAQ,uBAEEnV,EAAKlC,WAAY,KACvBoB,EAAQc,EAAKlC,WAAWnE,GACxBuE,EAAO8B,EAAKoV,gBAAgBzb,GAE9BqG,EAAKqV,sBAAwBrV,EAAKqV,qBAAqB1b,EAAGmb,IAE9DA,EAAMQ,UAAUpX,EAAKa,QAAUb,EAAKrE,KAAMF,EAAGuF,EAAOhB,GAAM,SAAC7D,EAAM6E,GAC7DuI,EAAYhK,MAAM8H,aAAavF,GAC/BA,EAAKuV,YAAYlb,EAAM6E,GACvBuI,EAAYhK,MAAMmI,cAClB6B,EAAY+N,cAAe,KAInCV,EAAMW,eAEFzV,EAAK0V,uBAAuB1V,EAAK0V,sBAAsBZ,GAC3DA,EAAMa,UAAU,UAAU,WAClB3V,EAAK4V,eACT5V,EAAKvC,MAAMgW,OAAOzT,GAClB8U,EAAMxG,YAELuB,UACAC,IAAI,UAgCb+F,QAEK5K,OAAOiF,WAAW5H,YAAYwM,WAvgK9BgB,iBAAmBpN,EAAaqN,yBAEjC9K,GAAUA,EAAOtP,cAAgBC,SACjCqP,EAASlD,SAAS0K,cAAcxH,SAG/BsH,GAAK,IAAI3I,OACToM,mBAAoB,OAGpBC,0BAAqBhc,EAAc7E,gCACnC8gB,iCAA4Bjc,EAAc3E,mCAC1C6gB,iBAAmBlc,EAAc/E,sBACjCkhB,mBAAqBnc,EAAc/D,gBACnCmgB,yBAA2B,CAC5BC,UAAW,OACXC,SAAU,OACVC,WAAY,OACZC,UAAW,aAGVC,oBAAqB,OACrBC,eAAgB,OAChBC,aAAe,OACfC,iBAAkB,OAClBC,kBAAmB,OAEnBC,WAAY,OACZC,sBAAuB,OACvBC,WAAY,OACZC,WAAY,OACZC,kBAAmB,OACnBC,iBAAkB,OAClBC,mBAAoB,OACpBC,iBAAkB,OAClBC,uBAAwB,OAGxBC,WAAY,OACZC,mBAAqB,UAErBxb,OAAS,UAETyb,iCAAkC,OAElCC,0BAA2B,OAC3BC,gBAAiB,OACjBC,sBAAuB,OACvBC,4BAA6B,OAC7BC,2BAA4B,OAC5BC,2BAA4B,OAC5BC,0BAA2B,OAC3BC,wBAAyB,OACzBC,wBAAyB,OACzBC,sBAAuB,OACvBC,qBAAsB,OAEtBC,kBAAoBre,EAAcrC,iBAElC2gB,MAAQ,CAAC,EAAG,QAEZC,YAAc,CAAC,EAAG,QAElBC,aAAevd,KAAKsd,iBAGpBvE,YAAc,UACdd,qBAAuB,UAGvB5I,QAAU,UACVmO,iBAAmB,UAEnBC,iBAAmB,UAEnBC,cAAgB,UAEhBC,kBAAoB,UACpBC,YAAc,UACdC,kBAAoB,UACpBC,mBAAqB,UACrBC,eAAiB,UACjBC,cAAgB,UAEhBC,kBAAoB,OACpBC,aAAe,OAEfC,aAAe,UACfC,YAAc,UACdC,iBAAmB,UACnBC,oBAAsB,CAAC,EAAG,QAC1BpP,aAAelP,KAAKqX,GAAGnI,kBACvBqP,cAAgB,GAGjBhc,GACAA,EAAMic,aAAaxe,WAGlBye,UAAU1O,QACV2O,QAEA5a,EAAQ6a,kBACJC,sBAGJC,WAAa/a,EAAQ+a,0DAmBrBC,MAAQ,OACRC,eAAiB,OACjBC,YAAc,OACdC,IAAM,OAKN1C,mBAAqB,UAErB2C,eAAiB,QACjBC,eAAiB,UAEjBC,cAAgB,QAChBC,aAAe,UACfC,UAAY,UACZnT,qBAAuB,UACvBoT,gBAAkB,UAClBC,kBAAoB,QAEpBC,iBAAkB,OAElBnF,cAAe,OACfoF,gBAAiB,OACjBC,WAAa,UAEbC,cAAgB,UAChBxB,YAAc,UAEdnP,WAAa,CAAC,EAAG,QACjB4Q,gBAAkB,OAClB3Q,aAAapP,IAAI,CAAC,EAAG,EAAG,EAAG,IAE5BE,KAAK8f,SAAS9f,KAAK8f,kCAU3B,SAASvd,EAAOwd,GACR/f,KAAKuC,QAAUA,IAIdwd,GAAW/f,KAAK0e,QAEhBnc,IAASvC,KAAKuC,OAKnBA,EAAMic,aAAaxe,MAGfA,KAAKggB,eAAchgB,KAAKggB,aAAe,WAEtCC,UAAS,GAAM,SATX1d,MAAM2d,aAAalgB,kCAkBhC,kBACQA,KAAKggB,aAAa/d,OAAejC,KAAKggB,aAAa,GAChDhgB,KAAKuC,kCAShB,SAAaA,OACJA,QACK,IAAIkS,MAAM,2BAGhBzU,KAAKuC,QAAUA,QACT,IAAIkS,MAAM,iCAGfiK,QAED1e,KAAKuC,QACAvC,KAAKggB,oBACDA,aAAe,SAEnBA,aAAahf,KAAKhB,KAAKuC,QAGhCA,EAAMic,aAAaxe,WACdmgB,mBACAF,UAAS,GAAM,gCAQxB,cACSjgB,KAAKggB,cAA6C,IAA7BhgB,KAAKggB,aAAa/d,YAGtCme,EAAepgB,KAAKuC,MAAM8d,eAC1B9d,EAAQvC,KAAKggB,aAAaM,WAC3BpB,eAAiB,QACjBM,kBAAoB,GACzBjd,EAAMic,aAAaxe,WACdigB,UAAS,GAAM,GAChBG,SACKG,aAAaH,QACbI,YAAY,CAACJ,qCAS1B,kBACWpgB,KAAKuC,+BAWhB,SAAUwN,EAAQnB,uBACVmB,wBAAQtP,eAAgBC,UACxBqP,EAASlD,SAAS4T,eAAe1Q,UAEvB,IAAI0E,MAAM,wDAIpB1E,IAAW/P,KAAK+P,UAIfA,GAAU/P,KAAK+P,SAEXnB,QACI8R,qBAIR3Q,OAASA,OACTsH,GAAG1I,QAAUoB,EAEbA,OAGLA,EAAO+C,WAAa,gBACpB/C,EAAO/K,KAAOhF,KACd+P,EAAO4Q,SAAW,SAGbC,SAAW,UACXA,SAAW/T,SAASM,cAAc,eAClCyT,SAASpR,MAAQxP,KAAK+P,OAAOP,WAC7BoR,SAASnR,OAASzP,KAAK+P,OAAON,OAET,OAAtBM,EAAO8Q,WAAqB,IACH,WAArB9Q,EAAO+Q,gBACD,IAAIrM,2FACN1E,EAAO+Q,kBAET,IAAIrM,MAAM,4CAGfjD,IAAMzB,EAAO8Q,WAAW,MACb,MAAZ7gB,KAAKwR,MACAzB,EAAOgR,eACR/hB,QAAQsB,KACJ,+DAGH0gB,oBAIJC,oBAAsBjhB,KAAKkhB,iBAAiB5R,KAAKtP,WACjDmhB,kBAAoBnhB,KAAKohB,eAAe9R,KAAKtP,MAE7C4O,GAAY5O,KAAKmP,wCAG1B,SAAWW,UACPA,EAAEwB,kBACK,+BAGX,SAAcxB,UACVA,EAAEwB,kBACK,4BAOX,cACQtR,KAAKqhB,eACLriB,QAAQsB,KAAK,gDAITyP,EAAW/P,KAAX+P,OAGAlD,EADU7M,KAAK8Z,kBACfjN,cAEHyU,oBAAsBthB,KAAKuhB,iBAAiBjS,KAAKtP,WACjDwhB,qBAAuBxhB,KAAKyhB,kBAAkBnS,KAAKtP,MAExD+P,EAAOR,iBAAiB,YAAavP,KAAKshB,qBAAqB,GAE/DvR,EAAOR,iBAAiB,YAAavP,KAAKihB,qBAC1ClR,EAAOR,iBAAiB,aAAcvP,KAAKwhB,sBAE3CzR,EAAOR,iBAAiB,cAAevP,KAAK0hB,YAC5C3R,EAAOR,iBAAiB,iBAAkBvP,KAAKwhB,sBAE/CzR,EAAOR,iBAAiB,aAAcvP,KAAK2hB,cAAc,GACzD5R,EAAOR,iBAAiB,YAAavP,KAAK2hB,cAAc,GACxD5R,EAAOR,iBAAiB,WAAYvP,KAAK2hB,cAAc,GACvD5R,EAAOR,iBAAiB,cAAevP,KAAK2hB,cAAc,QAGrDC,cAAgB5hB,KAAK6hB,WAAWvS,KAAKtP,MAE1C+P,EAAOR,iBAAiB,UAAWvP,KAAK4hB,eAAe,GACvD/U,EAAS0C,iBAAiB,QAASvP,KAAK4hB,eAAe,QAIlDE,iBAAmB9hB,KAAK+hB,YAAYzS,KAAKtP,MAE9C+P,EAAOR,iBAAiB,WAAYvP,KAAK0hB,YAAY,GACrD3R,EAAOR,iBAAiB,UAAWvP,KAAK0hB,YAAY,GACpD3R,EAAOR,iBAAiB,OAAQvP,KAAK8hB,kBAAkB,GACvD/R,EAAOR,iBAAiB,YAAavP,KAAKgiB,eAAe,QAEpDX,gBAAiB,+BAO1B,cACSrhB,KAAKqhB,oBAMFxU,EADU7M,KAAK8Z,kBACfjN,cAEHkD,OAAOY,oBAAoB,YAAa3Q,KAAKshB,0BAC7CvR,OAAOY,oBACR,aACA3Q,KAAKwhB,2BAEJzR,OAAOY,oBACR,iBACA3Q,KAAKwhB,2BAEJzR,OAAOY,oBAAoB,UAAW3Q,KAAK4hB,eAChD/U,EAAS8D,oBAAoB,QAAS3Q,KAAK4hB,oBACtC7R,OAAOY,oBAAoB,cAAe3Q,KAAK0hB,iBAC/C3R,OAAOY,oBAAoB,OAAQ3Q,KAAK8hB,uBACxC/R,OAAOY,oBAAoB,YAAa3Q,KAAKgiB,oBAE7CjS,OAAOY,oBAAoB,aAAc3Q,KAAK2hB,mBAC9C5R,OAAOY,oBAAoB,YAAa3Q,KAAK2hB,mBAC7C5R,OAAOY,oBAAoB,WAAY3Q,KAAK2hB,mBAC5C5R,OAAOY,oBAAoB,cAAe3Q,KAAK2hB,mBAE/CL,oBAAsB,UACtBE,qBAAuB,UACvBI,cAAgB,UAChBE,iBAAmB,UAEnBT,gBAAiB,OAhClBriB,QAAQsB,KAAK,6DAyCrB,eACS2hB,GAAI,MAAM,IAAIxN,MAAM,wDACpByN,kBAAmB,MAAM,IAAIzN,MAAM,4DAEnCjD,IAAM0Q,kBAAkBliB,KAAK+P,aAC7BoS,GAAKniB,KAAKwR,SACVA,IAAI4Q,OAAQ,OACZxB,SAAW5gB,KAAK+P,YAChBsS,MAAQriB,KAAKmiB,QACbpS,OAAOgR,eAAgB,0BAWhC,SAASuB,EAAU1B,GACX0B,IAAUtiB,KAAKsa,cAAe,GAC9BsG,IAAU5gB,KAAK0f,gBAAiB,kCASxC,kBACS1f,KAAK+P,OACE/P,KAAK+P,OAAO6D,cACb2O,YAFczM,qCAU7B,WACQ9V,KAAKwiB,oBAEJA,cAAe,OACfC,0CAQT,WACSziB,KAAK2b,iBAAiB3b,KAAK0iB,WAE1B5M,EAAS9V,KAAK8Z,kBAChB9Z,KAAKwiB,cAAc1M,EAAO6M,sBAAsB3iB,KAAKyiB,0CAQ7D,gBACSD,cAAe,4BAUxB,gBACSI,aAAc,OACd/C,gBAAkB,kCAG3B,SAAiB/P,iBACT9P,KAAKwc,kCAAiCxc,KAAKsa,cAAe,GAEzDta,KAAKuC,YAELsgB,iBAAiB/S,OAEhB+J,EAAY7Z,KAAK8Z,kBACvBtM,EAAauJ,cAAgB/W,UAGxB+P,OAAOY,oBAAoB,YAAa3Q,KAAKihB,qBAClDpH,EAAUhN,SAAS0C,iBAAiB,YAAavP,KAAKihB,qBAAqB,GAC3EpH,EAAUhN,SAAS0C,iBAAiB,UAAWvP,KAAKmhB,mBAAmB,OAEjErc,EAAO9E,KAAKuC,MAAMugB,aAAahT,EAAEiT,QAASjT,EAAEkT,QAAShjB,KAAKof,cAAe,GAC3E6D,GAAa,EAEXC,EADMvlB,IACgBqC,KAAK6f,gBAAkB,YAC9CxC,MAAM,GAAKvN,EAAEqT,YACb9F,MAAM,GAAKvN,EAAEsT,YACb9F,YAAY,GAAKxN,EAAEiT,aACnBzF,YAAY,GAAKxN,EAAEkT,aACnBK,oBAAsB,CAACrjB,KAAKqd,MAAM,GAAIrd,KAAKqd,MAAM,SAEjDtN,OAAOmH,QAEZjF,EAAYqR,qBAAqBzJ,IAE7B7Z,KAAKqP,UACDrP,KAAKqP,QAAQS,OAIL,IAAZA,EAAEyT,MAAa,CACXzT,EAAE0T,eACGjH,mBAAqB,IAAIna,aAAa,QACtCma,mBAAmB,GAAKzM,EAAEiT,aAC1BxG,mBAAmB,GAAKzM,EAAEkT,aAC1BzG,mBAAmB,GAAK,OACxBA,mBAAmB,GAAK,EAC7B0G,GAAa,OAGbQ,GAAmB,KAInB3e,GAAQ9E,KAAKmc,oBAAsB8G,IAAejjB,KAAK6b,UAAW,IAC7D7b,KAAK+b,WAAcjX,EAAKhC,MAAMwJ,aAC1BoX,aAAa5e,IAIjB9E,KAAKuf,kBAAoBza,EAAKhC,MAAM+G,YAAc7J,KAAK+b,cAEnDkH,IACiB,IAAnBne,EAAK6e,WACL7Z,EACCgG,EAAEiT,QACFjT,EAAEkT,QACFle,EAAK1F,IAAI,GAAK0F,EAAKxC,KAAK,GAAK,EAC7BwC,EAAK1F,IAAI,GAAK0F,EAAKxC,KAAK,GAAK,EAC7B,WAGKC,MAAM8H,oBACNuZ,cAAgB9e,OAChBiL,OAAO4C,MAAMkR,OAAS,YAC3BZ,GAAa,MACV,IAECne,EAAKpC,YACA,IAAIjE,EAAI,EAAGyH,EAAIpB,EAAKpC,QAAQT,OAAQxD,EAAIyH,EAAGzH,IAAK,KAC3CkF,EAASmB,EAAKpC,QAAQjE,GACtBqlB,EAAUhf,EAAKmF,kBAAiB,EAAOxL,MACzCqL,EACAgG,EAAEiT,QACFjT,EAAEkT,QACFc,EAAQ,GAAK,GACbA,EAAQ,GAAK,GACb,GACA,IACD,MACMvE,gBAAkBza,OAClBif,kBAAoBpgB,OACpBqgB,eAAiBlf,EAAKmF,kBAAiB,EAAOxL,QAC9CwlB,gBAAkBxlB,EACnBqR,EAAEoU,UACFpf,EAAKwC,iBAAiB7I,GAGtBykB,EACIpe,EAAKqf,kBACLrf,EAAKqf,iBAAiB1lB,EAAGqR,GAEtBhL,EAAKsf,eACZtf,EAAKsf,cAAc3lB,EAAGqR,GAG1BmT,GAAa,YAOrBne,EAAKrC,WACA,IAAIhE,EAAI,EAAGyH,EAAIpB,EAAKrC,OAAOR,OAAQxD,EAAIyH,EAAGzH,IAAK,KAC1C8E,EAAQuB,EAAKrC,OAAOhE,GACpBqlB,EAAUhf,EAAKmF,kBAAiB,EAAMxL,MACxCqL,EACAgG,EAAEiT,QACFjT,EAAEkT,QACFc,EAAQ,GAAK,GACbA,EAAQ,GAAK,GACb,GAAI,MAEAZ,EACIpe,EAAKuf,iBACLvf,EAAKuf,gBAAgB5lB,EAAGqR,GAErBhL,EAAKwf,cACZxf,EAAKwf,aAAa7lB,EAAGqR,GAGN,OAAfvM,EAAMG,MAAe,KACfF,EAAWxD,KAAKuC,MAAMkB,MACxBF,EAAMG,MAEVoB,EAAK4C,gBAAgBjJ,IAGjBuB,KAAKqc,uBACFvM,EAAEoU,iBAEA3E,gBAAkBvf,KAAKuC,MAAMgiB,aAC9B/gB,EAASiC,gBAERwe,gBAAkBzgB,EAASmC,iBAC3Boe,kBAAoB/jB,KAAKuf,gBAAgB7c,QAC1C1C,KAAKikB,sBAGJD,eAAiBhkB,KAAKuf,gBACtBtV,kBAAiB,EAAOjK,KAAKikB,uBAGjCvE,gBAAiB,EACtBuD,GAAa,QAShCA,EAAY,KACTuB,GAAgB,EACdplB,EAAM,CAAC0Q,EAAEiT,QAAUje,EAAK1F,IAAI,GAAI0Q,EAAEkT,QAAUle,EAAK1F,IAAI,IAGrDyE,EAAS7D,KAAKykB,mBAAmB3f,EAAM9E,KAAKsd,YAAaxN,GAC3DjM,IACA2gB,GAAgB,OACXpG,YAAc,CAACtZ,EAAMjB,IAI1Bqf,GAAiBljB,KAAKkf,eAAepa,EAAKtC,MAEtCsC,EAAK4f,YACL5f,EAAK4f,WAAW5U,EAAG1Q,EAAKY,WAEvB2kB,sBAAsB7f,GAC3B0f,GAAgB,GAIhB1f,EAAK8f,aAAe9f,EAAK8f,YAAY9U,EAAG1Q,EAAKY,MAC7CwkB,GAAgB,GAGZ1f,EAAK+f,WAAa/f,EAAKggB,uBAClBhgB,EAAKhC,MAAM+G,WAAazK,EAAI,GAC3B0F,EAAKxC,KAAK,GAAKvD,EAAcvF,mBAC5B4F,EAAI,GAAK,GACZ8T,YAAW,WACP6R,EAAKC,aAAalgB,EAAK+f,YACxB,IAIP7kB,KAAK+b,YACL0H,GAAmB,EACnBe,GAAgB,IAInBA,IACGxkB,KAAKkc,uBACA3Z,MAAM8H,oBACNgV,aAAeva,GAEnB9E,KAAKkf,eAAepa,EAAKtC,UACrByiB,oBAAoBngB,EAAMgL,SAIlCwK,cAAe,OAErB,KAEEta,KAAK6b,UAAW,WACE7b,KAAKue,8CAAe,KAA5B7a,UACDiO,EAASjO,EAAKX,WAEf4O,GACE7B,EAAEiT,QAAUpR,EAAO,GAAK,GACxB7B,EAAEiT,QAAUpR,EAAO,GAAK,GACxB7B,EAAEkT,QAAUrR,EAAO,GAAK,GACxB7B,EAAEkT,QAAUrR,EAAO,GAAK,SAK1BuT,aAAaxhB,EAAMoM,QACnBuO,iBAAmB,oDAK3Bc,eAAiBnf,KAAKuC,MAAM4iB,cAAcrV,EAAEiT,QAASjT,EAAEkT,cACvDoC,yBAA0B,EAC3BplB,KAAKmf,iBAAmBnf,KAAK6b,UACzB/L,EAAE0T,UAASxjB,KAAKuc,mBAAqB,MAE5B8I,SAAS,CAACvV,EAAEiT,QAASjT,EAAEkT,SAChC,CAAChjB,KAAKmf,eAAe/f,IAAI,GAAKY,KAAKmf,eAAe7c,KAAK,GACnDtC,KAAKmf,eAAe/f,IAAI,GAAKY,KAAKmf,eAAe7c,KAAK,KACnDtC,KAAKqX,GAAG7K,MAAQ,QAClB4Y,yBAA0B,OAE1BjG,eAAemG,uBAIxBpC,IAAkBljB,KAAK6b,WAAa7b,KAAKoc,sBACpCmJ,cAAczV,GAGvB2T,GAAmB,GAGlBR,GAAcQ,GAAoBzjB,KAAKic,wBACnCwD,iBAAkB,QAER,IAAZ3P,EAAEyT,OAEU,IAAZzT,EAAEyT,QAEJvjB,KAAK6b,WAAW7b,KAAKwlB,mBAAmB1gB,EAAMgL,gBAOlDb,WAAW,GAAKa,EAAEqT,YAClBlU,WAAW,GAAKa,EAAEsT,YAClBvD,gBAAkBliB,SAClB8nB,qBAAsB,OAOtBljB,MAAMmjB,WAIN7L,EAAUhN,SAAS8Y,eAEhB,UADA9L,EAAUhN,SAAS8Y,cAAcC,SAASjlB,eAG1C,aADDkZ,EAAUhN,SAAS8Y,cAAcC,SAASjlB,gBAE7CmP,EAAEwB,iBAENxB,EAAEyB,kBAEEvR,KAAK4kB,kBACAA,YAAY9U,IAGd,oCAOX,SAAiBA,MACT9P,KAAK6e,YAAY7e,KAAK6lB,SAEtB7lB,KAAKwc,kCAAiCxc,KAAKsa,cAAe,GAEzDta,KAAKuC,OAEViL,EAAauJ,cAAgB/W,UACxB6iB,iBAAiB/S,OAChBuN,EAAQ,CAACvN,EAAEqT,OAAQrT,EAAEsT,aACtB/F,MAAM,GAAKA,EAAM,QACjBA,MAAM,GAAKA,EAAM,OAChBjM,EAAQ,CACViM,EAAM,GAAKrd,KAAKiP,WAAW,GAC3BoO,EAAM,GAAKrd,KAAKiP,WAAW,YAE1BA,WAAaoO,OACbC,YAAY,GAAKxN,EAAEiT,aACnBzF,YAAY,GAAKxN,EAAEkT,QAEpBhjB,KAAK4iB,mBACL9S,EAAEwB,kBACK,KAGXxB,EAAEU,SAAWxQ,KAAKylB,oBAEdzlB,KAAKoe,mBACAqG,mBAAmBzkB,KAAKoe,YAAY,GAAIpe,KAAKsd,YAAaxN,EAAG9P,KAAKoe,YAAY,SAC9E9D,cAAe,GAGpBta,KAAKuc,wBACAA,mBAAmB,GAAKzM,EAAEiT,QAAU/iB,KAAKuc,mBAAmB,QAC5DA,mBAAmB,GAAKzM,EAAEkT,QAAUhjB,KAAKuc,mBAAmB,QAC5DjC,cAAe,OACjB,GAAIta,KAAKmf,iBAAmBnf,KAAK6b,UAAW,IAE3C7b,KAAKolB,6BACAjG,eAAe7c,KAAO,CACvBwN,EAAEiT,QAAU/iB,KAAKmf,eAAe/f,IAAI,GACpC0Q,EAAEkT,QAAUhjB,KAAKmf,eAAe/f,IAAI,QAErC,KACGgP,EAASgD,EAAM,GAAKpR,KAAKqX,GAAG7K,MAC5B6B,EAAS+C,EAAM,GAAKpR,KAAKqX,GAAG7K,WAC7B2S,eAAe2G,KAAK1X,EAAQC,EAAQyB,EAAE0T,SACvCxjB,KAAKmf,eAAepR,OAAO9L,SAAQjC,KAAKsa,cAAe,QAE1DoF,gBAAiB,OACnB,GAAI1f,KAAKyf,qBACPpI,GAAGtM,OAAO,IAAMqG,EAAM,GAAKpR,KAAKqX,GAAG7K,WACnC6K,GAAGtM,OAAO,IAAMqG,EAAM,GAAKpR,KAAKqX,GAAG7K,WACnC8N,cAAe,OACfoF,gBAAiB,OACnB,GAAI1f,KAAKmc,oBAAsBnc,KAAK6b,UAAW,CAC9C7b,KAAKuf,kBAAiBvf,KAAKsa,cAAe,SAGxCxV,EAAO9E,KAAKuC,MAAMugB,aAAahT,EAAEiT,QAASjT,EAAEkT,QAAShjB,KAAKof,mBAG5Cpf,KAAKuC,MAAMwL,uCAAQ,KAA5BgY,UACHA,EAAMC,WAAalhB,IAASihB,IAE5BA,EAAMC,WAAY,EACdhmB,KAAKsf,WAAatf,KAAKsf,UAAU2G,mBAC5B3G,UAAU2G,aAAanW,QAE3BwP,UAAY,UACZhF,cAAe,qCAKxBxV,EAAM,IACFA,EAAKohB,kBAAiBlmB,KAAKsa,cAAe,GAGzCxV,EAAKkhB,YAENlhB,EAAKkhB,WAAY,OACZ1G,UAAYxa,OACZwV,cAAe,EAEhBxV,EAAKqhB,cAAcrhB,EAAKqhB,aAAarW,IAIzChL,EAAKshB,aACLthB,EAAKshB,YAAYtW,EAAG,CAACA,EAAEiT,QAAUje,EAAK1F,IAAI,GAAI0Q,EAAEkT,QAAUle,EAAK1F,IAAI,IAAKY,MAIxEA,KAAKuf,gBAAiB,KAChBngB,EAAMY,KAAKqmB,kBAAoB,CAAC,EAAG,MAGrCrmB,KAAKsmB,cAAcxhB,EAAMgL,EAAEiT,QAASjT,EAAEkT,cAEnC,KAEG5d,EAAOpF,KAAKumB,gBAAgBzhB,EAAMgL,EAAEiT,QAASjT,EAAEkT,QAAS5jB,OAChD,IAAVgG,GAAeN,EAAKrC,OAAO2C,GAAO,KAC5BohB,EAAW1hB,EAAKrC,OAAO2C,GAAMzG,KAC/BgD,EAAkB3B,KAAK+jB,kBAAkBplB,KAAM6nB,UAC1CH,iBAAmBjnB,QAEzBY,KAAKqmB,iBAAmB,MAKnCrmB,KAAK+P,SACDjG,EACAgG,EAAEiT,QACFjT,EAAEkT,QACFle,EAAK1F,IAAI,GAAK0F,EAAKxC,KAAK,GAAK,EAC7BwC,EAAK1F,IAAI,GAAK0F,EAAKxC,KAAK,GAAK,EAC7B,EACA,QAEKyN,OAAO4C,MAAMkR,OAAS,YACxB7jB,KAAK+P,OAAO4C,MAAMkR,OAAS,iBAEnC,OAEC4C,EAAW,SACIzmB,KAAKue,8CAAe,KAA5B7a,UACDiO,EAASjO,EAAKX,WACf4O,GACE7B,EAAEiT,QAAUpR,EAAO,GAAK,GACxB7B,EAAEiT,QAAUpR,EAAO,GAAK,GACxB7B,EAAEkT,QAAUrR,EAAO,GAAK,GACxB7B,EAAEkT,QAAUrR,EAAO,GAAK,IAG/B8U,EAAW/iB,wCAGX+iB,IAAazmB,KAAKqe,wBACbA,iBAAmBoI,OACnBnM,cAAe,GAGpBta,KAAK+P,SAAQ/P,KAAK+P,OAAO4C,MAAMkR,OAAS,OAK5C7jB,KAAKmM,sBAAwBnM,KAAKmM,uBAAyBrH,GAAQ9E,KAAKmM,qBAAqBia,kBACxFja,qBAAqBia,YAAYtW,EAAG,CAACA,EAAEiT,QAAU/iB,KAAKmM,qBAAqB/M,IAAI,GAAI0Q,EAAEkT,QAAUhjB,KAAKmM,qBAAqB/M,IAAI,IAAKY,MAIvIA,KAAKqf,eAAiBrf,KAAK+b,UAAW,WAEtB/b,KAAKkf,+CAAgB,KAA1BwH,UACPA,EAAEtnB,IAAI,IAAMgS,EAAM,GAAKpR,KAAKqX,GAAG7K,MAC/Bka,EAAEtnB,IAAI,IAAMgS,EAAM,GAAKpR,KAAKqX,GAAG7K,0CAG9B8N,cAAe,OACfoF,gBAAiB,KAGtB1f,KAAK4jB,gBAAkB5jB,KAAK+b,UAAW,KAEjC4K,EAAc,CAChB7W,EAAEiT,QAAU/iB,KAAK4jB,cAAcxkB,IAAI,GACnC0Q,EAAEkT,QAAUhjB,KAAK4jB,cAAcxkB,IAAI,IAEjCwnB,EAAU5mB,KAAK4jB,cAAczc,cACnCwf,EAAY,GAAK3e,KAAKC,IAAI2e,EAAQ,GAAID,EAAY,IAClDA,EAAY,GAAK3e,KAAKC,IAAI2e,EAAQ,GAAID,EAAY,SAC7C/C,cAAc1c,QAAQyf,QAEtB5W,OAAO4C,MAAMkR,OAAS,iBACtBvJ,cAAe,OACfoF,gBAAiB,UAI9B5P,EAAEwB,kBACK,iCAOX,SAAexB,MACP9P,KAAKwc,kCAAiCxc,KAAKsa,cAAe,GAEzDta,KAAKuC,WAGFsK,EADO7M,KAAK8Z,kBACZjN,SACRW,EAAauJ,cAAgB/W,KAG7B6M,EAAS8D,oBAAoB,YAAa3Q,KAAKihB,qBAAqB,QAC/DlR,OAAOR,iBAAiB,YAAavP,KAAKihB,qBAAqB,GACpEpU,EAAS8D,oBAAoB,UAAW3Q,KAAKmhB,mBAAmB,QAE3D0B,iBAAiB/S,OAChBjS,EAAMF,OACZmS,EAAE+W,WAAahpB,EAAMmC,KAAK6f,qBACrB4F,qBAAsB,OACtBpC,oBAAsB,KAEvBrjB,KAAK4iB,cAAa5iB,KAAK4iB,aAAc,GAGzB,IAAZ9S,EAAEyT,MAAa,IACXvjB,KAAKoe,aAAape,KAAKykB,mBAAmBzkB,KAAKoe,YAAY,GAAIpe,KAAKsd,YAAaxN,QAGhFsO,YAAc,KAEfpe,KAAKmf,eAAgB,KACf2H,EAAQ9mB,KAAKmf,eAAe/f,IAAI,GAChC4I,KAAKiD,MAAMjL,KAAKmf,eAAe/f,IAAI,IACnC2nB,EAAQ/mB,KAAKmf,eAAe/f,IAAI,GAChC4I,KAAKiD,MAAMjL,KAAKmf,eAAe/f,IAAI,SAEpC+f,eAAe2G,KAAKgB,EAAOC,EAAOjX,EAAE0T,cAEpCrE,eAAe/f,IAAI,GAAK4I,KAAKiD,MAAMjL,KAAKmf,eAAe/f,IAAI,SAC3D+f,eAAe/f,IAAI,GAAK4I,KAAKiD,MAAMjL,KAAKmf,eAAe/f,IAAI,IAE5DY,KAAKmf,eAAepR,OAAO9L,SAAQjC,KAAKsa,cAAe,QACtD6E,eAAiB,aAErBiG,yBAA0B,EAE3BplB,KAAKuc,mBAAoB,IACrBvc,KAAKuC,MAAO,KACNyL,EAAQhO,KAAKuC,MAAMwL,OACnBiZ,EAAe,IAAI5kB,aAAa,QACjC6kB,uBAEC9hB,EAAI6C,KAAK6J,IAAI7R,KAAKuc,mBAAmB,IACrC2K,EAAIlf,KAAK6J,IAAI7R,KAAKuc,mBAAmB,IACrC7M,EAAS1P,KAAKuc,mBAAmB,GAAK,EACtCvc,KAAKuc,mBAAmB,GAAKpX,EAC7BnF,KAAKuc,mBAAmB,GACxB5M,EAAS3P,KAAKuc,mBAAmB,GAAK,EACtCvc,KAAKuc,mBAAmB,GAAK2K,EAC7BlnB,KAAKuc,mBAAmB,QACzBA,mBAAmB,GAAK7M,OACxB6M,mBAAmB,GAAK5M,OACxB4M,mBAAmB,GAAKpX,OACxBoX,mBAAmB,GAAK2K,QAGvBC,EAAW,OAEEnZ,kCAAO,KAAflJ,UACPA,EAAKoJ,YAAY8Y,GAEZ7Y,EACGnO,KAAKuc,mBACLyK,IAKRG,EAASnmB,KAAK8D,kCAEdqiB,EAASllB,aACJue,YAAY2G,QAGpB5K,mBAAqB,UACvB,GAAIvc,KAAKuf,gBAAiB,MAExBjF,cAAe,OACfoF,gBAAiB,MAEhB5a,EAAO9E,KAAKuC,MAAMugB,aACpBhT,EAAEiT,QACFjT,EAAEkT,QACFhjB,KAAKof,kBAILta,KAEI9E,KAAK+jB,kBAAkBplB,OAASI,EAAclD,OAC3CmE,KAAKsmB,cAAcxhB,EAAMgL,EAAEiT,QAASjT,EAAEkT,cAEpCzD,gBAAgB6H,QAAQpnB,KAAKikB,gBAAiBnf,EAAM/F,EAAclD,WACpE,KAEGuJ,EAAOpF,KAAKumB,gBAAgBzhB,EAAMgL,EAAEiT,QAASjT,EAAEkT,aACvC,IAAV5d,OACKma,gBAAgB6H,QAAQpnB,KAAKikB,gBAAiBnf,EAAMM,OACtD,KAEG7B,EAAQuB,EAAKuiB,aAAa,GAE5BrnB,KAAK+jB,kBAAkBplB,OAASI,EAAclD,WACzC0jB,gBAAgB6H,QACjBpnB,KAAKikB,gBAAiBnf,EACtB/F,EAAclD,OAGlB0H,IACIA,EAAMG,MACP/B,EACC4B,EAAM5E,MAAQqB,KAAK+jB,kBAAkBplB,YAGpC4gB,gBAAgB6H,QAAQpnB,KAAKikB,gBAAiBnf,EAAM,SAMpEif,kBAAoB,UACpBC,eAAiB,UACjBzE,gBAAkB,UAClB0E,iBAAmB,OACrB,GAAIjkB,KAAK4jB,mBACPtJ,cAAe,OACfoF,gBAAiB,OACjBnd,MAAMmI,YAAY1K,KAAK4jB,oBACvBA,cAAgB,UAClB,GAAI5jB,KAAKqf,aAAc,KAEpBva,EAAO9E,KAAKqf,aAEdva,GACGgL,EAAE+W,WAAa,KACf/c,EACCgG,EAAEiT,QACFjT,EAAEkT,QACFle,EAAK1F,IAAI,GACT0F,EAAK1F,IAAI,GAAKL,EAAcvF,kBAChCuF,EAAcvF,kBACduF,EAAcvF,oBAGdsL,EAAKwiB,gBAGJhN,cAAe,OACfoF,gBAAiB,OACjBL,aAAajgB,IAAI,GAAK4I,KAAKiD,MAAMjL,KAAKqf,aAAajgB,IAAI,SACvDigB,aAAajgB,IAAI,GAAK4I,KAAKiD,MAAMjL,KAAKqf,aAAajgB,IAAI,IACxDY,KAAKuC,MAAMglB,OAAOC,oBACbnI,aAAaoI,cAElBznB,KAAK4d,aAAa5d,KAAK4d,YAAY5d,KAAKqf,mBACvC9c,MAAMmI,YAAY1K,KAAKqf,mBACvBA,aAAe,SACjB,EAEUrf,KAAKuC,MAAMugB,aACpBhT,EAAEiT,QACFjT,EAAEkT,QACFhjB,KAAKof,gBAGItP,EAAE+W,WAAa,UACnBI,wBAGJ3M,cAAe,OACfmF,iBAAkB,EAEnBzf,KAAKsf,WAAatf,KAAKsf,UAAUoI,gBAC5BpI,UAAUoI,UAAU5X,EAAG,CAACA,EAAEiT,QAAU/iB,KAAKsf,UAAUlgB,IAAI,GAAI0Q,EAAEkT,QAAUhjB,KAAKsf,UAAUlgB,IAAI,IAAKY,MAGpGA,KAAKmM,sBACFnM,KAAKmM,qBAAqBub,gBAExBvb,qBAAqBub,UAAU5X,EAAG,CACnCA,EAAEiT,QAAU/iB,KAAKmM,qBAAqB/M,IAAI,GAC1C0Q,EAAEkT,QAAUhjB,KAAKmM,qBAAqB/M,IAAI,WAInC,IAAZ0Q,EAAEyT,OAKU,IAAZzT,EAAEyT,cAFJjJ,cAAe,OACfmF,iBAAkB,eAQtBld,MAAMmjB,SAEX5V,EAAEyB,kBACFzB,EAAEwB,kBACK,oCAOX,SAAkBxB,YACT9P,KAAKuC,OAAUvC,KAAKic,sBAInB7K,YAAQtB,EAAEmB,4BAA2B,GAAZnB,EAAEoB,YAE5B2R,iBAAiB/S,OAEhBtD,EAAUxM,KAAKqX,GAAf7K,aAEF4E,EAAQ,EACR5E,GAAS,IACF4E,EAAQ,IACf5E,GAAS,EAAI,UAIZ6K,GAAGrF,YAAYxF,EAAO,CAACsD,EAAEqT,OAAQrT,EAAEsT,cAEnC7gB,MAAMmjB,SAEX5V,EAAEwB,kBACK,gCAOX,SAAcxM,EAAMwL,EAASC,OACnBoX,EAAc5oB,EAAcvF,0BACzBsQ,EACLwG,EACAC,EACAzL,EAAK1F,IAAI,GAAK,EACd0F,EAAK1F,IAAI,GAAK,EAAIuoB,EAClBA,EAAc,EACdA,EAAc,kCAQtB,SACI7iB,EACAwL,EACAC,EACAqX,MAEI9iB,EAAKrC,WACA,IAAIhE,EAAI,EAAGyH,EAAIpB,EAAKrC,OAAOR,OAAQxD,EAAIyH,IAAKzH,EAAG,KAC1CqlB,EAAUhf,EAAKmF,kBAAiB,EAAMxL,MAExCqG,EAAKkG,WACMlB,EACPwG,EACAC,EACAuT,EAAQ,GAAK,EACbA,EAAQ,GAAK,GACb,GACA,IAGOha,EACPwG,EACAC,EACAuT,EAAQ,GAAK,GACbA,EAAQ,GAAK,EACb,GACA,WAIA8D,IACAA,EAAQ,GAAK9D,EAAQ,GACrB8D,EAAQ,GAAK9D,EAAQ,IAElBrlB,SAIX,4BAOZ,SAAWqR,MACF9P,KAAKuC,WAENslB,GAAe,KAEQ,UAAvB/X,EAAE1R,OAAO0iB,cAIE,YAAXhR,EAAEnR,SACgB,KAAdmR,EAAE6H,eAEG8H,iBAAkB,EACvBoI,GAAe,GAID,KAAd/X,EAAE6H,SAAkB7H,EAAE0T,eACjBhD,cACLqH,GAAe,GAGJ,SAAX/X,EAAEgY,OAAoBhY,EAAEiY,UAAWjY,EAAE0T,SAAa1T,EAAEoU,UAEhDlkB,KAAKkf,sBACA8I,kBACLH,GAAe,GAIR,SAAX/X,EAAEgY,OAAoBhY,EAAEiY,UAAWjY,EAAE0T,SAAa1T,EAAEoU,eAE/C+D,qBAIU,KAAdnY,EAAE6H,SAAgC,IAAd7H,EAAE6H,SACI,UAAvB7H,EAAE1R,OAAO0iB,WAAgD,aAAvBhR,EAAE1R,OAAO0iB,iBAC1CoH,sBACLL,GAAe,GAOf7nB,KAAKkf,mBACA,IAAIzgB,KAAKuB,KAAKkf,eACXlf,KAAKkf,eAAezgB,GAAG0pB,gBAClBjJ,eAAezgB,GAAG0pB,UAAUrY,QAI1C,GAAc,SAAVA,EAAEnR,OACQ,IAAbmR,EAAE6H,eACG8H,iBAAkB,GAGvBzf,KAAKkf,oBACA,IAAIzgB,KAAKuB,KAAKkf,eACXlf,KAAKkf,eAAezgB,GAAG2pB,cAClBlJ,eAAezgB,GAAG2pB,QAAQtY,eAM1CvN,MAAMmjB,SAEPmC,GACA/X,EAAEwB,iBACFxB,EAAEkI,4BACK,8CAIf,eACUhT,EAAOqjB,aAAaC,QAAQ,gCAC7BtjB,QAEAzC,MAAM8H,qBAGLke,EAAgBjqB,KAAKC,MAAMyG,GAC3BgJ,EAAQ,OACUua,EAAcva,sCAAO,KAAlCwa,UACD1jB,EAAO3C,EAAW4C,WAAWyjB,EAAU7pB,MACzCmG,IACAA,EAAK3B,UAAUqlB,GACf1jB,EAAK1F,IAAI,IAAM,EACf0F,EAAK1F,IAAI,IAAM,OACVmD,MAAMqS,IAAI9P,GACfkJ,EAAMhN,KAAK8D,6CAIKyjB,EAAc9kB,sCAAO,KAAlCwC,UACDwiB,EAAcza,EAAM/H,EAAU,IAC9BG,EAAc4H,EAAM/H,EAAU,IAChCwiB,GAAeriB,EAAaqiB,EAAYrB,QAAQnhB,EAAU,GAAIG,EAAaH,EAAU,IACpFjH,QAAQsB,KAAK,yEAGjBkgB,YAAYxS,QAEZzL,MAAMmI,8CAGf,iBACU6d,EAAgB,CAClBva,MAAO,GACPvK,MAAO,IAEPilB,EAAQ,EACNC,EAAqB,OAEA3oB,KAAKkf,+CAAgB,SAC5Cpa,KAAK8jB,aAAeF,EACpBC,EAAmB3nB,KAAK8D,MACxB4jB,GAAS,+CAGMC,iBAAoB,KAA5B7jB,OACD+jB,EAAS/jB,EAAKgkB,WACfD,MAILN,EAAcva,MAAMhN,KAAK6nB,EAAO5jB,aAC5BH,EAAKrC,QAAUqC,EAAKrC,OAAOR,WACtB,IAAIC,EAAI,EAAGA,EAAI4C,EAAKrC,OAAOR,SAAUC,EAAG,KACnCqB,EAAQuB,EAAKrC,OAAOP,MACrBqB,GAAuB,MAAdA,EAAMG,UAGduC,EAAYjG,KAAKuC,MAAMkB,MAAMF,EAAMG,SACpCuC,OAGCG,EAAcpG,KAAKuC,MAAMiD,YAC3BS,EAAUR,WAETW,GAAgBpG,KAAKkf,eAAe9Y,EAAY5D,KAIrD+lB,EAAc9kB,MAAMzC,KAAK,CACrBoF,EAAYwiB,aACZ3iB,EAAUN,YACVb,EAAK8jB,aACL3iB,EAAUW,sBAzBlB5H,QAAQsB,oCAA6BwE,EAAKnG,OA+BlD0pB,aAAaU,QAAQ,4BAA6BzqB,KAAKE,UAAU+pB,+BAOrE,SAAYzY,GACRA,EAAEwB,sBACGuR,iBAAiB/S,OAEhB1Q,EAAM,CAAC0Q,EAAEiT,QAASjT,EAAEkT,SACpBle,EAAO9E,KAAKuC,MAAQvC,KAAKuC,MAAMugB,aAAa1jB,EAAI,GAAIA,EAAI,IAAM,SAE/D0F,EAAM,KACHzG,EAAI,YACJ2B,KAAKgpB,aAAY3qB,EAAI2B,KAAKgpB,WAAWlZ,SACpCzR,QACI4qB,cAAcnZ,OAKvBhL,EAAKokB,YAAcpkB,EAAKqkB,WAAY,KAC5BC,EAAUtZ,EAAEuZ,aAAZD,SACJA,GAASA,EAAMnnB,OAAQ,WACJmnB,4BAARE,UACDC,EAAWD,EAAKnqB,QAGlB2F,EAAKokB,YACLpkB,EAAKokB,WAAWI,GAGhBxkB,EAAKqkB,WAAY,KAEXK,EAAS,IAAIC,WACnBD,EAAO1d,OAAS,SAACyG,OAEPvN,EAAOuN,EAAMnU,OAAOiD,OAC1ByD,EAAKqkB,WAAWnkB,EAAMukB,EAAUD,QAI9B3qB,EAAO2qB,EAAK3qB,KAAK8C,MAAM,KAAK,GACrB,SAAT9C,GAA4B,KAATA,EACnB6qB,EAAOE,WAAWJ,GACF,UAAT3qB,EACP6qB,EAAOG,cAAcL,GAErBE,EAAOI,kBAAkBN,6EAOzCxkB,EAAKkkB,aACDlkB,EAAKkkB,WAAWlZ,OAKpB9P,KAAKgpB,YACEhpB,KAAKgpB,WAAWlZ,gCAM/B,SAAcA,MACNA,EAAEuZ,aAAaD,MAAMnnB,OAAQ,KACvBqnB,EAAOxZ,EAAEuZ,aAAaD,MAAM,GAC5B5oB,EC1iDX,SAA0BiL,OACvBoe,EAAWpe,EAAI3J,QAAQ,MACX,IAAd+nB,IACApe,EAAMA,EAAIlM,OAAO,EAAGsqB,QAElBC,EAAQre,EAAIpM,YAAY,YACf,IAAXyqB,EACO,GAEJre,EAAIlM,OAAOuqB,EAAQ,GAAGnpB,cDiiDTopB,CAAiBT,EAAKnqB,MAAMwB,cAClCqpB,EAAWjrB,EAAczB,6BAA6BkD,MACxDwpB,EAAU,MACLznB,MAAM8H,mBACLvF,EAAO3C,EAAW4C,WAAWilB,EAASrrB,MAC5CmG,EAAK1F,IAAM,CAAC0Q,EAAEiT,QAASjT,EAAEkT,cACpBzgB,MAAMqS,IAAI9P,GACXA,EAAKokB,YACLpkB,EAAKokB,WAAWI,QAEf/mB,MAAMmI,qDAKvB,SAAsBgc,GACd1mB,KAAKiqB,gBAAiBjqB,KAAKiqB,gBAAgBvD,GAC1C1mB,KAAKkqB,kBAAkBxD,GAExB1mB,KAAKmqB,kBAAkBnqB,KAAKmqB,iBAAiBzD,QAE5CzG,UAAS,sCAGlB,SAAoBnb,EAAMgL,QACjBsa,WAAWtlB,EAAMgL,GAAKA,EAAEoU,UACzBlkB,KAAKqqB,qBACAA,eAAevlB,6BAU5B,SAAWA,EAAMwlB,GACD,MAARxlB,OACKmiB,wBAEAzG,YAAY,CAAC1b,GAAOwlB,8BAQjC,eAAYtc,yDAAQhO,KAAKuC,MAAMwL,OAAQuc,yCAC9BA,GAAuBtqB,KAAKinB,6BAEdjZ,kCAAO,KAAflJ,cACHA,EAAKylB,iBAEJzlB,EAAKylB,aAAezlB,EAAK0lB,YAAY1lB,EAAK0lB,aAC/C1lB,EAAKylB,aAAc,OACdrL,eAAepa,EAAKtC,IAAMsC,EAE3BA,EAAKrC,OAAQ,WACOqC,EAAKrC,4CAAdc,eAA2Bic,kBAAkBjc,EAAMG,OAAQ,qCAGtEoB,EAAKpC,QAAS,WACIoC,EAAKpC,wCAAS,KAArBmF,aACHA,EAAIpE,MAAO,WACQoE,EAAIpE,2CAAZC,eAAwB8b,kBAAkB9b,IAAQ,oGAMzE1D,KAAK6d,mBAAmB7d,KAAK6d,kBAAkB7d,KAAKkf,qBAEnDe,UAAS,+BAOlB,SAAanb,MACJA,EAAKylB,gBACNzlB,EAAK2lB,cACL3lB,EAAK2lB,eAET3lB,EAAKylB,aAAc,EAEfvqB,KAAK0qB,uBACAA,iBAAiB5lB,GAItBA,EAAKrC,OAAQ,WACOqC,EAAKrC,4CAAdc,iBAA6BvD,KAAKwf,kBAAkBjc,EAAMG,yCAErEoB,EAAKpC,QAAS,WACIoC,EAAKpC,wCAAS,KAArBmF,aACHA,EAAIpE,MAAO,WACQoE,EAAIpE,2CAAZC,iBAA0B1D,KAAKwf,kBAAkB9b,sGAU5E,cACS1D,KAAKuC,iBACSvC,KAAKuC,MAAMwL,uCAAQ,KAA3BjJ,UACFA,EAAKylB,cAGNzlB,EAAK2lB,cACL3lB,EAAK2lB,eAET3lB,EAAKylB,aAAc,EACfvqB,KAAK0qB,uBACAA,iBAAiB5lB,wCAGzBoa,eAAiB,QACjBf,aAAe,UACfqB,kBAAoB,GACrBxf,KAAK6d,mBAAmB7d,KAAK6d,kBAAkB7d,KAAKkf,qBACnDe,UAAS,uCAOlB,eAIS,IAAMxhB,UAHN8D,MAAM8H,eAGKrK,KAAKkf,eAAgB,KAC3Bpa,EAAO9E,KAAKkf,eAAezgB,OAE7BqG,EAAK4V,iBAGL5V,EAAKrC,QACFqC,EAAKrC,OAAOR,QACZ6C,EAAKpC,SACLoC,EAAKpC,QAAQT,QACbN,EAAkBmD,EAAKrC,OAAO,GAAG9D,KAAMmG,EAAKpC,QAAQ,GAAG/D,OACvDmG,EAAKrC,OAAO,GAAGiB,MACfoB,EAAKpC,QAAQ,GAAGe,OAChBqB,EAAKpC,QAAQ,GAAGe,MAAMxB,OAAQ,KAC3B0oB,EAAY7lB,EAAKvC,MAAMkB,MAAMqB,EAAKrC,OAAO,GAAGiB,MAC5CknB,EAAa9lB,EAAKvC,MAAMkB,MAAMqB,EAAKpC,QAAQ,GAAGe,MAAM,IACpDonB,EAAY/lB,EAAKgmB,aAAa,GAC9BC,EAAajmB,EAAKkmB,eAAe,GAAG,GACtCH,GAAaE,GACbF,EAAUzD,QAAQuD,EAAUhlB,YAAaolB,EAAYH,EAAWhkB,kBAGnErE,MAAMgW,OAAOzT,GACd9E,KAAK0qB,kBAAkB1qB,KAAK0qB,iBAAiB5lB,SAGhDoa,eAAiB,QACjBf,aAAe,UACfqB,kBAAoB,QACpBS,UAAS,QACT1d,MAAMmI,0CAOf,SAAa5F,QACJuS,GAAGtM,OAAO,IAAMjG,EAAK1F,IAAI,GACT,GAAf0F,EAAKxC,KAAK,GACW,GAApBtC,KAAK+P,OAAOP,MAAexP,KAAKqX,GAAG7K,WACrC6K,GAAGtM,OAAO,IAAMjG,EAAK1F,IAAI,GACT,GAAf0F,EAAKxC,KAAK,GACY,GAArBtC,KAAK+P,OAAON,OAAgBzP,KAAKqX,GAAG7K,WACtCyT,UAAS,GAAM,mCAOxB,SAAiBnQ,MACT9P,KAAK+P,OAAQ,KACPxB,EAAIvO,KAAK+P,OAAOE,wBACtBH,EAAEqT,OAASrT,EAAEI,QAAU3B,EAAE4B,KACzBL,EAAEsT,OAAStT,EAAEM,QAAU7B,EAAE8B,SAEzBP,EAAEqT,OAASrT,EAAEI,QACbJ,EAAEsT,OAAStT,EAAEM,QAGjBN,EAAEmb,OAASnb,EAAEqT,OAASnjB,KAAKse,oBAAoB,GAC/CxO,EAAEkB,OAASlB,EAAEsT,OAASpjB,KAAKse,oBAAoB,QAE1CA,oBAAoB,GAAKxO,EAAEqT,YAC3B7E,oBAAoB,GAAKxO,EAAEsT,OAEhCtT,EAAEiT,QAAUjT,EAAEqT,OAASnjB,KAAKqX,GAAG7K,MAAQxM,KAAKqX,GAAGtM,OAAO,GACtD+E,EAAEkT,QAAUlT,EAAEsT,OAASpjB,KAAKqX,GAAG7K,MAAQxM,KAAKqX,GAAGtM,OAAO,0BAQ1D,SAAQ/G,EAAO0N,QACN2F,GAAGrF,YAAYhO,EAAO0N,QACtB4I,cAAe,OACfoF,gBAAiB,uCAO1B,SAAsBtgB,UACXY,KAAKqX,GAAG6T,sBAAsB9rB,wCAOzC,SAAsBA,EAAKyI,UAChB7H,KAAKqX,GAAGzF,sBAAsBxS,EAAKyI,6CAS9C,SAA2BiI,OACjBE,EAAOhQ,KAAK+P,OAAOE,+BAClBjQ,KAAK4R,sBAAsB,CAAC9B,EAAEI,QAAUF,EAAKG,KAAML,EAAEM,QAAUJ,EAAKK,kCAQ/E,SAAavL,OACHrG,EAAIuB,KAAKuC,MAAMwL,OAAOjM,QAAQgD,IACzB,IAAPrG,SAIC8D,MAAMwL,OAAOxG,OAAO9I,EAAG,QACvB8D,MAAMwL,OAAO/M,KAAK8D,8BAQ3B,SAAWA,OACDrG,EAAIuB,KAAKuC,MAAMwL,OAAOjM,QAAQgD,IACzB,IAAPrG,SAIC8D,MAAMwL,OAAOxG,OAAO9I,EAAG,QACvB8D,MAAMwL,OAAOod,QAAQrmB,uCAU9B,eAAoBkJ,yDAAQhO,KAAKuC,MAAMwL,OAAQlG,yCACrCujB,EAAevjB,GAAO,GAC5BujB,EAAanpB,OAAS,YACN+L,kCAAO,KAAZ0Y,UACP1nB,QAAQC,IAAI+O,EAAOhO,KAAKuC,MAAMwL,UAE1B/N,KAAK+b,WAAc2K,EAAElJ,kBAAqBkJ,EAAEjJ,oBAI3CtP,EAAgBnO,KAAKkP,aAAcwX,EAAExY,YAAYsI,KAItD4U,EAAapqB,KAAK0lB,0CAEf0E,sBAUX,SAAKC,EAAcC,MACVtrB,KAAK+P,QAAgC,IAAtB/P,KAAK+P,OAAOP,OAAsC,IAAvBxP,KAAK+P,OAAON,YAGrD5R,EAAMF,SACPqhB,YAA4C,MAA7BnhB,EAAMmC,KAAK+e,qBAC1BA,eAAiBlhB,EAElBmC,KAAKuC,OAAOvC,KAAKqX,GAAGkU,sBAGpBvrB,KAAK0f,gBACF4L,GACAtrB,KAAKyc,0BACJzc,KAAKuC,OACNvC,KAAKuC,MAAMiE,oBACX3I,EAAMmC,KAAKuC,MAAMiE,mBAAqB,MAC3CxG,KAAKwrB,kBAEHxrB,KAAKsa,cAAgB+Q,IAAcrrB,KAAKyrB,uBAEvCxM,IAAMjf,KAAKgf,YAAc,EAAMhf,KAAKgf,YAAc,OAClDF,OAAS,kCAOlB,gBACSxE,cAAe,EAEfta,KAAKwR,MAAKxR,KAAKwR,IAAMxR,KAAK4gB,SAASC,WAAW,WAC3CrP,EAAQxR,KAARwR,OACHA,GAEDA,EAAIka,SACJla,EAAIka,cAGA3b,EAAW/P,KAAX+P,UAGRyB,EAAIma,UACJna,EAAIoa,aAAa,EAAG,EAAG,EAAG,EAAG,EAAG,GAG5B5rB,KAAK2f,aACLnO,EAAIqa,OACJra,EAAIsa,YACJta,EAAIxB,KACAhQ,KAAK2f,WAAW,GAChB3f,KAAK2f,WAAW,GAChB3f,KAAK2f,WAAW,GAChB3f,KAAK2f,WAAW,IAEpBnO,EAAIua,QAGJ/rB,KAAK4b,kBAAkBpK,EAAIwa,UAAU,EAAG,EAAGjc,EAAOP,MAAOO,EAAON,QAGhEzP,KAAK4gB,WAAa5gB,KAAK+P,YAClByb,iBAELha,EAAIya,UAAUjsB,KAAK4gB,SAAU,EAAG,GAIhC5gB,KAAKksB,UAAUlsB,KAAKksB,SAASnc,EAAQyB,GAGrCxR,KAAKgc,WAAWhc,KAAKmsB,WAAW3a,GAEhCxR,KAAKuC,MAAO,CAEZiP,EAAIqa,YACCxU,GAAG+U,gBAAgB5a,aAIHxR,KAAKqsB,oBAAoB,KAAMrsB,KAAKof,+CAExB,KAAtBta,UAEP0M,EAAIqa,OACJra,EAAIC,UAAU3M,EAAK1F,IAAI,GAAI0F,EAAK1F,IAAI,SAG/BktB,SAASxnB,EAAM0M,GACN,EAGdA,EAAIma,4CAIJ3rB,KAAKid,wBAAwBjd,KAAKusB,mBAAmB/a,GAGrDxR,KAAKuC,MAAMglB,OAAOiF,cAAgBxsB,KAAK+b,WAAW/b,KAAKysB,gBAAgBjb,GAG/C,OAAxBxR,KAAKgkB,eAAyB,CAC9BxS,EAAIkb,UAAY1sB,KAAKie,sBACjB0O,EAAY,YAER3sB,KAAK+jB,kBAAkBplB,WACtBI,EAAclD,MACf8wB,EAAY5tB,EAAc9D,+BAG1B0xB,EAAY5tB,EAAc7D,2BAI7B0xB,WACDpb,EACAxR,KAAKgkB,eACL,CAAChkB,KAAKsd,YAAY,GAAItd,KAAKsd,YAAY,IACvC,MACA,EACA,KACAqP,EACA3sB,KAAK+jB,kBAAkB8I,MACnB7sB,KAAKuf,gBAAgBvU,WAAajM,EAAc3C,KAAO2C,EAAczC,OACzEyC,EAAcxC,QAGlBiV,EAAIsa,YAEA9rB,KAAK+jB,kBAAkBplB,OAASI,EAAclD,OAC3CmE,KAAK+jB,kBAAkBnf,QAAU7F,EAAczD,UAElDkW,EAAIxB,KACAhQ,KAAKgkB,eAAe,GAAK,EAAI,GAC7BhkB,KAAKgkB,eAAe,GAAK,EAAI,GAC7B,GACA,IAGJxS,EAAIsb,IACA9sB,KAAKgkB,eAAe,GACpBhkB,KAAKgkB,eAAe,GACpB,EACA,EACU,EAAVhc,KAAK+kB,IAGbvb,EAAIwb,OAEJxb,EAAIyb,UAAY,UACZjtB,KAAKqmB,mBACL7U,EAAIsa,YACJta,EAAIsb,IACA9sB,KAAKqmB,iBAAiB,GACtBrmB,KAAKqmB,iBAAiB,GACtB,EACA,EACU,EAAVre,KAAK+kB,IAETvb,EAAIwb,QAKRhtB,KAAKuc,qBACL/K,EAAI0b,YAAc,OAClB1b,EAAI2b,WACAntB,KAAKuc,mBAAmB,GACxBvc,KAAKuc,mBAAmB,GACxBvc,KAAKuc,mBAAmB,GACxBvc,KAAKuc,mBAAmB,KAK5Bvc,KAAKqe,kBAAoBre,KAAKmd,yBACzBiQ,gBAAgB5b,EAAKxR,KAAKqe,kBACxBre,KAAK2d,wBACPA,kBAAkBnM,EAAK,MAI5BxR,KAAKyd,uBACAA,iBAAiBjM,EAAKxR,KAAKqtB,cAGpC7b,EAAIma,UAIJ3rB,KAAKggB,cAAgBhgB,KAAKggB,aAAa/d,QAAQjC,KAAKstB,kBAAkB9b,GAEtExR,KAAK0d,eAAe1d,KAAK0d,cAAclM,GAEvCxR,KAAK2f,YAAYnO,EAAIma,UAErBna,EAAI+b,UAAU/b,EAAI+b,6CAO1B,SAAkB/b,OACRqT,EAAW7kB,KAAKuC,MAChBirB,EAAU3I,EAASxE,kBACpBmN,OAKCC,EAAMD,EAAQ/qB,OAAS+qB,EAAQ/qB,OAAOR,OAAS,EAC/CkD,EAAI,IACJ+hB,EAAIlf,KAAK0lB,MAAuC,IAAjC3uB,EAAcrF,qBAEnC8X,EAAIyb,UAAY,OAChBzb,EAAImc,YAAc,GAClBnc,EAAIsa,YACJta,EAAIoc,UAAU,GAAI,GAAIzoB,GAAIsoB,EAAM,GAAKvG,EAAI,GAAI,GAC7C1V,EAAIwb,OACJxb,EAAImc,YAAc,EAElBnc,EAAIyb,UAAY,OAChBzb,EAAI/C,KAAO,aACX+C,EAAIqc,UAAY,OAChBrc,EAAIsc,SAAS,eAAgB,GAAI,IAE7B9tB,KAAK+tB,WAAW5oB,IAAQ,GAAI,GAAI,GAAI,IAAK,gBACpC6oB,yBAIL5kB,EAAI,MACRoI,EAAI/C,KAAO,aACP+e,EAAQ/qB,OAAQ,WACI+qB,EAAQ/qB,uCAAQ,KAAzBc,cACHA,EAAM0qB,uBAGNjuB,KAAK+tB,WAAW,GAAI3kB,EAAI,EAAGjE,IAAQ+hB,EAAI,GAAI,KACrCvoB,EAAO6uB,EAAQ/sB,YAAYytB,iBAAmB,mBAC/C3rB,MAAM8H,mBACL8jB,EAAUppB,WAAWpG,GACvBwvB,GACAtJ,EAASjQ,IAAIuZ,QACRvL,aAAc,OACdS,oBAAsB,UACtB7C,YAAY,CAAC2N,SACb9O,aAAe8O,OACf1O,iBAAkB,EACvB0O,EAAQ9T,YAAY,OAAQ9W,EAAMpE,MAClCgvB,EAAQ9T,YAAY,OAAQ9W,EAAM5E,WAC7B0gB,aAAajgB,IAAI,GAAKY,KAAKsd,YAAY,GAAK,OAC5C+B,aAAajgB,IAAI,GAAKY,KAAKsd,YAAY,GAAK,OAC5C/a,MAAMmI,eAEX1L,QAAQ0N,MAAM,8BAA+B/N,GAIrD6S,EAAIyb,UAAY,OAChBzb,EAAIsa,YACJta,EAAIsb,IAAI3nB,IAAQiE,EAAQ,GAAJ8d,EAAS,EAAG,EAAG,EAAIlf,KAAK+kB,IAC5Cvb,EAAIwb,OAEJxb,EAAIyb,UAAY,OAChBzb,EAAIsc,SAASvqB,EAAMpE,KAAM,GAAIiK,EAAQ,IAAJ8d,OAC3BkH,EAAK5c,EAAI6c,YAAY9qB,EAAMpE,MACjCqS,EAAIyb,UAAY,OAChBzb,EAAIsc,SAASvqB,EAAM5E,KAAM,GAAKyvB,EAAG5e,MAAQ,GAAIpG,EAAQ,IAAJ8d,GAEjD9d,GAAK8d,mCAKTlnB,KAAK+tB,WAAW,GAAI3kB,EAAI,EAAGjE,IAAQ+hB,EAAI,EAAG,IAAK,UAAW,cACrDoH,6BAA6Bd,SAtElCxuB,QAAQsB,KAAK,sDAwFrB,SAAWkJ,EAAGJ,EAAGjE,EAAG+hB,EAAGve,OAAMjE,yDAAU3F,EAAc1E,mBAAoBk0B,yDAAa,OAAQC,yDAAYzvB,EAAc5E,gBAC5GqX,EAAQxR,KAARwR,IAEJpS,EAAMY,KAAKqd,MACToR,EAAQ3kB,EAAkB1K,EAAI,GAAIA,EAAI,GAAIoK,EAAGJ,EAAGjE,EAAG+hB,GAEnDwH,GADNtvB,EAAMY,KAAKqjB,sBACYvZ,EAAkB1K,EAAI,GAAIA,EAAI,GAAIoK,EAAGJ,EAAGjE,EAAG+hB,UAElE1V,EAAIyb,UAAYwB,EAAQF,EAAa7pB,EACjCgqB,IAASld,EAAIyb,UAAY,QAC7Bzb,EAAIsa,YACJta,EAAIoc,UAAUpkB,EAAGJ,EAAGjE,EAAG+hB,EAAG,GAC1B1V,EAAIwb,OAES,OAATrkB,GACIA,EAAKlI,cAAgBC,SACrB8Q,EAAIyb,UAAYuB,EAChBhd,EAAIqc,UAAY,SAEhBrc,EAAI/C,eAAe,IAAJyY,EAAY,cAC3B1V,EAAIsc,SAASnlB,EAAMa,EAAQ,GAAJrE,EAASiE,EAAQ,IAAJ8d,GACpC1V,EAAIqc,UAAY,QAIpBa,GAAS1uB,KAAK2uB,aACXD,IAAY1uB,KAAK4iB,yCAG5B,SAAcpZ,EAAGJ,EAAGjE,EAAG+hB,EAAG0H,OAChBxvB,EAAMY,KAAKqjB,oBACXqL,EAAUtvB,GAAO0K,EAAkB1K,EAAI,GAAIA,EAAI,GAAIoK,EAAGJ,EAAGjE,EAAG+hB,UAC9DwH,GAAWE,GAAW5uB,KAAK2uB,aACxBD,IAAY1uB,KAAK4iB,sCAO5B,SAAWpR,OAAKhI,yDAAI,GAAIJ,yDAAIpJ,KAAK+P,OAAON,OAAS,GAC7C+B,EAAIqa,OACJra,EAAIC,UAAUjI,EAAGJ,GAEjBoI,EAAI/C,KAAO,aACX+C,EAAIyb,UAAY,OACZjtB,KAAKuC,OACLiP,EAAIsc,sBAAe9tB,KAAKuC,MAAMssB,WAAWhc,QAAQ,QAAO,EAAG,IAC3DrB,EAAIsc,sBAAe9tB,KAAKuC,MAAMusB,WAAa,EAAG,IAC9Ctd,EAAIsc,sBAAe9tB,KAAKuC,MAAMwL,OAAO9L,oBAAWjC,KAAKof,cAAcnd,YAAW,EAAG,IACjFuP,EAAIsc,sBAAe9tB,KAAKuC,MAAMU,UAAY,EAAG,IAC7CuO,EAAIsc,uBAAgB9tB,KAAKif,IAAIpM,QAAQ,IAAM,EAAG,KAE9CrB,EAAIsc,SAAS,oBAAqB,EAAG,IAEzCtc,EAAIma,wCAOR,sBACU5b,EAAS/P,KAAK4gB,SAChB7Q,EAAOP,QAAUxP,KAAK+P,OAAOP,OAASO,EAAON,SAAWzP,KAAK+P,OAAON,SACpEM,EAAOP,MAAQxP,KAAK+P,OAAOP,MAC3BO,EAAON,OAASzP,KAAK+P,OAAON,QAG3BzP,KAAKqiB,QAAOriB,KAAKqiB,MAAQriB,KAAK4gB,SAASC,WAAW,WACjDrP,EAAMxR,KAAKqiB,SACb7Q,EAAIud,OAAOvd,EAAIud,QAGf/uB,KAAK4b,kBAAkBpK,EAAIwa,UAAU,EAAG,EAAGjc,EAAOP,MAAOO,EAAON,QAEhEzP,KAAKggB,cAAgBhgB,KAAKggB,aAAa/d,OAAQ,CAC/CuP,EAAIqa,WACEzL,EAAepgB,KAAKuC,MAAM8d,eAChC7O,EAAI0b,YAAc9M,EAAa1b,QAC/B8M,EAAIkb,UAAY,GAChBlb,EAAI2b,WAAW,EAAG,EAAGpd,EAAOP,MAAQ,EAAGO,EAAON,OAAS,GACvD+B,EAAIkb,UAAY,EAChBlb,EAAI/C,KAAO,aACX+C,EAAIqc,UAAY,SAChBrc,EAAIyb,UAAY7M,EAAa1b,SAAW,aACpClF,EAAQ,OAEIQ,KAAKggB,kDAAVgP,UAAwBxvB,aAAYwvB,EAAE3O,eAAe4O,kDAEhEzd,EAAIsc,SACAtuB,EAAQ4gB,EAAa6O,WACN,GAAflf,EAAOP,MACP,IAEJgC,EAAIma,cAGJuD,GAAmB,KACnBlvB,KAAKmvB,qBACLD,EAAmBlvB,KAAKmvB,mBAAmBpf,EAAQyB,IAIvDA,EAAIma,UACJna,EAAIoa,aAAa,EAAG,EAAG,EAAG,EAAG,EAAG,QAC3BrN,cAActc,OAAS,EAExBjC,KAAKuC,MAAO,IAEZiP,EAAIqa,YACCxU,GAAG+U,gBAAgB5a,GAGpBxR,KAAK4a,kBAAoB5a,KAAKqX,GAAG7K,MAAQ,KAAQ0iB,EAAkB,CACnE1d,EAAImc,YAAc3tB,KAAK8a,mBAChB,EAAM,GAAM9a,KAAKqX,GAAG7K,OAASxM,KAAK0b,aACnC1b,KAAK0b,aAEXlK,EAAI4d,uBAAwB,EAC5B5d,EAAI6d,0BAA2B,EAC/B7d,EAAI4d,uBAAwB,EAEvBpvB,KAAKsvB,SACHtvB,KAAKsvB,QAAQ9sB,KAAOxC,KAAK4a,wBAEvB0U,QAAU,IAAI3jB,WACd2jB,QAAQ9sB,GAAKxC,KAAK4a,sBAClB0U,QAAQ1jB,IAAM5L,KAAK4a,sBACnB0U,QAAQxjB,OAAS,kBAAMyjB,EAAK7M,MAAK,GAAM,SAG5C8M,EAAU,KACO,MAAjBxvB,KAAKyvB,UAAoBzvB,KAAKsvB,QAAQ9f,MAAQ,GAC9CggB,EAAUhe,EAAIke,cAAc1vB,KAAKsvB,QAAS,eACrCK,aAAe3vB,KAAKsvB,aACpBG,SAAWD,GAEhBA,EAAUxvB,KAAKyvB,SAEfD,IACAhe,EAAIyb,UAAYuC,EAChBhe,EAAIoe,SACA5vB,KAAKkP,aAAa,GAClBlP,KAAKkP,aAAa,GAClBlP,KAAKkP,aAAa,GAClBlP,KAAKkP,aAAa,IAEtBsC,EAAIyb,UAAY,eAGpBzb,EAAImc,YAAc,EAClBnc,EAAI4d,uBAAwB,EAC5B5d,EAAI6d,0BAA2B,EAC/B7d,EAAI4d,uBAAwB,EAI5BpvB,KAAKuC,MAAMstB,QAAQ5tB,SAAWjC,KAAK+b,WAAW/b,KAAK8vB,WAAW/f,EAAQyB,GAEtExR,KAAKwd,kBAAkBxd,KAAKwd,iBAAiBhM,EAAKxR,KAAKkP,cAGvDlP,KAAK2c,uBACLnL,EAAI0b,YAAc,OAClB1b,EAAI2b,WAAW,EAAG,EAAGpd,EAAOP,MAAOO,EAAON,SAG1CzP,KAAK4c,4BACLpL,EAAIue,YAAc,OAClBve,EAAIwe,cAAgB,EACpBxe,EAAIye,cAAgB,EACpBze,EAAI0e,WAAa,GAEjB1e,EAAIue,YAAc,gBAIjB/vB,KAAK+b,WAAW/b,KAAKysB,gBAAgBjb,GAE1CA,EAAIue,YAAc,gBAElBve,EAAIma,UAGJna,EAAI2e,QAAQ3e,EAAI2e,cAEfzQ,gBAAiB,OACjBpF,cAAe,0BAOxB,SAASxV,EAAM0M,QAEN2M,aAAerZ,MAEdL,EAAQK,EAAKL,OAASK,EAAKrE,YAAYgE,OAAS1F,EAAc1E,mBAChEqK,EAAUI,EAAKJ,SAAWI,EAAKrE,YAAYiE,SAAW3F,EAAczE,qBAGpEwK,EAAKkhB,cAEHoK,EAAapwB,KAAKqX,GAAG7K,MAAQ,MAG/BxM,KAAK+b,UACAjX,EAAKhC,MAAM+G,YACZ2H,EAAIue,YAAc,cACdjrB,EAAK2Y,kBACL3Y,EAAK2Y,iBAAiBjM,EAAKxR,KAAMA,KAAK+P,iBAMlDyB,EAAImc,YAAc3tB,KAAK0b,aAEnB1b,KAAK0c,iBAAmB0T,GACxB5e,EAAIue,YAAchxB,EAAcrE,qBAChC8W,EAAIwe,cAAgB,EAAIhwB,KAAKqX,GAAG7K,MAChCgF,EAAIye,cAAgB,EAAIjwB,KAAKqX,GAAG7K,MAChCgF,EAAI0e,WAAa,EAAIlwB,KAAKqX,GAAG7K,OAE7BgF,EAAIue,YAAc,eAIlBjrB,EAAKhC,MAAM+G,YACR/E,EAAKurB,iBAC8B,GAAnCvrB,EAAKurB,gBAAgB7e,EAAKxR,WAM3B4E,EAAQE,EAAK7E,QAAUlB,EAAczD,UACrCgH,EAAOmU,EACbA,EAAQ3W,IAAIgF,EAAKxC,UACT0I,EAAelG,EAAfkG,cAEJlG,EAAKhC,MAAM+G,UAAW,CACtB2H,EAAI/C,KAAOzO,KAAKgb,oBACVxb,EAAQsF,EAAKmqB,SAAWnqB,EAAKmqB,WAAanqB,EAAKtF,MACvC,OAAVA,IACAsF,EAAKiF,iBAAmB/B,KAAKsoB,IACzBxrB,EAAKxC,KAAK,GACVkP,EAAI6c,YAAY7uB,GAAOgQ,MACa,EAAlCzQ,EAAcvF,mBAEpB8I,EAAK,GAAKwC,EAAKiF,iBACfzH,EAAK,GAAK,GAIdwC,EAAKyrB,YAEL/e,EAAIqa,OACJra,EAAIsa,YACAlnB,IAAU7F,EAAczD,UAAWkW,EAAIxB,KAAK,EAAG,EAAG1N,EAAK,GAAIA,EAAK,IAC3DsC,IAAU7F,EAAcxD,YAAaiW,EAAIoc,UAAU,EAAG,EAAGtrB,EAAK,GAAIA,EAAK,GAAI,IAC3EsC,IAAU7F,EAAcvD,cAC7BgW,EAAIsb,IACU,GAAVxqB,EAAK,GACK,GAAVA,EAAK,GACK,GAAVA,EAAK,GACL,EACU,EAAV0F,KAAK+kB,IAGbvb,EAAIua,QAIJjnB,EAAK0rB,aAAY9rB,EAAU,YAC1B+rB,cACD3rB,EACA0M,EACAlP,EACAmC,EACAC,EACAI,EAAKylB,YACLzlB,EAAKkhB,WAETxU,EAAIue,YAAc,cAGdjrB,EAAK2Y,kBACL3Y,EAAK2Y,iBAAiBjM,EAAKxR,KAAMA,KAAK+P,QAI1CyB,EAAIqc,UAAY7iB,EAAa,SAAW,OACxCwG,EAAI/C,KAAOzO,KAAKgb,oBAEV0V,GAAcN,EAEdO,EAAU3wB,KAAK+jB,kBACrBvS,EAAIkb,UAAY,MAEZkE,EAAO,EACLhJ,EAAU,IAAIxlB,aAAa,MAG5B0C,EAAKhC,MAAM+G,WAkJT,GAAI7J,KAAKgd,uBAAwB,KAIhC6T,EAFAC,EAAY,KACZC,EAAa,QAIbjsB,EAAKrC,OAAQ,WACMqC,EAAKrC,uCAAQ,KAArB2C,aACU,MAAbA,EAAK1B,MACTotB,EAAY1rB,EACZyrB,EAAazrB,4CAIjBN,EAAKpC,QAAS,WACKoC,EAAKpC,wCAAS,KAAtB0C,UACFA,EAAK3B,OAAU2B,EAAK3B,MAAMxB,SAC/B8uB,EAAa3rB,EACbyrB,EAAazrB,sCAIjB0rB,EAAW,KACPtnB,EAAI,EACJJ,GAAuC,GAAnCrK,EAAcvF,kBAClBwR,IACAxB,EAA4B,GAAxB1E,EAAKiF,iBACTX,GAAKrK,EAAcvF,mBAEvBgY,EAAIyb,UAAY,OAChBzb,EAAIsa,YACA+E,EAAWlyB,OAASI,EAAclD,OAC/Bg1B,EAAWjsB,QAAU7F,EAAczD,UACtCkW,EAAIxB,KAAKxG,EAAI,EAAI,GAAKJ,EAAI,EAAG,GAAI,GAC1BynB,EAAWjsB,QAAU7F,EAAcrD,aAC1C8V,EAAIwf,OAAOxnB,EAAI,EAAGJ,GAClBoI,EAAIyf,OAAOznB,GAAK,EAAGJ,EAAI,GACvBoI,EAAIyf,OAAOznB,GAAK,EAAGJ,EAAI,GACvBoI,EAAI0f,aACD1f,EAAIsb,IAAItjB,EAAGJ,EAAG,EAAG,EAAa,EAAVpB,KAAK+kB,IAChCvb,EAAIwb,UAGJ+D,EAAY,KACRvnB,EAAI1E,EAAKiF,iBACTX,GAAuC,GAAnCrK,EAAcvF,kBAClBwR,IACAxB,EAA4B,GAAxB1E,EAAKiF,iBACTX,EAAI,GAERoI,EAAIyb,UAAY,OAChBzb,EAAI0b,YAAc,QAClB1b,EAAIsa,YAEA+E,EAAWlyB,OAASI,EAAclD,OAC/Bg1B,EAAWjsB,QAAU7F,EAAczD,UAEtCkW,EAAIxB,KAAKxG,EAAI,EAAI,GAAKJ,EAAI,EAAG,GAAI,GAC1BhE,KAAKR,QAAU7F,EAAcrD,aACpC8V,EAAIwf,OAAOxnB,EAAI,EAAGJ,GAClBoI,EAAIyf,OAAOznB,EAAI,EAAGJ,EAAI,GACtBoI,EAAIyf,OAAOznB,EAAI,EAAGJ,EAAI,GACtBoI,EAAI0f,aACD1f,EAAIsb,IAAItjB,EAAGJ,EAAG,EAAG,EAAa,EAAVpB,KAAK+kB,IAChCvb,EAAIwb,aAnNe,IAEnBloB,EAAKrC,WACA,IAAIhE,EAAI,EAAGA,EAAIqG,EAAKrC,OAAOR,OAAQxD,IAAK,KACnC2G,EAAON,EAAKrC,OAAOhE,GAEzB+S,EAAImc,YAAc3tB,KAAK0b,aAEnB1b,KAAKuf,kBACD5d,EAAkByD,EAAKzG,KAAMgyB,EAAQhyB,QACzC6S,EAAImc,YAAc,GAAM3tB,KAAK0b,cAGjClK,EAAIyb,UAAY7nB,EAAK1B,KACf0B,EAAK+rB,UACJnxB,KAAKmb,yBAAyBE,SAC/BjW,EAAKgsB,WACJpxB,KAAKmb,yBAAyBC,cAE/Bhc,EAAM0F,EAAKmF,kBAAiB,EAAMxL,EAAGmpB,MAC3CxoB,EAAI,IAAM0F,EAAK1F,IAAI,GACnBA,EAAI,IAAM0F,EAAK1F,IAAI,GACfwxB,EAAOxxB,EAAI,GAAsC,GAAjCL,EAAcrF,mBAC9Bk3B,EAAOxxB,EAAI,GAAsC,GAAjCL,EAAcrF,kBAGlC8X,EAAIsa,YAEA1mB,EAAKzG,OAASI,EAAclD,OAASuJ,EAAKR,QAAU7F,EAAczD,UAC9D0P,EAAYwG,EAAIxB,KAAK5Q,EAAI,GAAK,EAAI,GAAKA,EAAI,GAAK,EAAI,GAAK,GAAI,IAC5DoS,EAAIxB,KAAK5Q,EAAI,GAAK,EAAI,GAAKA,EAAI,GAAK,EAAI,GAAK,GAAI,IAC/CgG,EAAKR,QAAU7F,EAAcrD,aACpC8V,EAAIwf,OAAO5xB,EAAI,GAAK,EAAGA,EAAI,GAAK,IAChCoS,EAAIyf,OAAO7xB,EAAI,GAAK,EAAGA,EAAI,GAAK,EAAI,IACpCoS,EAAIyf,OAAO7xB,EAAI,GAAK,EAAGA,EAAI,GAAK,EAAI,IACpCoS,EAAI0f,aACGd,EACP5e,EAAIxB,KAAK5Q,EAAI,GAAK,EAAGA,EAAI,GAAK,EAAG,EAAG,GAEpCoS,EAAIsb,IAAI1tB,EAAI,GAAIA,EAAI,GAAI,EAAG,EAAa,EAAV4I,KAAK+kB,IAEvCvb,EAAIwb,OAGA0D,EAAY,KACN/nB,EAAsB,OAAfvD,EAAKoD,MAAiBpD,EAAKoD,MAAQpD,EAAKjG,KACjDwJ,IACA6I,EAAIyb,UAAYluB,EAAc5E,gBAC1B6Q,GAAc5F,EAAKynB,MAAQ9tB,EAAc5C,GACzCqV,EAAIsc,SAASnlB,EAAMvJ,EAAI,GAAIA,EAAI,GAAK,IAEpCoS,EAAIsc,SAASnlB,EAAMvJ,EAAI,GAAK,GAAIA,EAAI,GAAK,QAQzDY,KAAKuf,kBACL/N,EAAImc,YAAc,GAAM3tB,KAAK0b,cAGjClK,EAAIqc,UAAY7iB,EAAa,SAAW,QACxCwG,EAAI0b,YAAc,QACdpoB,EAAKpC,YACA,IAAIjE,EAAI,EAAGA,EAAIqG,EAAKpC,QAAQT,OAAQxD,IAAK,KACpC2G,EAAON,EAAKpC,QAAQjE,GAEpBW,EAAM0F,EAAKmF,kBAAiB,EAAOxL,EAAGmpB,MAC5CxoB,EAAI,IAAM0F,EAAK1F,IAAI,GACnBA,EAAI,IAAM0F,EAAK1F,IAAI,GACfwxB,EAAOxxB,EAAI,GAAsC,GAAjCL,EAAcrF,mBAC9Bk3B,EAAOxxB,EAAI,GAAsC,GAAjCL,EAAcrF,kBAGlC8X,EAAIyb,UAAY7nB,EAAK3B,OAAS2B,EAAK3B,MAAMxB,OACnCmD,EAAK+rB,UACJnxB,KAAKmb,yBAAyBI,UAC/BnW,EAAKgsB,WACJpxB,KAAKmb,yBAAyBG,WACrC9J,EAAIsa,YAIA1mB,EAAKzG,OAASI,EAAclD,OACzBuJ,EAAKR,QAAU7F,EAAczD,UAE5B0P,EACAwG,EAAIxB,KACA5Q,EAAI,GAAK,EAAI,GACbA,EAAI,GAAK,EAAI,GACb,GACA,IAGJoS,EAAIxB,KACA5Q,EAAI,GAAK,EAAI,GACbA,EAAI,GAAK,EAAI,GACb,GACA,IAGDgG,EAAKR,QAAU7F,EAAcrD,aACpC8V,EAAIwf,OAAO5xB,EAAI,GAAK,EAAGA,EAAI,GAAK,IAChCoS,EAAIyf,OAAO7xB,EAAI,GAAK,EAAGA,EAAI,GAAK,EAAI,IACpCoS,EAAIyf,OAAO7xB,EAAI,GAAK,EAAGA,EAAI,GAAK,EAAI,IACpCoS,EAAI0f,aACGd,EACP5e,EAAIxB,KAAK5Q,EAAI,GAAK,EAAGA,EAAI,GAAK,EAAG,EAAG,GAEpCoS,EAAIsb,IAAI1tB,EAAI,GAAIA,EAAI,GAAI,EAAG,EAAa,EAAV4I,KAAK+kB,IAGvCvb,EAAIwb,OACCoD,GAAY5e,EAAI6f,SAGjBX,EAAY,KACN/nB,EAAqB,MAAdvD,EAAKoD,MAAgBpD,EAAKoD,MAAQpD,EAAKjG,KAChDwJ,IACA6I,EAAIyb,UAAYluB,EAAc5E,gBAC1B6Q,GAAc5F,EAAKynB,MAAQ9tB,EAAc3C,KACzCoV,EAAIsc,SAASnlB,EAAMvJ,EAAI,GAAIA,EAAI,GAAK,GAEpCoS,EAAIsc,SAASnlB,EAAMvJ,EAAI,GAAK,GAAIA,EAAI,GAAK,QAO7DoS,EAAIqc,UAAY,OAChBrc,EAAImc,YAAc,EAEd7oB,EAAKlB,QAAS,KACV0tB,EAAWV,GACX5lB,GAAclG,EAAK8D,cAAY0oB,EAAW,GACjB,OAAzBxsB,EAAK+D,kBAA0ByoB,EAAWxsB,EAAK+D,sBAC9C0oB,gBACDzsB,EACAwsB,EACA9f,EACAxR,KAAKoe,aAAepe,KAAKoe,YAAY,KAAOtZ,EAAO9E,KAAKoe,YAAY,GAAK,OAyEjFtZ,EAAKyrB,WAAW/e,EAAIma,UAExBna,EAAImc,YAAc,kCAItB,SAAgBnc,EAAK9N,OACXtE,EAAMsE,EAAKX,QACjByO,EAAIyb,UAAY,QAChBzb,EAAIsa,YACJta,EAAIsb,IAAI1tB,EAAI,GAAIA,EAAI,GAAI,EAAG,EAAa,EAAV4I,KAAK+kB,IACnCvb,EAAIwb,SAEa,MAAbtpB,EAAKsB,MAELhF,KAAK2d,mBAAqB3d,KAAK2d,kBAAkBnM,EAAK9N,EAAM1D,YAG5D2I,EADI3D,EAAStB,EAATsB,QAGyB2D,EAA7B3D,EAAKvE,cAAgB0J,OAAenF,EAAK6N,QAAQ,GAC5C7N,EAAKvE,cAAgBC,kBAAmBsE,OACxCA,EAAKvE,cAAgBiB,QAAgBhB,OAAOsE,GAC5CA,EAAKwsB,UAAkBxsB,EAAKwsB,uBACrBxsB,EAAKvE,YAAYtB,WAGjCwJ,EAAOA,EAAKpJ,OAAO,EAAG,IAEtBiS,EAAI/C,KAAO,uBAELtJ,EADOqM,EAAI6c,YAAY1lB,GACd6G,MAAQ,GAEvBgC,EAAIue,YAAc,QAClBve,EAAIwe,cAAgB,EACpBxe,EAAIye,cAAgB,EACpBze,EAAI0e,WAAa,EACjB1e,EAAIyb,UAAY,OAChBzb,EAAIsa,YACJta,EAAIoc,UAAUxuB,EAAI,GAAS,GAAJ+F,EAAS/F,EAAI,GAAK,GAP/B,GAOuC+F,EAPvC,GAO6C,EAAG,GAC1DqM,EAAIwf,OAAO5xB,EAAI,GAAK,GAAIA,EAAI,GAAK,IACjCoS,EAAIyf,OAAO7xB,EAAI,GAAK,GAAIA,EAAI,GAAK,IACjCoS,EAAIyf,OAAO7xB,EAAI,GAAIA,EAAI,GAAK,GAC5BoS,EAAIwb,OACJxb,EAAIue,YAAc,cAClBve,EAAIqc,UAAY,SAChBrc,EAAIyb,UAAY,OAChBzb,EAAIsc,SAASnlB,EAAMvJ,EAAI,GAAIA,EAAI,GAAK,GAf1B,GAemC,mCAOjD,SACI0F,EACA0M,EACAlP,EACAmvB,EACA/sB,EACAgT,EACAga,GAGAlgB,EAAI0b,YAAcuE,EAClBjgB,EAAIyb,UAAYvoB,MAEVijB,EAAc5oB,EAAcvF,kBAC5B42B,EAAapwB,KAAKqX,GAAG7K,MAAQ,GAG7B5H,EAAQE,EAAK7E,QAAU6E,EAAKrE,YAAYmE,OAAS7F,EAAcxD,YAE7Do2B,EAAe7sB,EAAKrE,YAApBkxB,WAEJC,GAAc,EACdD,IAAe5yB,EAAclC,kBAAmB+0B,GAAc,EACzDD,IAAe5yB,EAAcjC,gBAAkB40B,IAAYE,GAAc,OAE5EC,EAAOnb,EACbmb,EAAK,GAAK,EACVA,EAAK,GAAKD,GAAejK,EAAc,EACvCkK,EAAK,GAAKvvB,EAAK,GAAK,EACpBuvB,EAAK,GAAKD,EAActvB,EAAK,GAAKqlB,EAAcrlB,EAAK,OAE/CwvB,EAAWtgB,EAAImc,eAErBnc,EAAIsa,YACAlnB,IAAU7F,EAAczD,WAAa80B,EACrC5e,EAAIoe,SAASiC,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAIA,EAAK,IACtCjtB,IAAU7F,EAAcxD,aAAeqJ,IAAU7F,EAActD,WACtE+V,EAAIoc,UACAiE,EAAK,GACLA,EAAK,GACLA,EAAK,GACLA,EAAK,GACL7xB,KAAKke,aACLtZ,IAAU7F,EAActD,WAAa,EAAIuE,KAAKke,cAE3CtZ,IAAU7F,EAAcvD,cAC/BgW,EAAIsb,IACU,GAAVxqB,EAAK,GACK,GAAVA,EAAK,GACK,GAAVA,EAAK,GACL,EACU,EAAV0F,KAAK+kB,IAGbvb,EAAIwb,OAGCloB,EAAKhC,MAAM+G,YACZ2H,EAAIue,YAAc,cAClBve,EAAIyb,UAAY,kBAChBzb,EAAIoe,SAAS,GAAI,EAAGiC,EAAK,GAAI,IAEjCrgB,EAAIue,YAAc,cAEdjrB,EAAK0Y,kBAAkB1Y,EAAK0Y,iBAAiBhM,EAAKxR,KAAMA,KAAK+P,OAAQ/P,KAAKsd,aAG1EsU,GAAeD,IAAe5yB,EAAclC,kBAAmB,IAE3DiI,EAAKitB,eACLjtB,EAAKitB,eAAevgB,EAAKmW,EAAarlB,EAAMtC,KAAKqX,GAAG7K,MAAOilB,QACxD,GACHE,IAAe5yB,EAAclC,oBACzBiI,EAAKrE,YAAYuxB,aAAehyB,KAAKkd,sBAC3C,KACQ+U,EAAantB,EAAKrE,YAAYuxB,aAAeP,KAE/C3sB,EAAKhC,MAAM+G,YACX2H,EAAIue,YAAchxB,EAAcrE,sBAIhCsF,KAAKyb,cAAe,KAChByW,EAAO1kB,EAAa2kB,UAAUF,GAC7BC,IACDA,EAAO1gB,EAAI4gB,qBAAqB,EAAG,EAAG,IAAK,GAC3C5kB,EAAa2kB,UAAUF,GAAcC,EACrCA,EAAKG,aAAa,EAAGJ,GACrBC,EAAKG,aAAa,EAAG,SAEzB7gB,EAAIyb,UAAYiF,OAEhB1gB,EAAIyb,UAAYgF,EAIpBzgB,EAAIsa,YACAlnB,IAAU7F,EAAczD,WAAa80B,EACrC5e,EAAIxB,KAAK,GAAI2X,EAAarlB,EAAK,GAAK,EAAGqlB,GAChC/iB,IAAU7F,EAAcxD,aAAeqJ,IAAU7F,EAActD,YACtE+V,EAAIoc,UACA,GACCjG,EACDrlB,EAAK,GAAK,EACVqlB,EACA3nB,KAAKke,aACLpZ,EAAKhC,MAAM+G,UAAY7J,KAAKke,aAAe,GAGnD1M,EAAIwb,OACJxb,EAAIue,YAAc,kBAIhBuC,EAAU,MACZxtB,EAAKytB,eACLztB,EAAKytB,eAAe/gB,EAAKmW,EAAarlB,EAAMtC,KAAKqX,GAAG7K,OAC7C,CAACzN,EAAcxD,YAAawD,EAAcvD,aAAcuD,EAActD,YAAY+2B,SAAS5tB,IAC9FwrB,IACA5e,EAAIyb,UAAY,QAChBzb,EAAIsa,YACJta,EAAIsb,IACc,GAAdnF,GACe,GAAfA,EACA2K,EACA,EACU,EAAVtqB,KAAK+kB,IAETvb,EAAIwb,QAGRxb,EAAIyb,UAAYnoB,EAAKH,UAAY5F,EAAcxE,sBAC3C61B,EAAY5e,EAAIoe,SAAuB,GAAdjI,EAAoB2K,GAA8B,GAAf3K,EAAqB2K,EAAeA,EAASA,IAEzG9gB,EAAIsa,YACJta,EAAIsb,IACc,GAAdnF,GACe,GAAfA,EACA2K,EACA,EACU,EAAVtqB,KAAK+kB,IAETvb,EAAIwb,UAGJoD,IACA5e,EAAIyb,UAAY,QAChBzb,EAAIoe,SAC0B,IAAzBjI,EAAc2K,GAAiB,GACL,IAA1B3K,EAAc2K,GAAkB,EACjCA,GACAA,KAGR9gB,EAAIyb,UAAYnoB,EAAKH,UAAY5F,EAAcxE,sBAC/CiX,EAAIoe,SAC0B,IAAzBjI,EAAc2K,IACY,IAA1B3K,EAAc2K,GACfA,EACAA,IAGR9gB,EAAImc,YAAcmE,EAGdhtB,EAAK2tB,iBACL3tB,EAAK2tB,gBACDjhB,EACAmW,EACArlB,EACAtC,KAAKqX,GAAG7K,MACRxM,KAAK+a,gBACLrD,IAGH0Y,EAAY,CACb5e,EAAI/C,KAAOzO,KAAK+a,oBACVvb,EAAQkB,OAAOoE,EAAKmqB,YACtBzvB,IACcgS,EAAIyb,UAAdvV,EAA0B3Y,EAAc9E,0BACvB6K,EAAKrE,YAAYiyB,kBAAoB1yB,KAAKib,iBAC3DnW,EAAKhC,MAAM+G,WACX2H,EAAIqc,UAAY,OACArc,EAAI6c,YAAY7uB,GAChCgS,EAAIsc,SACAtuB,EAAMD,OAAO,EAAG,IAChBooB,EACA5oB,EAActF,kBAAoBkuB,GAEtCnW,EAAIqc,UAAY,SAEhBrc,EAAIqc,UAAY,OAChBrc,EAAIsc,SACAtuB,EACAmoB,EACA5oB,EAActF,kBAAoBkuB,SAO7C7iB,EAAKhC,MAAM+G,WAAa/E,EAAK+f,WAAa/f,EAAKggB,qBAAsB,KAChE3f,EAAIpG,EAAcvF,kBAClBgQ,EAAI1E,EAAKxC,KAAK,GAAK6C,EACnBwtB,EAAO7oB,EACT9J,KAAKsd,YAAY,GAAKxY,EAAK1F,IAAI,GAC/BY,KAAKsd,YAAY,GAAKxY,EAAK1F,IAAI,GAC/BoK,EAAI,EACC,EAAJrE,EACDA,EAAI,EACJA,EAAI,GAERqM,EAAIyb,UAAY0F,EAAO,OAAS,OAC5B/tB,IAAU7F,EAAczD,WAAa80B,EACrC5e,EAAIoe,SAASpmB,EAAI,EAAQ,EAAJrE,EAAOA,EAAI,EAAGA,EAAI,IAEvCqM,EAAIsa,YACJta,EAAIoc,UAAUpkB,EAAI,EAAQ,EAAJrE,EAAOA,EAAI,EAAGA,EAAI,EAAG,GAC3CqM,EAAIwb,QAERxb,EAAIyb,UAAY,OAChBzb,EAAIsa,YACJta,EAAIwf,OAAOxnB,EAAQ,GAAJrE,EAAc,IAAJA,GACzBqM,EAAIyf,OAAOznB,EAAQ,GAAJrE,EAAc,IAAJA,GACzBqM,EAAIyf,OAAOznB,EAAQ,GAAJrE,EAAc,IAAJA,GACzBqM,EAAIwb,OAIJloB,EAAK8tB,aAAa9tB,EAAK8tB,YAAYphB,GAIvCkG,IACI5S,EAAKyE,YAAYzE,EAAKyE,WAAWsoB,GAEjCF,IAAe5yB,EAAclC,oBAC7Bg1B,EAAK,IAAMlK,EACXkK,EAAK,IAAMlK,GAEfnW,EAAIkb,UAAY,EAChBlb,EAAImc,YAAc,GAClBnc,EAAIsa,YACAlnB,IAAU7F,EAAczD,UACxBkW,EAAIxB,MACC,EAAI6hB,EAAK,IACT,EAAIA,EAAK,GACV,GAAKA,EAAK,GACV,GAAKA,EAAK,IAGdjtB,IAAU7F,EAAcxD,aACpBqJ,IAAU7F,EAActD,YAAcqJ,EAAKhC,MAAM+G,UAErD2H,EAAIoc,WACC,EAAIiE,EAAK,IACT,EAAIA,EAAK,GACV,GAAKA,EAAK,GACV,GAAKA,EAAK,GACU,EAApB7xB,KAAKke,cAEFtZ,IAAU7F,EAActD,WAC/B+V,EAAIoc,WACC,EAAIiE,EAAK,IACT,EAAIA,EAAK,GACV,GAAKA,EAAK,GACV,GAAKA,EAAK,GACU,EAApB7xB,KAAKke,aACL,GAEGtZ,IAAU7F,EAAcvD,cAC/BgW,EAAIsb,IACU,GAAVxqB,EAAK,GACK,GAAVA,EAAK,GACK,GAAVA,EAAK,GAAW,EAChB,EACU,EAAV0F,KAAK+kB,IAGbvb,EAAI0b,YAAcnuB,EAActE,uBAChC+W,EAAI6f,SACJ7f,EAAI0b,YAAcuE,EAClBjgB,EAAImc,YAAc,kCAS1B,SAAgBnc,OACN3T,EAAMF,IACJuR,EAAiBlP,KAAjBkP,aACRyH,EAAW,GAAKzH,EAAa,GAAK,GAClCyH,EAAW,GAAKzH,EAAa,GAAK,GAClCyH,EAAW,GAAKzH,EAAa,GAAK,GAClCyH,EAAW,GAAKzH,EAAa,GAAK,GAGlCsC,EAAIkb,UAAY1sB,KAAKie,kBAErBzM,EAAIyb,UAAY,OAChBzb,EAAI0b,YAAc,OAClB1b,EAAImc,YAAc3tB,KAAK0b,uBAET1b,KAAKuC,MAAMwL,uCACC,KAAfjJ,aAGFA,EAAKrC,QAAWqC,EAAKrC,OAAOR,WAI5B,IAAIxD,EAAI,EAAGA,EAAIqG,EAAKrC,OAAOR,SAAUxD,EAAG,KACnC8E,EAAQuB,EAAKrC,OAAOhE,MACrB8E,GAAuB,MAAdA,EAAMG,UAEdmvB,EAAStvB,EAAMG,KACfA,EAAO1D,KAAKuC,MAAMkB,MAAMovB,MACzBnvB,OAGCovB,EAAY9yB,KAAKuC,MAAMiD,YAAY9B,EAAK+B,cACzCqtB,OAECC,EAAgBrvB,EAAKiC,YACvBqtB,EAAmB,KAEnBA,GADmB,IAAnBD,EACmB,CACfD,EAAU1zB,IAAI,GAAK,GACnB0zB,EAAU1zB,IAAI,GAAK,IAGJ0zB,EAAU7oB,kBACzB,EACA8oB,EACAlc,OAIFoc,EAAiBnuB,EAAKmF,kBAAiB,EAAMxL,EAAGqY,MAGtDF,EAAa,GAAKoc,EAAiB,GACnCpc,EAAa,GAAKoc,EAAiB,GACnCpc,EAAa,GAAKqc,EAAe,GAAKD,EAAiB,GACvDpc,EAAa,GAAKqc,EAAe,GAAKD,EAAiB,GAEnDpc,EAAa,GAAK,IAClBA,EAAa,IAAMA,EAAa,GAChCA,EAAa,GAAK5O,KAAK6J,IAAI+E,EAAa,KAExCA,EAAa,GAAK,IAClBA,EAAa,IAAMA,EAAa,GAChCA,EAAa,GAAK5O,KAAK6J,IAAI+E,EAAa,KAIvCzI,EAAgByI,EAAcD,QAI7Buc,EAAYJ,EAAUpwB,QAAQqwB,GAC9BI,EAAUruB,EAAKrC,OAAOhE,MACvBy0B,GAAcC,OACbC,EAAWF,EAAUrG,MACnBiG,EAAU9nB,WAAajM,EAAc3C,KAAO2C,EAAczC,OAC5D+2B,EAASF,EAAQtG,MACf/nB,EAAKkG,WAAajM,EAAc5C,GAAK4C,EAAc1C,cAEtDuwB,WACDpb,EACAwhB,EACAC,EACAvvB,GACA,EACA,EACA,KACA0vB,EACAC,GAIA3vB,GAAQA,EAAKgD,YAAc7I,EAAM6F,EAAKgD,WAAa,IAAM,KACnD4sB,EAAI,EAAgC,MAAzBz1B,EAAM6F,EAAKgD,YACtB6sB,EAAM/hB,EAAImc,YAChBnc,EAAImc,YAAc4F,EAAMD,OACnB1G,WACDpb,EACAwhB,EACAC,EACAvvB,GACA,EACA4vB,EACA,QACAF,EACAC,GAEJ7hB,EAAImc,YAAc4F,wCAI9B/hB,EAAImc,YAAc,4BAgBtB,SACInc,EACA2E,EACA5H,EACA7K,EACA8vB,EACAC,EACAhvB,EACA2uB,EACAC,EACAK,GAEIhwB,GAAM1D,KAAKue,cAAcvd,KAAK0C,IAG7Be,GAASf,IAAMe,EAAQf,EAAKe,OAAS+I,EAAammB,iBAAiBjwB,EAAK/E,OACxE8F,IAAOA,EAAQzE,KAAKkb,oBACb,MAARxX,GAAgB1D,KAAKwf,kBAAkB9b,EAAKlB,MAAKiC,EAAQ,QAE7D2uB,EAAWA,GAAYr0B,EAAczC,MACrC+2B,EAASA,GAAUt0B,EAAc1C,SAE3Bu3B,EAAOvO,SAASlP,EAAG5H,GAErBvO,KAAK6c,2BAA6B7c,KAAKqX,GAAG7K,MAAQ,KAClDgF,EAAIkb,UAAY1sB,KAAKie,kBAAoB,GAE7CzM,EAAIqiB,SAAW,SACfH,EAAaA,GAAc,GACV,IAAGliB,EAAIkb,UAAY,IAGpClb,EAAIsa,gBACC,IAAIrtB,EAAI,EAAGA,EAAIi1B,EAAYj1B,GAAK,EAAG,KAC9Bq1B,EAAyC,GAA9Br1B,EAAuB,IAAlBi1B,EAAa,OAE/B1zB,KAAKod,oBAAsBre,EAAcrC,YAAa,CACtD8U,EAAIwf,OAAO7a,EAAE,GAAIA,EAAE,GAAK2d,OACpBC,EAAe,EACfC,EAAe,EACfC,EAAa,EACbC,EAAa,SACTd,QACCr0B,EAAc1C,KACf03B,GAAuB,IAARH,aAEd70B,EAAczC,MACfy3B,EAAsB,IAAPH,aAEd70B,EAAc5C,GACf63B,GAAuB,IAARJ,aAEd70B,EAAc3C,KACf43B,EAAsB,IAAPJ,SAKfP,QACCt0B,EAAc1C,KACf43B,GAAqB,IAARL,aAEZ70B,EAAczC,MACf23B,EAAoB,IAAPL,aAEZ70B,EAAc5C,GACf+3B,GAAqB,IAARN,aAEZ70B,EAAc3C,KACf83B,EAAoB,IAAPN,EAKrBpiB,EAAI2iB,cACAhe,EAAE,GAAK4d,EACP5d,EAAE,GAAK6d,EAAeF,EACtBvlB,EAAE,GAAK0lB,EACP1lB,EAAE,GAAK2lB,EAAaJ,EACpBvlB,EAAE,GACFA,EAAE,GAAKulB,QAER,GAAI9zB,KAAKod,oBAAsBre,EAActC,YAAa,CAC7D+U,EAAIwf,OAAO7a,EAAE,GAAIA,EAAE,GAAK2d,OACpBC,EAAe,EACfC,EAAe,EACfC,EAAa,EACbC,EAAa,SACTd,QACCr0B,EAAc1C,KACf03B,GAAgB,aAEfh1B,EAAczC,MACfy3B,EAAe,aAEdh1B,EAAc5C,GACf63B,GAAgB,aAEfj1B,EAAc3C,KACf43B,EAAe,SAKfX,QACCt0B,EAAc1C,KACf43B,GAAc,aAEbl1B,EAAczC,MACf23B,EAAa,aAEZl1B,EAAc5C,GACf+3B,GAAc,aAEbn1B,EAAc3C,KACf83B,EAAa,EAMrB1iB,EAAIyf,OACA9a,EAAE,GAFI,GAEC4d,EACP5d,EAAE,GAHI,GAGC6d,EAAmBF,GAE9BtiB,EAAIyf,OACA1iB,EAAE,GANI,GAMC0lB,EACP1lB,EAAE,GAPI,GAOC2lB,EAAiBJ,GAE5BtiB,EAAIyf,OAAO1iB,EAAE,GAAIA,EAAE,GAAKulB,OACrB,CAAA,GAAI9zB,KAAKod,oBAAsBre,EAAcvC,cAiB7C,OAhBHgV,EAAIwf,OAAO7a,EAAE,GAAIA,EAAE,QACfie,EAASje,EAAE,GACXke,EAASle,EAAE,GACXme,EAAO/lB,EAAE,GACTgmB,EAAOhmB,EAAE,GAET6kB,IAAar0B,EAAczC,MAAO83B,GAAU,GAC3CC,GAAU,GACXhB,IAAWt0B,EAAc1C,KAAMi4B,GAAQ,GACtCC,GAAQ,GAEb/iB,EAAIyf,OAAOmD,EAAQC,GACnB7iB,EAAIyf,OAAyB,IAAjBmD,EAASE,GAAaD,GAClC7iB,EAAIyf,OAAyB,IAAjBmD,EAASE,GAAaC,GAClC/iB,EAAIyf,OAAOqD,EAAMC,GACjB/iB,EAAIyf,OAAO1iB,EAAE,GAAIA,EAAE,KAKvBvO,KAAK6c,2BAA6B7c,KAAKqX,GAAG7K,MAAQ,KAAQgnB,IAC1DhiB,EAAI0b,YAAc,kBAClB1b,EAAI6f,UAGR7f,EAAIkb,UAAY1sB,KAAKie,kBACrBzM,EAAIyb,UAAYxoB,EAChB+M,EAAI0b,YAAczoB,EAClB+M,EAAI6f,aAGEmD,EAAqBx0B,KAAKy0B,uBAAuBte,EAAG5H,EAAG,GAAK6kB,EAAUC,MACxE3vB,GAAQA,EAAKX,OACbW,EAAKX,KAAK,GAAKyxB,EAAmB,GAClC9wB,EAAKX,KAAK,GAAKyxB,EAAmB,IAIlCx0B,KAAKqX,GAAG7K,OAAS,IAAOxM,KAAKwb,oBAAsB6X,IAAWt0B,EAAcxC,OAAQ,IAEhFyD,KAAK+c,yBAA0B,KAEzB2X,EAAO10B,KAAKy0B,uBAAuBte,EAAG5H,EAAG,IAAM6kB,EAAUC,GACzDsB,EAAO30B,KAAKy0B,uBAAuBte,EAAG5H,EAAG,IAAM6kB,EAAUC,GACzDuB,EAAO50B,KAAKy0B,uBAAuBte,EAAG5H,EAAG,IAAM6kB,EAAUC,GACzDwB,EAAO70B,KAAKy0B,uBAAuBte,EAAG5H,EAAG,IAAM6kB,EAAUC,GAG3DyB,EAAS,EACTC,EAAS,EACT/0B,KAAK8c,2BACLgY,GAAU9sB,KAAKgtB,MAAML,EAAK,GAAKD,EAAK,GAAIC,EAAK,GAAKD,EAAK,IACvDK,GAAU/sB,KAAKgtB,MAAMH,EAAK,GAAKD,EAAK,GAAIC,EAAK,GAAKD,EAAK,KACpDG,EAASD,EAASvmB,EAAE,GAAK4H,EAAE,GAAK,EAAInO,KAAK+kB,GAGhDvb,EAAIqa,OACJra,EAAIC,UAAUijB,EAAK,GAAIA,EAAK,IAC5BljB,EAAIyjB,OAAOH,GACXtjB,EAAIsa,YACJta,EAAIwf,QAAQ,GAAI,GAChBxf,EAAIyf,OAAO,EAAG,GACdzf,EAAIyf,OAAO,GAAI,GACfzf,EAAIwb,OACJxb,EAAIma,UACJna,EAAIqa,OACJra,EAAIC,UAAUmjB,EAAK,GAAIA,EAAK,IAC5BpjB,EAAIyjB,OAAOF,GACXvjB,EAAIsa,YACJta,EAAIwf,QAAQ,GAAI,GAChBxf,EAAIyf,OAAO,EAAG,GACdzf,EAAIyf,OAAO,GAAI,GACfzf,EAAIwb,OACJxb,EAAIma,UAIRna,EAAIsa,YACJta,EAAIsb,IAAI1tB,IAAI,GAAIA,IAAI,GAAI,EAAG,EAAa,EAAV4I,KAAK+kB,IACnCvb,EAAIwb,UAIJyG,EAAM,CACNjiB,EAAIyb,UAAYxoB,MACX,IAAIhG,EAAI,EAAGA,EAAI,IAAKA,EAAG,KAClB60B,GAAiB,KAAZ31B,IAAwB,GAAJc,GAAW,EACpCW,EAAMY,KAAKy0B,uBAAuBte,EAAG5H,EAAG+kB,EAAGF,EAAUC,GAC3D7hB,EAAIsa,YACJta,EAAIsb,IAAI1tB,EAAI,GAAIA,EAAI,GAAI,EAAG,EAAG,EAAI4I,KAAK+kB,IACvCvb,EAAIwb,+CAehB,SAAuB7W,EAAG5H,EAAGvQ,OAAGo1B,yDAAWr0B,EAAczC,MAAO+2B,yDAASt0B,EAAc1C,KAC7Eu3B,EAAOvO,SAASlP,EAAG5H,GACnB2mB,EAAK/e,EACLgf,EAAK,CAAChf,EAAE,GAAIA,EAAE,IACdif,EAAK,CAAC7mB,EAAE,GAAIA,EAAE,IACd8mB,EAAK9mB,SAEH6kB,QACCr0B,EAAc1C,KACf84B,EAAG,KAAc,IAARvB,aAER70B,EAAczC,MACf64B,EAAG,IAAa,IAAPvB,aAER70B,EAAc5C,GACfg5B,EAAG,KAAc,IAARvB,aAER70B,EAAc3C,KACf+4B,EAAG,IAAa,IAAPvB,SAKTP,QACCt0B,EAAc1C,KACf+4B,EAAG,KAAc,IAARxB,aAER70B,EAAczC,MACf84B,EAAG,IAAa,IAAPxB,aAER70B,EAAc5C,GACfi5B,EAAG,KAAc,IAARxB,aAER70B,EAAc3C,KACfg5B,EAAG,IAAa,IAAPxB,MAMX0B,GAAM,EAAIt3B,IAAM,EAAIA,IAAM,EAAIA,GAC9Bu3B,GAAW,EAAIv3B,IAAM,EAAIA,GAApB,EAA0BA,EAC/Bw3B,EAAK,GAAK,EAAIx3B,IAAMA,EAAIA,GACxBy3B,EAAKz3B,EAAIA,EAAIA,EAEbwL,EAAI8rB,EAAKJ,EAAG,GAAKK,EAAKJ,EAAG,GAAKK,EAAKJ,EAAG,GAAKK,EAAKJ,EAAG,GACnDjsB,EAAIksB,EAAKJ,EAAG,GAAKK,EAAKJ,EAAG,GAAKK,EAAKJ,EAAG,GAAKK,EAAKJ,EAAG,SAClD,CAAC7rB,EAAGJ,qCAGf,SAAmBoI,GACfA,EAAIue,YAAc,cAClBve,EAAImc,YAAc,IAElBnc,EAAIqc,UAAY,SAChBrc,EAAI0b,YAAc,QAClB1b,EAAImc,YAAc,cAEQ3tB,KAAlBof,8CAC0B,KAAvBta,UACP0M,EAAIyb,UAAY,QAChBzb,EAAIoe,SACA9qB,EAAK1F,IAAI,GAAKL,EAAcvF,kBAC5BsL,EAAK1F,IAAI,GAAKL,EAAcvF,kBAC5BuF,EAAcvF,kBACduF,EAAcvF,mBAEC,IAAfsL,EAAKV,OACLoN,EAAI2b,WACAroB,EAAK1F,IAAI,GAAKL,EAAcvF,kBAAoB,GAChDsL,EAAK1F,IAAI,GAAKL,EAAcvF,kBAAoB,GAChDuF,EAAcvF,kBACduF,EAAcvF,mBAGtBgY,EAAIyb,UAAY,OAChBzb,EAAIsc,SACAhpB,EAAKV,MACLU,EAAK1F,IAAI,IAAwC,GAAnCL,EAAcvF,kBAC5BsL,EAAK1F,IAAI,GAAK,kCAGtBoS,EAAImc,YAAc,iCAOtB,SAAgB7oB,EAAM4wB,EAAMlkB,EAAKmkB,OACxB7wB,EAAKlB,UAAYkB,EAAKlB,QAAQ3B,OAAQ,OAAO,MAC5CuN,EAAQ1K,EAAKxC,KAAK,GAChBsB,EAAYkB,EAAZlB,QACR8xB,GAAQ,MACFE,EAAI72B,EAAcpF,mBAClBk8B,EAAW71B,KAAKqX,GAAG7K,MAAQ,GACjCgF,EAAIqa,OACJra,EAAImc,YAAc3tB,KAAK0b,mBACjBoa,EAAe/2B,EAAclE,qBAC7Bk7B,EAAkBh3B,EAAcnE,eAChCo7B,EAAYj3B,EAAcjE,kBAC1Bm7B,EAAqBl3B,EAAchE,4BACnC0O,EAAS,OAEC7F,kCAAS,KAAduB,UACHiE,EAAIssB,EACJvwB,EAAEiE,IAAGA,EAAIjE,EAAEiE,GACfjE,EAAE+wB,OAAS9sB,EACXoI,EAAI0b,YAAc4I,EAClBtkB,EAAIyb,UAAY,OAChBzb,EAAIqc,UAAY,OAEZ1oB,EAAE8O,WAAUzC,EAAImc,aAAe,QAC7BwI,EAAchxB,EAAEqK,OAASA,SAEvBrK,EAAExG,UACD,SACGwG,EAAEupB,UACFld,EAAIyb,UAAY,OAChB9nB,EAAEupB,SAAU,OACPpU,cAAe,GAExB9I,EAAIoe,SAASnmB,EAAQL,EAAG+sB,EAAc1sB,GAAYmsB,GAC9CC,IAAa1wB,EAAE8O,UAAUzC,EAAI2b,WAAW1jB,EAAQL,EAAG+sB,EAAc1sB,GAAYmsB,GAC7EC,IACArkB,EAAIqc,UAAY,SAChBrc,EAAIyb,UAAY+I,EAChBxkB,EAAIsc,SAAS3oB,EAAEhG,KAAoB,GAAdg3B,EAAmB/sB,EAAQ,GAAJwsB,cAG/C,SACDpkB,EAAIqc,UAAY,OAChBrc,EAAI0b,YAAc4I,EAClBtkB,EAAIyb,UAAY8I,EAChBvkB,EAAIsa,YAEA+J,EAAUrkB,EAAIoc,UAAUnkB,EAAQisB,EAAMS,EAAc1sB,GAAYmsB,EAAO,GAAJA,GAClEpkB,EAAIxB,KAAKvG,EAAQisB,EAAMS,EAAc1sB,GAAYmsB,GAEtDpkB,EAAIwb,OACA6I,IAAa1wB,EAAE8O,UAAUzC,EAAI6f,SACjC7f,EAAIyb,UAAY9nB,EAAEnB,MAAQ,OAAS,OACnCwN,EAAIsa,YACJta,EAAIsb,IAAIqJ,EAAc1sB,GAAYL,EAAQ,GAAJwsB,EAAa,IAAJA,EAAU,EAAa,EAAV5tB,KAAK+kB,IACjEvb,EAAIwb,OACA6I,IACArkB,EAAIyb,UAAYgJ,EACZ9wB,EAAEhG,MAAMqS,EAAIsc,SAAS3oB,EAAEhG,KAAMsK,GAAYL,EAAQ,GAAJwsB,GACjDpkB,EAAIyb,UAAY9nB,EAAEnB,MAAQgyB,EAAYC,EACtCzkB,EAAIqc,UAAY,QAChBrc,EAAIsc,SACA3oB,EAAEnB,MACImB,EAAErB,QAAQsyB,IAAM,OAChBjxB,EAAErB,QAAQuyB,KAAO,QACvBF,EAAc,GACd/sB,EAAQ,GAAJwsB,cAIX,SACDpkB,EAAIyb,UAAY8I,EAChBvkB,EAAIoe,SAASnmB,EAAQL,EAAG+sB,EAAc1sB,GAAYmsB,OAC9CU,EAAQnxB,EAAErB,QAAQmE,IAAM9C,EAAErB,QAAQwsB,IAClCiG,GAAUpxB,EAAEnB,MAAQmB,EAAErB,QAAQwsB,KAAOgG,KACzC9kB,EAAIyb,UAAY0I,IAAkBxwB,EAAI,OAAS,OAC/CqM,EAAIoe,SAASnmB,EAAQL,EAAGmtB,GAAUJ,EAAc1sB,IAAamsB,GACzDC,IAAa1wB,EAAE8O,UAAUzC,EAAI2b,WAAW1jB,EAAQL,EAAG+sB,EAAc1sB,GAAYmsB,GAC7EzwB,EAAEqxB,OAAQ,KACJC,GAAiBtxB,EAAEqxB,OAASrxB,EAAErB,QAAQwsB,KAAOgG,EACnD9kB,EAAIyb,UAAY,OAChBzb,EAAIoe,SAASnmB,EAASgtB,GAAiBN,EAAc1sB,IAAaL,EAAG,EAAGwsB,GAExEC,IACArkB,EAAIqc,UAAY,SAChBrc,EAAIyb,UAAY+I,EAChBxkB,EAAIsc,mBACG3oB,EAAEhG,kBAASgL,OAAOhF,EAAEnB,OAClB6O,QAAQ,IACC,GAAdsjB,EACA/sB,EAAQ,GAAJwsB,cAIX,aACA,WACDpkB,EAAIqc,UAAY,OAChBrc,EAAI0b,YAAc4I,EAClBtkB,EAAIyb,UAAY8I,EAChBvkB,EAAIsa,YACA+J,EAAUrkB,EAAIoc,UAAUnkB,EAAQisB,EAAMS,EAAc1sB,GAAYmsB,EAAO,GAAJA,GAClEpkB,EAAIxB,KAAKvG,EAAQisB,EAAMS,EAAc1sB,GAAYmsB,GACtDpkB,EAAIwb,OACA6I,KACK1wB,EAAE8O,UAAUzC,EAAI6f,SACrB7f,EAAIyb,UAAY+I,EACX7wB,EAAE8O,WACHzC,EAAIsa,YACJta,EAAIwf,OAAOvnB,GAAaisB,EAAO,GAC/BlkB,EAAIyf,OAAOxnB,GAAYisB,EAAW,GAAJE,GAC9BpkB,EAAIyf,OAAOxnB,GAAaisB,EAAOE,EAAI,GACnCpkB,EAAIwb,OACJxb,EAAIsa,YACJta,EAAIwf,OAAOmF,EAAc1sB,EAAS,GAAIisB,EAAO,GAC7ClkB,EAAIyf,OAAOkF,EAAc1sB,EAAS,EAAGisB,EAAW,GAAJE,GAC5CpkB,EAAIyf,OAAOkF,EAAc1sB,EAAS,GAAIisB,EAAOE,EAAI,GACjDpkB,EAAIwb,QAERxb,EAAIyb,UAAYgJ,EAChBzkB,EAAIsc,SAAS3oB,EAAEhG,KAAMsK,GAAgBL,EAAQ,GAAJwsB,GACzCpkB,EAAIyb,UAAY+I,EAChBxkB,EAAIqc,UAAY,QACD,WAAX1oB,EAAExG,KACF6S,EAAIsc,SACA3jB,OAAOhF,EAAEnB,OACJ6O,aAC2B1J,IAAxBhE,EAAErB,QAAQ4yB,UACJvxB,EAAErB,QAAQ4yB,UACV,GAEdP,EAAc1sB,GAAa,GAC3BL,EAAQ,GAAJwsB,OAEL,KACC71B,EAAIoF,EAAEnB,SACNmB,EAAErB,QAAQuF,OAAQ,KACZA,EAAWlE,EAAErB,QAAbuF,OACFA,EAAO5I,cAAgByI,WAAUG,EAASA,KAC1CA,GAAUA,EAAO5I,cAAgB6S,QAAOvT,EAAIsJ,EAAOlE,EAAEnB,QAE7DwN,EAAIsc,SACA/tB,EACAo2B,EAAc1sB,GAAa,GAC3BL,EAAQ,GAAJwsB,aAKf,aACA,OACDpkB,EAAIqc,UAAY,OAChBrc,EAAI0b,YAAc4I,EAClBtkB,EAAIyb,UAAY8I,EAChBvkB,EAAIsa,YAEA+J,EAAUrkB,EAAIoc,UAAUnkB,EAAQisB,EAAMS,EAAc1sB,GAAYmsB,EAAO,GAAJA,GAClEpkB,EAAIxB,KAAKvG,EAAQisB,EAAMS,EAAc1sB,GAAYmsB,GAEtDpkB,EAAIwb,OACA6I,IACK1wB,EAAE8O,UAAUzC,EAAI6f,SACrB7f,EAAIqa,OACJra,EAAIsa,YACJta,EAAIxB,KAAKvG,EAAQisB,EAAMS,EAAc1sB,GAAYmsB,GACjDpkB,EAAIua,OAGJva,EAAIyb,UAAYgJ,EACZ9wB,EAAEhG,MAAMqS,EAAIsc,SAAS3oB,EAAEhG,KAAMsK,GAAYL,EAAQ,GAAJwsB,GACjDpkB,EAAIyb,UAAY+I,EAChBxkB,EAAIqc,UAAY,QAChBrc,EAAIsc,SAASptB,OAAOyE,EAAEnB,OACjBzE,OAAO,EAAG,IAAK42B,EAAc1sB,GAAYL,EAAQ,GAAJwsB,GAClDpkB,EAAIma,yBAIJxmB,EAAEud,MAAMvd,EAAEud,KAAKlR,EAAK1M,EAAMqxB,EAAa/sB,EAAGwsB,GAGtDF,IAASvwB,EAAEgC,YAAchC,EAAEgC,YAAYgvB,GAAa,GAAKP,GAAK,EAC9DpkB,EAAImc,YAAc3tB,KAAK0b,4CAE3BlK,EAAIma,UACJna,EAAIqc,UAAY,yCAOpB,SAAmB/oB,EAAM1F,EAAKmT,EAAOokB,kBAC5B7xB,EAAKlB,UAAYkB,EAAKlB,QAAQ3B,OAAQ,OAAO,WAE5CuH,EAAIpK,EAAI,GAAK0F,EAAK1F,IAAI,GACtBgK,EAAIhK,EAAI,GAAK0F,EAAK1F,IAAI,GACtBoQ,EAAQ1K,EAAKxC,KAAK,GAClBuX,EAAY7Z,KAAK8Z,sBAEPhV,EAAKlB,kCAAVuB,cACFA,GAAKA,EAAE8O,SAAU,qBAChB2iB,EAAezxB,EAAEgC,YAAchC,EAAEgC,YAAYqI,GAAO,GAAKzQ,EAAcpF,mBACvEw8B,EAAchxB,EAAEqK,OAASA,KAE3BrK,IAAMwxB,IACFntB,EAAI,GAAKA,EAAI2sB,EAAc,IAAM/sB,EAAIjE,EAAE+wB,QAAU9sB,EAAIjE,EAAE+wB,OAASU,wBAIlEC,EAAW1xB,EAAEnB,aAIXmB,EAAExG,UACD,YACkB,cAAf4T,EAAM5T,WAGNwG,EAAE8D,UACFiK,YAAW,kBAAM/N,EAAE8D,SAAS9D,EAAG2xB,EAAMhyB,EAAM1F,EAAKmT,KAAQ,IAE5DpN,EAAEupB,SAAU,EACZoI,EAAKxc,cAAe,YAEnB,SACanV,EAAErB,QAAQmE,IAAM9C,EAAErB,QAAQwsB,QAClCiG,EAASvuB,KAAK+uB,OAAOvtB,EAAI,KAAO2sB,EAAc,IAAK,EAAG,GAC5DhxB,EAAEnB,MAAQmB,EAAErB,QAAQwsB,KAAOnrB,EAAErB,QAAQmE,IAAM9C,EAAErB,QAAQwsB,KAAOiG,EACxDpxB,EAAE8D,UACFiK,YAAW,kBAAM8jB,EAAiB7xB,EAAGA,EAAEnB,SAAQ,IAEnD8yB,EAAKxc,cAAe,YAEnB,aACA,YACKuc,EAAW1xB,EAAEnB,SACA,cAAfuO,EAAM5T,MAAmC,WAAXwG,EAAExG,KAChCwG,EAAEnB,OAAwB,GAAfuO,EAAM0Y,QAAgB9lB,EAAErB,QAAQmzB,MAAQ,GAC/C9xB,EAAErB,QAAQwsB,KAAOnrB,EAAEnB,MAAQmB,EAAErB,QAAQwsB,MAAKnrB,EAAEnB,MAAQmB,EAAErB,QAAQwsB,KAC9DnrB,EAAErB,QAAQmE,KAAO9C,EAAEnB,MAAQmB,EAAErB,QAAQmE,MAAK9C,EAAEnB,MAAQmB,EAAErB,QAAQmE,UAC/D,GAAmB,cAAfsK,EAAM5T,KAAsB,KAC7B0K,EAAWlE,EAAErB,QAAbuF,OACFA,GAAUA,EAAO5I,cAAgByI,WACjCG,EAASlE,EAAErB,QAAQuF,OAAOlE,EAAGL,QAE7BoyB,EAAa,GAEF,WAAX/xB,EAAExG,OAAmBu4B,EAAa7tB,EAAO5I,cAAgB6S,MAAQjK,EAAS3J,OAAO0Z,KAAK/P,QAEpF+H,EAAQ5H,EAAI,IAAM,EAAIA,EAAI2sB,EAAc,GAAK,EAAI,KACxC,WAAXhxB,EAAExG,KACFwG,EAAEnB,OAAiB,GAARoN,GAAejM,EAAErB,QAAQmzB,MAAQ,GACvB,MAAjB9xB,EAAErB,QAAQwsB,KAAenrB,EAAEnB,MAAQmB,EAAErB,QAAQwsB,MAC7CnrB,EAAEnB,MAAQmB,EAAErB,QAAQwsB,KAEH,MAAjBnrB,EAAErB,QAAQmE,KAAe9C,EAAEnB,MAAQmB,EAAErB,QAAQmE,MAC7C9C,EAAEnB,MAAQmB,EAAErB,QAAQmE,UAErB,GAAImJ,EAAO,KACVsX,GAAS,EACboO,EAAKjX,gBAAkB,GAEnB6I,EADArf,EAAO5I,cAAgBf,OACfw3B,EAAWp1B,QAAQpB,OAAOyE,EAAEnB,QAAUoN,EAEtC8lB,EAAWp1B,QAAQqD,EAAEnB,OAASoN,IAE7B8lB,EAAWj1B,SACpBymB,EAAQwO,EAAWj1B,OAAS,GAE5BymB,EAAQ,IACRA,EAAQ,GAERrf,EAAO5I,cAAgB6S,MACvBnO,EAAEnB,MAAQqF,EAAOqf,GAEjBvjB,EAAEnB,MAAQ0kB,WAGRyO,EAAa9tB,IAAW6tB,EACxBx3B,OAAO2J,OAAOA,GACdA,EACO,IAAI4I,EAAYklB,EAAY,CACrC3qB,MAAOxE,KAAKC,IAAI,EAAG6uB,EAAKzf,GAAG7K,OAC3B+F,MAAAA,EACAO,UAAW,OACX7J,SAIJ,SAAsBlJ,EAAGq3B,EAAQ7kB,UACzBlJ,GAAU6tB,IAAYn3B,EAAIo3B,EAAWr1B,QAAQ/B,SAC5CiE,MAAQjE,EACbi3B,EAAiBh3B,KAAMD,GACvBmS,EAAKoI,cAAe,GACb,GATgBhL,KAAKnK,IAEhC0U,SAUD,GAAmB,YAAftH,EAAM5T,MAAiC,WAAXwG,EAAExG,KAAmB,KAClDyS,EAAQ5H,EAAI,IAAM,EAAIA,EAAI2sB,EAAc,GAAK,EAAI,EACnD5jB,EAAMsU,WAAa,KAAgB,GAATzV,GAC1B0lB,EAAKO,OAAO,QAASlyB,EAAEnB,OAAO,SAACjE,GAC3B+2B,EAAK9yB,MAAQmG,OAAOpK,GACpBi3B,EAAiBF,EAAMA,EAAK9yB,SAC7BuO,GAIPskB,IAAa1xB,EAAEnB,OACfkP,YACI,WACI8jB,EAAiBF,EAAMA,EAAK9yB,SAEhC,IAGR8yB,EAAKxc,cAAe,YAEnB,SACkB,cAAf/H,EAAM5T,OACNwG,EAAEnB,OAASmB,EAAEnB,MACbkP,YAAW,WACP8jB,EAAiB7xB,EAAGA,EAAEnB,SACvB,eAGN,aACA,OACkB,cAAfuO,EAAM5T,MACNm4B,EAAKO,OAAO,QAASlyB,EAAEnB,OAAO,SAACjE,GAC3B+2B,EAAK9yB,MAAQjE,EACbi3B,EAAiBF,EAAM/2B,KACxBwS,IAAOpN,EAAErB,SAAUqB,EAAErB,QAAQwzB,yBAIhCnyB,EAAEkY,QACFyZ,EAAKxc,aAAenV,EAAEkY,MAAM9K,EAAO,CAAC/I,EAAGJ,GAAItE,WAMnD+xB,IAAa1xB,EAAEnB,QACXc,EAAKyyB,iBAAiBzyB,EAAKyyB,gBAAgBpyB,EAAEhG,KAAMgG,EAAEnB,MAAO6yB,EAAU1xB,GAC1EL,EAAKvC,MAAMU,eAGRkC,+BApJmB,4FAuJxB+M,EAAOlS,cACJg3B,EAAiBnzB,EAAQG,GAC9BH,EAAOG,MAAQA,EACXH,EAAOC,SAAWD,EAAOC,QAAQC,eAAyDoF,IAA7CrE,EAAKlC,WAAWiB,EAAOC,QAAQC,WAC5Ee,EAAKuV,YAAYxW,EAAOC,QAAQC,SAAUC,GAE1CH,EAAOoF,UACPpF,EAAOoF,SAASpF,EAAOG,MAAOkO,EAAMpN,EAAM1F,EAAKmT,UAIhD,+BAOX,SAAWxC,EAAQyB,MACVxR,KAAKuC,WAEJi1B,EAASx3B,KAAKuC,MAAMstB,QAE1Bre,EAAIqa,OACJra,EAAImc,YAAc,GAAM3tB,KAAK0b,uBAET8b,kCAAQ,KAAjBC,aACFtpB,EAAgBnO,KAAKkP,aAAcuoB,EAAM7pB,YAI9C4D,EAAIyb,UAAYwK,EAAMhzB,OAAS,OAC/B+M,EAAI0b,YAAcuK,EAAMhzB,OAAS,WAC3BrF,EAAMq4B,EAAM10B,KACZT,EAAOm1B,EAAM3pB,MACnB0D,EAAImc,YAAc,IAAO3tB,KAAK0b,aAC9BlK,EAAIsa,YACJta,EAAIxB,KAAK5Q,EAAI,GAAK,GAAKA,EAAI,GAAK,GAAKkD,EAAK,GAAIA,EAAK,IACnDkP,EAAIwb,OACJxb,EAAImc,YAAc3tB,KAAK0b,aACvBlK,EAAI6f,SAEJ7f,EAAIsa,YACJta,EAAIwf,OAAO5xB,EAAI,GAAKkD,EAAK,GAAIlD,EAAI,GAAKkD,EAAK,IAC3CkP,EAAIyf,OAAO7xB,EAAI,GAAKkD,EAAK,GAAK,GAAIlD,EAAI,GAAKkD,EAAK,IAChDkP,EAAIyf,OAAO7xB,EAAI,GAAKkD,EAAK,GAAIlD,EAAI,GAAKkD,EAAK,GAAK,IAChDkP,EAAIwb,WAEE0K,EAAWD,EAAMvvB,WAAanJ,EAAc44B,wBAClDnmB,EAAI/C,eAAUipB,cACdlmB,EAAIsc,SAAS2J,EAAMj4B,MAAOJ,EAAI,GAAK,EAAGA,EAAI,GAAKs4B,mCAGnDlmB,EAAIma,0CAGR,qBACkB3rB,KAAKuC,MAAMwL,4CACdjJ,UAAeA,EAAKxC,KAAOwC,EAAKqC,kDACtC8Y,UAAS,GAAM,yBAQxB,SAAOzQ,EAAOC,OACLD,IAAUC,EAAQ,KACbmoB,EAAS53B,KAAK+P,OAAOiF,WAC3BxF,EAAQooB,EAAOC,YACfpoB,EAASmoB,EAAOE,aAGhB93B,KAAK+P,OAAOP,QAAUA,GAASxP,KAAK+P,OAAON,SAAWA,SAIrDM,OAAOP,MAAQA,OACfO,OAAON,OAASA,OAChBmR,SAASpR,MAAQxP,KAAK+P,OAAOP,WAC7BoR,SAASnR,OAASzP,KAAK+P,OAAON,YAC9BwQ,UAAS,GAAM,kCAQxB,SAAe8X,kBACNA,cACIhc,WAAa/b,KAAK+b,eAClBzB,cAAe,YACfoF,gBAAiB,OAIpBtO,EAAQpR,KAAK+b,UAAY,IAAM,GACjC/b,KAAK+b,iBACAA,WAAY,OACZL,aAAe,QAGlB1d,EAAIg6B,aAAY,WAClBC,EAAKvc,cAAgBtK,EACrB6mB,EAAK3d,cAAe,EACpB2d,EAAKvY,gBAAiB,EAElBtO,EAAQ,GAAK6mB,EAAKvc,aAAe,MACjC7D,cAAc7Z,GACVoT,EAAQ,IACR6mB,EAAKlc,WAAY,IAGrB3K,EAAQ,GAAK6mB,EAAKvc,aAAe,MACjC7D,cAAc7Z,GACdi6B,EAAKvc,aAAe,KAEzB,wCAQP,SAAsB5W,gCAQtB,SAAayN,OAGHiF,EADUjF,EAAM2lB,eACA,GAClBv5B,EAAO,UAEH4T,EAAM5T,UACL,aACDA,EAAO,sBAEN,YACDA,EAAO,sBAEN,WACDA,EAAO,mCAUTmX,EAAS9V,KAAK8Z,kBAGdqe,EAFeriB,EAAbjJ,SAEwB4I,YAAY,cAC5C0iB,EAAeC,eACXz5B,GACA,GACA,EACAmX,EACA,EACA0B,EAAM6gB,QACN7gB,EAAM8gB,QACN9gB,EAAMtH,QACNsH,EAAMpH,SACN,GACA,GACA,GACA,EACA,EACA,MAEJoH,EAAMpZ,OAAOuX,cAAcwiB,GAC3B5lB,EAAMjB,6CAgVV,SAAa5N,EAAMoM,OACToC,EAAOlS,KAEPu4B,EAAO,IAAItmB,EADD,CAAC,WAAY,KAAM,UACG,CAClCM,MAAOzC,EACPtQ,MAAoB,MAAbkE,EAAKsB,KAAetB,EAAKsB,KAAKvE,YAAYtB,KAAO,KACxD8J,kBAGkBlJ,EAAG+D,EAASgM,UACtB/P,OACC,WACDyN,EAAagrB,UAAU,KAAM,KAAM1oB,EAAGyoB,GAAM,SAACzzB,GACzC9F,QAAQC,IAAI,wBACNw5B,EAAWvmB,EAAK3P,MAAMiD,YAAY9B,EAAK+B,WACvCizB,EAAYxmB,EAAK3P,MAAMiD,YAAY9B,EAAK2C,WACzCvB,EAAKrC,QACFqC,EAAKrC,OAAOR,QACZ6C,EAAKpC,SACLoC,EAAKpC,QAAQT,QACjBw2B,EAAS/1B,QAAQgB,EAAKiC,aAAahH,OAASmG,EAAKrC,OAAO,GAAG9D,MAAQmG,EAAKpC,QAAQ,GAAG/D,OAAS+5B,EAAUj2B,OAAO,GAAG9D,OAChH85B,EAASrR,QAAQ1jB,EAAKiC,YAAab,EAAM,GACzCA,EAAKsiB,QAAQ,EAAGsR,EAAWh1B,EAAKkD,aAChC9B,EAAK1F,IAAI,IAAqB,GAAf0F,EAAKxC,KAAK,iBAIhC,SACD4P,EAAK3P,MAAMo2B,WAAWj1B,EAAKlB,eAMhC,wBAiEX,sBAAOhD,yDAAQ,GAAIwE,yCAAOiF,yCAAUsJ,yCAAO+kB,yCAGnCsB,GAAW,EAET5hB,EAASnK,SAASM,cAAc,OACtC6J,EAAOlE,UAAY,sBAEfkE,EAAO3D,UADPikB,EACmB,8GAEA,6GAEvBtgB,EAAO5D,MAAQ,WACXylB,EAAKC,WAAa,KACd9hB,EAAOhC,YAAYgC,EAAOhC,WAAW3H,YAAY2J,IAGrDhX,KAAKqX,GAAG7K,MAAQ,IAChBwK,EAAOrE,MAAMqB,0BAAqBhU,KAAKqX,GAAG7K,YAG9CwK,EAAOzH,iBAAiB,cAAc,SAACO,GAC9B8oB,GAAU5hB,EAAO5D,WAGtBpT,KAAK84B,iBACAA,WAAW1lB,aAEf0lB,WAAa9hB,MAMZ+hB,EAAc/hB,EAAOO,cAAc,SACzCwhB,EAAYzf,UAAY9Z,MAClBw5B,EAAehiB,EAAOO,cAAc,UAC1CyhB,EAAah1B,MAAQA,MAEfT,EAAQy1B,EACdz1B,EAAMgM,iBAAiB,WAAW,SAACO,MAC/B8oB,GAAW,EACO,KAAd9oB,EAAE6H,QAAgBX,EAAO5D,YACxB,CAAA,GAAkB,KAAdtD,EAAE6H,SAAyC,aAAvB7H,EAAE1R,OAAO0iB,iBAC9B7X,GACAA,EAAS1F,EAAMS,OAEnBgT,EAAO5D,QAIXtD,EAAEwB,iBACFxB,EAAEyB,yBAGA4B,EAAS6D,EAAOO,cAAc,UACpCpE,EAAO5D,iBAAiB,SAAS,WACzBtG,GAAUA,EAAS1F,EAAMS,OAC7B60B,EAAK5Y,UAAS,GACdjJ,EAAO5D,eAGL7G,EAAciB,EAAauJ,cACzBhH,EAAWxD,EAAXwD,OAEFC,EAAOD,EAAOE,wBAChBgpB,GAAW,GACXnF,GAAW,UACX9jB,IACAipB,GAAWjpB,EAAKG,KAChB2jB,GAAW9jB,EAAKK,KAGhBkC,GACAyE,EAAOrE,MAAMxC,eAAUoC,EAAMrC,QAAU+oB,QACvCjiB,EAAOrE,MAAMtC,cAASkC,EAAMnC,QAAU0jB,UAEtC9c,EAAOrE,MAAMxC,eAAyB,GAAfJ,EAAOP,MAAcypB,QAC5CjiB,EAAOrE,MAAMtC,cAAyB,GAAhBN,EAAON,OAAeqkB,SAGhD/jB,EAAOiF,WAAW5H,YAAY4J,GAC9B9D,YAAW,kBAAM3P,EAAM2T,UAAS,IAEzBF,uCA0PX,SAAsBlS,EAAMf,OAAUD,yDAAU,MACvCgB,QAAsCqE,IAA9BrE,EAAKlC,WAAWmB,QAEvBf,EAAO8B,EAAKoV,gBAAgBnW,GAC1BpF,EAASqE,EAATrE,KAEJu6B,EAAY,MAEZ,CAAC,QAAS,SAAU,QAAS,UAAU1G,SAAS7zB,GAChDu6B,EAAY,oDACT,GAAI,CAAC,OAAQ,SAAS1G,SAAS7zB,IAASqE,EAAKqG,OAAQ,KAGnD,IAAM5K,KAFXy6B,EAAY,+CAEIl2B,EAAKqG,OAAQ,KACrBrF,EAAQvF,EACRuE,EAAKqG,OAAO5I,cAAgB6S,QAAOtP,EAAQhB,EAAKqG,OAAO5K,IAE3Dy6B,4BAA+Bl1B,eAAUA,GAASc,EAAKlC,WAAWmB,GAAY,WAAa,eAAMf,EAAKqG,OAAO5K,gBAEjHy6B,GAAa,gBACV,CAAA,GAAa,YAATv6B,cAKPK,QAAQsB,6BAAsB3B,IAJ9Bu6B,2DACIp0B,EAAKlC,WAAWmB,GAAY,UAAY,aAO1CiT,EAAShX,KAAKm5B,0CAEZn2B,EAAKwF,MAAQxF,EAAKwF,MAAQzE,oBAE1Bm1B,yBAEJp1B,MAGA,CAAC,OAAQ,SAAS0uB,SAAS7zB,IAASqE,EAAKqG,OAAQ,KAC3C9F,EAAQyT,EAAOO,cAAc,UACnChU,EAAMgM,iBAAiB,UAAU,SAACO,GAC9BspB,EAAStpB,EAAE1R,OAAO4F,eAEnB,GAAa,YAATrF,EAAoB,KACrB4E,EAAQyT,EAAOO,cAAc,SAC/BhU,GACAA,EAAMgM,iBAAiB,SAAS,kBAAM6pB,IAAW71B,EAAM81B,gBAExD,KACG91B,EAAQyT,EAAOO,cAAc,YAC/BhU,EAAO,CACPA,EAAMgM,iBAAiB,QAAQ,WAAQhM,EAAM2T,eAEzCnX,OAAkCoJ,IAA9BrE,EAAKlC,WAAWmB,GAA0Be,EAAKlC,WAAWmB,GAAY,GACjE,WAATpF,IACAoB,EAAIzB,KAAKE,UAAUuB,IAGvBwD,EAAMS,MAAQjE,EACdwD,EAAMgM,iBAAiB,WAAW,SAACO,GACd,IAAbA,EAAE6H,UACNyhB,EAAS71B,EAAMS,OACf8L,EAAEwB,iBACFxB,EAAEyB,2BAKR4B,EAAS6D,EAAOO,cAAc,iBACpCpE,EAAO5D,iBAAiB,SAAS,kBAAM6pB,EAAS71B,MAAMS,UAyB/CgT,WAxBEoiB,EAASp1B,GACVhB,GACGA,EAAKqG,QACLrG,EAAKqG,OAAO5I,cAAgBf,aACLyJ,IAAvBnG,EAAKqG,OAAOrF,KAAsBA,EAAQhB,EAAKqG,OAAOrF,IAEpB,iBAA9Bc,EAAKlC,WAAWmB,KACvBC,EAAQmG,OAAOnG,IAEf,CAAC,QAAS,UAAUwuB,SAAS7zB,KAC7BqF,EAAQ1F,KAAKC,MAAMyF,IAEvBc,EAAKlC,WAAWmB,GAAYC,EACxBc,EAAKvC,OACLuC,EAAKvC,MAAMU,WAEX6B,EAAKzB,mBACLyB,EAAKzB,kBAAkBU,EAAUC,GAEjCF,EAAQw1B,SAASx1B,EAAQw1B,UAC7BtiB,EAAO5D,QACPtO,EAAKsC,gBAAe,GAAM,gCAMlC,SAAamyB,cAAMz1B,yDAAU,GACnBkT,EAASnK,SAASM,cAAc,OACtC6J,EAAOlE,UAAY,cACnBkE,EAAO3D,UAAYkmB,MAEbvpB,EAAOhQ,KAAK+P,OAAOE,wBACrBgpB,GAAW,GACXnF,GAAW,UACX9jB,IACAipB,GAAWjpB,EAAKG,KAChB2jB,GAAW9jB,EAAKK,KAGhBvM,EAAQ01B,UACRP,GAAWn1B,EAAQ01B,SAAS,GAC5B1F,GAAWhwB,EAAQ01B,SAAS,IACrB11B,EAAQyO,OACf0mB,GAAWn1B,EAAQyO,MAAMrC,QACzB4jB,GAAWhwB,EAAQyO,MAAMnC,UAGzB6oB,GAA+B,GAApBj5B,KAAK+P,OAAOP,MACvBskB,GAAgC,GAArB9zB,KAAK+P,OAAON,QAG3BuH,EAAOrE,MAAMxC,eAAU8oB,QACvBjiB,EAAOrE,MAAMtC,cAASyjB,aAEjB/jB,OAAOiF,WAAW5H,YAAY4J,GAEnCA,EAAO5D,MAAQ,WACP4D,EAAOhC,YAAYgC,EAAOhC,WAAW3H,YAAYosB,IAGlDziB,6BAGX,SAAYxX,cAAOsE,yDAAU,GACnB+V,EAAY/V,EAAQgS,QAAUA,OAE9BtD,EAAO3F,SAASM,cAAc,UACpCqF,EAAKM,UAAY,mBACjBN,EAAKa,UAAY,yIACjBb,EAAKknB,OAASlnB,EAAK+E,cAAc,kBAE7BzT,EAAQ0L,QAAOgD,EAAKG,MAAMnD,MAAQ1L,EAAQ0L,OAAS1L,EAAQ0L,MAAM/O,cAAgB0J,OAAS,KAAO,KACjGrG,EAAQ2L,SAAQ+C,EAAKG,MAAMlD,OAAS3L,EAAQ2L,QAAU3L,EAAQ2L,OAAOhP,cAAgB0J,OAAS,KAAO,KACrGrG,EAAQkW,SAAU,KACZ5G,EAAQvG,SAASM,cAAc,QACrCiG,EAAMC,UAAY,WAClBD,EAAMuB,UAAUC,IAAI,SACpBxB,EAAM7D,iBAAiB,SAAS,kBAAMiD,EAAKY,WAC3CZ,EAAKknB,OAAOtsB,YAAYgG,UAE5BZ,EAAKmnB,cAAgBnnB,EAAK+E,cAAc,iBACxC/E,EAAKmnB,cAAcrgB,UAAY9Z,EAC/BgT,EAAKe,QAAUf,EAAK+E,cAAc,mBAClC/E,EAAKonB,OAASpnB,EAAK+E,cAAc,kBAEjC/E,EAAKY,MAAQ,kBAAMZ,EAAKwC,WAAW3H,YAAYwsB,IAE/CrnB,EAAKkM,MAAQ,kBAAMlM,EAAKe,QAAQF,UAAY,IAE5Cb,EAAKyH,QAAU,SAAC6N,EAAM5oB,EAAW46B,OACvBC,EAAOltB,SAASM,cAAc,cAChCjO,IAAW66B,EAAKjnB,UAAY5T,GAChC66B,EAAK1mB,UAAYyU,EACbgS,EAAUtnB,EAAKonB,OAAOxsB,YAAY2sB,GACjCvnB,EAAKe,QAAQnG,YAAY2sB,GACvBA,GAGXvnB,EAAKiI,UAAY,SAACtb,EAAM8J,EAAUnF,OACxBi2B,EAAOltB,SAASM,cAAc,iBACpC4sB,EAAKzgB,UAAYna,EACjB46B,EAAKj2B,QAAUA,EACfi2B,EAAKplB,UAAUC,IAAI,OACnBmlB,EAAKxqB,iBAAiB,QAAStG,GAC/BuJ,EAAKonB,OAAOxsB,YAAY2sB,GACjBA,GAGXvnB,EAAK+H,aAAe,eACVwf,EAAOltB,SAASM,cAAc,OACpC4sB,EAAKjnB,UAAY,YACjBN,EAAKe,QAAQnG,YAAY2sB,IAG7BvnB,EAAK4H,UAAY,SAACzb,EAAMQ,EAAM6E,OAAOF,yDAAU,GAAImF,yCAG3C+wB,EAAoB,YAFxBr7B,EAAOA,EAAKgC,eAEuBqD,EAAM6O,QAAQ,GAAK7O,EAAMi2B,WACtDF,EAAOltB,SAASM,cAAc,OACpC4sB,EAAKjnB,UAAY,WACjBinB,EAAK1mB,UAAY,0EACjB0mB,EAAKxiB,cAAc,kBAAkB+B,UAAYna,MAC3C65B,EAAee,EAAKxiB,cAAc,4BAuD/B2iB,EAAY/6B,EAAM6E,GACvBhF,QAAQC,IAAI,SAAUE,EAAM6E,GAExBF,EAAQmF,UAAUnF,EAAQmF,SAAS9J,EAAM6E,GACzCiF,GAAUA,EAAS9J,EAAM6E,UA1DjCg1B,EAAa1f,UAAY0gB,EACzBD,EAAKllB,QAAQ9Q,SAAW5E,EACxB46B,EAAKllB,QAAQlW,KAAOmF,EAAQnF,MAAQA,EACpCo7B,EAAKj2B,QAAUA,EACfi2B,EAAK/1B,MAAQg2B,EAEA,YAATr7B,GACAo7B,EAAKplB,UAAUC,IAAI,WACf5Q,GAAO+1B,EAAKplB,UAAUC,IAAI,WAC9BmlB,EAAKxqB,iBAAiB,SAAS,eAIrB4qB,EAAWJ,EAAKllB,QAAQ9Q,SAC9B81B,EAAK71B,OAAS+1B,EAAK/1B,MACnB61B,EAAKllB,UAAUylB,OAAO,WACtBP,EAAKtiB,cAAc,mBAAmB+B,UAAYugB,EAAK71B,MAAQ,OAAS,QACxEk2B,EAAYC,EAAUN,EAAK71B,WAExB,CAAC,SAAU,UAAUwuB,SAAS7zB,IACrCq6B,EAAaqB,aAAa,mBAAmB,GAC7CrB,EAAazpB,iBAAiB,WAAW,SAACO,GACvB,UAAXA,EAAEgY,OACFhY,EAAEwB,iBACF0nB,EAAasB,WAGrBtB,EAAazpB,iBAAiB,QAAQ,eAC9BxP,EAAI85B,EAAKvgB,UACP6gB,EAAWnB,EAAahkB,WAAWH,QAAQ9Q,SAEhC,WADAi1B,EAAahkB,WAAWH,QAAQlW,OACtBoB,EAAIoK,OAAOpK,IACtCm6B,EAAYC,EAAUp6B,OAEnB,CAAC,OAAQ,SAASyyB,SAAS7zB,KAAOq7B,EAAWxsB,EAAa+sB,0BAA0Bv2B,EAAOF,EAAQuF,SAC9G2vB,EAAa1f,UAAY0gB,EAEzBhB,EAAazpB,iBAAiB,SAAS,SAACgD,OAC9BlJ,EAASvF,EAAQuF,QAAU,GAC3B8wB,EAAWnB,EAAahkB,WAAWH,QAAQ9Q,SACpC,IAAIkO,EAAY5I,EAAQ,CACjCkJ,MAAAA,EACAO,UAAW,OACX7J,SAAU,SAAClJ,EAAGq3B,EAAQ7kB,UAClBsnB,EAAKvgB,UAAYvZ,EACjBm6B,EAAYC,EAAUp6B,IACf,IAGf8Z,MAGJrH,EAAKe,QAAQnG,YAAY2sB,GASlBA,GAGJvnB,8CAmGX,SAA6B1N,GACzB9F,QAAQC,IAAI,0CAENu7B,EAAYx6B,KAAK+P,OAAOiF,WAAWuC,cAAc,oBACnDijB,GAAWA,EAAUpnB,YAEnBwG,EAAQ5Z,KAAK+Z,YAAY,kBAAmB,CAC9CC,UAAU,EACVxK,MAAO,eAKFmL,OACLf,EAAM8E,QAGF5Z,EAAKrC,OAAQ,WACOqC,EAAKrC,iCAAdc,aACHA,EAAM0qB,mBAAoB,qBAExB8L,EAAOngB,EAAMK,QADN,kHACoB,qBACjC8f,EAAKllB,QAAQ1V,KAAOoE,EAAMpE,KAC1B46B,EAAKllB,QAAQzP,KAAO3G,EACpBs7B,EAAKxiB,cAAc,SAAS+B,UAAY/V,EAAMpE,KAC9C46B,EAAKxiB,cAAc,SAAS+B,UAAY/V,EAAM5E,KAC9Co7B,EAAKxiB,cAAc,UACdhI,iBAAiB,SAAS,WACvBzK,EAAK21B,YAAYtwB,OAAO4vB,EAAK/kB,WAAWH,QAAQzP,OAChDuV,uEAnBpBf,EAAM9U,KAAOA,EACb8U,EAAMjF,UAAUC,IAAI,0BA0BPgF,EAAMK,QADN,gIACoB,2BAA2B,GACvD1C,cAAc,UACdhI,iBAAiB,SAAS,SAAUO,OAC3BiqB,EAAO/5B,KAAKgV,WACZ7V,EAAO46B,EAAKxiB,cAAc,SAASvT,MACnCrF,EAAOo7B,EAAKxiB,cAAc,SAASvT,MACpC7E,IAAsC,IAA9B2F,EAAKgB,cAAc3G,KAChC2F,EAAK41B,SAASv7B,EAAMR,GACpBo7B,EAAKxiB,cAAc,SAASvT,MAAQ,GACpC+1B,EAAKxiB,cAAc,SAASvT,MAAQ,GACpC2W,QAGRA,SACK5K,OAAOiF,WAAW5H,YAAYwM,GAC5BA,6BAGX,cACS5Z,KAAK+P,kBACK/P,KAAK+P,OAAOiF,WAAWgB,iBAAiB,qDAC3B,KAAjB4D,UACFA,EAAM9U,OACN8U,EAAM9U,KAAKvC,OAASqX,EAAMrX,QAAUvC,KAAKuC,OAAOqX,EAAMxG,8EA2MnE,eACQtP,EAAU,QACV9D,KAAK26B,eACL72B,EAAU9D,KAAK26B,kBAEf72B,EAAU,CACN,CACIyP,QAAS,WACTY,aAAa,EACblL,SAAUuE,EAAagrB,WAE3B,CACIjlB,QAAS,YACTtK,SAAUuE,EAAaotB,aAK3B56B,KAAKggB,cAAgBhgB,KAAKggB,aAAa/d,OAAS,GAChD6B,EAAQ9C,KAAK,KAAM,CACfuS,QAAS,iBACTtK,SAAUjJ,KAAKguB,cAAc1e,KAAKtP,SAK1CA,KAAK66B,oBAAqB,KACpBtmB,EAAQvU,KAAK66B,oBAAoB76B,KAAM8D,GACzCyQ,IAAOzQ,EAAUA,EAAQgE,OAAOyM,WAGjCzQ,oCAGX,SAAmBgB,OACXhB,EAAU,QAEWA,EAArBgB,EAAK61B,eAA0B71B,EAAK61B,eAAe36B,MAEzC,CACN,CACIuT,QAAS,SACTY,aAAa,EACbF,UAAU,EACVhL,SAAUuE,EAAastB,4BAE3B,CACIvnB,QAAS,UACTY,aAAa,EACbF,UAAU,EACVhL,SAAUuE,EAAautB,6BAE3B,KACA,CACIxnB,QAAS,aACTY,aAAa,EACblL,SAAUuE,EAAawtB,0BAE3B,KACA,CACIznB,QAAS,QACTtK,SAAUuE,EAAaytB,sBAE3B,CACI1nB,QAAS,OACTY,aAAa,EACblL,SAAUuE,EAAa0tB,gBAE3B,CACI3nB,QAAS,SACTtK,uBACQnE,EAAK6e,iBACEnW,EAAa2tB,eAIhC,CACI5nB,QAAS,WACTtK,SAAUuE,EAAa4tB,oBAE3B,CACI7nB,QAAS,MACTtK,SAAUuE,EAAa6tB,eAE3B,CACI9nB,QAAS,SACTY,aAAa,EACblL,SAAUuE,EAAa8tB,kBAE3B,CACI/nB,QAAS,SACTY,aAAa,EACblL,SAAUuE,EAAa+tB,kBAE3B,MAIJz2B,EAAK02B,YAAa,KACZ/4B,EAASqC,EAAK02B,cAChB/4B,GAAUA,EAAOR,SAAQ6B,EAAQ,GAAGmQ,UAAW,MAGnDnP,EAAK22B,aAAc,KACb/4B,EAAUoC,EAAK22B,eACjB/4B,GAAWA,EAAQT,SAAQ6B,EAAQ,GAAGmQ,UAAW,MAGrDnP,EAAK+1B,oBAAqB,KACpBtmB,EAAQzP,EAAK+1B,oBAAoB76B,KAAM8D,GACzCyQ,IACAA,EAAMvT,KAAK,MACX8C,EAAUyQ,EAAMzM,OAAOhE,WAIT,IAAlBgB,EAAK42B,UACL53B,EAAQ9C,KAAK,CACTuS,QAAS,QACTtK,SAAUuE,EAAamuB,kBAI/B73B,EAAQ9C,KAAK,KAAM,CACfuS,QAAS,SACTU,YAA+B,IAAnBnP,EAAK82B,YAAwB92B,EAAK4V,cAC9CzR,SAAUuE,EAAaquB,mBAGvB/2B,EAAKvC,OAASuC,EAAKvC,MAAMu5B,sBACzBh3B,EAAKvC,MAAMu5B,qBAAqBh4B,EAASgB,GAGtChB,qCAGX,iBACW,CACH,CACIyP,QAAS,QACTtK,SAAUuE,EAAaytB,sBAE3B,CACI1nB,QAAS,QACTY,aAAa,EACblL,SAAUuE,EAAa8tB,kBAE3B,CACI/nB,QAAS,YACTxP,SAAU,YACVpF,KAAM,SACNsK,SAAUuE,EAAaytB,sBAE3B,KACA,CACI1nB,QAAS,SACTtK,SAAUuE,EAAaquB,qDAKnC,SAAmB/2B,EAAMyN,OACfL,EAAOlS,KAEP6Z,EADSrM,EAAauJ,cACH+C,kBAErBiiB,EAAW,KACTj4B,EAAU,CACZyO,MAAAA,EACAtJ,kBAuD0BlJ,EAAG+D,EAASgM,OACjC/P,YAIa,gBAAdA,EAAEwT,QAA2B,KACvBvQ,EAAOjD,EAAEqF,KACXpC,EAAKO,MAAOuB,EAAK21B,YAAYz3B,EAAKoC,MAC7BpC,EAAKW,QAAQmB,EAAKk3B,aAAah5B,EAAKoC,WAC1C,GAAkB,qBAAdrF,EAAEwT,QAAgC,KACnCvQ,EAAOjD,EAAEqF,KACXpC,EAAKW,OAAQmB,EAAKwC,iBAAiBtE,EAAKoC,MACnCpC,EAAKO,OAAOuB,EAAK4C,gBAAgB1E,EAAKoC,WAC5C,GAAkB,gBAAdrF,EAAEwT,QAA2B,KAC9BvQ,EAAOjD,EAAEqF,KACT62B,EAAWj5B,EAAKO,MAChBuB,EAAKuiB,aAAarkB,EAAKoC,MAAQN,EAAKo3B,cAAcl5B,EAAKoC,MACvD4R,EAAS9E,EAAKinB,aAChB,kFACAr1B,GAEEP,EAAQyT,EAAOO,cAAc,SAC/BhU,GAAS04B,IAAU14B,EAAMS,MAAQi4B,EAASzzB,OAAS,IACvDwO,EAAOO,cAAc,UAChBhI,iBAAiB,SAAS,WACnBhM,EAAMS,QACFi4B,IAAUA,EAASzzB,MAAQjF,EAAMS,OACrCkO,EAAK+N,UAAS,IAElBjJ,EAAO5D,aAnFnBmB,MAAOzP,GAGPA,IAAMhB,EAAQtE,MAAQsF,EAAKnG,UAG3ByG,EAAO,QACPN,IACAM,EAAON,EAAKq3B,kBAAkB5pB,EAAMwQ,QAASxQ,EAAMyQ,SACnDxV,EAAa4uB,YAAct3B,GAG3BM,EAAM,IAEN22B,EAAW,GACPj3B,EAAKu3B,mBAAoBN,EAAWj3B,EAAKu3B,mBAAmBj3B,OAC3D,CACGA,GAAQA,EAAKzB,QAAUyB,EAAKzB,OAAOF,OAAS2B,EAAKzB,OAAOF,MAAMxB,QAC9D85B,EAAS/6B,KAAK,CACVuS,QAAS,mBACTnO,KAAAA,QAGFk3B,EAAQl3B,EAAK7B,OAAS6B,EAAKzB,OACjCo4B,EAAS/6B,KAAKs7B,EAAMC,OAAS,gBAAkB,CAAEhpB,QAAS,cAAenO,KAAAA,IACzE22B,EAAS/6B,KAAKs7B,EAAME,WAAa,gBAAkB,CAAEjpB,QAAS,cAAenO,KAAAA,IAEjFtB,EAAQtE,OAAS4F,EAAK7B,MAAQ6B,EAAK7B,MAAM5E,KAAOyG,EAAKzB,OAAOhF,OAAS,IACjEyG,EAAK7B,OAAS6B,EAAK7B,MAAM5E,OAASI,EAAcjD,SAAQgI,EAAQtE,MAAQ,UACxE4F,EAAKzB,QAAUyB,EAAKzB,OAAOhF,OAASI,EAAclD,QAAOiI,EAAQtE,MAAQ,cAC1E,GAAIsF,EACPi3B,EAAW/7B,KAAKy8B,mBAAmB33B,OAChC,CACHi3B,EAAW/7B,KAAK08B,2BACVjF,EAAQz3B,KAAKuC,MAAM4iB,cAAc5S,EAAMwQ,QAASxQ,EAAMyQ,SACxDyU,GAEAsE,EAAS/6B,KAAK,KAAM,CAChBuS,QAAS,aACTY,aAAa,EACbK,QAAS,CACLhV,MAAO,QACP+U,MAAOkjB,EACP3zB,QAAS9D,KAAK28B,oBAAoBlF,MAO7CsE,GAEQ,IAAI9pB,EAAY8pB,EAAUj4B,EAAS+V,+BAlkDpD,SAAkB7W,EAAM45B,EAAOC,OACrB9sB,EAASvC,EAAauJ,cAEtB0gB,EAAQ,IAAInqB,EAClBmqB,EAAMr4B,IAAM2Q,EAAOmI,2BAA2B2kB,GAC9C9sB,EAAOxN,MAAMqS,IAAI6iB,4BAGrB,SAAiB3yB,EAAMhB,EAASgM,EAAGgtB,EAAc7zB,OACvC8G,EAASvC,EAAauJ,cACtB8C,EAAY9J,EAAO+J,kBACjBvX,EAAUwN,EAAVxN,SACHA,kBAEIw6B,EAAkBC,EAAeC,OAChC97B,EAAa+7B,EAAgCntB,EAAOhP,QAAUwB,EAAMxB,QACrEA,QAAO,SAACzB,UAAaA,EAAS69B,WAAWH,MACxCI,EAAU,GAEhBj8B,EAAWk8B,SAAQ,SAAC/9B,MACXA,OAICg+B,EAAsB,IAAIC,mBAAYP,QACtCQ,EAAgBl+B,EAASkC,QAAQ87B,EAAqB,IAAI77B,MAAM,KAAK,GACrEg8B,YAAkC,KAAlBT,EAA0BQ,EAAsBR,EAAgBQ,OAElFr+B,EAAOq+B,GACgB,GAAvBr+B,EAAK2C,QAAQ,QACb3C,EAAOA,EAAKsC,MAAM,MAAM,KAIb,IADD27B,EAAQM,WAAU,SAACd,UAAUA,EAAM54B,QAAUy5B,MAEvDL,EAAQp8B,KAAK,CACTgD,MAAOy5B,EACPlqB,QAASpU,EACTgV,aAAa,EACblL,kBAASjF,EAAOuO,EAAOsqB,EAAYc,GAC/BZ,EAAkB/4B,EAAMA,MAAO25B,UAMjCT,EAAgCF,EAAcY,MAAM,GAAI,GAAI7tB,EAAOhP,QAAUwB,EAAMxB,QAC3Fs8B,SAAQ,SAACv4B,OACPA,EAAK1D,eAEHw7B,EAAQ,CACV54B,MAAOc,EAAKnG,KACZ4U,QAASzO,EAAKtF,MACd2U,aAAa,EACblL,kBAASjF,EAAOuO,EAAOsqB,EAAYc,OACzBE,EAAcF,EAAYvoB,gBAChCrF,EAAOxN,MAAM8H,mBACPvF,EAAO3C,EAAW4C,WAAWf,EAAMA,OACrCc,IACAA,EAAK1F,IAAM2Q,EAAOmI,2BAA2B2lB,GAC7C9tB,EAAOxN,MAAMqS,IAAI9P,IAEjBmE,GAAUA,EAASnE,GACvBiL,EAAOxN,MAAMmI,gBAIrB0yB,EAAQp8B,KAAK47B,WAGb3qB,EAAYmrB,EAAS,CACrB7qB,MAAOzC,EACPqC,WAAY8qB,GACbpjB,GAGPkjB,CAAkB,GAAID,IACf,mCAOX,0CAOA,sDAGA,SAAkC/8B,EAAG+9B,EAAchuB,EAAGgtB,EAAch4B,MAC3DA,OAECoN,EAAOlS,KAEP6Z,EADSrM,EAAauJ,cACH+C,kBAErBhW,EAAUgB,EAAKi5B,gBACfj5B,EAAK02B,cAAa13B,EAAUgB,EAAK02B,mBAEjC4B,EAAU,MACVt5B,EAAS,WACWA,kCAAS,KAAlB84B,aACFA,OAIDp0B,EAAQo0B,EAAM,GACdA,EAAM,IAAMA,EAAM,GAAGp0B,QACrBA,EAAQo0B,EAAM,GAAGp0B,WAEfxD,EAAO,CACTuO,QAAS/K,EACTxE,MAAO44B,GAEPA,EAAM,KAAO79B,EAAcjD,SAC3BkJ,EAAK8N,UAAY,SAErBsqB,EAAQp8B,KAAKgE,QAdTo4B,EAAQp8B,KAAK,yCAkBrBhB,KAAKg+B,mBAAkBZ,EAAUp9B,KAAKg+B,iBAAiBZ,IAEtDA,EAAQn7B,cAKA,IAAIgQ,EACbmrB,EACA,CACI7qB,MAAOzC,EACP7G,kBAOclJ,EAAG+P,EAAGrQ,OACnBqF,SAID/E,EAAEkJ,UACFlJ,EAAEkJ,SAASrJ,KAAKsS,EAAMpN,EAAM/E,EAAG+P,EAAGrQ,GAGlCM,EAAEiE,QACFc,EAAKvC,MAAM8H,eACXvF,EAAK41B,SAAS36B,EAAEiE,MAAM,GAAIjE,EAAEiE,MAAM,GAAIjE,EAAEiE,MAAM,IAC9Cc,EAAKsC,gBAAe,GAAM,GAC1BtC,EAAKvC,MAAMmI,gBAnBXyH,WAAY2qB,EACZh4B,KAAAA,GAEJ+U,IAoBG,EAhCH7a,QAAQC,IAAI,gEAmCpB,SAAmCc,EAAG+9B,EAAchuB,EAAGgtB,EAAch4B,MAC5DA,OAECoN,EAAOlS,KAEP6Z,EADSrM,EAAauJ,cACH+C,kBAErBhW,EAAUgB,EAAKm5B,iBACfn5B,EAAK22B,eACL33B,EAAUgB,EAAK22B,oBAGf2B,EAAU,MACVt5B,EAAS,WACWA,kCAAS,KAAlB84B,aACFA,OAMD93B,EAAKhC,QACFgC,EAAKhC,MAAMo7B,wBACwB,IAAnCp5B,EAAKoF,eAAe0yB,EAAM,SAG7Bp0B,EAAQo0B,EAAM,GACdA,EAAM,IAAMA,EAAM,GAAGp0B,QAAOA,EAAQo0B,EAAM,GAAGp0B,WAC3CxD,EAAO,CACTuO,QAAS/K,EACTxE,MAAO44B,GAEPA,EAAM,KAAO79B,EAAclD,QAAOmJ,EAAK8N,UAAY,SACvDsqB,EAAQp8B,KAAKgE,SAhBTo4B,EAAQp8B,KAAK,yCAoBrBhB,KAAKm+B,oBAAmBf,EAAUp9B,KAAKm+B,kBAAkBf,IAExDA,EAAQn7B,cAEA,IAAIgQ,EACbmrB,EACA,CACI7qB,MAAOzC,EACP7G,kBAOCm1B,EAAar+B,EAAG+P,EAAGrQ,OACnBqF,EAAM,OAEP/E,EAAEkJ,UAAUlJ,EAAEkJ,SAASrJ,KAAKsS,EAAMpN,EAAM/E,EAAG+P,EAAGrQ,OAE7CM,EAAEiE,iBAIDA,EAAQjE,EAAEiE,MAAM,MAGlBA,IACIA,EAAMvD,cAAgBf,QAAUsE,EAAMvD,cAAgB6S,OAC5D,KAEQ8pB,EAAU,OACX,IAAM3+B,KAAKuF,EACZo5B,EAAQp8B,KAAK,CACTuS,QAAS9U,EACTuF,MAAOA,EAAMvF,gBAGjBwT,EAAYmrB,EAAS,CACrB7qB,MAAOzC,EACP7G,SAAUm1B,EACVjsB,WAAY2qB,EACZh4B,KAAAA,KAEG,EAEXA,EAAKvC,MAAM8H,eACXvF,EAAKsT,UAAUrY,EAAEiE,MAAM,GAAIjE,EAAEiE,MAAM,GAAIjE,EAAEiE,MAAM,IAC/Cc,EAAKsC,gBAAe,GAAM,GAC1BtC,EAAKvC,MAAMmI,eAxCPyH,WAAY2qB,EACZh4B,KAAAA,GAEJ+U,IAwCG,2CAGX,SAAgC7V,EAAOF,EAASgM,EAAGgtB,EAAch4B,MACxDA,GAASA,EAAKlC,gBAIbmN,EAASvC,EAAauJ,cACtB8C,EAAY9J,EAAO+J,kBAEnBsjB,EAAU,OAEX,IAAM3+B,KAAKqG,EAAKlC,WAAY,KACzBoB,OAA+BmF,IAAvBrE,EAAKlC,WAAWnE,GAAmBqG,EAAKlC,WAAWnE,GAAK,IAC/C,WAAjByE,EAAOc,KAAoBA,EAAQ1F,KAAKE,UAAUwF,QAChDhB,EAAO8B,EAAKoV,gBAAgBzb,GACjB,QAAbuE,EAAKrE,MAA+B,SAAbqE,EAAKrE,OAAiBqF,EAAQwJ,EAAa+sB,0BAA0Bv2B,EAAOhB,EAAKqG,SAG5GrF,EAAQwJ,EAAa6wB,WAAWr6B,GAChCo5B,EAAQp8B,KAAK,CACTuS,QACI,sCACIvQ,EAAKwF,MAAQxF,EAAKwF,MAAQ/J,oDAG1BuF,aAERA,MAAOvF,OAGV2+B,EAAQn7B,cAIA,IAAIgQ,EACbmrB,EACA,CACI7qB,MAAOzC,EACP7G,kBAQclJ,OACb+E,aAGCkL,EAAOhQ,KAAKiQ,wBAClBF,EAAOuuB,sBAAsBx5B,EAAM/E,EAAEiE,MAAO,CACxCw1B,SAAU,CAACxpB,EAAKG,KAAMH,EAAKK,QAb3B8B,WAAY2qB,EACZyB,YAAY,EACZz5B,KAAAA,GAEJ+U,IAaG,6BAGX,SAAkBf,OACRhJ,EAAIjD,SAASM,cAAc,cACjC2C,EAAEwJ,UAAYR,EACPhJ,EAAEuD,sCAGb,SAAoBrP,EAAOF,EAASgM,EAAGyoB,EAAMzzB,GACpCA,IACLA,EAAKxC,KAAOwC,EAAKqC,cACbrC,EAAKgC,UAAUhC,EAAKgC,SAAShC,EAAKxC,MACtCwC,EAAKsC,gBAAe,GAAM,wCAwC9B,SAA4Bo3B,EAAM16B,EAASgM,EAAGyoB,EAAMzzB,OAC1Cf,EAAWy6B,EAAKz6B,UAAY,QAC5BC,EAAQc,EAAKf,GAEbiT,EAASnK,SAASM,cAAc,OACtC6J,EAAOlE,UAAY,cACnBkE,EAAO3D,UAAY,4FAEL2D,EAAOO,cAAc,SAC7B+B,UAAYvV,MAEZR,EAAQyT,EAAOO,cAAc,UAC/BhU,IACAA,EAAMS,MAAQA,EACdT,EAAMgM,iBAAiB,QAAQ,SAACO,GAC5BvM,EAAM2T,WAEV3T,EAAMgM,iBAAiB,WAAW,SAACO,GACb,KAAdA,EAAE6H,SAAyC,aAAvB7H,EAAE1R,OAAO0iB,YACjCsY,EAAS71B,EAAMS,OACf8L,EAAEwB,iBACFxB,EAAEyB,2BAKFxB,EADYvC,EAAauJ,cACzBhH,OAEFC,EAAOD,EAAOE,wBAChBgpB,GAAW,GACXnF,GAAW,YAkBNsF,EAASp1B,GACI,WAAdw6B,EAAK7/B,KACLqF,EAAQmG,OAAOnG,GACM,YAAdw6B,EAAK7/B,OACZqF,EAAQtC,QAAQsC,IAEpBc,EAAKf,GAAYC,EACbgT,EAAOhC,YACPgC,EAAOhC,WAAW3H,YAAY2J,GAElClS,EAAKsC,gBAAe,GAAM,GA3B1B4I,IACAipB,GAAWjpB,EAAKG,KAChB2jB,GAAW9jB,EAAKK,KAGhBP,GACAkH,EAAOrE,MAAMxC,eAAUL,EAAEI,QAAU+oB,QACnCjiB,EAAOrE,MAAMtC,cAASP,EAAEM,QAAU0jB,UAElC9c,EAAOrE,MAAMxC,eAAyB,GAAfJ,EAAOP,MAAcypB,QAC5CjiB,EAAOrE,MAAMtC,cAAyB,GAAhBN,EAAON,OAAeqkB,SAGjC9c,EAAOO,cAAc,UAC7BhI,iBAAiB,SAAS,kBAAM6pB,EAAS71B,EAAMS,UACtD+L,EAAOiF,WAAW5H,YAAY4J,4CAmmBlC,SAAiChT,EAAOqF,OAC/BA,EAAQ,OAAO3I,OAAOsD,MACvBqF,EAAO5I,cAAgB6S,MAAO,OAAO5S,OAAOsD,MAE5CqF,EAAO5I,cAAgBf,OAAQ,KAC3B++B,EAAa,OACZ,IAAMr7B,KAAKiG,KACRA,EAAOjG,KAAOY,GAClBy6B,EAAar7B,wBAGP1C,OAAOsD,gBAAWy6B,0CAqJpC,SAA0Bz6B,EAAOF,EAASgM,EAAGyoB,EAAMzzB,GAC/CA,EAAKvC,MAAM8H,aAAavF,GACxBA,EAAKwiB,WACLxiB,EAAKvC,MAAMmI,YAAY5F,gCAG3B,SAAqBd,EAAOF,EAASgM,EAAGyoB,EAAMzzB,GAC1CA,EAAK45B,sCAmCT,SAAwB16B,EAAOF,EAASgM,EAAGyoB,EAAMzzB,OACxCA,EAAM,MAAM,IAAI2P,MAAM,yBACrBpL,EAAS,OAQV,IAAM5K,KAPX4K,EAAOrI,KAAK,CACRgD,MAAO,KACPuP,QACI,qEAIQ/F,EAAaC,YAAa,KAChChJ,EAAQ+I,EAAaC,YAAYhP,GACvC4K,EAAOrI,KAAK,CACRgD,MAAOvF,EACP8U,sGAAgG9O,EAAMA,oCAA2BA,EAAMC,qBAAYjG,0BAGvJwT,EAAY5I,EAAQ,CACpBkJ,MAAOzC,EACP7G,SAAU,SAAClJ,MACF+E,OAICL,EAAQ1E,EAAEiE,MAAQwJ,EAAaC,YAAY1N,EAAEiE,OAAS,KACxDS,EAC8B,gBAA1BK,EAAKrE,YAAYtB,KACjB2F,EAAKL,MAAQA,EAAMkJ,YAEnB7I,EAAKL,MAAQA,EAAMA,MACnBK,EAAKJ,QAAUD,EAAMC,iBAGlBI,EAAKL,aACLK,EAAKJ,SAEhBI,EAAKsC,gBAAe,GAAM,KAE9B+K,WAAYomB,EACZzzB,KAAAA,KAGG,kCAGX,SAAwBd,EAAOF,EAASgM,EAAGyoB,EAAMzzB,OACxCA,QACK,IAAI2P,MAAM,6BAGhBxC,EAAYlT,EAAc1D,aAAc,CACxCkX,MAAOzC,EACP7G,SAAU,SAAClJ,GACF+E,IACLA,EAAKvC,MAAM8H,aAAavF,GACxBA,EAAKF,MAAQ7E,EACb+E,EAAKvC,MAAMmI,YAAY5F,GACvBA,EAAKsC,gBAAe,MAEzB,CACC+K,WAAYomB,EACZzzB,KAAAA,KAGG,kCAGX,SAAwBd,EAAOF,EAASgM,EAAGyoB,EAAMzzB,OACxCA,EAAM,MAAM,IAAI2P,MAAM,sBACJ,IAAnB3P,EAAK82B,eAEDr5B,EAAUuC,EAAVvC,MACRA,EAAM8H,eACN9H,EAAMgW,OAAOzT,GACbvC,EAAMmI,cACN5F,EAAKsC,gBAAe,GAAM,wCAG9B,SAA4BpD,EAAOF,EAASgM,EAAGyoB,EAAMzzB,OACzCvC,EAAUuC,EAAVvC,MACFgK,EAAciB,EAAauJ,iBAC5BxK,OAEDoyB,EAAYj/B,OAAO2J,OAAOkD,EAAY2S,gBAAkB,IACvDyf,EAAU18B,SAAQ08B,EAAY,CAAC75B,QAE9Bsb,EAAeje,EAAW4C,WAAW,kBAC3Cqb,EAAahhB,IAAM0F,EAAK1F,IAAI0I,SAC5BvF,EAAMqS,IAAIwL,GAEVA,EAAawe,eAAeD,GAE5BpyB,EAAY0a,mBACZniB,EAAKsC,gBAAe,GAAM,mCAG9B,SAAuBpD,EAAOF,EAASgM,EAAGyoB,EAAMzzB,OACtB,IAAlBA,EAAK42B,cACHvN,EAAUrpB,EAAKgkB,QAChBqF,IACLA,EAAQ/uB,IAAM,CAAC0F,EAAK1F,IAAI,GAAK,EAAG0F,EAAK1F,IAAI,GAAK,GAE9C0F,EAAKvC,MAAM8H,eACXvF,EAAKvC,MAAMqS,IAAIuZ,GACfrpB,EAAKvC,MAAMmI,cAEX5F,EAAKsC,gBAAe,GAAM,gBA9uKboG,6BA6HiB,gfA7HjBA,qBA+HS,MAChBzO,EAAc9D,iBACpB4jC,OAAQ,OACR/5B,KAAM,WAlIO0I,cAqIE,MArIFA,kBA87IM,KA97INA,oBAomKO,SAAUxJ,EAAOF,EAASgM,EAAGyoB,EAAMzzB,cACnDmN,EACA,CAAC,SAAU,WAAY,aAAc,SACrC,CACIM,MAAOzC,EACP7G,SAAU,SAAClJ,MACF+E,SAGG/E,OACC,WACD+E,EAAKT,KAAOtF,EAAc/C,mBAEzB,aACD8I,EAAKT,KAAOtF,EAAc7C,qBAEzB,QACD4I,EAAKT,KAAOtF,EAAc9C,gBAEzB,iBAED6I,EAAKT,KAAOtF,EAAchD,SAItCoW,WAAYomB,EACZzzB,KAAAA,KAGD,OAjoKM0I,gBAivKI,CACjBsxB,IAAK,CACDr6B,MAAO,OACPC,QAAS,OACTiJ,WAAY,QAEhBoxB,MAAO,CACHt6B,MAAO,UACPC,QAAS,UACTiJ,WAAY,WAEhBqxB,MAAO,CACHv6B,MAAO,OACPC,QAAS,OACTiJ,WAAY,QAEhBsxB,KAAM,CACFx6B,MAAO,OACPC,QAAS,OACTiJ,WAAY,QAEhBD,UAAW,CACPjJ,MAAO,UACPC,QAAS,UACTiJ,WAAY,WAEhBuxB,KAAM,CACFz6B,MAAO,OACPC,QAAS,OACTiJ,WAAY,QAEhBwxB,OAAQ,CACJ16B,MAAO,OACPC,QAAS,OACTiJ,WAAY,WAEhByxB,OAAQ,CACJ36B,MAAO,OACPC,QAAS,OACTiJ,WAAY,WAEhB0xB,MAAO,CACH56B,MAAO,OACPC,QAAS,OACTiJ,WAAY,cE9xKH2xB,wBACLn7B,qCAgBK,2BAEA,2BAEA,CAAC,SAAU,SAAU,YAnB9BpF,EAAc9B,OACd+B,QAAQC,IAAI,sBAEX+M,oBAAsB,UACtB0S,QAEDva,QACKhB,UAAUgB,8CAIvB,kBACWnE,KAAKu/B,gBAAkBD,EAAOC,uDAkBhCC,YACAC,OAASH,EAAOI,oBAEhBC,aAAe,OACfn1B,aAAe,OAEfvH,UAAY,EAGbjD,KAAK+N,OAAQ,WACM/N,KAAK+N,uCAAQ,KAArBjJ,UACHA,EAAK86B,WAAW96B,EAAK86B,iDAK5B7xB,OAAS,QACTwW,aAAe,QACfsb,gBAAkB,QAClBC,kBAAoB,UAGpBjQ,QAAU,QAGVpsB,MAAQ,QAGRqrB,UAAY,OAGZvH,OAAS,QACTwY,KAAO,QACPxrB,MAAQ,QAGRsa,WAAa,OACbmR,YAAc,OACdC,UAAY,OACZC,gBAAkB,SAClBC,aAAe,SACfC,iBAAmB,OACnBC,UAAY,OAEZC,cAAe,OAGf79B,OAAS,QACTC,QAAU,QAGVgjB,cAEAla,mBAAmB,qCAQ5B,SAAae,MACLA,EAAY9L,cAAgB+M,QACtB,IAAIiH,MAAM,gDAEhBlI,EAAYhK,OAASgK,EAAYhK,QAAUvC,MAC3CuM,EAAYhK,MAAM2d,aAAa3T,GAGnCA,EAAYhK,MAAQvC,KAEfA,KAAKgM,sBAAqBhM,KAAKgM,oBAAsB,SACrDA,oBAAoBhL,KAAKuL,+BAQlC,SAAaA,MACJvM,KAAKgM,yBAIJ5M,EAAMY,KAAKgM,oBAAoBlK,QAAQyK,IAChC,IAATnN,IAGJmN,EAAYhK,MAAQ,UACfyJ,oBAAoBzE,OAAOnI,EAAK,0BASzC,SAAMmhC,MACEvgC,KAAKy/B,SAAWH,EAAOkB,qBAGtBf,OAASH,EAAOkB,eAEjBxgC,KAAKygC,kBACAA,mBAGJC,oBAAoB,gBAGpBL,UAAY1iC,SACZyiC,iBAAmBpgC,KAAKqgC,cAEvBnuB,EAAOlS,QAGI,KAJjBugC,EAAWA,GAAY,IAIiB,oBAAXzqB,QAA0BA,OAAO6M,sBAAuB,MAY5Ege,oBAAsB,EAV3B,SAASC,KAC4B,IAA7B1uB,EAAKyuB,qBAGT7qB,OAAO6M,sBAAsBie,GACzB1uB,EAAK2uB,cAAc3uB,EAAK2uB,eAC5B3uB,EAAK4uB,QAAQ,GAAI5uB,EAAKouB,cAClBpuB,EAAK6uB,aAAa7uB,EAAK6uB,eAI/BH,aAEKD,mBAAqB3I,aAAY,WAE9B9lB,EAAK2uB,cAAc3uB,EAAK2uB,eAC5B3uB,EAAK4uB,QAAQ,GAAI5uB,EAAKouB,cAClBpuB,EAAK6uB,aAAa7uB,EAAK6uB,gBAC5BR,wBAQX,WACQvgC,KAAKy/B,SAAWH,EAAOI,sBAItBD,OAASH,EAAOI,eAEjB1/B,KAAKghC,kBACAA,cAGuB,OAA5BhhC,KAAK2gC,sBAC4B,IAA7B3gC,KAAK2gC,oBACL9oB,cAAc7X,KAAK2gC,yBAElBA,mBAAqB,WAGzBD,oBAAoB,kCAU7B,SAAQjT,EAAKwT,EAAiBC,GAC1BzT,EAAMA,GAAO,MAEPsB,EAAQpxB,SACTkxB,WAAa,MAASE,EAAQ/uB,KAAKqgC,eAElCryB,EAAQhO,KAAK8/B,kBACb9/B,KAAK8/B,kBACL9/B,KAAK+N,UACNC,MAILkzB,EAAQA,GAASlzB,EAAM/L,OAEnBg/B,EAAiB,KAEZ,IAAIxiC,EAAI,EAAGA,EAAIgvB,EAAKhvB,IAAK,KACrB,IAAIyD,EAAI,EAAGA,EAAIg/B,EAAOh/B,IAAK,KACtB4C,EAAOkJ,EAAM9L,GACf4C,EAAKT,OAAStF,EAAchD,QAAU+I,EAAKc,WAC3Cd,EAAKc,iBAIRq6B,WAAajgC,KAAKkgC,gBACnBlgC,KAAKmhC,oBACAA,gBAITnhC,KAAKohC,qBACAA,8BAKA,IAAI3iC,EAAI,EAAGA,EAAIgvB,EAAKhvB,IAAK,KACrB,IAAIyD,EAAI,EAAGA,EAAIg/B,IAASh/B,EAAG,KACtB4C,EAAOkJ,EAAM9L,GACf4C,EAAKT,OAAStF,EAAchD,QAAU+I,EAAKc,WAC3Cd,EAAKc,iBAIRq6B,WAAajgC,KAAKkgC,gBACnBlgC,KAAKmhC,oBACAA,gBAITnhC,KAAKohC,qBACAA,sBAEJC,qBAAsB,EAC7B,MAAO50B,WACA40B,qBAAsB,EACvBtiC,EAAc5B,mBACRsP,EAEN1N,EAAc9B,OACd+B,QAAQC,sCAA+BwN,SAEtC+yB,WAIP3hC,EAAMF,IACR2jC,EAAUzjC,EAAMkxB,EACJ,IAAZuS,IACAA,EAAU,QAETC,eAAiB,KAAQD,OACzBzS,YAAc,KAAQyS,OACtBxS,WAAa,OACbqR,aAA+C,MAA/BtiC,EAAMmC,KAAKogC,uBAC3BA,iBAAmBviC,uCAQ5B,gBACSgiC,gBAAkB7/B,KAAKwhC,uBAAsB,QAC7C1B,kBAAoB,aACN9/B,KAAK6/B,gDAAiB,KAA9B/6B,UACHA,EAAKc,gBACAk6B,kBAAkB9+B,KAAK8D,wEAYxC,SAAsB28B,EAAeC,SAC7BC,EAAI,GACFC,EAAI,GACJC,EAAI,GACJC,EAAe,GACfC,EAAiB,OAGJ/hC,KAAK+N,uCAAQ,KAArBjJ,cACH28B,GAAkB38B,EAAKc,WAI3Bi8B,EAAE/8B,EAAKtC,IAAMsC,MAET2oB,EAAM,KACN3oB,EAAKrC,WACA,IAAIP,EAAI,EAAG8/B,EAAKl9B,EAAKrC,OAAOR,OAAQC,EAAI8/B,EAAI9/B,IACzC4C,EAAKrC,OAAOP,IAA6B,MAAvB4C,EAAKrC,OAAOP,GAAGwB,OACjC+pB,GAAO,GAKP,IAARA,GAEAmU,EAAE5gC,KAAK8D,GACH48B,IACA58B,EAAKm9B,OAAS,KAGdP,IACA58B,EAAKm9B,OAAS,GAElBF,EAAej9B,EAAKtC,IAAMirB,wCAKb,IAAbmU,EAAE3/B,QADG,KAMH6C,EAAO88B,EAAEx2B,WACfu2B,EAAE3gC,KAAK8D,UACA+8B,EAAE/8B,EAAKtC,IAETsC,EAAKpC,mBAKWoC,EAAKpC,wCAAS,KAAxBiB,aAEO,MAAVA,GACmB,MAAhBA,EAAOF,OACiB,IAAxBE,EAAOF,MAAMxB,kBAMC0B,EAAOF,sCAAO,KAAxBovB,UACDnvB,EAAO1D,KAAKyD,MAAMovB,MACnBnvB,IAKDo+B,EAAap+B,EAAKlB,SAIhB0/B,EAAaliC,KAAKwF,YAAY9B,EAAK2C,WACvB,MAAd67B,GAMAR,KACKQ,EAAWD,QACbC,EAAWD,QAAUn9B,EAAKm9B,UAE7BC,EAAWD,OAASn9B,EAAKm9B,OAAS,GAGtCH,EAAap+B,EAAKlB,KAAM,EACxBu/B,EAAeG,EAAW1/B,KAAO,EACK,IAAlCu/B,EAAeG,EAAW1/B,KAC1Bo/B,EAAE5gC,KAAKkhC,IAfPJ,EAAap+B,EAAKlB,KAAM,yEAuBnC,IAAM/D,KAAKojC,EAAGF,EAAE3gC,KAAK6gC,EAAEpjC,IAExBkjC,EAAE1/B,SAAWjC,KAAK+N,OAAO9L,QAAUlD,EAAc9B,OACjD+B,QAAQsB,KAAK,+CAGX4F,EAAIy7B,EAAE1/B,OAGHxD,EAAI,EAAGA,EAAIyH,EAAGzH,IAAKkjC,EAAEljC,GAAG2F,MAAQ3F,EAGzCkjC,EAAIA,EAAE1gC,MAAK,SAACkhC,EAAGC,OACLC,EAAKF,EAAE1hC,YAAY6hC,UAAYH,EAAEG,UAAY,EAC7CC,EAAKH,EAAE3hC,YAAY6hC,UAAYF,EAAEE,UAAY,SAC/CD,IAAOE,EAEAJ,EAAE/9B,MAAQg+B,EAAEh+B,MAEhBi+B,EAAKE,SAIX,IAAI9jC,EAAI,EAAGA,EAAIyH,IAAKzH,EAAGkjC,EAAEljC,GAAG2F,MAAQ3F,SAElCkjC,8BAWX,SAAa78B,WACH09B,EAAY,GACZC,EAAU,CAAC39B,GACX49B,EAAU,GAETD,EAAQxgC,QAAQ,KACb0gC,EAAUF,EAAQr3B,WACnBu3B,EAAQlgC,QAGRigC,EAAQC,EAAQngC,KAAOmgC,IAAY79B,IACpC49B,EAAQC,EAAQngC,KAAM,EACtBggC,EAAUxhC,KAAK2hC,QAGd,IAAIlkC,EAAI,EAAGA,EAAIkkC,EAAQlgC,OAAOR,SAAUxD,EAAG,KACtC8E,EAAQo/B,EAAQ7X,aAAarsB,GAC/B8E,IAAuC,IAA9Bi/B,EAAU1gC,QAAQyB,IAC3Bk/B,EAAQzhC,KAAKuC,YAKzBi/B,EAAUvhC,MAAK,SAACkV,EAAG5H,UAAM4H,EAAE/R,MAAQmK,EAAEnK,SAC9Bo+B,yBAOX,SAAQ/4B,GACJA,EAASA,GAAU,UAGbm5B,EAAU,OADF5iC,KAAKwhC,uBAAsB,GAAO,mCAEtB,KAAf18B,UACD+9B,EAAM/9B,EAAKm9B,QAAU,EACtBW,EAAQC,KACTD,EAAQC,GAAO,IAEnBD,EAAQC,GAAK7hC,KAAK8D,0CAGlB0E,EAAIC,QAEam5B,iBAAS,KAAnBE,UACFA,SAGDC,EAAU,IACV35B,EAAIK,EAAS1K,EAAcvF,sBACZspC,kCAAQ,KAAhBh+B,UACPA,EAAK1F,IAAI,GAAKoK,EACd1E,EAAK1F,IAAI,GAAKgK,EACVtE,EAAKxC,KAAK,GAAKygC,IAASA,EAAUj+B,EAAKxC,KAAK,IAChD8G,GAAKtE,EAAKxC,KAAK,GAAKmH,EAAS1K,EAAcvF,iDAE/CgQ,GAAKu5B,EAAUt5B,QAGdrC,gBAAe,GAAM,0BAQ9B,kBACWpH,KAAK6uB,uCAUhB,kBACW7uB,KAAKigC,wCAUhB,kBACWjgC,KAAKmgC,gDAShB,SAAoB6C,EAAW1tB,EAAQjR,GACnCA,EAAOA,GAAQtF,EAAchD,WAEvBiS,EAAQhO,KAAK6/B,gBAAkB7/B,KAAK6/B,gBAAkB7/B,KAAK+N,UAC5DC,MAIA,IAAI9L,EAAI,EAAGgE,EAAI8H,EAAM/L,OAAQC,EAAIgE,IAAKhE,EAAG,KACpC4C,EAAOkJ,EAAM9L,GAGW,aAA1B4C,EAAKrE,YAAYtB,MACA,cAAd6jC,EAQFl+B,EAAKk+B,IAAcl+B,EAAKT,OAASA,SAGvB8E,IAAXmM,EACAxQ,EAAKk+B,KACE1tB,GAAUA,EAAO7U,cAAgB6S,MACxCxO,EAAKk+B,SAALl+B,IAAmBwQ,IAEnBxQ,EAAKk+B,GAAW1tB,IAdZxQ,EAAKT,OAASA,GACdS,EAAK47B,oBAAoBsC,EAAW1tB,EAAQjR,sCAkB5D,SAAmBiC,EAAQgP,MAClBtV,KAAKgM,wBAIL,IAAIvN,EAAI,EAAGA,EAAIuB,KAAKgM,oBAAoB/J,SAAUxD,EAAG,KAChDyN,EAAIlM,KAAKgM,oBAAoBvN,GAC/ByN,EAAE5F,IACF4F,EAAE5F,SAAF4F,IAAaoJ,wBAYzB,SAAIxQ,EAAMm+B,MACDn+B,MAKDA,EAAKrE,cAAgB6M,cAChBuiB,QAAQ7uB,KAAK8D,QACbsC,gBAAe,QACfse,SACL5gB,EAAKvC,MAAQvC,eACRiD,eAKQ,IAAb6B,EAAKtC,IAA2C,MAA9BxC,KAAKukB,aAAazf,EAAKtC,MACzCxD,QAAQsB,KACJ,gEAEJwE,EAAKtC,KAAOxC,KAAK2/B,cAGjB3/B,KAAK+N,OAAO9L,QAAUlD,EAAc5D,0BAC9B,IAAIsZ,MAAM,4DAIL,MAAX3P,EAAKtC,KAA2B,IAAbsC,EAAKtC,GACxBsC,EAAKtC,KAAOxC,KAAK2/B,aACV3/B,KAAK2/B,aAAe76B,EAAKtC,UAC3Bm9B,aAAe76B,EAAKtC,IAG7BsC,EAAKvC,MAAQvC,UACRiD,gBAEA8K,OAAO/M,KAAK8D,QACZyf,aAAazf,EAAKtC,IAAMsC,EAEzBA,EAAKo+B,SAASp+B,EAAKo+B,QAAQljC,MAE3BA,KAAKunB,OAAOC,eAAe1iB,EAAK2iB,cAE/Bwb,GAAkBjjC,KAAKmjC,uBAExBnjC,KAAKojC,aAAapjC,KAAKojC,YAAYt+B,QAElCsC,gBAAe,QACfse,SAEE5gB,yBASX,SAAOA,MAC2B,gBAA1BA,EAAKrE,YAAYtB,KAAwB,KACnCupB,EAAQ1oB,KAAK6vB,QAAQ/tB,QAAQgD,UACpB,IAAX4jB,QACKmH,QAAQtoB,OAAOmhB,EAAO,GAE/B5jB,EAAKvC,MAAQ,UACRU,gBACAmE,gBAAe,GAAM,aACrBse,YAIyB,MAA9B1lB,KAAKukB,aAAazf,EAAKtC,MAIvBsC,EAAKu+B,uBAIJh5B,eAGDvF,EAAKrC,WACA,IAAIhE,EAAI,EAAGA,EAAIqG,EAAKrC,OAAOR,OAAQxD,IAAK,CAExB,MADJqG,EAAKrC,OAAOhE,GAChBiF,MACLoB,EAAK4C,gBAAgBjJ,MAM7BqG,EAAKpC,YACA,IAAIjE,EAAI,EAAGA,EAAIqG,EAAKpC,QAAQT,OAAQxD,IAAK,KACpC2G,EAAON,EAAKrC,OAAOhE,GACP,MAAd2G,EAAK3B,OAAiB2B,EAAK3B,MAAMxB,QACjC6C,EAAKwC,iBAAiB7I,MAQ9BqG,EAAK86B,WACL96B,EAAK86B,YAGT96B,EAAKvC,MAAQ,UACRU,WAGDjD,KAAKgM,oBAAqB,WACLhM,KAAKgM,oDAAqB,KAApC+D,UACHA,EAAOmP,eAAepa,EAAKtC,YACpBuN,EAAOmP,eAAepa,EAAKtC,IAElCuN,EAAOsP,eAAiBva,IACxBiL,EAAOsP,aAAe,0CAM5BjgB,EAAMY,KAAK+N,OAAOjM,QAAQgD,IACnB,IAAT1F,QACK2O,OAAOxG,OAAOnI,EAAK,UAErBY,KAAKukB,aAAazf,EAAKtC,IAE1BxC,KAAKsjC,oBACAA,cAAcx+B,QAIlB0G,mBAAmB,oBAEnBpE,gBAAe,GAAM,QACrBsD,mBACAgb,cAEAyd,mDAST,SAAY3gC,UACE,MAANA,EACO,KAEJxC,KAAKukB,aAAa/hB,mCAU7B,SAAiB+gC,OAAaliC,yDAAS,GACnCA,EAAOY,OAAS,YACGjC,KAAK+N,uCAAQ,KAArBjJ,UACHA,EAAKrE,cAAgB8iC,GAAaliC,EAAOL,KAAK8D,yCAE/CzD,iCAUX,SAAgB1C,OAAM0C,yDAAS,GAC3B1C,EAAOA,EAAKgC,eACZU,EAASA,GAAU,IACZY,OAAS,YACGjC,KAAK+N,uCAAQ,KAArBjJ,UACHA,EAAKnG,KAAKgC,gBAAkBhC,GAAM0C,EAAOL,KAAK8D,yCAE/CzD,iCASX,SAAgB7B,aACOQ,KAAK+N,uCAAQ,KAArBjJ,aACHA,EAAKtF,QAAUA,EAAO,OAAOsF,wCAE9B,qCASX,SAAiBtF,SACP6B,EAAS,OACIrB,KAAK+N,uCAAQ,KAArBjJ,UACHA,EAAKtF,QAAUA,GAAO6B,EAAOL,KAAK8D,yCAEnCzD,8BAaX,SAAamI,EAAGJ,SAAGu1B,yDAAY3+B,KAAK+N,OAAQtE,6CACxBk1B,kCAAW,KAAhBjY,aACHA,EAAEnZ,cAAc/D,EAAGJ,EAAGK,GAAS,OAAOid,wCAEvC,kCAUX,SAAcld,EAAGJ,aACGpJ,KAAK6vB,wCAAS,KAAnBb,aACHA,EAAEzhB,cAAc/D,EAAGJ,EAAG,GAAG,GAAO,OAAO4lB,wCAExC,mCASX,qBACqBhvB,KAAK+N,uCAAQ,KAArBjJ,UACCoU,EAAOna,EAAc1B,sBAAsByH,EAAKnG,SAClDmG,EAAKrE,cAAgByY,GAGzBla,QAAQC,oDAA6C6F,EAAKnG,WACpDwvB,EAAUhsB,EAAW4C,WAAWD,EAAKnG,MAC3CmG,EAAOqpB,EACPA,EAAQhrB,UAAU2B,EAAKG,aACvBkpB,EAAQ5rB,MAAQvC,UACXukB,aAAa4J,EAAQ3rB,IAAM2rB,EAC5BrpB,EAAKrC,SACL0rB,EAAQ1rB,OAASqC,EAAKrC,OAAOqF,UAE7BhD,EAAKpC,UACLyrB,EAAQzrB,QAAUoC,EAAKpC,QAAQoF,+CAGlCq7B,+CAKT,SAAS78B,EAAQC,QACRi9B,aAAexjC,KAAKyjC,iBACrBC,UAAUC,WACV3jC,KAAKwjC,wBAEUxjC,KAAKwjC,6CAAc,KAA3B1+B,aACHA,EAAKlC,WAAWzD,OAASmH,GAG7BxB,EAAK+B,SAASP,EAAQC,iEAK9B,SAAQD,EAAQC,GACRvG,KAAK4jC,gBACAA,UAAUt9B,EAAQC,2BAW/B,SAASpH,EAAMR,EAAMqF,GACHhE,KAAKyC,OAAOtD,UAMrBkL,oBACA5H,OAAOtD,GAAQ,CAChBA,KAAAA,EACAR,KAAAA,EACAqF,MAAAA,QAECf,gBACAyH,cAED1K,KAAKyH,mBACAA,aAAatI,EAAMR,GAGxBqB,KAAK6jC,4BACAA,qDAUb,SAAa1kC,EAAM6F,OACTzB,EAAQvD,KAAKyC,OAAOtD,GACrBoE,IAGLA,EAAMS,MAAQgB,+BASlB,SAAa7F,OACHoE,EAAQvD,KAAKyC,OAAOtD,UACrBoE,EAGEA,EAAMS,MAFF,gCAWf,SAAY8/B,EAASC,MACbA,IAAYD,OAIX9jC,KAAKyC,OAAOqhC,UACN,KAGP9jC,KAAKyC,OAAOshC,UACZ/kC,QAAQ0N,MAAM,iDACP,OAGNjK,OAAOshC,GAAW/jC,KAAKyC,OAAOqhC,UAC5B9jC,KAAKyC,OAAOqhC,QACd7gC,WAEDjD,KAAKgkC,qBACAA,eAAeF,EAASC,GAG7B/jC,KAAK6jC,4BACAA,wDAUb,SAAgB1kC,EAAMR,OACbqB,KAAKyC,OAAOtD,UACN,EAIPa,KAAKyC,OAAOtD,GAAMR,MACf+B,OAAOV,KAAKyC,OAAOtD,GAAMR,MAAMgC,gBAC9BD,OAAO/B,GAAMgC,qBAKhB8B,OAAOtD,GAAMR,KAAOA,OACpBsE,WACDjD,KAAKikC,yBACAA,mBAAmB9kC,EAAMR,+BAStC,SAAYQ,WACHa,KAAKyC,OAAOtD,YAIVa,KAAKyC,OAAOtD,QACd8D,WAEDjD,KAAK2H,qBACAA,eAAexI,GAGpBa,KAAK6jC,4BACAA,yBAEF,4BAUX,SAAU1kC,EAAMR,EAAMqF,QACbtB,QAAQvD,GAAQ,CACjBA,KAAAA,EACAR,KAAAA,EACAqF,MAAAA,QAECf,WAEDjD,KAAKiH,oBACAA,cAAc9H,EAAMR,GAGzBqB,KAAK6jC,4BACAA,qDAUb,SAAc1kC,EAAM6E,OACVL,EAAS3D,KAAK0C,QAAQvD,GACvBwE,IAGLA,EAAOK,MAAQA,gCASnB,SAAc7E,OACJwE,EAAS3D,KAAK0C,QAAQvD,UACvBwE,EAGEA,EAAOK,MAFH,iCAWf,SAAa8/B,EAASC,WACb/jC,KAAK0C,QAAQohC,KAId9jC,KAAK0C,QAAQqhC,IACb/kC,QAAQ0N,MAAM,kDACP,SAGNhK,QAAQqhC,GAAW/jC,KAAK0C,QAAQohC,UAC9B9jC,KAAK0C,QAAQohC,QACf7gC,WAEDjD,KAAKkkC,sBACAA,gBAAgBJ,EAASC,QAG9B/jC,KAAK6jC,4BACAA,2DAUb,SAAiB1kC,EAAMR,OACdqB,KAAK0C,QAAQvD,UACP,EAIPa,KAAK0C,QAAQvD,GAAMR,MAChB+B,OAAOV,KAAK0C,QAAQvD,GAAMR,MAAMgC,gBAC/BD,OAAO/B,GAAMgC,qBAKhB+B,QAAQvD,GAAMR,KAAOA,OACrBsE,WACDjD,KAAKmkC,0BACAA,oBAAoBhlC,EAAMR,gCASvC,SAAaQ,WACJa,KAAK0C,QAAQvD,YAGXa,KAAK0C,QAAQvD,QACf8D,WAEDjD,KAAKwH,sBACAA,gBAAgBrI,GAGrBa,KAAK6jC,4BACAA,yBAEF,+BAGX,SAAa1kC,EAAM6E,WACTgK,EAAQhO,KAAKokC,iBAAiBjlC,GAC3BV,EAAI,EAAGA,EAAIuP,EAAM/L,SAAUxD,EAChCuP,EAAMvP,GAAGmlC,UAAU5/B,8BAI3B,SAAY7E,EAAMoC,WACRyM,EAAQhO,KAAKokC,iBAAiBjlC,GAC3BV,EAAI,EAAGA,EAAIuP,EAAM/L,SAAUxD,EAChCuP,EAAMvP,GAAG4lC,WAAW9iC,+BAK5B,SAAayB,GACLhD,KAAK+d,qBACAA,eAAe/d,KAAMgD,QAEzBwI,mBAAmB,iBAAkBxL,iCAI9C,SAAYgD,GACJhD,KAAKge,oBACAA,cAAche,KAAMgD,QAExBwI,mBAAmB,gBAAiBxL,sCAG7C,SAAiB8E,QACRq+B,uBACDnjC,KAAKskC,yBACAA,mBAAmBx/B,QAEvB7B,gBACAuI,mBAAmB,4CAQ5B,eACSxL,KAAKgM,2BACC,MAGN,IAAIvN,EAAI,EAAGA,EAAIuB,KAAKgM,oBAAoB/J,SAAUxD,EAAG,IAC5CuB,KAAKgM,oBAAoBvN,GAC7Bsd,iBACK,SAGR,qCAOX,eAES,IAAMtd,KAAKuB,KAAKyD,MAAO,KAClBD,EAAWxD,KAAKyD,MAAMhF,GACvB+E,IAGDA,EAASkD,aACTlD,EAASkD,WAAa,2BAMlC,WACQ3H,EAAc9B,OACd+B,QAAQC,IAAI,sBAEXuM,mBAAmB,WAAY,EAAC,GAAM,IACvCxL,KAAKukC,gBACAA,UAAUvkC,oCAIvB,SAAewkC,EAAIC,QACVj5B,mBAAmB,WAAY,CAACg5B,EAAIC,8BAQ7C,SAAW5R,OACDnvB,EAAO1D,KAAKyD,MAAMovB,MACnBnvB,OAGCoB,EAAO9E,KAAKwF,YAAY9B,EAAK2C,WAC/BvB,GACAA,EAAK4C,gBAAgBhE,EAAKkD,uCAUlC,iBACU89B,EAAY,OACC1kC,KAAK+N,uCAAQ,KAArBjJ,UACP4/B,EAAU1jC,KAAK8D,EAAKG,gDAIlBxB,EAAQ,OAET,IAAMhF,KAAKuB,KAAKyD,MAAO,KAEpBC,EAAO1D,KAAKyD,MAAMhF,OACjBiF,EAAKuB,UAAW,CAEjBjG,QAAQsB,KACJ,sEAEEqkC,EAAQ,IAAIp6B,UAEb,IAAMrI,KAAKwB,EACZihC,EAAMziC,GAAKwB,EAAKxB,QAEfuB,MAAMhF,GAAKkmC,EAChBjhC,EAAOihC,EAGXlhC,EAAMzC,KAAK0C,EAAKuB,mBAGd2/B,EAAa,OACC5kC,KAAK6vB,6CAAd4H,UAAuBmN,EAAW5jC,KAAKy2B,EAAMxyB,gDAElDD,EAAO,CACT26B,aAAc3/B,KAAK2/B,aACnBn1B,aAAcxK,KAAKwK,aACnBwD,MAAO02B,EACPjhC,MAAAA,EACA+zB,OAAQoN,EACRrd,OAAQvnB,KAAKunB,OACbhT,MAAOvU,KAAKuU,MACZswB,QAAS9lC,EAAczF,gBAGvB0G,KAAK6E,aAAa7E,KAAK6E,YAAYG,GAEhCA,2BASX,SAAUA,EAAM8/B,MACP9/B,GAIA8/B,GAAS9kC,KAAK0e,YAEX1Q,EAAUhJ,EAAVgJ,SAGJhJ,EAAKvB,OAASuB,EAAKvB,MAAMhD,cAAgB6S,MAAO,OAC1C7P,EAAQ,OACSuB,EAAKvB,sCAAO,KAAxBshC,aACFA,OAICrhC,EAAO,IAAI6G,MACjB7G,EAAKP,UAAU4hC,GACfthC,EAAMC,EAAKlB,IAAMkB,OALb1E,QAAQsB,KAAK,wFAOrB0E,EAAKvB,MAAQA,MAKZ,IAAMhF,KAAKuG,EACF,UAANvG,GAAuB,WAANA,SAGhBA,GAAKuG,EAAKvG,QAGfiO,GAAQ,UAGPqB,OAAS,GACVC,EAAO,WACaA,kCAAO,KAAhBg3B,UACHlgC,EAAO3C,EAAW4C,WAAWigC,EAAMrmC,KAAMqmC,EAAMxlC,OAC9CsF,IACG/F,EAAc9B,OACd+B,QAAQC,4CAC6B+lC,EAAMrmC,QAK/CmG,EAAO,IAAI3C,GACNmC,mBAAqB0gC,EAC1BlgC,EAAK0rB,YAAa,EAClB9jB,GAAQ,GAIZ5H,EAAKtC,GAAKwiC,EAAMxiC,QACXoS,IAAI9P,GAAM,4CAKCkJ,kCAAO,KAAhBg3B,UACDlgC,EAAO9E,KAAKwF,YAAYw/B,EAAMxiC,IAChCsC,GACAA,EAAK3B,UAAU6hC,2CAMtBnV,QAAQ5tB,OAAS,EAClB+C,EAAKwyB,OAAQ,WACWxyB,EAAKwyB,uCAAQ,KAA1ByN,UACDxN,EAAQ,IAAInqB,EAClBmqB,EAAMt0B,UAAU8hC,QACXrwB,IAAI6iB,+CAIZ0L,4BAEA5uB,MAAQvP,EAAKuP,OAAS,GAEvBvU,KAAKkE,aAAalE,KAAKkE,YAAYc,QAElC/B,gBACAmE,gBAAe,GAAM,GACnBsF,uBAGX,SAAKjB,EAAKxC,OACAiJ,EAAOlS,QAGTyL,EAAIhL,cAAgBykC,MAAQz5B,EAAIhL,cAAgB0kC,KAAM,KAChD3b,EAAS,IAAIC,kBACnBD,EAAOja,iBAAiB,QAAQ,SAACgD,OACvBvN,EAAO1G,KAAKC,MAAMgU,EAAMnU,OAAOiD,QACrC6Q,EAAK/O,UAAU6B,GACXiE,GAAUA,YAGlBugB,EAAOE,WAAWje,OAKhB25B,EAAM,IAAIC,eAChBD,EAAIE,KAAK,MAAO75B,GAAK,GACrB25B,EAAIG,KAAK,MACTH,EAAIt5B,QAAO,cACY,MAAfs5B,EAAI3F,YAIFz6B,EAAO1G,KAAKC,MAAM6mC,EAAII,UAC5BtzB,EAAK/O,UAAU6B,GACXiE,GAAUA,SALVjK,QAAQ0N,MAAM,uBAAwB04B,EAAI3F,OAAQ2F,EAAII,aAO9DJ,EAAIK,SAAQ,SAACh5B,GACTzN,QAAQ0N,MAAM,uBAAwBD,iCAW9C,SAAY3H,EAAMoG,EAAKzG,eAx7CN66B,mBAuBO,CAAC,SAAU,SAAU,gBCzC5B/0B,wBACL/H,EAAI7D,EAAM8G,EAAWE,EAAaU,EAAWO,kBAChDpE,GAAKA,OACL7D,KAAOA,OACP8G,UAAYA,OACZE,YAAcA,OACdU,UAAYA,OACZO,YAAcA,OAEdrC,MAAQ,UACRxB,KAAO,IAAIX,aAAa,sCAGjC,SAAU+B,GACFA,EAAE1D,cAAgB6S,YACb9Q,GAAK2B,EAAE,QACPsB,UAAYtB,EAAE,QACdwB,YAAcxB,EAAE,QAChBkC,UAAYlC,EAAE,QACdyC,YAAczC,EAAE,QAChBxF,KAAOwF,EAAE,UAET3B,GAAK2B,EAAE3B,QACP7D,KAAOwF,EAAExF,UACT8G,UAAYtB,EAAEsB,eACdE,YAAcxB,EAAEwB,iBAChBU,UAAYlC,EAAEkC,eACdO,YAAczC,EAAEyC,sCAI7B,iBACW,CACH5G,KAAKwC,GACLxC,KAAKyF,UACLzF,KAAK2F,YACL3F,KAAKqG,UACLrG,KAAK4G,YACL5G,KAAKrB,eCtCI+mC,wBACLC,kBACHA,OAASA,OACTjuB,UAAY,OACZkuB,SAAW,OACXtjC,KAAO,UACPujC,aAAc,OACdp8B,OAAS,uCAGlB,SAAY6pB,EAAGqS,MACNA,OACA,IAAIlnC,EAAI,EAAGA,EAAIknC,EAAO1jC,OAAS,IAAKxD,EAAG,KAClCqnC,EAAIH,EAAOlnC,GACXsnC,EAAKJ,EAAOlnC,EAAI,QAClBsnC,EAAG,GAAKzS,QACNj1B,EAAK0nC,EAAG,GAAKD,EAAE,MACjB99B,KAAK6J,IAAIxT,GAAK,KAAS,OAAOynC,EAAE,OAC9BE,GAAU1S,EAAIwS,EAAE,IAAMznC,SACrBynC,EAAE,IAAM,EAAME,GAAUD,EAAG,GAAKC,UAEpC,uBAGX,SAAKx0B,EAAKlP,EAAMiK,EAAawpB,OAAiBkQ,yDAAY,OAAQC,yCACtDP,EAAW3lC,KAAX2lC,UACHA,QACArjC,KAAOA,MACN6C,EAAI7C,EAAK,GAAmB,EAAdtC,KAAKyJ,OACnByd,EAAI5kB,EAAK,GAAmB,EAAdtC,KAAKyJ,OAEzB+H,EAAIqa,OACJra,EAAIC,UAAUzR,KAAKyJ,OAAQzJ,KAAKyJ,QAE5BssB,IACAvkB,EAAIyb,UAAY,OAChBzb,EAAIoe,SAAS,EAAG,EAAGzqB,EAAG+hB,GACtB1V,EAAIyb,UAAY,OAChBzb,EAAIoe,SAAa,GAAJzqB,EAAS,EAAG,EAAG+hB,GAC5B1V,EAAI0b,YAAc,OAClB1b,EAAI2b,WAAW,EAAG,EAAGhoB,EAAG+hB,IAE5B1V,EAAI0b,YAAc+Y,EACdC,IAAU10B,EAAImc,YAAc,IAChCnc,EAAIsa,sBACgB6Z,kCAAQ,KAAjB7b,UACPtY,EAAIyf,OAAOnH,EAAM,GAAK3kB,GAAI,EAAM2kB,EAAM,IAAM5C,qCAEhD1V,EAAI6f,SACJ7f,EAAImc,YAAc,GACbuY,MACI,IAAIznC,EAAI,EAAGA,EAAIknC,EAAO1jC,SAAUxD,EAAG,KAC9BqnC,EAAIH,EAAOlnC,GACbuB,KAAK0X,WAAajZ,EAAG+S,EAAIyb,UAAY,OAChCjtB,KAAK4lC,UAAYnnC,EAAG+S,EAAIyb,UAAY,OACxCzb,EAAIyb,UAAY,OACrBzb,EAAIsa,YACJta,EAAIsb,IAAIgZ,EAAE,GAAK3gC,GAAI,EAAM2gC,EAAE,IAAM5e,EAAG,EAAG,EAAa,EAAVlf,KAAK+kB,IAC/Cvb,EAAIwb,OAGZxb,EAAIma,sCAGR,SAAYwa,EAAU55B,OACVo5B,EAAW3lC,KAAX2lC,UACHA,KACDQ,EAAS,GAAK,QAGZhhC,EAAInF,KAAKsC,KAAK,GAAmB,EAAdtC,KAAKyJ,OACxByd,EAAIlnB,KAAKsC,KAAK,GAAmB,EAAdtC,KAAKyJ,OACxBD,EAAI28B,EAAS,GAAKnmC,KAAKyJ,OACvBL,EAAI+8B,EAAS,GAAKnmC,KAAKyJ,OACvBrK,EAAM,CAACoK,EAAGJ,GACVg9B,EAAU,GAAK75B,EAAY8K,GAAG7K,cAE/BkL,SAAW1X,KAAKqmC,eAAejnC,EAAKgnC,IAElB,IAAnBpmC,KAAK0X,SAAiB,KAChBoS,EAAQ,CAACtgB,EAAIrE,EAAG,EAAIiE,EAAI8d,GAC9Bye,EAAO3kC,KAAK8oB,GACZ6b,EAAO1kC,MAAK,SAACkV,EAAG5H,UAAM4H,EAAE,GAAK5H,EAAE,WAC1BmJ,SAAWiuB,EAAO7jC,QAAQgoB,QAC1B+b,aAAc,SAEA,IAAnB7lC,KAAK0X,6CAGb,SAAYyuB,EAAU55B,OACVo5B,EAAW3lC,KAAX2lC,UACHA,OACCW,EAAItmC,KAAK0X,cACX4uB,EAAI,QACF98B,GAAK28B,EAAS,GAAKnmC,KAAKyJ,SAAWzJ,KAAKsC,KAAK,GAAmB,EAAdtC,KAAKyJ,QACvDL,GAAK+8B,EAAS,GAAKnmC,KAAKyJ,SAAWzJ,KAAKsC,KAAK,GAAmB,EAAdtC,KAAKyJ,QACvD88B,EAAW,CAAEJ,EAAS,GAAKnmC,KAAKyJ,OAAU08B,EAAS,GAAKnmC,KAAKyJ,QAC7D28B,EAAU,GAAK75B,EAAY8K,GAAG7K,WAC/Bg6B,SAAWxmC,KAAKqmC,eAAeE,EAAUH,OACxCtc,EAAQ6b,EAAOW,MACjBxc,EAAO,KACD2c,EAAoB,IAANH,GAAWA,IAAMX,EAAO1jC,OAAS,MAChDwkC,IACGN,EAAS,IAAM,IACZA,EAAS,GAAKnmC,KAAKsC,KAAK,GAAK,IAC7B6jC,EAAS,IAAM,IACfA,EAAS,GAAKnmC,KAAKsC,KAAK,GAAK,WACpCqjC,EAAOp+B,OAAO++B,EAAG,aACZ5uB,UAAY,GAMjBoS,EAAM,GAHL2c,EAGgB,IAANH,EAAU,EAAI,EAFdt+B,KAAK+uB,MAAMvtB,EAAG,EAAG,GAIhCsgB,EAAM,GAAK,EAAM9hB,KAAK+uB,MAAM3tB,EAAG,EAAG,GAClCu8B,EAAO1kC,MAAK,SAACkV,EAAG5H,UAAM4H,EAAE,GAAK5H,EAAE,WAC1BmJ,SAAWiuB,EAAO7jC,QAAQgoB,QAC1B+b,aAAc,8BAI3B,uBACSnuB,UAAY,GACV,gCAGX,SAAetY,OAAKgnC,yDAAU,GAClBT,EAAW3lC,KAAX2lC,WACHA,EAAQ,OAAQ,UACfxgC,EAAKnF,KAAKsC,KAAK,GAAmB,EAAdtC,KAAKyJ,OACzByd,EAAKlnB,KAAKsC,KAAK,GAAmB,EAAdtC,KAAKyJ,OACzBgkB,EAAMkY,EAAO1jC,OACbmzB,EAAK,CAAC,EAAG,GACXsR,EAAU,IACVC,GAAW,EAENloC,EAAI,EAAGA,EAAIgvB,IAAOhvB,EAAG,KACpBqnC,EAAIH,EAAOlnC,GACjB22B,EAAG,GAAK0Q,EAAE,GAAK3gC,EACfiwB,EAAG,IAAM,EAAM0Q,EAAE,IAAM5e,EAEnBkO,EAAG,GAAKh2B,EAAI,OACVw0B,EAAOgT,KAAKvhB,SAASjmB,EAAKg2B,GAC5BxB,EAAO8S,GAAW9S,EAAOwS,IAC7BO,EAAUloC,EACVioC,EAAU9S,UAEP+S,WCjJME,wBACLC,EAAahjC,aACrBA,EAAUA,GAAW,OAKf0O,EAAO3F,SAASM,cAAc,YAC/BqF,KAAOA,EACZA,EAAKM,UAAY,6BACjBN,EAAKa,UALQ,6IAORE,QAAUf,EAAK+E,cAAc,iBAC7BqiB,OAASpnB,EAAK+E,cAAc,eAE3BxH,EAASyC,EAAK+E,cAAc,gBAG5BhV,EAASvC,KAAKuC,MAAQ,IAAI+8B,EAC1B/yB,EAAevM,KAAKuM,YAAc,IAAIiB,EAAauC,EAAQxN,GACjEgK,EAAYqO,iBAAmB,gBAC/BrY,EAAM6+B,eAAiB,WACnB70B,EAAYmW,MAAK,IAGrBnW,EAAYyc,WAAahpB,KAAKgpB,WAAW1Z,KAAKtP,MAE1C8D,EAAQijC,iBACHC,cAAc,IAAK,SAItBpP,EAAS/qB,SAAS4T,eAAeqmB,GACnClP,GACAA,EAAOxqB,YAAYoF,GAGvBjG,EAAYsZ,6CAIhB,SAAW/V,oBACYA,EAAEuZ,aAAaD,sCAAO,KAA9BE,UACD9oB,EAAMgN,EAAauc,iBAAiBT,EAAKnqB,MACzCqqB,EAAS,IAAIC,WACP,SAARjpB,IACAgpB,EAAO1d,OAAS,SAACyG,GACbxG,EAAKxJ,MAAMY,UAAU7E,KAAKC,MAAMgU,EAAMnU,OAAOiD,UAEjDmoB,EAAOE,WAAWJ,iEAK9B,SAAcnkB,EAAG+hB,OACP6f,EAAal6B,SAASM,cAAc,OAC1C45B,EAAWj0B,UAAY,uBACvBi0B,EAAW1zB,uDACPlO,uBAEA+hB,iCAEEnX,EAASg3B,EAAWxvB,cAAc,UAClCrF,EAAOlS,KAEPuM,EAAc,IAAIiB,EAAauC,EAAQ/P,KAAKuC,OAClDgK,EAAYyP,WAAY,EACxBzP,EAAYqO,iBAAmB,gBAC/BrO,EAAYC,MAAQ,IACpBD,EAAY2P,iBAAkB,EAC9B3P,EAAY4P,mBAAoB,EAChC5P,EAAYmQ,gBAAiB,EAC7BnQ,EAAY06B,SAAW,SAClBC,uBAAyB36B,EAC9BA,EAAYuT,QAAU,WAClBvT,EAAYC,MAAQ,IACpBD,EAAY2P,iBAAkB,EAC9B3P,EAAY4P,mBAAoB,GAEpC5P,EAAY4iB,mBAAqB,SAAUpf,EAAQyB,GAC/CA,EAAI0b,YAAc,WACdia,EAAKj1B,EAAK3F,YAAY2e,sBAAsB,CAAC,EAAG,IAChDkc,EAAKl1B,EAAK3F,YAAY2e,sBAAsB,CAC5ChZ,EAAK3F,YAAYwD,OAAOP,MACxB0C,EAAK3F,YAAYwD,OAAON,SAE5B03B,EAAKnnC,KAAK4R,sBAAsBu1B,GAChCC,EAAKpnC,KAAK4R,sBAAsBw1B,GAChC51B,EAAIkb,UAAY,EAChBlb,EAAI2b,WACAnlB,KAAK0lB,MAAMyZ,EAAG,IAAM,GACpBn/B,KAAK0lB,MAAMyZ,EAAG,IAAM,GACpBn/B,KAAK0lB,MAAM0Z,EAAG,GAAKD,EAAG,IACtBn/B,KAAK0lB,MAAM0Z,EAAG,GAAKD,EAAG,MAI9BJ,EAAWp0B,MAAM6mB,SAAW,WAC5BuN,EAAWp0B,MAAMtC,IAAM,MACvB02B,EAAWp0B,MAAM00B,MAAQ,UAEnBC,EAAez6B,SAASM,cAAc,OAC5Cm6B,EAAax0B,UAAY,gBACzBw0B,EAAaj0B,UAAY,WACzBi0B,EAAa/3B,iBAAiB,SAAS,SAACO,GACpCvD,EAAYg7B,SAAS,MACrBR,EAAW/xB,WAAW3H,YAAY05B,MAEtCA,EAAW35B,YAAYk6B,QAElB90B,KAAK+E,cAAc,YAAYnK,YAAY25B,mBCnGpDjxB,QAAUA,OAAO0xB,2BACjB1xB,OAAO0xB,yBAAyB3oC,UAAU+uB,UAAY,SAClDpkB,EACAJ,EACAoG,EACAC,OACAg4B,yDAAS,EACTC,yDAAYD,OAEPzW,OAAOxnB,EAAIi+B,EAAQr+B,QACnB6nB,OAAOznB,EAAIgG,EAAQi4B,EAAQr+B,QAC3Bu+B,iBAAiBn+B,EAAIgG,EAAOpG,EAAGI,EAAIgG,EAAOpG,EAAIq+B,QAE9CxW,OAAOznB,EAAIgG,EAAOpG,EAAIqG,EAASi4B,QAC/BC,iBACDn+B,EAAIgG,EACJpG,EAAIqG,EACJjG,EAAIgG,EAAQk4B,EACZt+B,EAAIqG,QAEHwhB,OAAOznB,EAAIk+B,EAAWt+B,EAAIqG,QAC1Bk4B,iBAAiBn+B,EAAGJ,EAAIqG,EAAQjG,EAAGJ,EAAIqG,EAASi4B,QAChDzW,OAAOznB,EAAGJ,EAAIq+B,QACdE,iBAAiBn+B,EAAGJ,EAAGI,EAAIi+B,EAAQr+B,6JbsFzC,WACHrK,EAAc1B,sBAAwB,GACtC0B,EAAczB,6BAA+B,GAC7CyB,EAAcxB,MAAQ,GACtBwB,EAActB,iBAAmB,oCAS9B,SAAqBkB,UACjBqB,KAAK3C,sBAAsBsB,oJAkC/B,SAAgCipC,EAAUC,EAAa7iC,QACrDvH,iBAAiBoqC,EAAYlnC,eAAiB,CAC/ChC,KAAMipC,EACN3uB,KAAM4uB,EACN7iC,KAAAA,yBAzKD,SAA4BrG,OACzBC,EAAYD,EAAK8B,cAAgBC,OAASV,KAAK3C,sBAAsBsB,GAAQA,MAC9EC,EAAW,MAAM,IAAI6V,qCAA8B9V,WACjDI,EAAc1B,sBAAsBuB,EAAUD,MACjDC,EAAU6B,YAAYtB,aAAaJ,EAAcxB,MAAMqB,EAAU6B,YAAYtB,4BCmB9E,SACHA,EACAoC,EACAumC,EACAC,EACAnlC,WAEM0S,EAAShC,MAAM/R,EAAKU,QACtB6lB,EAAO,GACLkgB,EAAQ1mC,EAAkBC,GACvB9C,EAAI,EAAGA,EAAIupC,EAAM/lC,SAAUxD,EAChCqpB,4BAA0BkgB,EAAMvpC,gBAAOqpC,GAAaA,EAAUrpC,cAASqpC,EAAUrpC,QAAQ,YAE7FqpB,kCAAgCigB,aAAiBA,OAAgB,UAC7DnlC,IAAYklB,+BAA6BxpB,KAAKE,UAAUoE,eACtDqlC,EAAW/+B,SAAS4e,GAC1BmgB,EAASzoC,MAAQL,EAAKsC,MAAM,KAAK6e,MACjC2nB,EAAShvB,8BAAyB1X,EAAKpC,MACvC8oC,EAASppC,UAAU+G,UAAY,eACtB,IAAInH,EAAI,EAAGA,EAAI6W,EAAOrT,SAAUxD,EACjC6W,EAAO7W,GAAKuB,KAAK+F,aAAatH,OAE5BJ,EAAIkD,EAAK2mC,MAAMloC,KAAMsV,QACtB6yB,cAAc,EAAG9pC,IAE1BK,EAAiBS,EAAM8oC"}
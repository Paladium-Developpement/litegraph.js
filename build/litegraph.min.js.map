{"version":3,"file":"litegraph.min.js","sources":["../src/litegraph.js","../src/LGraph.js","../src/LLink.js","../src/LGraphNode.js","../src/LGraphGroup.js","../src/litegraph-editor.js"],"sourcesContent":["// *************************************************************\n//   LiteGraph CLASS                                     *******\n// *************************************************************\n\n/**\n * The Global Scope. It contains all the registered node classes.\n *\n * @class LiteGraph\n * @constructor\n */\n\nlet LiteGraph = {\n    VERSION: 0.4,\n\n    CANVAS_GRID_SIZE: 10,\n\n    NODE_TITLE_HEIGHT: 30,\n    NODE_TITLE_TEXT_Y: 20,\n    NODE_SLOT_HEIGHT: 20,\n    NODE_WIDGET_HEIGHT: 20,\n    NODE_WIDTH: 140,\n    NODE_MIN_WIDTH: 50,\n    NODE_COLLAPSED_RADIUS: 10,\n    NODE_COLLAPSED_WIDTH: 80,\n    NODE_TITLE_COLOR: \"#999\",\n    NODE_SELECTED_TITLE_COLOR: \"#FFF\",\n    NODE_TEXT_SIZE: 14,\n    NODE_TEXT_COLOR: \"#AAA\",\n    NODE_SUBTEXT_SIZE: 12,\n    NODE_DEFAULT_COLOR: \"#333\",\n    NODE_DEFAULT_BGCOLOR: \"#353535\",\n    NODE_DEFAULT_BOXCOLOR: \"#666\",\n    NODE_DEFAULT_SHAPE: \"box\",\n    NODE_BOX_OUTLINE_COLOR: \"#FFF\",\n    DEFAULT_SHADOW_COLOR: \"rgba(0,0,0,0.5)\",\n    DEFAULT_GROUP_FONT: 24,\n\n    WIDGET_BGCOLOR: \"#222\",\n    WIDGET_OUTLINE_COLOR: \"#666\",\n    WIDGET_TEXT_COLOR: \"#DDD\",\n    WIDGET_SECONDARY_TEXT_COLOR: \"#999\",\n\n    LINK_COLOR: \"#9A9\",\n    EVENT_LINK_COLOR: \"#A86\",\n    CONNECTING_LINK_COLOR: \"#AFA\",\n\n    MAX_NUMBER_OF_NODES: 1000, // avoid infinite loops\n    DEFAULT_POSITION: [100, 100], // default node position\n    VALID_SHAPES: [\"default\", \"box\", \"round\", \"card\"], // ,\"circle\"\n\n    // shapes are used for nodes but also for slots\n    BOX_SHAPE: 1,\n    ROUND_SHAPE: 2,\n    CIRCLE_SHAPE: 3,\n    CARD_SHAPE: 4,\n    ARROW_SHAPE: 5,\n\n    // enums\n    INPUT: 1,\n    OUTPUT: 2,\n\n    EVENT: -1, // for outputs\n    ACTION: -1, // for inputs\n\n    ALWAYS: 0,\n    ON_EVENT: 1,\n    NEVER: 2,\n    ON_TRIGGER: 3,\n\n    UP: 1,\n    DOWN: 2,\n    LEFT: 3,\n    RIGHT: 4,\n    CENTER: 5,\n\n    STRAIGHT_LINK: 0,\n    LINEAR_LINK: 1,\n    SPLINE_LINK: 2,\n\n    NORMAL_TITLE: 0,\n    NO_TITLE: 1,\n    TRANSPARENT_TITLE: 2,\n    AUTOHIDE_TITLE: 3,\n\n    proxy: null, // used to redirect calls\n    node_images_path: \"\",\n\n    debug: false,\n    catch_exceptions: true,\n    throw_errors: true,\n    allow_scripts: false,\n    // if set to true some nodes like Formula would be allowed\n    // to evaluate code that comes from unsafe sources\n    // (like node configuration), which could lead to exploits\n    registered_node_types: {}, // nodetypes by string\n    node_types_by_file_extension: {}, // used for dropping files in the canvas\n    Nodes: {}, // node types by classname\n    Globals: {}, // used to store vars between graphs\n\n    searchbox_extras: {}, // used to add extra features to the search box\n    auto_sort_node_types: false,\n    // If set to true, will automatically sort node types / categories in the context menus\n\n    /**\n     * Register a node class so it can be listed when the user wants to create a new one\n     * @method registerNodeType\n     * @param {String} type name of the node and path\n     * @param {Class} base_class class containing the structure of a node\n     */\n\n    registerNodeType(type, base_class) {\n        if (!base_class.prototype) {\n            throw \"Cannot register a simple object, it must be a class with a prototype\";\n        }\n        base_class.type = type;\n\n        if (LiteGraph.debug) {\n            console.log(`Node registered: ${type}`);\n        }\n\n        const categories = type.split(\"/\");\n        const classname = base_class.name;\n\n        const pos = type.lastIndexOf(\"/\");\n        base_class.category = type.substr(0, pos);\n\n        if (!base_class.title) {\n            base_class.title = classname;\n        }\n        // info.name = name.substr(pos+1,name.length - pos);\n\n        // extend class\n        if (base_class.prototype) {\n            // is a class\n            for (var i in LGraphNode.prototype) {\n                if (!base_class.prototype[i]) {\n                    base_class.prototype[i] = LGraphNode.prototype[i];\n                }\n            }\n        }\n\n        const prev = this.registered_node_types[type];\n        if (prev) {\n            console.log(`replacing node type: ${type}`);\n        } else {\n            if (!Object.hasOwnProperty(base_class.prototype, \"shape\")) {\n                Object.defineProperty(base_class.prototype, \"shape\", {\n                    set(v) {\n                        switch (v) {\n                            case \"default\":\n                                delete this._shape;\n                                break;\n                            case \"box\":\n                                this._shape = LiteGraph.BOX_SHAPE;\n                                break;\n                            case \"round\":\n                                this._shape = LiteGraph.ROUND_SHAPE;\n                                break;\n                            case \"circle\":\n                                this._shape = LiteGraph.CIRCLE_SHAPE;\n                                break;\n                            case \"card\":\n                                this._shape = LiteGraph.CARD_SHAPE;\n                                break;\n                            default:\n                                this._shape = v;\n                        }\n                    },\n                    get(v) {\n                        return this._shape;\n                    },\n                    enumerable: true,\n                    configurable: true,\n                });\n            }\n\n            // warnings\n            if (base_class.prototype.onPropertyChange) {\n                console.warn(\n                    `LiteGraph node class ${\n                        type\n                    } has onPropertyChange method, it must be called onPropertyChanged with d at the end`,\n                );\n            }\n\n            // used to know which nodes create when dragging files to the canvas\n            if (base_class.supported_extensions) {\n                for (var i in base_class.supported_extensions) {\n                    var ext = base_class.supported_extensions[i];\n                    if (ext && ext.constructor === String) this.node_types_by_file_extension[ext.toLowerCase()] = base_class;\n                }\n            }\n        }\n\n        this.registered_node_types[type] = base_class;\n        if (base_class.constructor.name) {\n            this.Nodes[classname] = base_class;\n        }\n        if (LiteGraph.onNodeTypeRegistered) {\n            LiteGraph.onNodeTypeRegistered(type, base_class);\n        }\n        if (prev && LiteGraph.onNodeTypeReplaced) {\n            LiteGraph.onNodeTypeReplaced(type, base_class, prev);\n        }\n\n        // warnings\n        if (base_class.prototype.onPropertyChange) {\n            console.warn(\n                `LiteGraph node class ${\n                    type\n                } has onPropertyChange method, it must be called onPropertyChanged with d at the end`,\n            );\n        }\n\n        // used to know which nodes create when dragging files to the canvas\n        if (base_class.supported_extensions) {\n            for (var i = 0; i < base_class.supported_extensions.length; i++) {\n                var ext = base_class.supported_extensions[i];\n                if (ext && ext.constructor === String) this.node_types_by_file_extension[ext.toLowerCase()] = base_class;\n            }\n        }\n    },\n\n    /**\n     * removes a node type from the system\n     * @method unregisterNodeType\n     * @param {String|Object} type name of the node or the node constructor itself\n     */\n    unregisterNodeType(type) {\n        const base_class = type.constructor === String ? this.registered_node_types[type] : type;\n        if (!base_class) throw (`node type not found: ${type}`);\n        delete this.registered_node_types[base_class.type];\n        if (base_class.constructor.name) delete this.Nodes[base_class.constructor.name];\n    },\n\n    /**\n     * Create a new nodetype by passing a function, it wraps it with a proper class and\n     * generates inputs according to the parameters of the function. Useful to wrap simple\n     * methods that do not require properties, and that only process some input to generate an\n     * output.\n     * @method wrapFunctionAsNode\n     * @param {String} name node name with namespace (p.e.: 'math/sum')\n     * @param {Function} func\n     * @param {Array} param_types [optional] an array containing the type of every parameter,\n     *     otherwise parameters will accept any type\n     * @param {String} return_type [optional] string with the return type, otherwise it will be\n     *     generic\n     * @param {Object} properties [optional] properties to be configurable\n     */\n    wrapFunctionAsNode(\n        name,\n        func,\n        param_types,\n        return_type,\n        properties,\n    ) {\n        const params = Array(func.length);\n        let code = \"\";\n        const names = LiteGraph.getParameterNames(func);\n        for (let i = 0; i < names.length; ++i) {\n            code\n                += `this.addInput('${\n                    names[i]\n                }',${\n                    param_types && param_types[i]\n                        ? `'${param_types[i]}'`\n                        : \"0\"\n                });\\n`;\n        }\n        code\n            += `this.addOutput('out',${\n                return_type ? `'${return_type}'` : 0\n            });\\n`;\n        if (properties) {\n            code\n                += `this.properties = ${JSON.stringify(properties)};\\n`;\n        }\n        const classobj = Function(code);\n        classobj.title = name.split(\"/\")\n            .pop();\n        classobj.desc = `Generated from ${func.name}`;\n        classobj.prototype.onExecute = function onExecute() {\n            for (let i = 0; i < params.length; ++i) {\n                params[i] = this.getInputData(i);\n            }\n            const r = func.apply(this, params);\n            this.setOutputData(0, r);\n        };\n        this.registerNodeType(name, classobj);\n    },\n\n    /**\n     * Removes all previously registered node's types\n     */\n    clearRegisteredTypes() {\n        this.registered_node_types = {};\n        this.node_types_by_file_extension = {};\n        this.Nodes = {};\n        this.searchbox_extras = {};\n    },\n\n    /**\n     * Adds this method to all nodetypes, existing and to be created\n     * (You can add it to LGraphNode.prototype but then existing node types wont have it)\n     * @method addNodeMethod\n     * @param {Function} func\n     */\n    addNodeMethod(name, func) {\n        LGraphNode.prototype[name] = func;\n        for (const i in this.registered_node_types) {\n            const type = this.registered_node_types[i];\n            if (type.prototype[name]) {\n                type.prototype[`_${name}`] = type.prototype[name];\n            } // keep old in case of replacing\n            type.prototype[name] = func;\n        }\n    },\n\n    /**\n     * Create a node of a given type with a name. The node is not attached to any graph yet.\n     * @method createNode\n     * @param {String} type full name of the node class. p.e. \"math/sin\"\n     * @param {String} name a name to distinguish from other nodes\n     * @param {Object} options to set options\n     */\n\n    createNode(type, title, options) {\n        const base_class = this.registered_node_types[type];\n        if (!base_class) {\n            if (LiteGraph.debug) {\n                console.log(\n                    `GraphNode type \"${type}\" not registered.`,\n                );\n            }\n            return null;\n        }\n\n        const prototype = base_class.prototype || base_class;\n\n        title = title || base_class.title || type;\n\n        let node = null;\n\n        if (LiteGraph.catch_exceptions) {\n            try {\n                node = new base_class(title);\n            } catch (err) {\n                console.error(err);\n                return null;\n            }\n        } else {\n            node = new base_class(title);\n        }\n\n        node.type = type;\n\n        if (!node.title && title) {\n            node.title = title;\n        }\n        if (!node.properties) {\n            node.properties = {};\n        }\n        if (!node.properties_info) {\n            node.properties_info = [];\n        }\n        if (!node.flags) {\n            node.flags = {};\n        }\n        if (!node.size) {\n            node.size = node.computeSize();\n            // call onresize?\n        }\n        if (!node.pos) {\n            node.pos = LiteGraph.DEFAULT_POSITION.concat();\n        }\n        if (!node.mode) {\n            node.mode = LiteGraph.ALWAYS;\n        }\n\n        // extra options\n        if (options) {\n            for (const i in options) {\n                node[i] = options[i];\n            }\n        }\n\n        return node;\n    },\n\n    /**\n     * Returns a registered node type with a given name\n     * @method getNodeType\n     * @param {String} type full name of the node class. p.e. \"math/sin\"\n     * @return {Class} the node class\n     */\n    getNodeType(type) {\n        return this.registered_node_types[type];\n    },\n\n    /**\n     * Returns a list of node types matching one category\n     * @method getNodeType\n     * @param {String} category category name\n     * @return {Array} array with all the node classes\n     */\n\n    getNodeTypesInCategory(category, filter) {\n        const r = [];\n        for (const i in this.registered_node_types) {\n            const type = this.registered_node_types[i];\n            if (type.filter != filter) {\n                continue;\n            }\n\n            if (category == \"\") {\n                if (type.category == null) {\n                    r.push(type);\n                }\n            } else if (type.category == category) {\n                r.push(type);\n            }\n        }\n\n        return this.auto_sort_node_types ? r.sort() : r;\n    },\n\n    /**\n     * Returns a list with all the node type categories\n     * @method getNodeTypesCategories\n     * @param {String} filter only nodes with ctor.filter equal can be shown\n     * @return {Array} array with all the names of the categories\n     */\n    getNodeTypesCategories(filter) {\n        const categories = { \"\": 1 };\n        for (var i in this.registered_node_types) {\n            const type = this.registered_node_types[i];\n            if (type.category && !type.skip_list) {\n                if (type.filter != filter) continue;\n                categories[type.category] = 1;\n            }\n        }\n        const result = [];\n        for (var i in categories) {\n            result.push(i);\n        }\n        return this.auto_sort_node_types ? result.sort() : result;\n    },\n\n    // debug purposes: reloads all the js scripts that matches a wildcard\n    reloadNodes(folder_wildcard) {\n        const tmp = document.getElementsByTagName(\"script\");\n        // weird, this array changes by its own, so we use a copy\n        const script_files = [];\n        for (var i = 0; i < tmp.length; i++) {\n            script_files.push(tmp[i]);\n        }\n\n        const docHeadObj = document.getElementsByTagName(\"head\")[0];\n        folder_wildcard = document.location.href + folder_wildcard;\n\n        for (var i = 0; i < script_files.length; i++) {\n            const { src } = script_files[i];\n            if (\n                !src\n                || src.substr(0, folder_wildcard.length) != folder_wildcard\n            ) {\n                continue;\n            }\n\n            try {\n                if (LiteGraph.debug) {\n                    console.log(`Reloading: ${src}`);\n                }\n                const dynamicScript = document.createElement(\"script\");\n                dynamicScript.type = \"text/javascript\";\n                dynamicScript.src = src;\n                docHeadObj.appendChild(dynamicScript);\n                docHeadObj.removeChild(script_files[i]);\n            } catch (err) {\n                if (LiteGraph.throw_errors) {\n                    throw err;\n                }\n                if (LiteGraph.debug) {\n                    console.log(`Error while reloading ${src}`);\n                }\n            }\n        }\n\n        if (LiteGraph.debug) {\n            console.log(\"Nodes reloaded\");\n        }\n    },\n\n    // separated just to improve if it doesn't work\n    cloneObject(obj, target) {\n        if (obj == null) {\n            return null;\n        }\n        const r = JSON.parse(JSON.stringify(obj));\n        if (!target) {\n            return r;\n        }\n\n        for (const i in r) {\n            target[i] = r[i];\n        }\n        return target;\n    },\n\n    /**\n     * Returns if the types of two slots are compatible (taking into account wildcards, etc)\n     * @method isValidConnection\n     * @param {String} type_a\n     * @param {String} type_b\n     * @return {Boolean} true if they can be connected\n     */\n    isValidConnection(type_a, type_b) {\n        if (\n            !type_a // generic output\n            || !type_b // generic input\n            || type_a == type_b // same type (is valid for triggers)\n            || (type_a == LiteGraph.EVENT && type_b == LiteGraph.ACTION)\n        ) {\n            return true;\n        }\n\n        // Enforce string type to handle toLowerCase call (-1 number not ok)\n        type_a = String(type_a);\n        type_b = String(type_b);\n        type_a = type_a.toLowerCase();\n        type_b = type_b.toLowerCase();\n\n        // For nodes supporting multiple connection types\n        if (type_a.indexOf(\",\") == -1 && type_b.indexOf(\",\") == -1) {\n            return type_a == type_b;\n        }\n\n        // Check all permutations to see if one is valid\n        const supported_types_a = type_a.split(\",\");\n        const supported_types_b = type_b.split(\",\");\n        for (let i = 0; i < supported_types_a.length; ++i) {\n            for (let j = 0; j < supported_types_b.length; ++j) {\n                if (supported_types_a[i] == supported_types_b[j]) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    },\n\n    /**\n     * Register a string in the search box so when the user types it it will recommend this node\n     * @method registerSearchboxExtra\n     * @param {String} node_type the node recommended\n     * @param {String} description text to show next to it\n     * @param {Object} data it could contain info of how the node should be configured\n     * @return {Boolean} true if they can be connected\n     */\n    registerSearchboxExtra(node_type, description, data) {\n        this.searchbox_extras[description.toLowerCase()] = {\n            type: node_type,\n            desc: description,\n            data,\n        };\n    },\n\n    /**\n     * Wrapper to load files (from url using fetch or from file using FileReader)\n     * @method fetchFile\n     * @param {String|File|Blob} url the url of the file (or the file itself)\n     * @param {String} type an string to know how to fetch it:\n     *     \"text\",\"arraybuffer\",\"json\",\"blob\"\n     * @param {Function} on_complete callback(data)\n     * @param {Function} on_error in case of an error\n     * @return {FileReader|Promise} returns the object used to\n     */\n    fetchFile(url, type, on_complete, on_error) {\n        const that = this;\n        if (!url) return null;\n\n        type = type || \"text\";\n        if (url.constructor === String) {\n            if (url.substr(0, 4) == \"http\" && LiteGraph.proxy) {\n                url = LiteGraph.proxy + url.substr(url.indexOf(\":\") + 3);\n            }\n            return fetch(url)\n                .then((response) => {\n                    if (!response.ok) throw new Error(\"File not found\"); // it will be catch\n                    // below\n                    if (type == \"arraybuffer\") return response.arrayBuffer();\n                    if (type == \"text\" || type == \"string\") return response.text();\n                    if (type == \"json\") return response.json();\n                    if (type == \"blob\") return response.blob();\n                })\n                .then((data) => {\n                    if (on_complete) on_complete(data);\n                })\n                .catch((error) => {\n                    console.error(\"error fetching file:\", url);\n                    if (on_error) on_error(error);\n                });\n        }\n        if (url.constructor === File || url.constructor === Blob) {\n            const reader = new FileReader();\n            reader.onload = function (e) {\n                let v = e.target.result;\n                if (type == \"json\") v = JSON.parse(v);\n                if (on_complete) on_complete(v);\n            };\n            if (type == \"arraybuffer\") return reader.readAsArrayBuffer(url);\n            if (type == \"text\" || type == \"json\") return reader.readAsText(url);\n            if (type == \"blob\") return reader.readAsBinaryString(url);\n        }\n        return null;\n    },\n};\n\n// timer that works everywhere\nif (performance) {\n    LiteGraph.getTime = performance.now.bind(performance);\n} else if (Date && Date.now) {\n    LiteGraph.getTime = Date.now.bind(Date);\n} else if (process) {\n    LiteGraph.getTime = () => {\n        const t = process.hrtime();\n        return t[0] * 0.001 + t[1] * 1e-6;\n    };\n} else {\n    LiteGraph.getTime = function getTime() {\n        return new Date().getTime();\n    };\n}\n//* ***************************************\n\n// Scale and Offset\nfunction DragAndScale(element, skip_events) {\n    this.offset = new Float32Array([0, 0]);\n    this.scale = 1;\n    this.max_scale = 10;\n    this.min_scale = 0.1;\n    this.onredraw = null;\n    this.enabled = true;\n    this.last_mouse = [0, 0];\n    this.element = null;\n    this.visible_area = new Float32Array(4);\n\n    if (element) {\n        this.element = element;\n        if (!skip_events) {\n            this.bindEvents(element);\n        }\n    }\n}\n\nLiteGraph.DragAndScale = DragAndScale;\n\nDragAndScale.prototype.bindEvents = function (element) {\n    this.last_mouse = new Float32Array(2);\n\n    this._binded_mouse_callback = this.onMouse.bind(this);\n\n    element.addEventListener(\"mousedown\", this._binded_mouse_callback);\n    element.addEventListener(\"mousemove\", this._binded_mouse_callback);\n\n    element.addEventListener(\n        \"mousewheel\",\n        this._binded_mouse_callback,\n        false,\n    );\n    element.addEventListener(\"wheel\", this._binded_mouse_callback, false);\n};\n\nDragAndScale.prototype.computeVisibleArea = function () {\n    if (!this.element) {\n        this.visible_area[0] = this.visible_area[1] = this.visible_area[2] = this.visible_area[3] = 0;\n        return;\n    }\n    const { width } = this.element;\n    const { height } = this.element;\n    const startx = -this.offset[0];\n    const starty = -this.offset[1];\n    const endx = startx + width / this.scale;\n    const endy = starty + height / this.scale;\n    this.visible_area[0] = startx;\n    this.visible_area[1] = starty;\n    this.visible_area[2] = endx - startx;\n    this.visible_area[3] = endy - starty;\n};\n\nDragAndScale.prototype.onMouse = function (e) {\n    if (!this.enabled) {\n        return;\n    }\n\n    const canvas = this.element;\n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    e.canvasx = x;\n    e.canvasy = y;\n    e.dragging = this.dragging;\n\n    let ignore = false;\n    if (this.onmouse) {\n        ignore = this.onmouse(e);\n    }\n\n    if (e.type == \"mousedown\") {\n        this.dragging = true;\n        canvas.removeEventListener(\n            \"mousemove\",\n            this._binded_mouse_callback,\n        );\n        document.body.addEventListener(\n            \"mousemove\",\n            this._binded_mouse_callback,\n        );\n        document.body.addEventListener(\n            \"mouseup\",\n            this._binded_mouse_callback,\n        );\n    } else if (e.type == \"mousemove\") {\n        if (!ignore) {\n            const deltax = x - this.last_mouse[0];\n            const deltay = y - this.last_mouse[1];\n            if (this.dragging) {\n                this.mouseDrag(deltax, deltay);\n            }\n        }\n    } else if (e.type == \"mouseup\") {\n        this.dragging = false;\n        document.body.removeEventListener(\n            \"mousemove\",\n            this._binded_mouse_callback,\n        );\n        document.body.removeEventListener(\n            \"mouseup\",\n            this._binded_mouse_callback,\n        );\n        canvas.addEventListener(\"mousemove\", this._binded_mouse_callback);\n    } else if (\n        e.type == \"mousewheel\"\n        || e.type == \"wheel\"\n        || e.type == \"DOMMouseScroll\"\n    ) {\n        e.eventType = \"mousewheel\";\n        if (e.type == \"wheel\") {\n            e.wheel = -e.deltaY;\n        } else {\n            e.wheel = e.wheelDeltaY != null ? e.wheelDeltaY : e.detail * -60;\n        }\n\n        // from stack overflow\n        e.delta = e.wheelDelta\n            ? e.wheelDelta / 40\n            : e.deltaY\n                ? -e.deltaY / 3\n                : 0;\n        this.changeDeltaScale(1.0 + e.delta * 0.05);\n    }\n\n    this.last_mouse[0] = x;\n    this.last_mouse[1] = y;\n\n    e.preventDefault();\n    e.stopPropagation();\n    return false;\n};\n\nDragAndScale.prototype.toCanvasContext = function (ctx) {\n    ctx.scale(this.scale, this.scale);\n    ctx.translate(this.offset[0], this.offset[1]);\n};\n\nDragAndScale.prototype.convertOffsetToCanvas = function (pos) {\n    // return [pos[0] / this.scale - this.offset[0], pos[1] / this.scale - this.offset[1]];\n    return [\n        (pos[0] + this.offset[0]) * this.scale,\n        (pos[1] + this.offset[1]) * this.scale,\n    ];\n};\n\nDragAndScale.prototype.convertCanvasToOffset = function (pos, out) {\n    out = out || [0, 0];\n    out[0] = pos[0] / this.scale - this.offset[0];\n    out[1] = pos[1] / this.scale - this.offset[1];\n    return out;\n};\n\nDragAndScale.prototype.mouseDrag = function (x, y) {\n    this.offset[0] += x / this.scale;\n    this.offset[1] += y / this.scale;\n\n    if (this.onredraw) {\n        this.onredraw(this);\n    }\n};\n\nDragAndScale.prototype.changeScale = function (value, zooming_center) {\n    if (value < this.min_scale) {\n        value = this.min_scale;\n    } else if (value > this.max_scale) {\n        value = this.max_scale;\n    }\n\n    if (value == this.scale) {\n        return;\n    }\n\n    if (!this.element) {\n        return;\n    }\n\n    const rect = this.element.getBoundingClientRect();\n    if (!rect) {\n        return;\n    }\n\n    zooming_center = zooming_center || [\n        rect.width * 0.5,\n        rect.height * 0.5,\n    ];\n    const center = this.convertCanvasToOffset(zooming_center);\n    this.scale = value;\n    if (Math.abs(this.scale - 1) < 0.01) {\n        this.scale = 1;\n    }\n\n    const new_center = this.convertCanvasToOffset(zooming_center);\n    const delta_offset = [\n        new_center[0] - center[0],\n        new_center[1] - center[1],\n    ];\n\n    this.offset[0] += delta_offset[0];\n    this.offset[1] += delta_offset[1];\n\n    if (this.onredraw) {\n        this.onredraw(this);\n    }\n};\n\nDragAndScale.prototype.changeDeltaScale = function (value, zooming_center) {\n    this.changeScale(this.scale * value, zooming_center);\n};\n\nDragAndScale.prototype.reset = function () {\n    this.scale = 1;\n    this.offset[0] = 0;\n    this.offset[1] = 0;\n};\n\n//* ********************************************************************************\n// LGraphCanvas: LGraph renderer CLASS\n//* ********************************************************************************\n\n/**\n * This class is in charge of rendering one graph inside a canvas. And provides all the\n * interaction required. Valid callbacks are: onNodeSelected, onNodeDeselected,\n * onShowNodePanel, onNodeDblClicked\n *\n * @class LGraphCanvas\n * @constructor\n * @param {HTMLCanvas} canvas the canvas where you want to render (it accepts a selector in\n *     string format or the canvas element itself)\n * @param {LGraph} graph [optional]\n * @param {Object} options [optional] { skip_rendering, autoresize }\n */\nfunction LGraphCanvas(canvas, graph, options) {\n    options = options || {};\n\n    // if(graph === undefined)\n    //\tthrow (\"No graph assigned\");\n    this.background_image = LGraphCanvas.DEFAULT_BACKGROUND_IMAGE;\n\n    if (canvas && canvas.constructor === String) {\n        canvas = document.querySelector(canvas);\n    }\n\n    this.ds = new DragAndScale();\n    this.zoom_modify_alpha = true; // otherwise it generates ugly patterns when scaling down\n    // too much\n\n    this.title_text_font = `${LiteGraph.NODE_TEXT_SIZE}px Arial`;\n    this.inner_text_font = `normal ${LiteGraph.NODE_SUBTEXT_SIZE}px Arial`;\n    this.node_title_color = LiteGraph.NODE_TITLE_COLOR;\n    this.default_link_color = LiteGraph.LINK_COLOR;\n    this.default_connection_color = {\n        input_off: \"#778\",\n        input_on: \"#7F7\",\n        output_off: \"#778\",\n        output_on: \"#7F7\",\n    };\n\n    this.highquality_render = true;\n    this.use_gradients = false; // set to true to render titlebar with gradients\n    this.editor_alpha = 1; // used for transition\n    this.pause_rendering = false;\n    this.clear_background = true;\n\n    this.read_only = false; // if set to true users cannot modify the graph\n    this.render_only_selected = true;\n    this.live_mode = false;\n    this.show_info = true;\n    this.allow_dragcanvas = true;\n    this.allow_dragnodes = true;\n    this.allow_interaction = true; // allow to control widgets, buttons, collapse, etc\n    this.allow_searchbox = true;\n    this.allow_reconnect_links = false; // allows to change a connection with having to redo it\n    // again\n\n    this.drag_mode = false;\n    this.dragging_rectangle = null;\n\n    this.filter = null; // allows to filter to only accept some type of nodes in a graph\n\n    this.set_canvas_dirty_on_mouse_event = true; // forces to redraw the canvas if the mouse\n    // does anything\n    this.always_render_background = false;\n    this.render_shadows = true;\n    this.render_canvas_border = true;\n    this.render_connections_shadows = false; // too much cpu\n    this.render_connections_border = true;\n    this.render_curved_connections = false;\n    this.render_connection_arrows = false;\n    this.render_collapsed_slots = true;\n    this.render_execution_order = false;\n    this.render_title_colored = true;\n    this.render_link_tooltip = true;\n\n    this.links_render_mode = LiteGraph.SPLINE_LINK;\n\n    this.mouse = [0, 0]; // mouse in canvas coordinates, where 0,0 is the top-left corner of\n    // the blue rectangle\n    this.graph_mouse = [0, 0]; // mouse in graph coordinates, where 0,0 is the top-left corner\n    // of the blue rectangle\n    this.canvas_mouse = this.graph_mouse; // LEGACY: REMOVE THIS, USE GRAPH_MOUSE INSTEAD\n\n    // to personalize the search box\n    this.onSearchBox = null;\n    this.onSearchBoxSelection = null;\n\n    // callbacks\n    this.onMouse = null;\n    this.onDrawBackground = null; // to render background objects (behind nodes and\n    // connections) in the canvas affected by transform\n    this.onDrawForeground = null; // to render foreground objects (above nodes and connections)\n    // in the canvas affected by transform\n    this.onDrawOverlay = null; // to render foreground objects not affected by transform (for\n    // GUIs)\n    this.onDrawLinkTooltip = null; // called when rendering a tooltip\n    this.onNodeMoved = null; // called after moving a node\n    this.onSelectionChange = null; // called if the selection changes\n    this.onConnectingChange = null; // called before any link changes\n    this.onBeforeChange = null; // called before modifying the graph\n    this.onAfterChange = null; // called after modifying the graph\n\n    this.connections_width = 3;\n    this.round_radius = 8;\n\n    this.current_node = null;\n    this.node_widget = null; // used for widgets\n    this.over_link_center = null;\n    this.last_mouse_position = [0, 0];\n    this.visible_area = this.ds.visible_area;\n    this.visible_links = [];\n\n    // link canvas and graph\n    if (graph) {\n        graph.attachCanvas(this);\n    }\n\n    this.setCanvas(canvas);\n    this.clear();\n\n    if (!options.skip_render) {\n        this.startRendering();\n    }\n\n    this.autoresize = options.autoresize;\n}\n\nLGraphCanvas = LiteGraph.LGraphCanvas = LGraphCanvas;\n\nLGraphCanvas.DEFAULT_BACKGROUND_IMAGE = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQBJREFUeNrs1rEKwjAUhlETUkj3vP9rdmr1Ysammk2w5wdxuLgcMHyptfawuZX4pJSWZTnfnu/lnIe/jNNxHHGNn//HNbbv+4dr6V+11uF527arU7+u63qfa/bnmh8sWLBgwYJlqRf8MEptXPBXJXa37BSl3ixYsGDBMliwFLyCV/DeLIMFCxYsWLBMwSt4Be/NggXLYMGCBUvBK3iNruC9WbBgwYJlsGApeAWv4L1ZBgsWLFiwYJmCV/AK3psFC5bBggULloJX8BpdwXuzYMGCBctgwVLwCl7Be7MMFixYsGDBsu8FH1FaSmExVfAxBa/gvVmwYMGCZbBg/W4vAQYA5tRF9QYlv/QAAAAASUVORK5CYII=\";\n\nLGraphCanvas.link_type_colors = {\n    \"-1\": LiteGraph.EVENT_LINK_COLOR,\n    number: \"#AAA\",\n    node: \"#DCA\",\n};\nLGraphCanvas.gradients = {}; // cache of gradients\n\n/**\n * clears all the data inside\n *\n * @method clear\n */\nLGraphCanvas.prototype.clear = function () {\n    this.frame = 0;\n    this.last_draw_time = 0;\n    this.render_time = 0;\n    this.fps = 0;\n\n    // this.scale = 1;\n    // this.offset = [0,0];\n\n    this.dragging_rectangle = null;\n\n    this.selected_nodes = {};\n    this.selected_group = null;\n\n    this.visible_nodes = [];\n    this.node_dragged = null;\n    this.node_over = null;\n    this.node_capturing_input = null;\n    this.connecting_node = null;\n    this.highlighted_links = {};\n\n    this.dragging_canvas = false;\n\n    this.dirty_canvas = true;\n    this.dirty_bgcanvas = true;\n    this.dirty_area = null;\n\n    this.node_in_panel = null;\n    this.node_widget = null;\n\n    this.last_mouse = [0, 0];\n    this.last_mouseclick = 0;\n    this.visible_area.set([0, 0, 0, 0]);\n\n    if (this.onClear) {\n        this.onClear();\n    }\n};\n\n/**\n * assigns a graph, you can reassign graphs to the same canvas\n *\n * @method setGraph\n * @param {LGraph} graph\n */\nLGraphCanvas.prototype.setGraph = function (graph, skip_clear) {\n    if (this.graph == graph) {\n        return;\n    }\n\n    if (!skip_clear) {\n        this.clear();\n    }\n\n    if (!graph && this.graph) {\n        this.graph.detachCanvas(this);\n        return;\n    }\n\n    graph.attachCanvas(this);\n\n    // remove the graph stack in case a subgraph was open\n    if (this._graph_stack) this._graph_stack = null;\n\n    this.setDirty(true, true);\n};\n\n/**\n * returns the top level graph (in case there are subgraphs open on the canvas)\n *\n * @method getTopGraph\n * @return {LGraph} graph\n */\nLGraphCanvas.prototype.getTopGraph = function () {\n    if (this._graph_stack.length) return this._graph_stack[0];\n    return this.graph;\n};\n\n/**\n * opens a graph contained inside a node in the current graph\n *\n * @method openSubgraph\n * @param {LGraph} graph\n */\nLGraphCanvas.prototype.openSubgraph = function (graph) {\n    if (!graph) {\n        throw \"graph cannot be null\";\n    }\n\n    if (this.graph == graph) {\n        throw \"graph cannot be the same\";\n    }\n\n    this.clear();\n\n    if (this.graph) {\n        if (!this._graph_stack) {\n            this._graph_stack = [];\n        }\n        this._graph_stack.push(this.graph);\n    }\n\n    graph.attachCanvas(this);\n    this.checkPanels();\n    this.setDirty(true, true);\n};\n\n/**\n * closes a subgraph contained inside a node\n *\n * @method closeSubgraph\n * @param {LGraph} assigns a graph\n */\nLGraphCanvas.prototype.closeSubgraph = function () {\n    if (!this._graph_stack || this._graph_stack.length == 0) {\n        return;\n    }\n    const subgraph_node = this.graph._subgraph_node;\n    const graph = this._graph_stack.pop();\n    this.selected_nodes = {};\n    this.highlighted_links = {};\n    graph.attachCanvas(this);\n    this.setDirty(true, true);\n    if (subgraph_node) {\n        this.centerOnNode(subgraph_node);\n        this.selectNodes([subgraph_node]);\n    }\n};\n\n/**\n * returns the visualy active graph (in case there are more in the stack)\n * @method getCurrentGraph\n * @return {LGraph} the active graph\n */\nLGraphCanvas.prototype.getCurrentGraph = function () {\n    return this.graph;\n};\n\n/**\n * assigns a canvas\n *\n * @method setCanvas\n * @param {Canvas} assigns a canvas (also accepts the ID of the element (not a selector)\n */\nLGraphCanvas.prototype.setCanvas = function (canvas, skip_events) {\n    const that = this;\n\n    if (canvas) {\n        if (canvas.constructor === String) {\n            canvas = document.getElementById(canvas);\n            if (!canvas) {\n                throw \"Error creating LiteGraph canvas: Canvas not found\";\n            }\n        }\n    }\n\n    if (canvas === this.canvas) {\n        return;\n    }\n\n    if (!canvas && this.canvas) {\n        // maybe detach events from old_canvas\n        if (!skip_events) {\n            this.unbindEvents();\n        }\n    }\n\n    this.canvas = canvas;\n    this.ds.element = canvas;\n\n    if (!canvas) {\n        return;\n    }\n\n    // this.canvas.tabindex = \"1000\";\n    canvas.className += \" lgraphcanvas\";\n    canvas.data = this;\n    canvas.tabindex = \"1\"; // to allow key events\n\n    // bg canvas: used for non changing stuff\n    this.bgcanvas = null;\n    if (!this.bgcanvas) {\n        this.bgcanvas = document.createElement(\"canvas\");\n        this.bgcanvas.width = this.canvas.width;\n        this.bgcanvas.height = this.canvas.height;\n    }\n\n    if (canvas.getContext == null) {\n        if (canvas.localName != \"canvas\") {\n            throw `Element supplied for LGraphCanvas must be a <canvas> element, you passed a ${\n                canvas.localName}`;\n        }\n        throw \"This browser doesn't support Canvas\";\n    }\n\n    const ctx = (this.ctx = canvas.getContext(\"2d\"));\n    if (ctx == null) {\n        if (!canvas.webgl_enabled) {\n            console.warn(\n                \"This canvas seems to be WebGL, enabling WebGL renderer\",\n            );\n        }\n        this.enableWebGL();\n    }\n\n    // input:  (move and up could be unbinded)\n    this._mousemove_callback = this.processMouseMove.bind(this);\n    this._mouseup_callback = this.processMouseUp.bind(this);\n\n    if (!skip_events) {\n        this.bindEvents();\n    }\n};\n\n// used in some events to capture them\nLGraphCanvas.prototype._doNothing = function doNothing(e) {\n    e.preventDefault();\n    return false;\n};\nLGraphCanvas.prototype._doReturnTrue = function doNothing(e) {\n    e.preventDefault();\n    return true;\n};\n\n/**\n * binds mouse, keyboard, touch and drag events to the canvas\n * @method bindEvents\n * */\nLGraphCanvas.prototype.bindEvents = function () {\n    if (this._events_binded) {\n        console.warn(\"LGraphCanvas: events already binded\");\n        return;\n    }\n\n    const { canvas } = this;\n\n    const ref_window = this.getCanvasWindow();\n    const { document } = ref_window; // hack used when moving canvas between windows\n\n    this._mousedown_callback = this.processMouseDown.bind(this);\n    this._mousewheel_callback = this.processMouseWheel.bind(this);\n\n    canvas.addEventListener(\"mousedown\", this._mousedown_callback, true); // down do not need\n    // to store the\n    // binded\n    canvas.addEventListener(\"mousemove\", this._mousemove_callback);\n    canvas.addEventListener(\"mousewheel\", this._mousewheel_callback, false);\n\n    canvas.addEventListener(\"contextmenu\", this._doNothing);\n    canvas.addEventListener(\n        \"DOMMouseScroll\",\n        this._mousewheel_callback,\n        false,\n    );\n\n    // touch events\n    // if( 'touchstart' in document.documentElement )\n    {\n        canvas.addEventListener(\"touchstart\", this.touchHandler, true);\n        canvas.addEventListener(\"touchmove\", this.touchHandler, true);\n        canvas.addEventListener(\"touchend\", this.touchHandler, true);\n        canvas.addEventListener(\"touchcancel\", this.touchHandler, true);\n    }\n\n    // Keyboard ******************\n    this._key_callback = this.processKey.bind(this);\n\n    canvas.addEventListener(\"keydown\", this._key_callback, true);\n    document.addEventListener(\"keyup\", this._key_callback, true); // in document, otherwise it\n    // doesn't fire keyup\n\n    // Dropping Stuff over nodes ************************************\n    this._ondrop_callback = this.processDrop.bind(this);\n\n    canvas.addEventListener(\"dragover\", this._doNothing, false);\n    canvas.addEventListener(\"dragend\", this._doNothing, false);\n    canvas.addEventListener(\"drop\", this._ondrop_callback, false);\n    canvas.addEventListener(\"dragenter\", this._doReturnTrue, false);\n\n    this._events_binded = true;\n};\n\n/**\n * unbinds mouse events from the canvas\n * @method unbindEvents\n * */\nLGraphCanvas.prototype.unbindEvents = function () {\n    if (!this._events_binded) {\n        console.warn(\"LGraphCanvas: no events binded\");\n        return;\n    }\n\n    const ref_window = this.getCanvasWindow();\n    const { document } = ref_window;\n\n    this.canvas.removeEventListener(\"mousedown\", this._mousedown_callback);\n    this.canvas.removeEventListener(\n        \"mousewheel\",\n        this._mousewheel_callback,\n    );\n    this.canvas.removeEventListener(\n        \"DOMMouseScroll\",\n        this._mousewheel_callback,\n    );\n    this.canvas.removeEventListener(\"keydown\", this._key_callback);\n    document.removeEventListener(\"keyup\", this._key_callback);\n    this.canvas.removeEventListener(\"contextmenu\", this._doNothing);\n    this.canvas.removeEventListener(\"drop\", this._ondrop_callback);\n    this.canvas.removeEventListener(\"dragenter\", this._doReturnTrue);\n\n    this.canvas.removeEventListener(\"touchstart\", this.touchHandler);\n    this.canvas.removeEventListener(\"touchmove\", this.touchHandler);\n    this.canvas.removeEventListener(\"touchend\", this.touchHandler);\n    this.canvas.removeEventListener(\"touchcancel\", this.touchHandler);\n\n    this._mousedown_callback = null;\n    this._mousewheel_callback = null;\n    this._key_callback = null;\n    this._ondrop_callback = null;\n\n    this._events_binded = false;\n};\n\nLGraphCanvas.getFileExtension = function (url) {\n    const question = url.indexOf(\"?\");\n    if (question != -1) {\n        url = url.substr(0, question);\n    }\n    const point = url.lastIndexOf(\".\");\n    if (point == -1) {\n        return \"\";\n    }\n    return url.substr(point + 1)\n        .toLowerCase();\n};\n\n/**\n * this function allows to render the canvas using WebGL instead of Canvas2D\n * this is useful if you plant to render 3D objects inside your nodes, it uses litegl.js for\n * webgl and canvas2DtoWebGL to emulate the Canvas2D calls in webGL\n * @method enableWebGL\n * */\nLGraphCanvas.prototype.enableWebGL = function () {\n    if (typeof GL === undefined) {\n        throw \"litegl.js must be included to use a WebGL canvas\";\n    }\n    if (typeof enableWebGLCanvas === undefined) {\n        throw \"webglCanvas.js must be included to use this feature\";\n    }\n\n    this.gl = this.ctx = enableWebGLCanvas(this.canvas);\n    this.ctx.webgl = true;\n    this.bgcanvas = this.canvas;\n    this.bgctx = this.gl;\n    this.canvas.webgl_enabled = true;\n\n    /*\nGL.create({ canvas: this.bgcanvas });\nthis.bgctx = enableWebGLCanvas( this.bgcanvas );\nwindow.gl = this.gl;\n*/\n};\n\n/**\n * marks as dirty the canvas, this way it will be rendered again\n *\n * @class LGraphCanvas\n * @method setDirty\n * @param {bool} fgcanvas if the foreground canvas is dirty (the one containing the nodes)\n * @param {bool} bgcanvas if the background canvas is dirty (the one containing the wires)\n */\nLGraphCanvas.prototype.setDirty = function (fgcanvas, bgcanvas) {\n    if (fgcanvas) {\n        this.dirty_canvas = true;\n    }\n    if (bgcanvas) {\n        this.dirty_bgcanvas = true;\n    }\n};\n\n/**\n * Used to attach the canvas in a popup\n *\n * @method getCanvasWindow\n * @return {window} returns the window where the canvas is attached (the DOM root node)\n */\nLGraphCanvas.prototype.getCanvasWindow = function () {\n    if (!this.canvas) {\n        return window;\n    }\n    const doc = this.canvas.ownerDocument;\n    return doc.defaultView || doc.parentWindow;\n};\n\n/**\n * starts rendering the content of the canvas when needed\n *\n * @method startRendering\n */\nLGraphCanvas.prototype.startRendering = function () {\n    if (this.is_rendering) {\n        return;\n    } // already rendering\n\n    this.is_rendering = true;\n    renderFrame.call(this);\n\n    function renderFrame() {\n        if (!this.pause_rendering) {\n            this.draw();\n        }\n\n        const window = this.getCanvasWindow();\n        if (this.is_rendering) {\n            window.requestAnimationFrame(renderFrame.bind(this));\n        }\n    }\n};\n\n/**\n * stops rendering the content of the canvas (to save resources)\n *\n * @method stopRendering\n */\nLGraphCanvas.prototype.stopRendering = function () {\n    this.is_rendering = false;\n    /*\nif(this.rendering_timer_id)\n{\nclearInterval(this.rendering_timer_id);\nthis.rendering_timer_id = null;\n}\n*/\n};\n\n/* LiteGraphCanvas input */\n\n// used to block future mouse events (because of im gui)\nLGraphCanvas.prototype.blockClick = function () {\n    this.block_click = true;\n    this.last_mouseclick = 0;\n};\n\nLGraphCanvas.prototype.processMouseDown = function (e) {\n    if (this.set_canvas_dirty_on_mouse_event) this.dirty_canvas = true;\n\n    if (!this.graph) {\n        return;\n    }\n\n    this.adjustMouseEvent(e);\n\n    const ref_window = this.getCanvasWindow();\n    const { document } = ref_window;\n    LGraphCanvas.active_canvas = this;\n    var that = this;\n\n    // move mouse move event to the window in case it drags outside of the canvas\n    this.canvas.removeEventListener(\"mousemove\", this._mousemove_callback);\n    ref_window.document.addEventListener(\n        \"mousemove\",\n        this._mousemove_callback,\n        true,\n    ); // catch for the entire window\n    ref_window.document.addEventListener(\n        \"mouseup\",\n        this._mouseup_callback,\n        true,\n    );\n\n    const node = this.graph.getNodeOnPos(\n        e.canvasX,\n        e.canvasY,\n        this.visible_nodes,\n        5,\n    );\n    const skip_dragging = false;\n    let skip_action = false;\n    const now = LiteGraph.getTime();\n    const is_double_click = now - this.last_mouseclick < 300;\n    this.mouse[0] = e.localX;\n    this.mouse[1] = e.localY;\n    this.graph_mouse[0] = e.canvasX;\n    this.graph_mouse[1] = e.canvasY;\n    this.last_click_position = [this.mouse[0], this.mouse[1]];\n\n    this.canvas.focus();\n\n    LiteGraph.closeAllContextMenus(ref_window);\n\n    if (this.onMouse) {\n        if (this.onMouse(e) == true) return;\n    }\n\n    // left button mouse\n    if (e.which == 1) {\n        if (e.ctrlKey) {\n            this.dragging_rectangle = new Float32Array(4);\n            this.dragging_rectangle[0] = e.canvasX;\n            this.dragging_rectangle[1] = e.canvasY;\n            this.dragging_rectangle[2] = 1;\n            this.dragging_rectangle[3] = 1;\n            skip_action = true;\n        }\n\n        let clicking_canvas_bg = false;\n\n        // when clicked on top of a node\n        // and it is not interactive\n        if (node && this.allow_interaction && !skip_action && !this.read_only) {\n            if (!this.live_mode && !node.flags.pinned) {\n                this.bringToFront(node);\n            } // if it wasn't selected?\n\n            // not dragging mouse to connect two slots\n            if (\n                !this.connecting_node\n                && !node.flags.collapsed\n                && !this.live_mode\n            ) {\n                // Search for corner for resize\n                if (\n                    !skip_action\n                    && node.resizable !== false\n                    && isInsideRectangle(\n                        e.canvasX,\n                        e.canvasY,\n                        node.pos[0] + node.size[0] - 5,\n                        node.pos[1] + node.size[1] - 5,\n                        10,\n                        10,\n                    )\n                ) {\n                    this.graph.beforeChange();\n                    this.resizing_node = node;\n                    this.canvas.style.cursor = \"se-resize\";\n                    skip_action = true;\n                } else {\n                    // search for outputs\n                    if (node.outputs) {\n                        for (\n                            var i = 0, l = node.outputs.length;\n                            i < l;\n                            ++i\n                        ) {\n                            const output = node.outputs[i];\n                            var link_pos = node.getConnectionPos(false, i);\n                            if (\n                                isInsideRectangle(\n                                    e.canvasX,\n                                    e.canvasY,\n                                    link_pos[0] - 15,\n                                    link_pos[1] - 10,\n                                    30,\n                                    20,\n                                )\n                            ) {\n                                this.connecting_node = node;\n                                this.connecting_output = output;\n                                this.connecting_pos = node.getConnectionPos(false, i);\n                                this.connecting_slot = i;\n\n                                if (e.shiftKey) {\n                                    node.disconnectOutput(i);\n                                }\n\n                                if (is_double_click) {\n                                    if (node.onOutputDblClick) {\n                                        node.onOutputDblClick(i, e);\n                                    }\n                                } else if (node.onOutputClick) {\n                                    node.onOutputClick(i, e);\n                                }\n\n                                skip_action = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    // search for inputs\n                    if (node.inputs) {\n                        for (\n                            var i = 0, l = node.inputs.length;\n                            i < l;\n                            ++i\n                        ) {\n                            const input = node.inputs[i];\n                            var link_pos = node.getConnectionPos(true, i);\n                            if (\n                                isInsideRectangle(\n                                    e.canvasX,\n                                    e.canvasY,\n                                    link_pos[0] - 15,\n                                    link_pos[1] - 10,\n                                    30,\n                                    20,\n                                )\n                            ) {\n                                if (is_double_click) {\n                                    if (node.onInputDblClick) {\n                                        node.onInputDblClick(i, e);\n                                    }\n                                } else if (node.onInputClick) {\n                                    node.onInputClick(i, e);\n                                }\n\n                                if (input.link !== null) {\n                                    const link_info = this.graph.links[\n                                        input.link\n                                    ]; // before disconnecting\n                                    node.disconnectInput(i);\n\n                                    if (\n                                        this.allow_reconnect_links\n                                        || e.shiftKey\n                                    ) {\n                                        this.connecting_node = this.graph._nodes_by_id[\n                                            link_info.origin_id\n                                        ];\n                                        this.connecting_slot = link_info.origin_slot;\n                                        this.connecting_output = this.connecting_node.outputs[\n                                            this.connecting_slot\n                                        ];\n                                        this.connecting_pos = this.connecting_node.getConnectionPos(false, this.connecting_slot);\n                                    }\n\n                                    this.dirty_bgcanvas = true;\n                                    skip_action = true;\n                                }\n                            }\n                        }\n                    }\n                } // not resizing\n            }\n\n            // it wasn't clicked on the links boxes\n            if (!skip_action) {\n                let block_drag_node = false;\n                const pos = [e.canvasX - node.pos[0], e.canvasY - node.pos[1]];\n\n                // widgets\n                const widget = this.processNodeWidgets(node, this.graph_mouse, e);\n                if (widget) {\n                    block_drag_node = true;\n                    this.node_widget = [node, widget];\n                }\n\n                // double clicking\n                if (is_double_click && this.selected_nodes[node.id]) {\n                    // double click node\n                    if (node.onDblClick) {\n                        node.onDblClick(e, pos, this);\n                    }\n                    this.processNodeDblClicked(node);\n                    block_drag_node = true;\n                }\n\n                // if do not capture mouse\n                if (node.onMouseDown && node.onMouseDown(e, pos, this)) {\n                    block_drag_node = true;\n                } else {\n                    // open subgraph button\n                    if (node.subgraph && !node.skip_subgraph_button) {\n                        if (!node.flags.collapsed && pos[0] > node.size[0] - LiteGraph.NODE_TITLE_HEIGHT && pos[1] < 0) {\n                            var that = this;\n                            setTimeout(() => {\n                                that.openSubgraph(node.subgraph);\n                            }, 10);\n                        }\n                    }\n\n                    if (this.live_mode) {\n                        clicking_canvas_bg = true;\n                        block_drag_node = true;\n                    }\n                }\n\n                if (!block_drag_node) {\n                    if (this.allow_dragnodes) {\n                        this.graph.beforeChange();\n                        this.node_dragged = node;\n                    }\n                    if (!this.selected_nodes[node.id]) {\n                        this.processNodeSelected(node, e);\n                    }\n                }\n\n                this.dirty_canvas = true;\n            }\n        } // clicked outside of nodes\n        else {\n            // search for link connector\n            if (!this.read_only) {\n                for (var i = 0; i < this.visible_links.length; ++i) {\n                    const link = this.visible_links[i];\n                    const center = link._pos;\n                    if (\n                        !center\n                        || e.canvasX < center[0] - 4\n                        || e.canvasX > center[0] + 4\n                        || e.canvasY < center[1] - 4\n                        || e.canvasY > center[1] + 4\n                    ) {\n                        continue;\n                    }\n                    // link clicked\n                    this.showLinkMenu(link, e);\n                    this.over_link_center = null; // clear tooltip\n                    break;\n                }\n            }\n\n            this.selected_group = this.graph.getGroupOnPos(e.canvasX, e.canvasY);\n            this.selected_group_resizing = false;\n            if (this.selected_group && !this.read_only) {\n                if (e.ctrlKey) {\n                    this.dragging_rectangle = null;\n                }\n\n                const dist = distance([e.canvasX, e.canvasY], [this.selected_group.pos[0] + this.selected_group.size[0], this.selected_group.pos[1] + this.selected_group.size[1]]);\n                if (dist * this.ds.scale < 10) {\n                    this.selected_group_resizing = true;\n                } else {\n                    this.selected_group.recomputeInsideNodes();\n                }\n            }\n\n            if (is_double_click && !this.read_only && this.allow_searchbox) {\n                this.showSearchBox(e);\n            }\n\n            clicking_canvas_bg = true;\n        }\n\n        if (!skip_action && clicking_canvas_bg && this.allow_dragcanvas) {\n            this.dragging_canvas = true;\n        }\n    } else if (e.which == 2) {\n        // middle button\n    } else if (e.which == 3) {\n        // right button\n        if (!this.read_only) this.processContextMenu(node, e);\n    }\n\n    // TODO\n    // if(this.node_selected != prev_selected)\n    //\tthis.onNodeSelectionChange(this.node_selected);\n\n    this.last_mouse[0] = e.localX;\n    this.last_mouse[1] = e.localY;\n    this.last_mouseclick = LiteGraph.getTime();\n    this.last_mouse_dragging = true;\n\n    /*\nif( (this.dirty_canvas || this.dirty_bgcanvas) && this.rendering_timer_id == null)\nthis.draw();\n*/\n\n    this.graph.change();\n\n    // this is to ensure to defocus(blur) if a text input element is on focus\n    if (\n        !ref_window.document.activeElement\n        || (ref_window.document.activeElement.nodeName.toLowerCase()\n        != \"input\"\n        && ref_window.document.activeElement.nodeName.toLowerCase()\n        != \"textarea\")\n    ) {\n        e.preventDefault();\n    }\n    e.stopPropagation();\n\n    if (this.onMouseDown) {\n        this.onMouseDown(e);\n    }\n\n    return false;\n};\n\n/**\n * Called when a mouse move event has to be processed\n * @method processMouseMove\n * */\nLGraphCanvas.prototype.processMouseMove = function (e) {\n    if (this.autoresize) {\n        this.resize();\n    }\n\n    if (this.set_canvas_dirty_on_mouse_event) this.dirty_canvas = true;\n\n    if (!this.graph) {\n        return;\n    }\n\n    LGraphCanvas.active_canvas = this;\n    this.adjustMouseEvent(e);\n    const mouse = [e.localX, e.localY];\n    this.mouse[0] = mouse[0];\n    this.mouse[1] = mouse[1];\n    const delta = [\n        mouse[0] - this.last_mouse[0],\n        mouse[1] - this.last_mouse[1],\n    ];\n    this.last_mouse = mouse;\n    this.graph_mouse[0] = e.canvasX;\n    this.graph_mouse[1] = e.canvasY;\n\n    if (this.block_click) {\n        e.preventDefault();\n        return false;\n    }\n\n    e.dragging = this.last_mouse_dragging;\n\n    if (this.node_widget) {\n        this.processNodeWidgets(\n            this.node_widget[0],\n            this.graph_mouse,\n            e,\n            this.node_widget[1],\n        );\n        this.dirty_canvas = true;\n    }\n\n    if (this.dragging_rectangle) {\n        this.dragging_rectangle[2] = e.canvasX - this.dragging_rectangle[0];\n        this.dragging_rectangle[3] = e.canvasY - this.dragging_rectangle[1];\n        this.dirty_canvas = true;\n    } else if (this.selected_group && !this.read_only) {\n        // moving/resizing a group\n        if (this.selected_group_resizing) {\n            this.selected_group.size = [\n                e.canvasX - this.selected_group.pos[0],\n                e.canvasY - this.selected_group.pos[1],\n            ];\n        } else {\n            const deltax = delta[0] / this.ds.scale;\n            const deltay = delta[1] / this.ds.scale;\n            this.selected_group.move(deltax, deltay, e.ctrlKey);\n            if (this.selected_group._nodes.length) {\n                this.dirty_canvas = true;\n            }\n        }\n        this.dirty_bgcanvas = true;\n    } else if (this.dragging_canvas) {\n        this.ds.offset[0] += delta[0] / this.ds.scale;\n        this.ds.offset[1] += delta[1] / this.ds.scale;\n        this.dirty_canvas = true;\n        this.dirty_bgcanvas = true;\n    } else if (this.allow_interaction && !this.read_only) {\n        if (this.connecting_node) {\n            this.dirty_canvas = true;\n        }\n\n        // get node over\n        const node = this.graph.getNodeOnPos(e.canvasX, e.canvasY, this.visible_nodes);\n\n        // remove mouseover flag\n        for (var i = 0, l = this.graph._nodes.length; i < l; ++i) {\n            if (this.graph._nodes[i].mouseOver && node != this.graph._nodes[i]) {\n                // mouse leave\n                this.graph._nodes[i].mouseOver = false;\n                if (this.node_over && this.node_over.onMouseLeave) {\n                    this.node_over.onMouseLeave(e);\n                }\n                this.node_over = null;\n                this.dirty_canvas = true;\n            }\n        }\n\n        // mouse over a node\n        if (node) {\n            if (node.redraw_on_mouse) this.dirty_canvas = true;\n\n            // this.canvas.style.cursor = \"move\";\n            if (!node.mouseOver) {\n                // mouse enter\n                node.mouseOver = true;\n                this.node_over = node;\n                this.dirty_canvas = true;\n\n                if (node.onMouseEnter) {\n                    node.onMouseEnter(e);\n                }\n            }\n\n            // in case the node wants to do something\n            if (node.onMouseMove) {\n                node.onMouseMove(e, [e.canvasX - node.pos[0], e.canvasY - node.pos[1]], this);\n            }\n\n            // if dragging a link\n            if (this.connecting_node) {\n                const pos = this._highlight_input || [0, 0]; // to store the output of\n                // isOverNodeInput\n\n                // on top of input\n                if (this.isOverNodeBox(node, e.canvasX, e.canvasY)) {\n                    // mouse on top of the corner box, don't know what to do\n                } else {\n                    // check if I have a slot below de mouse\n                    const slot = this.isOverNodeInput(node, e.canvasX, e.canvasY, pos);\n                    if (slot != -1 && node.inputs[slot]) {\n                        const slot_type = node.inputs[slot].type;\n                        if (LiteGraph.isValidConnection(this.connecting_output.type, slot_type)) {\n                            this._highlight_input = pos;\n                        }\n                    } else {\n                        this._highlight_input = null;\n                    }\n                }\n            }\n\n            // Search for corner\n            if (this.canvas) {\n                if (\n                    isInsideRectangle(\n                        e.canvasX,\n                        e.canvasY,\n                        node.pos[0] + node.size[0] - 5,\n                        node.pos[1] + node.size[1] - 5,\n                        5,\n                        5,\n                    )\n                ) {\n                    this.canvas.style.cursor = \"se-resize\";\n                } else {\n                    this.canvas.style.cursor = \"crosshair\";\n                }\n            }\n        } else { // not over a node\n            // search for link connector\n            let over_link = null;\n            for (var i = 0; i < this.visible_links.length; ++i) {\n                const link = this.visible_links[i];\n                const center = link._pos;\n                if (\n                    !center\n                    || e.canvasX < center[0] - 4\n                    || e.canvasX > center[0] + 4\n                    || e.canvasY < center[1] - 4\n                    || e.canvasY > center[1] + 4\n                ) {\n                    continue;\n                }\n                over_link = link;\n                break;\n            }\n            if (over_link != this.over_link_center) {\n                this.over_link_center = over_link;\n                this.dirty_canvas = true;\n            }\n\n            if (this.canvas) {\n                this.canvas.style.cursor = \"\";\n            }\n        } // end\n\n        // send event to node if capturing input (used with widgets that allow drag outside of\n        // the area of the node)\n        if (this.node_capturing_input && this.node_capturing_input != node && this.node_capturing_input.onMouseMove) {\n            this.node_capturing_input.onMouseMove(e, [e.canvasX - this.node_capturing_input.pos[0], e.canvasY - this.node_capturing_input.pos[1]], this);\n        }\n\n        // node being dragged\n        if (this.node_dragged && !this.live_mode) {\n            // console.log(\"draggin!\",this.selected_nodes);\n            for (var i in this.selected_nodes) {\n                const n = this.selected_nodes[i];\n                n.pos[0] += delta[0] / this.ds.scale;\n                n.pos[1] += delta[1] / this.ds.scale;\n            }\n\n            this.dirty_canvas = true;\n            this.dirty_bgcanvas = true;\n        }\n\n        if (this.resizing_node && !this.live_mode) {\n            // convert mouse to node space\n            const desired_size = [e.canvasX - this.resizing_node.pos[0], e.canvasY - this.resizing_node.pos[1]];\n            const min_size = this.resizing_node.computeSize();\n            desired_size[0] = Math.max(min_size[0], desired_size[0]);\n            desired_size[1] = Math.max(min_size[1], desired_size[1]);\n            this.resizing_node.setSize(desired_size);\n\n            this.canvas.style.cursor = \"se-resize\";\n            this.dirty_canvas = true;\n            this.dirty_bgcanvas = true;\n        }\n    }\n\n    e.preventDefault();\n    return false;\n};\n\n/**\n * Called when a mouse up event has to be processed\n * @method processMouseUp\n * */\nLGraphCanvas.prototype.processMouseUp = function (e) {\n    if (this.set_canvas_dirty_on_mouse_event) this.dirty_canvas = true;\n\n    if (!this.graph) return;\n\n    const window = this.getCanvasWindow();\n    const { document } = window;\n    LGraphCanvas.active_canvas = this;\n\n    // restore the mousemove event back to the canvas\n    document.removeEventListener(\"mousemove\", this._mousemove_callback, true);\n    this.canvas.addEventListener(\"mousemove\", this._mousemove_callback, true);\n    document.removeEventListener(\"mouseup\", this._mouseup_callback, true);\n\n    this.adjustMouseEvent(e);\n    const now = LiteGraph.getTime();\n    e.click_time = now - this.last_mouseclick;\n    this.last_mouse_dragging = false;\n    this.last_click_position = null;\n\n    if (this.block_click) {\n        console.log(\"foo\");\n        this.block_click = false; // used to avoid sending twice a click in a immediate button\n    }\n\n    if (e.which == 1) {\n        if (this.node_widget) {\n            this.processNodeWidgets(this.node_widget[0], this.graph_mouse, e);\n        }\n\n        // left button\n        this.node_widget = null;\n\n        if (this.selected_group) {\n            const diffx = this.selected_group.pos[0]\n                - Math.round(this.selected_group.pos[0]);\n            const diffy = this.selected_group.pos[1]\n                - Math.round(this.selected_group.pos[1]);\n            this.selected_group.move(diffx, diffy, e.ctrlKey);\n            this.selected_group.pos[0] = Math.round(\n                this.selected_group.pos[0],\n            );\n            this.selected_group.pos[1] = Math.round(\n                this.selected_group.pos[1],\n            );\n            if (this.selected_group._nodes.length) {\n                this.dirty_canvas = true;\n            }\n            this.selected_group = null;\n        }\n        this.selected_group_resizing = false;\n\n        if (this.dragging_rectangle) {\n            if (this.graph) {\n                const nodes = this.graph._nodes;\n                const node_bounding = new Float32Array(4);\n                this.deselectAllNodes();\n                // compute bounding and flip if left to right\n                const w = Math.abs(this.dragging_rectangle[2]);\n                const h = Math.abs(this.dragging_rectangle[3]);\n                const startx = this.dragging_rectangle[2] < 0\n                    ? this.dragging_rectangle[0] - w\n                    : this.dragging_rectangle[0];\n                const starty = this.dragging_rectangle[3] < 0\n                    ? this.dragging_rectangle[1] - h\n                    : this.dragging_rectangle[1];\n                this.dragging_rectangle[0] = startx;\n                this.dragging_rectangle[1] = starty;\n                this.dragging_rectangle[2] = w;\n                this.dragging_rectangle[3] = h;\n\n                // test against all nodes (not visible because the rectangle maybe start outside\n                const to_select = [];\n                for (let i = 0; i < nodes.length; ++i) {\n                    var node = nodes[i];\n                    node.getBounding(node_bounding);\n                    if (\n                        !overlapBounding(\n                            this.dragging_rectangle,\n                            node_bounding,\n                        )\n                    ) {\n                        continue;\n                    } // out of the visible area\n                    to_select.push(node);\n                }\n                if (to_select.length) {\n                    this.selectNodes(to_select);\n                }\n            }\n            this.dragging_rectangle = null;\n        } else if (this.connecting_node) {\n            // dragging a connection\n            this.dirty_canvas = true;\n            this.dirty_bgcanvas = true;\n\n            var node = this.graph.getNodeOnPos(\n                e.canvasX,\n                e.canvasY,\n                this.visible_nodes,\n            );\n\n            // node below mouse\n            if (node) {\n                if (\n                    this.connecting_output.type == LiteGraph.EVENT\n                    && this.isOverNodeBox(node, e.canvasX, e.canvasY)\n                ) {\n                    this.connecting_node.connect(\n                        this.connecting_slot,\n                        node,\n                        LiteGraph.EVENT,\n                    );\n                } else {\n                    // slot below mouse? connect\n                    const slot = this.isOverNodeInput(\n                        node,\n                        e.canvasX,\n                        e.canvasY,\n                    );\n                    if (slot != -1) {\n                        this.connecting_node.connect(\n                            this.connecting_slot,\n                            node,\n                            slot,\n                        );\n                    } else {\n                        // not on top of an input\n                        const input = node.getInputInfo(0);\n                        // auto connect\n                        if (\n                            this.connecting_output.type == LiteGraph.EVENT\n                        ) {\n                            this.connecting_node.connect(\n                                this.connecting_slot,\n                                node,\n                                LiteGraph.EVENT,\n                            );\n                        } else if (\n                            input\n                            && !input.link\n                            && LiteGraph.isValidConnection(\n                                input.type && this.connecting_output.type,\n                            )\n                        ) {\n                            this.connecting_node.connect(\n                                this.connecting_slot,\n                                node,\n                                0,\n                            );\n                        }\n                    }\n                }\n            }\n\n            this.connecting_output = null;\n            this.connecting_pos = null;\n            this.connecting_node = null;\n            this.connecting_slot = -1;\n        } // not dragging connection\n        else if (this.resizing_node) {\n            this.dirty_canvas = true;\n            this.dirty_bgcanvas = true;\n            this.graph.afterChange(this.resizing_node);\n            this.resizing_node = null;\n        } else if (this.node_dragged) {\n            // node being dragged?\n            var node = this.node_dragged;\n            if (\n                node\n                && e.click_time < 300\n                && isInsideRectangle(e.canvasX, e.canvasY, node.pos[0], node.pos[1] - LiteGraph.NODE_TITLE_HEIGHT, LiteGraph.NODE_TITLE_HEIGHT, LiteGraph.NODE_TITLE_HEIGHT)\n            ) {\n                node.collapse();\n            }\n\n            this.dirty_canvas = true;\n            this.dirty_bgcanvas = true;\n            this.node_dragged.pos[0] = Math.round(this.node_dragged.pos[0]);\n            this.node_dragged.pos[1] = Math.round(this.node_dragged.pos[1]);\n            if (this.graph.config.align_to_grid) {\n                this.node_dragged.alignToGrid();\n            }\n            if (this.onNodeMoved) this.onNodeMoved(this.node_dragged);\n            this.graph.afterChange(this.node_dragged);\n            this.node_dragged = null;\n        } // no node being dragged\n        else {\n            // get node over\n            var node = this.graph.getNodeOnPos(\n                e.canvasX,\n                e.canvasY,\n                this.visible_nodes,\n            );\n\n            if (!node && e.click_time < 300) {\n                this.deselectAllNodes();\n            }\n\n            this.dirty_canvas = true;\n            this.dragging_canvas = false;\n\n            if (this.node_over && this.node_over.onMouseUp) {\n                this.node_over.onMouseUp(e, [e.canvasX - this.node_over.pos[0], e.canvasY - this.node_over.pos[1]], this);\n            }\n            if (\n                this.node_capturing_input\n                && this.node_capturing_input.onMouseUp\n            ) {\n                this.node_capturing_input.onMouseUp(e, [\n                    e.canvasX - this.node_capturing_input.pos[0],\n                    e.canvasY - this.node_capturing_input.pos[1],\n                ]);\n            }\n        }\n    } else if (e.which == 2) {\n        // middle button\n        // trace(\"middle\");\n        this.dirty_canvas = true;\n        this.dragging_canvas = false;\n    } else if (e.which == 3) {\n        // right button\n        // trace(\"right\");\n        this.dirty_canvas = true;\n        this.dragging_canvas = false;\n    }\n\n    /*\nif((this.dirty_canvas || this.dirty_bgcanvas) && this.rendering_timer_id == null)\nthis.draw();\n*/\n\n    this.graph.change();\n\n    e.stopPropagation();\n    e.preventDefault();\n    return false;\n};\n\n/**\n * Called when a mouse wheel event has to be processed\n * @method processMouseWheel\n * */\nLGraphCanvas.prototype.processMouseWheel = function (e) {\n    if (!this.graph || !this.allow_dragcanvas) {\n        return;\n    }\n\n    const delta = e.wheelDeltaY != null ? e.wheelDeltaY : e.detail * -60;\n\n    this.adjustMouseEvent(e);\n\n    let { scale } = this.ds;\n\n    if (delta > 0) {\n        scale *= 1.1;\n    } else if (delta < 0) {\n        scale *= 1 / 1.1;\n    }\n\n    // this.setZoom( scale, [ e.localX, e.localY ] );\n    this.ds.changeScale(scale, [e.localX, e.localY]);\n\n    this.graph.change();\n\n    e.preventDefault();\n    return false; // prevent default\n};\n\n/**\n * returns true if a position (in graph space) is on top of a node little corner box\n * @method isOverNodeBox\n * */\nLGraphCanvas.prototype.isOverNodeBox = function (node, canvasx, canvasy) {\n    const title_height = LiteGraph.NODE_TITLE_HEIGHT;\n    if (\n        isInsideRectangle(\n            canvasx,\n            canvasy,\n            node.pos[0] + 2,\n            node.pos[1] + 2 - title_height,\n            title_height - 4,\n            title_height - 4,\n        )\n    ) {\n        return true;\n    }\n    return false;\n};\n\n/**\n * returns true if a position (in graph space) is on top of a node input slot\n * @method isOverNodeInput\n * */\nLGraphCanvas.prototype.isOverNodeInput = function (\n    node,\n    canvasx,\n    canvasy,\n    slot_pos,\n) {\n    if (node.inputs) {\n        for (let i = 0, l = node.inputs.length; i < l; ++i) {\n            const input = node.inputs[i];\n            const link_pos = node.getConnectionPos(true, i);\n            let is_inside = false;\n            if (node.horizontal) {\n                is_inside = isInsideRectangle(\n                    canvasx,\n                    canvasy,\n                    link_pos[0] - 5,\n                    link_pos[1] - 10,\n                    10,\n                    20,\n                );\n            } else {\n                is_inside = isInsideRectangle(\n                    canvasx,\n                    canvasy,\n                    link_pos[0] - 10,\n                    link_pos[1] - 5,\n                    40,\n                    10,\n                );\n            }\n            if (is_inside) {\n                if (slot_pos) {\n                    slot_pos[0] = link_pos[0];\n                    slot_pos[1] = link_pos[1];\n                }\n                return i;\n            }\n        }\n    }\n    return -1;\n};\n\n/**\n * process a key event\n * @method processKey\n * */\nLGraphCanvas.prototype.processKey = function (e) {\n    if (!this.graph) {\n        return;\n    }\n\n    let block_default = false;\n    // console.log(e); //debug\n\n    if (e.target.localName == \"input\") {\n        return;\n    }\n\n    if (e.type == \"keydown\") {\n        if (e.keyCode == 32) {\n            // esc\n            this.dragging_canvas = true;\n            block_default = true;\n        }\n\n        // select all Control A\n        if (e.keyCode == 65 && e.ctrlKey) {\n            this.selectNodes();\n            block_default = true;\n        }\n\n        if (e.code == \"KeyC\" && (e.metaKey || e.ctrlKey) && !e.shiftKey) {\n            // copy\n            if (this.selected_nodes) {\n                this.copyToClipboard();\n                block_default = true;\n            }\n        }\n\n        if (e.code == \"KeyV\" && (e.metaKey || e.ctrlKey) && !e.shiftKey) {\n            // paste\n            this.pasteFromClipboard();\n        }\n\n        // delete or backspace\n        if (e.keyCode == 46 || e.keyCode == 8) {\n            if (\n                e.target.localName != \"input\"\n                && e.target.localName != \"textarea\"\n            ) {\n                this.deleteSelectedNodes();\n                block_default = true;\n            }\n        }\n\n        // collapse\n        // ...\n\n        // TODO\n        if (this.selected_nodes) {\n            for (var i in this.selected_nodes) {\n                if (this.selected_nodes[i].onKeyDown) {\n                    this.selected_nodes[i].onKeyDown(e);\n                }\n            }\n        }\n    } else if (e.type == \"keyup\") {\n        if (e.keyCode == 32) {\n            this.dragging_canvas = false;\n        }\n\n        if (this.selected_nodes) {\n            for (var i in this.selected_nodes) {\n                if (this.selected_nodes[i].onKeyUp) {\n                    this.selected_nodes[i].onKeyUp(e);\n                }\n            }\n        }\n    }\n\n    this.graph.change();\n\n    if (block_default) {\n        e.preventDefault();\n        e.stopImmediatePropagation();\n        return false;\n    }\n};\n\nLGraphCanvas.prototype.copyToClipboard = function () {\n    const clipboard_info = {\n        nodes: [],\n        links: [],\n    };\n    let index = 0;\n    const selected_nodes_array = [];\n    for (var i in this.selected_nodes) {\n        var node = this.selected_nodes[i];\n        node._relative_id = index;\n        selected_nodes_array.push(node);\n        index += 1;\n    }\n\n    for (var i = 0; i < selected_nodes_array.length; ++i) {\n        var node = selected_nodes_array[i];\n        const cloned = node.clone();\n        if (!cloned) {\n            console.warn(`node type not found: ${node.type}`);\n            continue;\n        }\n        clipboard_info.nodes.push(cloned.serialize());\n        if (node.inputs && node.inputs.length) {\n            for (let j = 0; j < node.inputs.length; ++j) {\n                const input = node.inputs[j];\n                if (!input || input.link == null) {\n                    continue;\n                }\n                const link_info = this.graph.links[input.link];\n                if (!link_info) {\n                    continue;\n                }\n                const target_node = this.graph.getNodeById(\n                    link_info.origin_id,\n                );\n                if (!target_node || !this.selected_nodes[target_node.id]) {\n                    // improve this by allowing connections to non-selected nodes\n                    continue;\n                } // not selected\n                clipboard_info.links.push([\n                    target_node._relative_id,\n                    link_info.origin_slot, // j,\n                    node._relative_id,\n                    link_info.target_slot,\n                ]);\n            }\n        }\n    }\n    localStorage.setItem(\n        \"litegrapheditor_clipboard\",\n        JSON.stringify(clipboard_info),\n    );\n};\n\nLGraphCanvas.prototype.pasteFromClipboard = function () {\n    const data = localStorage.getItem(\"litegrapheditor_clipboard\");\n    if (!data) {\n        return;\n    }\n\n    this.graph.beforeChange();\n\n    // create nodes\n    const clipboard_info = JSON.parse(data);\n    const nodes = [];\n    for (var i = 0; i < clipboard_info.nodes.length; ++i) {\n        const node_data = clipboard_info.nodes[i];\n        const node = LiteGraph.createNode(node_data.type);\n        if (node) {\n            node.configure(node_data);\n            node.pos[0] += 5;\n            node.pos[1] += 5;\n            this.graph.add(node);\n            nodes.push(node);\n        }\n    }\n\n    // create links\n    for (var i = 0; i < clipboard_info.links.length; ++i) {\n        const link_info = clipboard_info.links[i];\n        const origin_node = nodes[link_info[0]];\n        const target_node = nodes[link_info[2]];\n        if (origin_node && target_node) {\n            origin_node.connect(link_info[1], target_node, link_info[3]);\n        } else {\n            console.warn(\"Warning, nodes missing on pasting\");\n        }\n    }\n\n    this.selectNodes(nodes);\n\n    this.graph.afterChange();\n};\n\n/**\n * process a item drop event on top the canvas\n * @method processDrop\n * */\nLGraphCanvas.prototype.processDrop = function (e) {\n    e.preventDefault();\n    this.adjustMouseEvent(e);\n\n    const pos = [e.canvasX, e.canvasY];\n    const node = this.graph ? this.graph.getNodeOnPos(pos[0], pos[1]) : null;\n\n    if (!node) {\n        let r = null;\n        if (this.onDropItem) {\n            r = this.onDropItem(event);\n        }\n        if (!r) {\n            this.checkDropItem(e);\n        }\n        return;\n    }\n\n    if (node.onDropFile || node.onDropData) {\n        const { files } = e.dataTransfer;\n        if (files && files.length) {\n            for (let i = 0; i < files.length; i++) {\n                var file = e.dataTransfer.files[0];\n                var filename = file.name;\n                const ext = LGraphCanvas.getFileExtension(filename);\n                // console.log(file);\n\n                if (node.onDropFile) {\n                    node.onDropFile(file);\n                }\n\n                if (node.onDropData) {\n                    // prepare reader\n                    const reader = new FileReader();\n                    reader.onload = function (event) {\n                        // console.log(event.target);\n                        const data = event.target.result;\n                        node.onDropData(data, filename, file);\n                    };\n\n                    // read data\n                    const type = file.type.split(\"/\")[0];\n                    if (type == \"text\" || type == \"\") {\n                        reader.readAsText(file);\n                    } else if (type == \"image\") {\n                        reader.readAsDataURL(file);\n                    } else {\n                        reader.readAsArrayBuffer(file);\n                    }\n                }\n            }\n        }\n    }\n\n    if (node.onDropItem) {\n        if (node.onDropItem(event)) {\n            return true;\n        }\n    }\n\n    if (this.onDropItem) {\n        return this.onDropItem(event);\n    }\n\n    return false;\n};\n\n// called if the graph doesn't have a default drop item behaviour\nLGraphCanvas.prototype.checkDropItem = function (e) {\n    if (e.dataTransfer.files.length) {\n        const file = e.dataTransfer.files[0];\n        const ext = LGraphCanvas.getFileExtension(file.name)\n            .toLowerCase();\n        const nodetype = LiteGraph.node_types_by_file_extension[ext];\n        if (nodetype) {\n            this.graph.beforeChange();\n            const node = LiteGraph.createNode(nodetype.type);\n            node.pos = [e.canvasX, e.canvasY];\n            this.graph.add(node);\n            if (node.onDropFile) {\n                node.onDropFile(file);\n            }\n            this.graph.afterChange();\n        }\n    }\n};\n\nLGraphCanvas.prototype.processNodeDblClicked = function (n) {\n    if (this.onShowNodePanel) {\n        this.onShowNodePanel(n);\n    } else {\n        this.showShowNodePanel(n);\n    }\n\n    if (this.onNodeDblClicked) {\n        this.onNodeDblClicked(n);\n    }\n\n    this.setDirty(true);\n};\n\nLGraphCanvas.prototype.processNodeSelected = function (node, e) {\n    this.selectNode(node, e && e.shiftKey);\n    if (this.onNodeSelected) {\n        this.onNodeSelected(node);\n    }\n};\n\n/**\n * selects a given node (or adds it to the current selection)\n * @method selectNode\n * */\nLGraphCanvas.prototype.selectNode = function (\n    node,\n    add_to_current_selection,\n) {\n    if (node == null) {\n        this.deselectAllNodes();\n    } else {\n        this.selectNodes([node], add_to_current_selection);\n    }\n};\n\n/**\n * selects several nodes (or adds them to the current selection)\n * @method selectNodes\n * */\nLGraphCanvas.prototype.selectNodes = function (nodes, add_to_current_selection) {\n    if (!add_to_current_selection) {\n        this.deselectAllNodes();\n    }\n\n    nodes = nodes || this.graph._nodes;\n    for (let i = 0; i < nodes.length; ++i) {\n        const node = nodes[i];\n        if (node.is_selected) {\n            continue;\n        }\n\n        if (!node.is_selected && node.onSelected) {\n            node.onSelected();\n        }\n        node.is_selected = true;\n        this.selected_nodes[node.id] = node;\n\n        if (node.inputs) {\n            for (var j = 0; j < node.inputs.length; ++j) {\n                this.highlighted_links[node.inputs[j].link] = true;\n            }\n        }\n        if (node.outputs) {\n            for (var j = 0; j < node.outputs.length; ++j) {\n                const out = node.outputs[j];\n                if (out.links) {\n                    for (let k = 0; k < out.links.length; ++k) {\n                        this.highlighted_links[out.links[k]] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    if (this.onSelectionChange) this.onSelectionChange(this.selected_nodes);\n\n    this.setDirty(true);\n};\n\n/**\n * removes a node from the current selection\n * @method deselectNode\n * */\nLGraphCanvas.prototype.deselectNode = function (node) {\n    if (!node.is_selected) {\n        return;\n    }\n    if (node.onDeselected) {\n        node.onDeselected();\n    }\n    node.is_selected = false;\n\n    if (this.onNodeDeselected) {\n        this.onNodeDeselected(node);\n    }\n\n    // remove highlighted\n    if (node.inputs) {\n        for (var i = 0; i < node.inputs.length; ++i) {\n            delete this.highlighted_links[node.inputs[i].link];\n        }\n    }\n    if (node.outputs) {\n        for (var i = 0; i < node.outputs.length; ++i) {\n            const out = node.outputs[i];\n            if (out.links) {\n                for (let j = 0; j < out.links.length; ++j) {\n                    delete this.highlighted_links[out.links[j]];\n                }\n            }\n        }\n    }\n};\n\n/**\n * removes all nodes from the current selection\n * @method deselectAllNodes\n * */\nLGraphCanvas.prototype.deselectAllNodes = function () {\n    if (!this.graph) {\n        return;\n    }\n    const nodes = this.graph._nodes;\n    for (let i = 0, l = nodes.length; i < l; ++i) {\n        const node = nodes[i];\n        if (!node.is_selected) {\n            continue;\n        }\n        if (node.onDeselected) {\n            node.onDeselected();\n        }\n        node.is_selected = false;\n        if (this.onNodeDeselected) {\n            this.onNodeDeselected(node);\n        }\n    }\n    this.selected_nodes = {};\n    this.current_node = null;\n    this.highlighted_links = {};\n    if (this.onSelectionChange) this.onSelectionChange(this.selected_nodes);\n    this.setDirty(true);\n};\n\n/**\n * deletes all nodes in the current selection from the graph\n * @method deleteSelectedNodes\n * */\nLGraphCanvas.prototype.deleteSelectedNodes = function () {\n    this.graph.beforeChange();\n\n    for (const i in this.selected_nodes) {\n        const node = this.selected_nodes[i];\n\n        if (node.block_delete) continue;\n\n        // autoconnect when possible (very basic, only takes into account first input-output)\n        if (node.inputs && node.inputs.length && node.outputs && node.outputs.length && LiteGraph.isValidConnection(node.inputs[0].type, node.outputs[0].type) && node.inputs[0].link && node.outputs[0].links && node.outputs[0].links.length) {\n            const input_link = node.graph.links[node.inputs[0].link];\n            const output_link = node.graph.links[node.outputs[0].links[0]];\n            const input_node = node.getInputNode(0);\n            const output_node = node.getOutputNodes(0)[0];\n            if (input_node && output_node) input_node.connect(input_link.origin_slot, output_node, output_link.target_slot);\n        }\n        this.graph.remove(node);\n        if (this.onNodeDeselected) {\n            this.onNodeDeselected(node);\n        }\n    }\n    this.selected_nodes = {};\n    this.current_node = null;\n    this.highlighted_links = {};\n    this.setDirty(true);\n    this.graph.afterChange();\n};\n\n/**\n * centers the camera on a given node\n * @method centerOnNode\n * */\nLGraphCanvas.prototype.centerOnNode = function (node) {\n    this.ds.offset[0] = -node.pos[0]\n        - node.size[0] * 0.5\n        + (this.canvas.width * 0.5) / this.ds.scale;\n    this.ds.offset[1] = -node.pos[1]\n        - node.size[1] * 0.5\n        + (this.canvas.height * 0.5) / this.ds.scale;\n    this.setDirty(true, true);\n};\n\n/**\n * adds some useful properties to a mouse event, like the position in graph coordinates\n * @method adjustMouseEvent\n * */\nLGraphCanvas.prototype.adjustMouseEvent = function (e) {\n    if (this.canvas) {\n        const b = this.canvas.getBoundingClientRect();\n        e.localX = e.clientX - b.left;\n        e.localY = e.clientY - b.top;\n    } else {\n        e.localX = e.clientX;\n        e.localY = e.clientY;\n    }\n\n    e.deltaX = e.localX - this.last_mouse_position[0];\n    e.deltaY = e.localY - this.last_mouse_position[1];\n\n    this.last_mouse_position[0] = e.localX;\n    this.last_mouse_position[1] = e.localY;\n\n    e.canvasX = e.localX / this.ds.scale - this.ds.offset[0];\n    e.canvasY = e.localY / this.ds.scale - this.ds.offset[1];\n};\n\n/**\n * changes the zoom level of the graph (default is 1), you can pass also a place used to pivot\n * the zoom\n * @method setZoom\n * */\nLGraphCanvas.prototype.setZoom = function (value, zooming_center) {\n    this.ds.changeScale(value, zooming_center);\n    /*\nif(!zooming_center && this.canvas)\nzooming_center = [this.canvas.width * 0.5,this.canvas.height * 0.5];\n\nvar center = this.convertOffsetToCanvas( zooming_center );\n\nthis.ds.scale = value;\n\nif(this.scale > this.max_zoom)\nthis.scale = this.max_zoom;\nelse if(this.scale < this.min_zoom)\nthis.scale = this.min_zoom;\n\nvar new_center = this.convertOffsetToCanvas( zooming_center );\nvar delta_offset = [new_center[0] - center[0], new_center[1] - center[1]];\n\nthis.offset[0] += delta_offset[0];\nthis.offset[1] += delta_offset[1];\n*/\n\n    this.dirty_canvas = true;\n    this.dirty_bgcanvas = true;\n};\n\n/**\n * converts a coordinate from graph coordinates to canvas2D coordinates\n * @method convertOffsetToCanvas\n * */\nLGraphCanvas.prototype.convertOffsetToCanvas = function (pos, out) {\n    return this.ds.convertOffsetToCanvas(pos, out);\n};\n\n/**\n * converts a coordinate from Canvas2D coordinates to graph space\n * @method convertCanvasToOffset\n * */\nLGraphCanvas.prototype.convertCanvasToOffset = function (pos, out) {\n    return this.ds.convertCanvasToOffset(pos, out);\n};\n\n// converts event coordinates from canvas2D to graph coordinates\nLGraphCanvas.prototype.convertEventToCanvasOffset = function (e) {\n    const rect = this.canvas.getBoundingClientRect();\n    return this.convertCanvasToOffset([\n        e.clientX - rect.left,\n        e.clientY - rect.top,\n    ]);\n};\n\n/**\n * brings a node to front (above all other nodes)\n * @method bringToFront\n * */\nLGraphCanvas.prototype.bringToFront = function (node) {\n    const i = this.graph._nodes.indexOf(node);\n    if (i == -1) {\n        return;\n    }\n\n    this.graph._nodes.splice(i, 1);\n    this.graph._nodes.push(node);\n};\n\n/**\n * sends a node to the back (below all other nodes)\n * @method sendToBack\n * */\nLGraphCanvas.prototype.sendToBack = function (node) {\n    const i = this.graph._nodes.indexOf(node);\n    if (i == -1) {\n        return;\n    }\n\n    this.graph._nodes.splice(i, 1);\n    this.graph._nodes.unshift(node);\n};\n\n/* Interaction */\n\n/* LGraphCanvas render */\nconst temp = new Float32Array(4);\n\n/**\n * checks which nodes are visible (inside the camera area)\n * @method computeVisibleNodes\n * */\nLGraphCanvas.prototype.computeVisibleNodes = function (nodes, out) {\n    const visible_nodes = out || [];\n    visible_nodes.length = 0;\n    nodes = nodes || this.graph._nodes;\n    for (let i = 0, l = nodes.length; i < l; ++i) {\n        const n = nodes[i];\n\n        // skip rendering nodes in live mode\n        if (this.live_mode && !n.onDrawBackground && !n.onDrawForeground) {\n            continue;\n        }\n\n        if (!overlapBounding(this.visible_area, n.getBounding(temp))) {\n            continue;\n        } // out of the visible area\n\n        visible_nodes.push(n);\n    }\n    return visible_nodes;\n};\n\n/**\n * renders the whole canvas content, by rendering in two separated canvas, one containing the\n * background grid and the connections, and one containing the nodes)\n * @method draw\n * */\nLGraphCanvas.prototype.draw = function (force_canvas, force_bgcanvas) {\n    if (!this.canvas || this.canvas.width == 0 || this.canvas.height == 0) {\n        return;\n    }\n\n    // fps counting\n    const now = LiteGraph.getTime();\n    this.render_time = (now - this.last_draw_time) * 0.001;\n    this.last_draw_time = now;\n\n    if (this.graph) {\n        this.ds.computeVisibleArea();\n    }\n\n    if (\n        this.dirty_bgcanvas\n        || force_bgcanvas\n        || this.always_render_background\n        || (this.graph\n        && this.graph._last_trigger_time\n        && now - this.graph._last_trigger_time < 1000)\n    ) {\n        this.drawBackCanvas();\n    }\n\n    if (this.dirty_canvas || force_canvas) {\n        this.drawFrontCanvas();\n    }\n\n    this.fps = this.render_time ? 1.0 / this.render_time : 0;\n    this.frame += 1;\n};\n\n/**\n * draws the front canvas (the one containing all the nodes)\n * @method drawFrontCanvas\n * */\nLGraphCanvas.prototype.drawFrontCanvas = function () {\n    this.dirty_canvas = false;\n\n    if (!this.ctx) {\n        this.ctx = this.bgcanvas.getContext(\"2d\");\n    }\n    const { ctx } = this;\n    if (!ctx) {\n        // maybe is using webgl...\n        return;\n    }\n\n    if (ctx.start2D) {\n        ctx.start2D();\n    }\n\n    const { canvas } = this;\n\n    // reset in case of error\n    ctx.restore();\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n\n    // clip dirty area if there is one, otherwise work in full canvas\n    if (this.dirty_area) {\n        ctx.save();\n        ctx.beginPath();\n        ctx.rect(\n            this.dirty_area[0],\n            this.dirty_area[1],\n            this.dirty_area[2],\n            this.dirty_area[3],\n        );\n        ctx.clip();\n    }\n\n    // clear\n    // canvas.width = canvas.width;\n    if (this.clear_background) {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n    }\n\n    // draw bg canvas\n    if (this.bgcanvas == this.canvas) {\n        this.drawBackCanvas();\n    } else {\n        ctx.drawImage(this.bgcanvas, 0, 0);\n    }\n\n    // rendering\n    if (this.onRender) {\n        this.onRender(canvas, ctx);\n    }\n\n    // info widget\n    if (this.show_info) {\n        this.renderInfo(ctx);\n    }\n\n    if (this.graph) {\n        // apply transformations\n        ctx.save();\n        this.ds.toCanvasContext(ctx);\n\n        // draw nodes\n        let drawn_nodes = 0;\n        const visible_nodes = this.computeVisibleNodes(\n            null,\n            this.visible_nodes,\n        );\n\n        for (let i = 0; i < visible_nodes.length; ++i) {\n            const node = visible_nodes[i];\n\n            // transform coords system\n            ctx.save();\n            ctx.translate(node.pos[0], node.pos[1]);\n\n            // Draw\n            this.drawNode(node, ctx);\n            drawn_nodes += 1;\n\n            // Restore\n            ctx.restore();\n        }\n\n        // on top (debug)\n        if (this.render_execution_order) {\n            this.drawExecutionOrder(ctx);\n        }\n\n        // connections ontop?\n        if (this.graph.config.links_ontop) {\n            if (!this.live_mode) {\n                this.drawConnections(ctx);\n            }\n        }\n\n        // current connection (the one being dragged by the mouse)\n        if (this.connecting_pos != null) {\n            ctx.lineWidth = this.connections_width;\n            let link_color = null;\n\n            switch (this.connecting_output.type) {\n                case LiteGraph.EVENT:\n                    link_color = LiteGraph.EVENT_LINK_COLOR;\n                    break;\n                default:\n                    link_color = LiteGraph.CONNECTING_LINK_COLOR;\n            }\n\n            // the connection being dragged by the mouse\n            this.renderLink(\n                ctx,\n                this.connecting_pos,\n                [this.graph_mouse[0], this.graph_mouse[1]],\n                null,\n                false,\n                null,\n                link_color,\n                this.connecting_output.dir\n                || (this.connecting_node.horizontal\n                    ? LiteGraph.DOWN\n                    : LiteGraph.RIGHT),\n                LiteGraph.CENTER,\n            );\n\n            ctx.beginPath();\n            if (\n                this.connecting_output.type === LiteGraph.EVENT\n                || this.connecting_output.shape === LiteGraph.BOX_SHAPE\n            ) {\n                ctx.rect(\n                    this.connecting_pos[0] - 6 + 0.5,\n                    this.connecting_pos[1] - 5 + 0.5,\n                    14,\n                    10,\n                );\n            } else {\n                ctx.arc(\n                    this.connecting_pos[0],\n                    this.connecting_pos[1],\n                    4,\n                    0,\n                    Math.PI * 2,\n                );\n            }\n            ctx.fill();\n\n            ctx.fillStyle = \"#ffcc00\";\n            if (this._highlight_input) {\n                ctx.beginPath();\n                ctx.arc(\n                    this._highlight_input[0],\n                    this._highlight_input[1],\n                    6,\n                    0,\n                    Math.PI * 2,\n                );\n                ctx.fill();\n            }\n        }\n\n        // the selection rectangle\n        if (this.dragging_rectangle) {\n            ctx.strokeStyle = \"#FFF\";\n            ctx.strokeRect(\n                this.dragging_rectangle[0],\n                this.dragging_rectangle[1],\n                this.dragging_rectangle[2],\n                this.dragging_rectangle[3],\n            );\n        }\n\n        // on top of link center\n        if (this.over_link_center && this.render_link_tooltip) {\n            this.drawLinkTooltip(ctx, this.over_link_center);\n        } else if (this.onDrawLinkTooltip) // to remove\n        {\n            this.onDrawLinkTooltip(ctx, null);\n        }\n\n        // custom info\n        if (this.onDrawForeground) {\n            this.onDrawForeground(ctx, this.visible_rect);\n        }\n\n        ctx.restore();\n    }\n\n    // draws panel in the corner\n    if (this._graph_stack && this._graph_stack.length) {\n        this.drawSubgraphPanel(ctx);\n    }\n\n    if (this.onDrawOverlay) {\n        this.onDrawOverlay(ctx);\n    }\n\n    if (this.dirty_area) {\n        ctx.restore();\n        // this.dirty_area = null;\n    }\n\n    if (ctx.finish2D) {\n        // this is a function I use in webgl renderer\n        ctx.finish2D();\n    }\n};\n\n/**\n * draws the panel in the corner that shows subgraph properties\n * @method drawSubgraphPanel\n * */\nLGraphCanvas.prototype.drawSubgraphPanel = function (ctx) {\n    const subgraph = this.graph;\n    const subnode = subgraph._subgraph_node;\n    if (!subnode) {\n        console.warn(\"subgraph without subnode\");\n        return;\n    }\n\n    const num = subnode.inputs ? subnode.inputs.length : 0;\n    const w = 300;\n    const h = Math.floor(LiteGraph.NODE_SLOT_HEIGHT * 1.6);\n\n    ctx.fillStyle = \"#111\";\n    ctx.globalAlpha = 0.8;\n    ctx.beginPath();\n    ctx.roundRect(10, 10, w, (num + 1) * h + 50, 8);\n    ctx.fill();\n    ctx.globalAlpha = 1;\n\n    ctx.fillStyle = \"#888\";\n    ctx.font = \"14px Arial\";\n    ctx.textAlign = \"left\";\n    ctx.fillText(\"Graph Inputs\", 20, 34);\n    const pos = this.mouse;\n\n    if (this.drawButton(w - 20, 20, 20, 20, \"X\", \"#151515\")) {\n        this.closeSubgraph();\n        return;\n    }\n\n    let y = 50;\n    ctx.font = \"20px Arial\";\n    if (subnode.inputs) {\n        for (let i = 0; i < subnode.inputs.length; ++i) {\n            const input = subnode.inputs[i];\n            if (input.not_subgraph_input) continue;\n\n            // input button clicked\n            if (this.drawButton(20, y + 2, w - 20, h - 2)) {\n                const type = subnode.constructor.input_node_type || \"graph/input\";\n                this.graph.beforeChange();\n                const newnode = LiteGraph.createNode(type);\n                if (newnode) {\n                    subgraph.add(newnode);\n                    this.block_click = false;\n                    this.last_click_position = null;\n                    this.selectNodes([newnode]);\n                    this.node_dragged = newnode;\n                    this.dragging_canvas = false;\n                    newnode.setProperty(\"name\", input.name);\n                    newnode.setProperty(\"type\", input.type);\n                    this.node_dragged.pos[0] = this.graph_mouse[0] - 5;\n                    this.node_dragged.pos[1] = this.graph_mouse[1] - 5;\n                    this.graph.afterChange();\n                } else {\n                    console.error(\"graph input node not found:\", type);\n                }\n            }\n\n            ctx.fillStyle = \"#9C9\";\n            ctx.beginPath();\n            ctx.arc(w - 16, y + h * 0.5, 5, 0, 2 * Math.PI);\n            ctx.fill();\n\n            ctx.fillStyle = \"#AAA\";\n            ctx.fillText(input.name, 50, y + h * 0.75);\n            const tw = ctx.measureText(input.name);\n            ctx.fillStyle = \"#777\";\n            ctx.fillText(input.type, 50 + tw.width + 10, y + h * 0.75);\n\n            y += h;\n        }\n    }\n\n    // add + button\n    if (this.drawButton(20, y + 2, w - 20, h - 2, \"+\", \"#151515\", \"#222\")) {\n        this.showSubgraphPropertiesDialog(subnode);\n    }\n};\n\n// Draws a button into the canvas overlay and computes if it was clicked using the immediate\n// gui paradigm\nLGraphCanvas.prototype.drawButton = function (x, y, w, h, text, bgcolor, hovercolor, textcolor) {\n    const { ctx } = this;\n    bgcolor = bgcolor || LiteGraph.NODE_DEFAULT_COLOR;\n    hovercolor = hovercolor || \"#555\";\n    textcolor = textcolor || LiteGraph.NODE_TEXT_COLOR;\n\n    let pos = this.mouse;\n    const hover = LiteGraph.isInsideRectangle(pos[0], pos[1], x, y, w, h);\n    pos = this.last_click_position;\n    const clicked = pos && LiteGraph.isInsideRectangle(pos[0], pos[1], x, y, w, h);\n\n    ctx.fillStyle = hover ? hovercolor : bgcolor;\n    if (clicked) ctx.fillStyle = \"#AAA\";\n    ctx.beginPath();\n    ctx.roundRect(x, y, w, h, 4);\n    ctx.fill();\n\n    if (text != null) {\n        if (text.constructor == String) {\n            ctx.fillStyle = textcolor;\n            ctx.textAlign = \"center\";\n            ctx.font = `${(h * 0.65) | 0}px Arial`;\n            ctx.fillText(text, x + w * 0.5, y + h * 0.75);\n            ctx.textAlign = \"left\";\n        }\n    }\n\n    const was_clicked = clicked && !this.block_click;\n    if (clicked) this.blockClick();\n    return was_clicked;\n};\n\nLGraphCanvas.prototype.isAreaClicked = function (x, y, w, h, hold_click) {\n    let pos = this.mouse;\n    const hover = LiteGraph.isInsideRectangle(pos[0], pos[1], x, y, w, h);\n    pos = this.last_click_position;\n    const clicked = pos && LiteGraph.isInsideRectangle(pos[0], pos[1], x, y, w, h);\n    const was_clicked = clicked && !this.block_click;\n    if (clicked && hold_click) this.blockClick();\n    return was_clicked;\n};\n\n/**\n * draws some useful stats in the corner of the canvas\n * @method renderInfo\n * */\nLGraphCanvas.prototype.renderInfo = function (ctx, x, y) {\n    x = x || 10;\n    y = y || this.canvas.height - 80;\n\n    ctx.save();\n    ctx.translate(x, y);\n\n    ctx.font = \"10px Arial\";\n    ctx.fillStyle = \"#888\";\n    if (this.graph) {\n        ctx.fillText(`T: ${this.graph.globaltime.toFixed(2)}s`, 5, 13 * 1);\n        ctx.fillText(`I: ${this.graph.iteration}`, 5, 13 * 2);\n        ctx.fillText(`N: ${this.graph._nodes.length} [${this.visible_nodes.length}]`, 5, 13 * 3);\n        ctx.fillText(`V: ${this.graph._version}`, 5, 13 * 4);\n        ctx.fillText(`FPS:${this.fps.toFixed(2)}`, 5, 13 * 5);\n    } else {\n        ctx.fillText(\"No graph selected\", 5, 13 * 1);\n    }\n    ctx.restore();\n};\n\n/**\n * draws the back canvas (the one containing the background and the connections)\n * @method drawBackCanvas\n * */\nLGraphCanvas.prototype.drawBackCanvas = function () {\n    const canvas = this.bgcanvas;\n    if (\n        canvas.width != this.canvas.width\n        || canvas.height != this.canvas.height\n    ) {\n        canvas.width = this.canvas.width;\n        canvas.height = this.canvas.height;\n    }\n\n    if (!this.bgctx) {\n        this.bgctx = this.bgcanvas.getContext(\"2d\");\n    }\n    const ctx = this.bgctx;\n    if (ctx.start) {\n        ctx.start();\n    }\n\n    // clear\n    if (this.clear_background) {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n    }\n\n    if (this._graph_stack && this._graph_stack.length) {\n        ctx.save();\n        const parent_graph = this._graph_stack[this._graph_stack.length - 1];\n        const subgraph_node = this.graph._subgraph_node;\n        ctx.strokeStyle = subgraph_node.bgcolor;\n        ctx.lineWidth = 10;\n        ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);\n        ctx.lineWidth = 1;\n        ctx.font = \"40px Arial\";\n        ctx.textAlign = \"center\";\n        ctx.fillStyle = subgraph_node.bgcolor || \"#AAA\";\n        let title = \"\";\n        for (let i = 1; i < this._graph_stack.length; ++i) {\n            title\n                += `${this._graph_stack[i]._subgraph_node.getTitle()} >> `;\n        }\n        ctx.fillText(\n            title + subgraph_node.getTitle(),\n            canvas.width * 0.5,\n            40,\n        );\n        ctx.restore();\n    }\n\n    let bg_already_painted = false;\n    if (this.onRenderBackground) {\n        bg_already_painted = this.onRenderBackground(canvas, ctx);\n    }\n\n    // reset in case of error\n    ctx.restore();\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    this.visible_links.length = 0;\n\n    if (this.graph) {\n        // apply transformations\n        ctx.save();\n        this.ds.toCanvasContext(ctx);\n\n        // render BG\n        if (\n            this.background_image\n            && this.ds.scale > 0.5\n            && !bg_already_painted\n        ) {\n            if (this.zoom_modify_alpha) {\n                ctx.globalAlpha = (1.0 - 0.5 / this.ds.scale) * this.editor_alpha;\n            } else {\n                ctx.globalAlpha = this.editor_alpha;\n            }\n            ctx.imageSmoothingEnabled = ctx.mozImageSmoothingEnabled = ctx.imageSmoothingEnabled = false;\n            if (\n                !this._bg_img\n                || this._bg_img.name != this.background_image\n            ) {\n                this._bg_img = new Image();\n                this._bg_img.name = this.background_image;\n                this._bg_img.src = this.background_image;\n                const that = this;\n                this._bg_img.onload = function () {\n                    that.draw(true, true);\n                };\n            }\n\n            let pattern = null;\n            if (this._pattern == null && this._bg_img.width > 0) {\n                pattern = ctx.createPattern(this._bg_img, \"repeat\");\n                this._pattern_img = this._bg_img;\n                this._pattern = pattern;\n            } else {\n                pattern = this._pattern;\n            }\n            if (pattern) {\n                ctx.fillStyle = pattern;\n                ctx.fillRect(\n                    this.visible_area[0],\n                    this.visible_area[1],\n                    this.visible_area[2],\n                    this.visible_area[3],\n                );\n                ctx.fillStyle = \"transparent\";\n            }\n\n            ctx.globalAlpha = 1.0;\n            ctx.imageSmoothingEnabled = ctx.mozImageSmoothingEnabled = ctx.imageSmoothingEnabled = true;\n        }\n\n        // groups\n        if (this.graph._groups.length && !this.live_mode) {\n            this.drawGroups(canvas, ctx);\n        }\n\n        if (this.onDrawBackground) {\n            this.onDrawBackground(ctx, this.visible_area);\n        }\n        if (this.onBackgroundRender) {\n            // LEGACY\n            console.error(\n                \"WARNING! onBackgroundRender deprecated, now is named onDrawBackground \",\n            );\n            this.onBackgroundRender = null;\n        }\n\n        // DEBUG: show clipping area\n        // ctx.fillStyle = \"red\";\n        // ctx.fillRect( this.visible_area[0] + 10, this.visible_area[1] + 10,\n        // this.visible_area[2] - 20, this.visible_area[3] - 20);\n\n        // bg\n        if (this.render_canvas_border) {\n            ctx.strokeStyle = \"#235\";\n            ctx.strokeRect(0, 0, canvas.width, canvas.height);\n        }\n\n        if (this.render_connections_shadows) {\n            ctx.shadowColor = \"#000\";\n            ctx.shadowOffsetX = 0;\n            ctx.shadowOffsetY = 0;\n            ctx.shadowBlur = 6;\n        } else {\n            ctx.shadowColor = \"rgba(0,0,0,0)\";\n        }\n\n        // draw connections\n        if (!this.live_mode) {\n            this.drawConnections(ctx);\n        }\n\n        ctx.shadowColor = \"rgba(0,0,0,0)\";\n\n        // restore state\n        ctx.restore();\n    }\n\n    if (ctx.finish) {\n        ctx.finish();\n    }\n\n    this.dirty_bgcanvas = false;\n    this.dirty_canvas = true; // to force to repaint the front canvas with the bgcanvas\n};\n\nconst temp_vec2 = new Float32Array(2);\n\n/**\n * draws the given node inside the canvas\n * @method drawNode\n * */\nLGraphCanvas.prototype.drawNode = function (node, ctx) {\n    let glow = false;\n    this.current_node = node;\n\n    const color = node.color || node.constructor.color || LiteGraph.NODE_DEFAULT_COLOR;\n    let bgcolor = node.bgcolor || node.constructor.bgcolor || LiteGraph.NODE_DEFAULT_BGCOLOR;\n\n    // shadow and glow\n    if (node.mouseOver) {\n        glow = true;\n    }\n\n    const low_quality = this.ds.scale < 0.6; // zoomed out\n\n    // only render if it forces it to do it\n    if (this.live_mode) {\n        if (!node.flags.collapsed) {\n            ctx.shadowColor = \"transparent\";\n            if (node.onDrawForeground) {\n                node.onDrawForeground(ctx, this, this.canvas);\n            }\n        }\n        return;\n    }\n\n    const { editor_alpha } = this;\n    ctx.globalAlpha = editor_alpha;\n\n    if (this.render_shadows && !low_quality) {\n        ctx.shadowColor = LiteGraph.DEFAULT_SHADOW_COLOR;\n        ctx.shadowOffsetX = 2 * this.ds.scale;\n        ctx.shadowOffsetY = 2 * this.ds.scale;\n        ctx.shadowBlur = 3 * this.ds.scale;\n    } else {\n        ctx.shadowColor = \"transparent\";\n    }\n\n    // custom draw collapsed method (draw after shadows because they are affected)\n    if (\n        node.flags.collapsed\n        && node.onDrawCollapsed\n        && node.onDrawCollapsed(ctx, this) == true\n    ) {\n        return;\n    }\n\n    // clip if required (mask)\n    const shape = node._shape || LiteGraph.BOX_SHAPE;\n    const size = temp_vec2;\n    temp_vec2.set(node.size);\n    const { horizontal } = node; // || node.flags.horizontal;\n\n    if (node.flags.collapsed) {\n        ctx.font = this.inner_text_font;\n        const title = node.getTitle ? node.getTitle() : node.title;\n        if (title != null) {\n            node._collapsed_width = Math.min(\n                node.size[0],\n                ctx.measureText(title).width\n                + LiteGraph.NODE_TITLE_HEIGHT * 2,\n            ); // LiteGraph.NODE_COLLAPSED_WIDTH;\n            size[0] = node._collapsed_width;\n            size[1] = 0;\n        }\n    }\n\n    if (node.clip_area) {\n        // Start clipping\n        ctx.save();\n        ctx.beginPath();\n        if (shape == LiteGraph.BOX_SHAPE) {\n            ctx.rect(0, 0, size[0], size[1]);\n        } else if (shape == LiteGraph.ROUND_SHAPE) {\n            ctx.roundRect(0, 0, size[0], size[1], 10);\n        } else if (shape == LiteGraph.CIRCLE_SHAPE) {\n            ctx.arc(\n                size[0] * 0.5,\n                size[1] * 0.5,\n                size[0] * 0.5,\n                0,\n                Math.PI * 2,\n            );\n        }\n        ctx.clip();\n    }\n\n    // draw shape\n    if (node.has_errors) {\n        bgcolor = \"red\";\n    }\n    this.drawNodeShape(\n        node,\n        ctx,\n        size,\n        color,\n        bgcolor,\n        node.is_selected,\n        node.mouseOver,\n    );\n    ctx.shadowColor = \"transparent\";\n\n    // draw foreground\n    if (node.onDrawForeground) {\n        node.onDrawForeground(ctx, this, this.canvas);\n    }\n\n    // connection slots\n    ctx.textAlign = horizontal ? \"center\" : \"left\";\n    ctx.font = this.inner_text_font;\n\n    const render_text = !low_quality;\n\n    const out_slot = this.connecting_output;\n    ctx.lineWidth = 1;\n\n    let max_y = 0;\n    const slot_pos = new Float32Array(2); // to reuse\n\n    // render inputs and outputs\n    if (!node.flags.collapsed) {\n        // input connection slots\n        if (node.inputs) {\n            for (var i = 0; i < node.inputs.length; i++) {\n                var slot = node.inputs[i];\n\n                ctx.globalAlpha = editor_alpha;\n                // change opacity of incompatible slots when dragging a connection\n                if (this.connecting_node && !LiteGraph.isValidConnection(slot.type, out_slot.type)) {\n                    ctx.globalAlpha = 0.4 * editor_alpha;\n                }\n\n                ctx.fillStyle = slot.link != null\n                    ? slot.color_on\n                    || this.default_connection_color.input_on\n                    : slot.color_off\n                    || this.default_connection_color.input_off;\n\n                var pos = node.getConnectionPos(true, i, slot_pos);\n                pos[0] -= node.pos[0];\n                pos[1] -= node.pos[1];\n                if (max_y < pos[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5) {\n                    max_y = pos[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5;\n                }\n\n                ctx.beginPath();\n\n                if (\n                    slot.type === LiteGraph.EVENT\n                    || slot.shape === LiteGraph.BOX_SHAPE\n                ) {\n                    if (horizontal) {\n                        ctx.rect(\n                            pos[0] - 5 + 0.5,\n                            pos[1] - 8 + 0.5,\n                            10,\n                            14,\n                        );\n                    } else {\n                        ctx.rect(\n                            pos[0] - 6 + 0.5,\n                            pos[1] - 5 + 0.5,\n                            14,\n                            10,\n                        );\n                    }\n                } else if (slot.shape === LiteGraph.ARROW_SHAPE) {\n                    ctx.moveTo(pos[0] + 8, pos[1] + 0.5);\n                    ctx.lineTo(pos[0] - 4, pos[1] + 6 + 0.5);\n                    ctx.lineTo(pos[0] - 4, pos[1] - 6 + 0.5);\n                    ctx.closePath();\n                } else if (low_quality) {\n                    ctx.rect(pos[0] - 4, pos[1] - 4, 8, 8);\n                }// faster\n                else {\n                    ctx.arc(pos[0], pos[1], 4, 0, Math.PI * 2);\n                }\n                ctx.fill();\n\n                // render name\n                if (render_text) {\n                    var text = slot.label != null ? slot.label : slot.name;\n                    if (text) {\n                        ctx.fillStyle = LiteGraph.NODE_TEXT_COLOR;\n                        if (horizontal || slot.dir == LiteGraph.UP) {\n                            ctx.fillText(text, pos[0], pos[1] - 10);\n                        } else {\n                            ctx.fillText(text, pos[0] + 10, pos[1] + 5);\n                        }\n                    }\n                }\n            }\n        }\n\n        // output connection slots\n        if (this.connecting_node) {\n            ctx.globalAlpha = 0.4 * editor_alpha;\n        }\n\n        ctx.textAlign = horizontal ? \"center\" : \"right\";\n        ctx.strokeStyle = \"black\";\n        if (node.outputs) {\n            for (var i = 0; i < node.outputs.length; i++) {\n                var slot = node.outputs[i];\n\n                var pos = node.getConnectionPos(false, i, slot_pos);\n                pos[0] -= node.pos[0];\n                pos[1] -= node.pos[1];\n                if (max_y < pos[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5) {\n                    max_y = pos[1] + LiteGraph.NODE_SLOT_HEIGHT * 0.5;\n                }\n\n                ctx.fillStyle = slot.links && slot.links.length\n                    ? slot.color_on\n                    || this.default_connection_color.output_on\n                    : slot.color_off\n                    || this.default_connection_color.output_off;\n                ctx.beginPath();\n                // ctx.rect( node.size[0] - 14,i*14,10,10);\n\n                if (\n                    slot.type === LiteGraph.EVENT\n                    || slot.shape === LiteGraph.BOX_SHAPE\n                ) {\n                    if (horizontal) {\n                        ctx.rect(\n                            pos[0] - 5 + 0.5,\n                            pos[1] - 8 + 0.5,\n                            10,\n                            14,\n                        );\n                    } else {\n                        ctx.rect(\n                            pos[0] - 6 + 0.5,\n                            pos[1] - 5 + 0.5,\n                            14,\n                            10,\n                        );\n                    }\n                } else if (slot.shape === LiteGraph.ARROW_SHAPE) {\n                    ctx.moveTo(pos[0] + 8, pos[1] + 0.5);\n                    ctx.lineTo(pos[0] - 4, pos[1] + 6 + 0.5);\n                    ctx.lineTo(pos[0] - 4, pos[1] - 6 + 0.5);\n                    ctx.closePath();\n                } else if (low_quality) {\n                    ctx.rect(pos[0] - 4, pos[1] - 4, 8, 8);\n                } else {\n                    ctx.arc(pos[0], pos[1], 4, 0, Math.PI * 2);\n                }\n\n                // trigger\n                // if(slot.node_id != null && slot.slot == -1)\n                //\tctx.fillStyle = \"#F85\";\n\n                // if(slot.links != null && slot.links.length)\n                ctx.fill();\n                if (!low_quality) ctx.stroke();\n\n                // render output name\n                if (render_text) {\n                    var text = slot.label != null ? slot.label : slot.name;\n                    if (text) {\n                        ctx.fillStyle = LiteGraph.NODE_TEXT_COLOR;\n                        if (horizontal || slot.dir == LiteGraph.DOWN) {\n                            ctx.fillText(text, pos[0], pos[1] - 8);\n                        } else {\n                            ctx.fillText(text, pos[0] - 10, pos[1] + 5);\n                        }\n                    }\n                }\n            }\n        }\n\n        ctx.textAlign = \"left\";\n        ctx.globalAlpha = 1;\n\n        if (node.widgets) {\n            let widgets_y = max_y;\n            if (horizontal || node.widgets_up) {\n                widgets_y = 2;\n            }\n            if (node.widgets_start_y != null) widgets_y = node.widgets_start_y;\n            this.drawNodeWidgets(\n                node,\n                widgets_y,\n                ctx,\n                this.node_widget && this.node_widget[0] == node\n                    ? this.node_widget[1]\n                    : null,\n            );\n        }\n    } else if (this.render_collapsed_slots) {\n        // if collapsed\n        let input_slot = null;\n        let output_slot = null;\n\n        // get first connected slot to render\n        if (node.inputs) {\n            for (var i = 0; i < node.inputs.length; i++) {\n                var slot = node.inputs[i];\n                if (slot.link == null) {\n                    continue;\n                }\n                input_slot = slot;\n                break;\n            }\n        }\n        if (node.outputs) {\n            for (var i = 0; i < node.outputs.length; i++) {\n                var slot = node.outputs[i];\n                if (!slot.links || !slot.links.length) {\n                    continue;\n                }\n                output_slot = slot;\n            }\n        }\n\n        if (input_slot) {\n            var x = 0;\n            var y = LiteGraph.NODE_TITLE_HEIGHT * -0.5; // center\n            if (horizontal) {\n                x = node._collapsed_width * 0.5;\n                y = -LiteGraph.NODE_TITLE_HEIGHT;\n            }\n            ctx.fillStyle = \"#686\";\n            ctx.beginPath();\n            if (\n                slot.type === LiteGraph.EVENT\n                || slot.shape === LiteGraph.BOX_SHAPE\n            ) {\n                ctx.rect(x - 7 + 0.5, y - 4, 14, 8);\n            } else if (slot.shape === LiteGraph.ARROW_SHAPE) {\n                ctx.moveTo(x + 8, y);\n                ctx.lineTo(x + -4, y - 4);\n                ctx.lineTo(x + -4, y + 4);\n                ctx.closePath();\n            } else {\n                ctx.arc(x, y, 4, 0, Math.PI * 2);\n            }\n            ctx.fill();\n        }\n\n        if (output_slot) {\n            var x = node._collapsed_width;\n            var y = LiteGraph.NODE_TITLE_HEIGHT * -0.5; // center\n            if (horizontal) {\n                x = node._collapsed_width * 0.5;\n                y = 0;\n            }\n            ctx.fillStyle = \"#686\";\n            ctx.strokeStyle = \"black\";\n            ctx.beginPath();\n            if (\n                slot.type === LiteGraph.EVENT\n                || slot.shape === LiteGraph.BOX_SHAPE\n            ) {\n                ctx.rect(x - 7 + 0.5, y - 4, 14, 8);\n            } else if (slot.shape === LiteGraph.ARROW_SHAPE) {\n                ctx.moveTo(x + 6, y);\n                ctx.lineTo(x - 6, y - 4);\n                ctx.lineTo(x - 6, y + 4);\n                ctx.closePath();\n            } else {\n                ctx.arc(x, y, 4, 0, Math.PI * 2);\n            }\n            ctx.fill();\n            // ctx.stroke();\n        }\n    }\n\n    if (node.clip_area) {\n        ctx.restore();\n    }\n\n    ctx.globalAlpha = 1.0;\n};\n\n// used by this.over_link_center\nLGraphCanvas.prototype.drawLinkTooltip = function (ctx, link) {\n    const pos = link._pos;\n    ctx.fillStyle = \"black\";\n    ctx.beginPath();\n    ctx.arc(pos[0], pos[1], 3, 0, Math.PI * 2);\n    ctx.fill();\n\n    if (link.data == null) return;\n\n    if (this.onDrawLinkTooltip) if (this.onDrawLinkTooltip(ctx, link, this) == true) return;\n\n    const { data } = link;\n    let text = null;\n\n    if (data.constructor === Number) {\n        text = data.toFixed(2);\n    } else if (data.constructor === String) {\n        text = `\"${data}\"`;\n    } else if (data.constructor === Boolean) {\n        text = String(data);\n    } else if (data.toToolTip) {\n        text = data.toToolTip();\n    } else {\n        text = `[${data.constructor.name}]`;\n    }\n\n    if (text == null) return;\n    text = text.substr(0, 30); // avoid weird\n\n    ctx.font = \"14px Courier New\";\n    const info = ctx.measureText(text);\n    const w = info.width + 20;\n    const h = 24;\n    ctx.shadowColor = \"black\";\n    ctx.shadowOffsetX = 2;\n    ctx.shadowOffsetY = 2;\n    ctx.shadowBlur = 3;\n    ctx.fillStyle = \"#454\";\n    ctx.beginPath();\n    ctx.roundRect(pos[0] - w * 0.5, pos[1] - 15 - h, w, h, 3, 3);\n    ctx.moveTo(pos[0] - 10, pos[1] - 15);\n    ctx.lineTo(pos[0] + 10, pos[1] - 15);\n    ctx.lineTo(pos[0], pos[1] - 5);\n    ctx.fill();\n    ctx.shadowColor = \"transparent\";\n    ctx.textAlign = \"center\";\n    ctx.fillStyle = \"#CEC\";\n    ctx.fillText(text, pos[0], pos[1] - 15 - h * 0.3);\n};\n\n/**\n * draws the shape of the given node in the canvas\n * @method drawNodeShape\n * */\nconst tmp_area = new Float32Array(4);\n\nLGraphCanvas.prototype.drawNodeShape = function (\n    node,\n    ctx,\n    size,\n    fgcolor,\n    bgcolor,\n    selected,\n    mouse_over,\n) {\n    // bg rect\n    ctx.strokeStyle = fgcolor;\n    ctx.fillStyle = bgcolor;\n\n    const title_height = LiteGraph.NODE_TITLE_HEIGHT;\n    const low_quality = this.ds.scale < 0.5;\n\n    // render node area depending on shape\n    const shape = node._shape || node.constructor.shape || LiteGraph.ROUND_SHAPE;\n\n    const { title_mode } = node.constructor;\n\n    let render_title = true;\n    if (title_mode == LiteGraph.TRANSPARENT_TITLE) {\n        render_title = false;\n    } else if (title_mode == LiteGraph.AUTOHIDE_TITLE && mouse_over) {\n        render_title = true;\n    }\n\n    const area = tmp_area;\n    area[0] = 0; // x\n    area[1] = render_title ? -title_height : 0; // y\n    area[2] = size[0] + 1; // w\n    area[3] = render_title ? size[1] + title_height : size[1]; // h\n\n    const old_alpha = ctx.globalAlpha;\n\n    // full node shape\n    // if(node.flags.collapsed)\n    {\n        ctx.beginPath();\n        if (shape == LiteGraph.BOX_SHAPE || low_quality) {\n            ctx.fillRect(area[0], area[1], area[2], area[3]);\n        } else if (\n            shape == LiteGraph.ROUND_SHAPE\n            || shape == LiteGraph.CARD_SHAPE\n        ) {\n            ctx.roundRect(\n                area[0],\n                area[1],\n                area[2],\n                area[3],\n                this.round_radius,\n                shape == LiteGraph.CARD_SHAPE ? 0 : this.round_radius,\n            );\n        } else if (shape == LiteGraph.CIRCLE_SHAPE) {\n            ctx.arc(\n                size[0] * 0.5,\n                size[1] * 0.5,\n                size[0] * 0.5,\n                0,\n                Math.PI * 2,\n            );\n        }\n        ctx.fill();\n\n        // separator\n        if (!node.flags.collapsed) {\n            ctx.shadowColor = \"transparent\";\n            ctx.fillStyle = \"rgba(0,0,0,0.2)\";\n            ctx.fillRect(0, -1, area[2], 2);\n        }\n    }\n    ctx.shadowColor = \"transparent\";\n\n    if (node.onDrawBackground) {\n        node.onDrawBackground(ctx, this, this.canvas, this.graph_mouse);\n    }\n\n    // title bg (remember, it is rendered ABOVE the node)\n    if (render_title || title_mode == LiteGraph.TRANSPARENT_TITLE) {\n        // title bar\n        if (node.onDrawTitleBar) {\n            node.onDrawTitleBar(ctx, title_height, size, this.ds.scale, fgcolor);\n        } else if (\n            title_mode != LiteGraph.TRANSPARENT_TITLE\n            && (node.constructor.title_color || this.render_title_colored)\n        ) {\n            const title_color = node.constructor.title_color || fgcolor;\n\n            if (node.flags.collapsed) {\n                ctx.shadowColor = LiteGraph.DEFAULT_SHADOW_COLOR;\n            }\n\n            //* gradient test\n            if (this.use_gradients) {\n                let grad = LGraphCanvas.gradients[title_color];\n                if (!grad) {\n                    grad = LGraphCanvas.gradients[title_color] = ctx.createLinearGradient(0, 0, 400, 0);\n                    grad.addColorStop(0, title_color);\n                    grad.addColorStop(1, \"#000\");\n                }\n                ctx.fillStyle = grad;\n            } else {\n                ctx.fillStyle = title_color;\n            }\n\n            // ctx.globalAlpha = 0.5 * old_alpha;\n            ctx.beginPath();\n            if (shape == LiteGraph.BOX_SHAPE || low_quality) {\n                ctx.rect(0, -title_height, size[0] + 1, title_height);\n            } else if (shape == LiteGraph.ROUND_SHAPE || shape == LiteGraph.CARD_SHAPE) {\n                ctx.roundRect(\n                    0,\n                    -title_height,\n                    size[0] + 1,\n                    title_height,\n                    this.round_radius,\n                    node.flags.collapsed ? this.round_radius : 0,\n                );\n            }\n            ctx.fill();\n            ctx.shadowColor = \"transparent\";\n        }\n\n        // title box\n        const box_size = 10;\n        if (node.onDrawTitleBox) {\n            node.onDrawTitleBox(ctx, title_height, size, this.ds.scale);\n        } else if (\n            shape == LiteGraph.ROUND_SHAPE\n            || shape == LiteGraph.CIRCLE_SHAPE\n            || shape == LiteGraph.CARD_SHAPE\n        ) {\n            if (low_quality) {\n                ctx.fillStyle = \"black\";\n                ctx.beginPath();\n                ctx.arc(\n                    title_height * 0.5,\n                    title_height * -0.5,\n                    box_size * 0.5 + 1,\n                    0,\n                    Math.PI * 2,\n                );\n                ctx.fill();\n            }\n\n            ctx.fillStyle = node.boxcolor || LiteGraph.NODE_DEFAULT_BOXCOLOR;\n            if (low_quality) {\n                ctx.fillRect(title_height * 0.5 - box_size * 0.5, title_height * -0.5 - box_size * 0.5, box_size, box_size);\n            } else {\n                ctx.beginPath();\n                ctx.arc(\n                    title_height * 0.5,\n                    title_height * -0.5,\n                    box_size * 0.5,\n                    0,\n                    Math.PI * 2,\n                );\n                ctx.fill();\n            }\n        } else {\n            if (low_quality) {\n                ctx.fillStyle = \"black\";\n                ctx.fillRect(\n                    (title_height - box_size) * 0.5 - 1,\n                    (title_height + box_size) * -0.5 - 1,\n                    box_size + 2,\n                    box_size + 2,\n                );\n            }\n            ctx.fillStyle = node.boxcolor || LiteGraph.NODE_DEFAULT_BOXCOLOR;\n            ctx.fillRect(\n                (title_height - box_size) * 0.5,\n                (title_height + box_size) * -0.5,\n                box_size,\n                box_size,\n            );\n        }\n        ctx.globalAlpha = old_alpha;\n\n        // title text\n        if (node.onDrawTitleText) {\n            node.onDrawTitleText(\n                ctx,\n                title_height,\n                size,\n                this.ds.scale,\n                this.title_text_font,\n                selected,\n            );\n        }\n        if (!low_quality) {\n            ctx.font = this.title_text_font;\n            const title = String(node.getTitle());\n            if (title) {\n                if (selected) {\n                    ctx.fillStyle = LiteGraph.NODE_SELECTED_TITLE_COLOR;\n                } else {\n                    ctx.fillStyle = node.constructor.title_text_color\n                        || this.node_title_color;\n                }\n                if (node.flags.collapsed) {\n                    ctx.textAlign = \"left\";\n                    const measure = ctx.measureText(title);\n                    ctx.fillText(\n                        title.substr(0, 20), // avoid urls too long\n                        title_height, // + measure.width * 0.5,\n                        LiteGraph.NODE_TITLE_TEXT_Y - title_height,\n                    );\n                    ctx.textAlign = \"left\";\n                } else {\n                    ctx.textAlign = \"left\";\n                    ctx.fillText(\n                        title,\n                        title_height,\n                        LiteGraph.NODE_TITLE_TEXT_Y - title_height,\n                    );\n                }\n            }\n        }\n\n        // subgraph box\n        if (!node.flags.collapsed && node.subgraph && !node.skip_subgraph_button) {\n            const w = LiteGraph.NODE_TITLE_HEIGHT;\n            const x = node.size[0] - w;\n            const over = LiteGraph.isInsideRectangle(this.graph_mouse[0] - node.pos[0], this.graph_mouse[1] - node.pos[1], x + 2, -w + 2, w - 4, w - 4);\n            ctx.fillStyle = over ? \"#888\" : \"#555\";\n            if (shape == LiteGraph.BOX_SHAPE || low_quality) {\n                ctx.fillRect(x + 2, -w + 2, w - 4, w - 4);\n            } else {\n                ctx.beginPath();\n                ctx.roundRect(x + 2, -w + 2, w - 4, w - 4, 4);\n                ctx.fill();\n            }\n            ctx.fillStyle = \"#333\";\n            ctx.beginPath();\n            ctx.moveTo(x + w * 0.2, -w * 0.6);\n            ctx.lineTo(x + w * 0.8, -w * 0.6);\n            ctx.lineTo(x + w * 0.5, -w * 0.3);\n            ctx.fill();\n        }\n\n        // custom title render\n        if (node.onDrawTitle) {\n            node.onDrawTitle(ctx);\n        }\n    }\n\n    // render selection marker\n    if (selected) {\n        if (node.onBounding) {\n            node.onBounding(area);\n        }\n\n        if (title_mode == LiteGraph.TRANSPARENT_TITLE) {\n            area[1] -= title_height;\n            area[3] += title_height;\n        }\n        ctx.lineWidth = 1;\n        ctx.globalAlpha = 0.8;\n        ctx.beginPath();\n        if (shape == LiteGraph.BOX_SHAPE) {\n            ctx.rect(\n                -6 + area[0],\n                -6 + area[1],\n                12 + area[2],\n                12 + area[3],\n            );\n        } else if (\n            shape == LiteGraph.ROUND_SHAPE\n            || (shape == LiteGraph.CARD_SHAPE && node.flags.collapsed)\n        ) {\n            ctx.roundRect(\n                -6 + area[0],\n                -6 + area[1],\n                12 + area[2],\n                12 + area[3],\n                this.round_radius * 2,\n            );\n        } else if (shape == LiteGraph.CARD_SHAPE) {\n            ctx.roundRect(\n                -6 + area[0],\n                -6 + area[1],\n                12 + area[2],\n                12 + area[3],\n                this.round_radius * 2,\n                2,\n            );\n        } else if (shape == LiteGraph.CIRCLE_SHAPE) {\n            ctx.arc(\n                size[0] * 0.5,\n                size[1] * 0.5,\n                size[0] * 0.5 + 6,\n                0,\n                Math.PI * 2,\n            );\n        }\n        ctx.strokeStyle = LiteGraph.NODE_BOX_OUTLINE_COLOR;\n        ctx.stroke();\n        ctx.strokeStyle = fgcolor;\n        ctx.globalAlpha = 1;\n    }\n};\n\nconst margin_area = new Float32Array(4);\nconst link_bounding = new Float32Array(4);\nconst tempA = new Float32Array(2);\nconst tempB = new Float32Array(2);\n\n/**\n * draws every connection visible in the canvas\n * OPTIMIZE THIS: pre-catch connections position instead of recomputing them every time\n * @method drawConnections\n * */\nLGraphCanvas.prototype.drawConnections = function (ctx) {\n    const now = LiteGraph.getTime();\n    const { visible_area } = this;\n    margin_area[0] = visible_area[0] - 20;\n    margin_area[1] = visible_area[1] - 20;\n    margin_area[2] = visible_area[2] + 40;\n    margin_area[3] = visible_area[3] + 40;\n\n    // draw connections\n    ctx.lineWidth = this.connections_width;\n\n    ctx.fillStyle = \"#AAA\";\n    ctx.strokeStyle = \"#AAA\";\n    ctx.globalAlpha = this.editor_alpha;\n    // for every node\n    const nodes = this.graph._nodes;\n    for (let n = 0, l = nodes.length; n < l; ++n) {\n        const node = nodes[n];\n        // for every input (we render just inputs because it is easier as every slot can only\n        // have one input)\n        if (!node.inputs || !node.inputs.length) {\n            continue;\n        }\n\n        for (let i = 0; i < node.inputs.length; ++i) {\n            const input = node.inputs[i];\n            if (!input || input.link == null) {\n                continue;\n            }\n            const link_id = input.link;\n            const link = this.graph.links[link_id];\n            if (!link) {\n                continue;\n            }\n\n            // find link info\n            const start_node = this.graph.getNodeById(link.origin_id);\n            if (start_node == null) {\n                continue;\n            }\n            const start_node_slot = link.origin_slot;\n            let start_node_slotpos = null;\n            if (start_node_slot == -1) {\n                start_node_slotpos = [\n                    start_node.pos[0] + 10,\n                    start_node.pos[1] + 10,\n                ];\n            } else {\n                start_node_slotpos = start_node.getConnectionPos(\n                    false,\n                    start_node_slot,\n                    tempA,\n                );\n            }\n            const end_node_slotpos = node.getConnectionPos(true, i, tempB);\n\n            // compute link bounding\n            link_bounding[0] = start_node_slotpos[0];\n            link_bounding[1] = start_node_slotpos[1];\n            link_bounding[2] = end_node_slotpos[0] - start_node_slotpos[0];\n            link_bounding[3] = end_node_slotpos[1] - start_node_slotpos[1];\n            if (link_bounding[2] < 0) {\n                link_bounding[0] += link_bounding[2];\n                link_bounding[2] = Math.abs(link_bounding[2]);\n            }\n            if (link_bounding[3] < 0) {\n                link_bounding[1] += link_bounding[3];\n                link_bounding[3] = Math.abs(link_bounding[3]);\n            }\n\n            // skip links outside of the visible area of the canvas\n            if (!overlapBounding(link_bounding, margin_area)) {\n                continue;\n            }\n\n            const start_slot = start_node.outputs[start_node_slot];\n            const end_slot = node.inputs[i];\n            if (!start_slot || !end_slot) {\n                continue;\n            }\n            const start_dir = start_slot.dir\n                || (start_node.horizontal ? LiteGraph.DOWN : LiteGraph.RIGHT);\n            const end_dir = end_slot.dir\n                || (node.horizontal ? LiteGraph.UP : LiteGraph.LEFT);\n\n            this.renderLink(\n                ctx,\n                start_node_slotpos,\n                end_node_slotpos,\n                link,\n                false,\n                0,\n                null,\n                start_dir,\n                end_dir,\n            );\n\n            // event triggered rendered on top\n            if (link && link._last_time && now - link._last_time < 1000) {\n                const f = 2.0 - (now - link._last_time) * 0.002;\n                const tmp = ctx.globalAlpha;\n                ctx.globalAlpha = tmp * f;\n                this.renderLink(\n                    ctx,\n                    start_node_slotpos,\n                    end_node_slotpos,\n                    link,\n                    true,\n                    f,\n                    \"white\",\n                    start_dir,\n                    end_dir,\n                );\n                ctx.globalAlpha = tmp;\n            }\n        }\n    }\n    ctx.globalAlpha = 1;\n};\n\n/**\n * draws a link between two points\n * @method renderLink\n * @param {vec2} a start pos\n * @param {vec2} b end pos\n * @param {Object} link the link object with all the link info\n * @param {boolean} skip_border ignore the shadow of the link\n * @param {boolean} flow show flow animation (for events)\n * @param {string} color the color for the link\n * @param {number} start_dir the direction enum\n * @param {number} end_dir the direction enum\n * @param {number} num_sublines number of sublines (useful to represent vec3 or rgb)\n * */\nLGraphCanvas.prototype.renderLink = function (\n    ctx,\n    a,\n    b,\n    link,\n    skip_border,\n    flow,\n    color,\n    start_dir,\n    end_dir,\n    num_sublines,\n) {\n    if (link) {\n        this.visible_links.push(link);\n    }\n\n    // choose color\n    if (!color && link) {\n        color = link.color || LGraphCanvas.link_type_colors[link.type];\n    }\n    if (!color) {\n        color = this.default_link_color;\n    }\n    if (link != null && this.highlighted_links[link.id]) {\n        color = \"#FFF\";\n    }\n\n    start_dir = start_dir || LiteGraph.RIGHT;\n    end_dir = end_dir || LiteGraph.LEFT;\n\n    const dist = distance(a, b);\n\n    if (this.render_connections_border && this.ds.scale > 0.6) {\n        ctx.lineWidth = this.connections_width + 4;\n    }\n    ctx.lineJoin = \"round\";\n    num_sublines = num_sublines || 1;\n    if (num_sublines > 1) {\n        ctx.lineWidth = 0.5;\n    }\n\n    // begin line shape\n    ctx.beginPath();\n    for (var i = 0; i < num_sublines; i += 1) {\n        const offsety = (i - (num_sublines - 1) * 0.5) * 5;\n\n        if (this.links_render_mode == LiteGraph.SPLINE_LINK) {\n            ctx.moveTo(a[0], a[1] + offsety);\n            var start_offset_x = 0;\n            var start_offset_y = 0;\n            var end_offset_x = 0;\n            var end_offset_y = 0;\n            switch (start_dir) {\n                case LiteGraph.LEFT:\n                    start_offset_x = dist * -0.25;\n                    break;\n                case LiteGraph.RIGHT:\n                    start_offset_x = dist * 0.25;\n                    break;\n                case LiteGraph.UP:\n                    start_offset_y = dist * -0.25;\n                    break;\n                case LiteGraph.DOWN:\n                    start_offset_y = dist * 0.25;\n                    break;\n            }\n            switch (end_dir) {\n                case LiteGraph.LEFT:\n                    end_offset_x = dist * -0.25;\n                    break;\n                case LiteGraph.RIGHT:\n                    end_offset_x = dist * 0.25;\n                    break;\n                case LiteGraph.UP:\n                    end_offset_y = dist * -0.25;\n                    break;\n                case LiteGraph.DOWN:\n                    end_offset_y = dist * 0.25;\n                    break;\n            }\n            ctx.bezierCurveTo(\n                a[0] + start_offset_x,\n                a[1] + start_offset_y + offsety,\n                b[0] + end_offset_x,\n                b[1] + end_offset_y + offsety,\n                b[0],\n                b[1] + offsety,\n            );\n        } else if (this.links_render_mode == LiteGraph.LINEAR_LINK) {\n            ctx.moveTo(a[0], a[1] + offsety);\n            var start_offset_x = 0;\n            var start_offset_y = 0;\n            var end_offset_x = 0;\n            var end_offset_y = 0;\n            switch (start_dir) {\n                case LiteGraph.LEFT:\n                    start_offset_x = -1;\n                    break;\n                case LiteGraph.RIGHT:\n                    start_offset_x = 1;\n                    break;\n                case LiteGraph.UP:\n                    start_offset_y = -1;\n                    break;\n                case LiteGraph.DOWN:\n                    start_offset_y = 1;\n                    break;\n            }\n            switch (end_dir) {\n                case LiteGraph.LEFT:\n                    end_offset_x = -1;\n                    break;\n                case LiteGraph.RIGHT:\n                    end_offset_x = 1;\n                    break;\n                case LiteGraph.UP:\n                    end_offset_y = -1;\n                    break;\n                case LiteGraph.DOWN:\n                    end_offset_y = 1;\n                    break;\n            }\n            const l = 15;\n            ctx.lineTo(\n                a[0] + start_offset_x * l,\n                a[1] + start_offset_y * l + offsety,\n            );\n            ctx.lineTo(\n                b[0] + end_offset_x * l,\n                b[1] + end_offset_y * l + offsety,\n            );\n            ctx.lineTo(b[0], b[1] + offsety);\n        } else if (this.links_render_mode == LiteGraph.STRAIGHT_LINK) {\n            ctx.moveTo(a[0], a[1]);\n            let start_x = a[0];\n            let start_y = a[1];\n            let end_x = b[0];\n            let end_y = b[1];\n            if (start_dir == LiteGraph.RIGHT) {\n                start_x += 10;\n            } else {\n                start_y += 10;\n            }\n            if (end_dir == LiteGraph.LEFT) {\n                end_x -= 10;\n            } else {\n                end_y -= 10;\n            }\n            ctx.lineTo(start_x, start_y);\n            ctx.lineTo((start_x + end_x) * 0.5, start_y);\n            ctx.lineTo((start_x + end_x) * 0.5, end_y);\n            ctx.lineTo(end_x, end_y);\n            ctx.lineTo(b[0], b[1]);\n        } else {\n            return;\n        } // unknown\n    }\n\n    // rendering the outline of the connection can be a little bit slow\n    if (\n        this.render_connections_border\n        && this.ds.scale > 0.6\n        && !skip_border\n    ) {\n        ctx.strokeStyle = \"rgba(0,0,0,0.5)\";\n        ctx.stroke();\n    }\n\n    ctx.lineWidth = this.connections_width;\n    ctx.fillStyle = ctx.strokeStyle = color;\n    ctx.stroke();\n    // end line shape\n\n    var pos = this.computeConnectionPoint(a, b, 0.5, start_dir, end_dir);\n    if (link && link._pos) {\n        link._pos[0] = pos[0];\n        link._pos[1] = pos[1];\n    }\n\n    // render arrow in the middle\n    if (\n        this.ds.scale >= 0.6\n        && this.highquality_render\n        && end_dir != LiteGraph.CENTER\n    ) {\n        // render arrow\n        if (this.render_connection_arrows) {\n            // compute two points in the connection\n            const posA = this.computeConnectionPoint(\n                a,\n                b,\n                0.25,\n                start_dir,\n                end_dir,\n            );\n            const posB = this.computeConnectionPoint(\n                a,\n                b,\n                0.26,\n                start_dir,\n                end_dir,\n            );\n            const posC = this.computeConnectionPoint(\n                a,\n                b,\n                0.75,\n                start_dir,\n                end_dir,\n            );\n            const posD = this.computeConnectionPoint(\n                a,\n                b,\n                0.76,\n                start_dir,\n                end_dir,\n            );\n\n            // compute the angle between them so the arrow points in the right direction\n            let angleA = 0;\n            let angleB = 0;\n            if (this.render_curved_connections) {\n                angleA = -Math.atan2(posB[0] - posA[0], posB[1] - posA[1]);\n                angleB = -Math.atan2(posD[0] - posC[0], posD[1] - posC[1]);\n            } else {\n                angleB = angleA = b[1] > a[1] ? 0 : Math.PI;\n            }\n\n            // render arrow\n            ctx.save();\n            ctx.translate(posA[0], posA[1]);\n            ctx.rotate(angleA);\n            ctx.beginPath();\n            ctx.moveTo(-5, -3);\n            ctx.lineTo(0, +7);\n            ctx.lineTo(+5, -3);\n            ctx.fill();\n            ctx.restore();\n            ctx.save();\n            ctx.translate(posC[0], posC[1]);\n            ctx.rotate(angleB);\n            ctx.beginPath();\n            ctx.moveTo(-5, -3);\n            ctx.lineTo(0, +7);\n            ctx.lineTo(+5, -3);\n            ctx.fill();\n            ctx.restore();\n        }\n\n        // circle\n        ctx.beginPath();\n        ctx.arc(pos[0], pos[1], 5, 0, Math.PI * 2);\n        ctx.fill();\n    }\n\n    // render flowing points\n    if (flow) {\n        ctx.fillStyle = color;\n        for (var i = 0; i < 5; ++i) {\n            const f = (LiteGraph.getTime() * 0.001 + i * 0.2) % 1;\n            var pos = this.computeConnectionPoint(\n                a,\n                b,\n                f,\n                start_dir,\n                end_dir,\n            );\n            ctx.beginPath();\n            ctx.arc(pos[0], pos[1], 5, 0, 2 * Math.PI);\n            ctx.fill();\n        }\n    }\n};\n\n// returns the link center point based on curvature\nLGraphCanvas.prototype.computeConnectionPoint = function (\n    a,\n    b,\n    t,\n    start_dir,\n    end_dir,\n) {\n    start_dir = start_dir || LiteGraph.RIGHT;\n    end_dir = end_dir || LiteGraph.LEFT;\n\n    const dist = distance(a, b);\n    const p0 = a;\n    const p1 = [a[0], a[1]];\n    const p2 = [b[0], b[1]];\n    const p3 = b;\n\n    switch (start_dir) {\n        case LiteGraph.LEFT:\n            p1[0] += dist * -0.25;\n            break;\n        case LiteGraph.RIGHT:\n            p1[0] += dist * 0.25;\n            break;\n        case LiteGraph.UP:\n            p1[1] += dist * -0.25;\n            break;\n        case LiteGraph.DOWN:\n            p1[1] += dist * 0.25;\n            break;\n    }\n    switch (end_dir) {\n        case LiteGraph.LEFT:\n            p2[0] += dist * -0.25;\n            break;\n        case LiteGraph.RIGHT:\n            p2[0] += dist * 0.25;\n            break;\n        case LiteGraph.UP:\n            p2[1] += dist * -0.25;\n            break;\n        case LiteGraph.DOWN:\n            p2[1] += dist * 0.25;\n            break;\n    }\n\n    const c1 = (1 - t) * (1 - t) * (1 - t);\n    const c2 = 3 * ((1 - t) * (1 - t)) * t;\n    const c3 = 3 * (1 - t) * (t * t);\n    const c4 = t * t * t;\n\n    const x = c1 * p0[0] + c2 * p1[0] + c3 * p2[0] + c4 * p3[0];\n    const y = c1 * p0[1] + c2 * p1[1] + c3 * p2[1] + c4 * p3[1];\n    return [x, y];\n};\n\nLGraphCanvas.prototype.drawExecutionOrder = function (ctx) {\n    ctx.shadowColor = \"transparent\";\n    ctx.globalAlpha = 0.25;\n\n    ctx.textAlign = \"center\";\n    ctx.strokeStyle = \"white\";\n    ctx.globalAlpha = 0.75;\n\n    const { visible_nodes } = this;\n    for (let i = 0; i < visible_nodes.length; ++i) {\n        const node = visible_nodes[i];\n        ctx.fillStyle = \"black\";\n        ctx.fillRect(\n            node.pos[0] - LiteGraph.NODE_TITLE_HEIGHT,\n            node.pos[1] - LiteGraph.NODE_TITLE_HEIGHT,\n            LiteGraph.NODE_TITLE_HEIGHT,\n            LiteGraph.NODE_TITLE_HEIGHT,\n        );\n        if (node.order == 0) {\n            ctx.strokeRect(\n                node.pos[0] - LiteGraph.NODE_TITLE_HEIGHT + 0.5,\n                node.pos[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5,\n                LiteGraph.NODE_TITLE_HEIGHT,\n                LiteGraph.NODE_TITLE_HEIGHT,\n            );\n        }\n        ctx.fillStyle = \"#FFF\";\n        ctx.fillText(\n            node.order,\n            node.pos[0] + LiteGraph.NODE_TITLE_HEIGHT * -0.5,\n            node.pos[1] - 6,\n        );\n    }\n    ctx.globalAlpha = 1;\n};\n\n/**\n * draws the widgets stored inside a node\n * @method drawNodeWidgets\n * */\nLGraphCanvas.prototype.drawNodeWidgets = function (\n    node,\n    posY,\n    ctx,\n    active_widget,\n) {\n    if (!node.widgets || !node.widgets.length) {\n        return 0;\n    }\n    const width = node.size[0];\n    const { widgets } = node;\n    posY += 2;\n    const H = LiteGraph.NODE_WIDGET_HEIGHT;\n    const show_text = this.ds.scale > 0.5;\n    ctx.save();\n    ctx.globalAlpha = this.editor_alpha;\n    const outline_color = LiteGraph.WIDGET_OUTLINE_COLOR;\n    const background_color = LiteGraph.WIDGET_BGCOLOR;\n    const text_color = LiteGraph.WIDGET_TEXT_COLOR;\n    const secondary_text_color = LiteGraph.WIDGET_SECONDARY_TEXT_COLOR;\n    const margin = 15;\n\n    for (let i = 0; i < widgets.length; ++i) {\n        const w = widgets[i];\n        let y = posY;\n        if (w.y) {\n            y = w.y;\n        }\n        w.last_y = y;\n        ctx.strokeStyle = outline_color;\n        ctx.fillStyle = \"#222\";\n        ctx.textAlign = \"left\";\n        // ctx.lineWidth = 2;\n        if (w.disabled) ctx.globalAlpha *= 0.5;\n        const widget_width = w.width || width;\n\n        switch (w.type) {\n            case \"button\":\n                if (w.clicked) {\n                    ctx.fillStyle = \"#AAA\";\n                    w.clicked = false;\n                    this.dirty_canvas = true;\n                }\n                ctx.fillRect(margin, y, widget_width - margin * 2, H);\n                if (show_text && !w.disabled) ctx.strokeRect(margin, y, widget_width - margin * 2, H);\n                if (show_text) {\n                    ctx.textAlign = \"center\";\n                    ctx.fillStyle = text_color;\n                    ctx.fillText(w.name, widget_width * 0.5, y + H * 0.7);\n                }\n                break;\n            case \"toggle\":\n                ctx.textAlign = \"left\";\n                ctx.strokeStyle = outline_color;\n                ctx.fillStyle = background_color;\n                ctx.beginPath();\n                if (show_text) {\n                    ctx.roundRect(margin, posY, widget_width - margin * 2, H, H * 0.5);\n                } else {\n                    ctx.rect(margin, posY, widget_width - margin * 2, H);\n                }\n                ctx.fill();\n                if (show_text && !w.disabled) ctx.stroke();\n                ctx.fillStyle = w.value ? \"#89A\" : \"#333\";\n                ctx.beginPath();\n                ctx.arc(widget_width - margin * 2, y + H * 0.5, H * 0.36, 0, Math.PI * 2);\n                ctx.fill();\n                if (show_text) {\n                    ctx.fillStyle = secondary_text_color;\n                    if (w.name != null) {\n                        ctx.fillText(w.name, margin * 2, y + H * 0.7);\n                    }\n                    ctx.fillStyle = w.value ? text_color : secondary_text_color;\n                    ctx.textAlign = \"right\";\n                    ctx.fillText(\n                        w.value\n                            ? w.options.on || \"true\"\n                            : w.options.off || \"false\",\n                        widget_width - 40,\n                        y + H * 0.7,\n                    );\n                }\n                break;\n            case \"slider\":\n                ctx.fillStyle = background_color;\n                ctx.fillRect(margin, y, widget_width - margin * 2, H);\n                var range = w.options.max - w.options.min;\n                var nvalue = (w.value - w.options.min) / range;\n                ctx.fillStyle = active_widget == w ? \"#89A\" : \"#678\";\n                ctx.fillRect(margin, y, nvalue * (widget_width - margin * 2), H);\n                if (show_text && !w.disabled) ctx.strokeRect(margin, y, widget_width - margin * 2, H);\n                if (w.marker) {\n                    const marker_nvalue = (w.marker - w.options.min) / range;\n                    ctx.fillStyle = \"#AA9\";\n                    ctx.fillRect(margin + marker_nvalue * (widget_width - margin * 2), y, 2, H);\n                }\n                if (show_text) {\n                    ctx.textAlign = \"center\";\n                    ctx.fillStyle = text_color;\n                    ctx.fillText(\n                        `${w.name}  ${Number(w.value)\n                            .toFixed(3)}`,\n                        widget_width * 0.5,\n                        y + H * 0.7,\n                    );\n                }\n                break;\n            case \"number\":\n            case \"combo\":\n                ctx.textAlign = \"left\";\n                ctx.strokeStyle = outline_color;\n                ctx.fillStyle = background_color;\n                ctx.beginPath();\n                if (show_text) {\n                    ctx.roundRect(margin, posY, widget_width - margin * 2, H, H * 0.5);\n                } else {\n                    ctx.rect(margin, posY, widget_width - margin * 2, H);\n                }\n                ctx.fill();\n                if (show_text) {\n                    if (!w.disabled) ctx.stroke();\n                    ctx.fillStyle = text_color;\n                    if (!w.disabled) {\n                        ctx.beginPath();\n                        ctx.moveTo(margin + 16, posY + 5);\n                        ctx.lineTo(margin + 6, posY + H * 0.5);\n                        ctx.lineTo(margin + 16, posY + H - 5);\n                        ctx.fill();\n                        ctx.beginPath();\n                        ctx.moveTo(widget_width - margin - 16, posY + 5);\n                        ctx.lineTo(widget_width - margin - 6, posY + H * 0.5);\n                        ctx.lineTo(widget_width - margin - 16, posY + H - 5);\n                        ctx.fill();\n                    }\n                    ctx.fillStyle = secondary_text_color;\n                    ctx.fillText(w.name, margin * 2 + 5, y + H * 0.7);\n                    ctx.fillStyle = text_color;\n                    ctx.textAlign = \"right\";\n                    if (w.type == \"number\") {\n                        ctx.fillText(\n                            Number(w.value)\n                                .toFixed(\n                                    w.options.precision !== undefined\n                                        ? w.options.precision\n                                        : 3,\n                                ),\n                            widget_width - margin * 2 - 20,\n                            y + H * 0.7,\n                        );\n                    } else {\n                        let v = w.value;\n                        if (w.options.values) {\n                            let { values } = w.options;\n                            if (values.constructor === Function) values = values();\n                            if (values && values.constructor !== Array) v = values[w.value];\n                        }\n                        ctx.fillText(\n                            v,\n                            widget_width - margin * 2 - 20,\n                            y + H * 0.7,\n                        );\n                    }\n                }\n                break;\n            case \"string\":\n            case \"text\":\n                ctx.textAlign = \"left\";\n                ctx.strokeStyle = outline_color;\n                ctx.fillStyle = background_color;\n                ctx.beginPath();\n                if (show_text) {\n                    ctx.roundRect(margin, posY, widget_width - margin * 2, H, H * 0.5);\n                } else {\n                    ctx.rect(margin, posY, widget_width - margin * 2, H);\n                }\n                ctx.fill();\n                if (show_text) {\n                    if (!w.disabled) ctx.stroke();\n                    ctx.save();\n                    ctx.beginPath();\n                    ctx.rect(margin, posY, widget_width - margin * 2, H);\n                    ctx.clip();\n\n                    // ctx.stroke();\n                    ctx.fillStyle = secondary_text_color;\n                    if (w.name != null) {\n                        ctx.fillText(w.name, margin * 2, y + H * 0.7);\n                    }\n                    ctx.fillStyle = text_color;\n                    ctx.textAlign = \"right\";\n                    ctx.fillText(String(w.value)\n                        .substr(0, 30), widget_width - margin * 2, y + H * 0.7); // 30 chars max\n                    ctx.restore();\n                }\n                break;\n            default:\n                if (w.draw) {\n                    w.draw(ctx, node, widget_width, y, H);\n                }\n                break;\n        }\n        posY += (w.computeSize ? w.computeSize(widget_width)[1] : H) + 4;\n        ctx.globalAlpha = this.editor_alpha;\n    }\n    ctx.restore();\n    ctx.textAlign = \"left\";\n};\n\n/**\n * process an event on widgets\n * @method processNodeWidgets\n * */\nLGraphCanvas.prototype.processNodeWidgets = function (\n    node,\n    pos,\n    event,\n    active_widget,\n) {\n    if (!node.widgets || !node.widgets.length) {\n        return null;\n    }\n\n    const x = pos[0] - node.pos[0];\n    const y = pos[1] - node.pos[1];\n    const width = node.size[0];\n    const that = this;\n    const ref_window = this.getCanvasWindow();\n\n    for (let i = 0; i < node.widgets.length; ++i) {\n        var w = node.widgets[i];\n        if (!w || w.disabled) continue;\n        const widget_height = w.computeSize ? w.computeSize(width)[1] : LiteGraph.NODE_WIDGET_HEIGHT;\n        const widget_width = w.width || width;\n        // outside\n        if (w != active_widget\n            && (x < 6 || x > widget_width - 12 || y < w.last_y || y > w.last_y + widget_height)) {\n            continue;\n        }\n\n        var old_value = w.value;\n\n        // if ( w == active_widget || (x > 6 && x < widget_width - 12 && y > w.last_y && y <\n        // w.last_y + widget_height) ) { inside widget\n        switch (w.type) {\n            case \"button\":\n                if (event.type === \"mousemove\") {\n                    break;\n                }\n                if (w.callback) {\n                    setTimeout(() => {\n                        w.callback(w, that, node, pos, event);\n                    }, 20);\n                }\n                w.clicked = true;\n                this.dirty_canvas = true;\n                break;\n            case \"slider\":\n                var range = w.options.max - w.options.min;\n                var nvalue = Math.clamp((x - 15) / (widget_width - 30), 0, 1);\n                w.value = w.options.min + (w.options.max - w.options.min) * nvalue;\n                if (w.callback) {\n                    setTimeout(() => {\n                        inner_value_change(w, w.value);\n                    }, 20);\n                }\n                this.dirty_canvas = true;\n                break;\n            case \"number\":\n            case \"combo\":\n                var old_value = w.value;\n                if (event.type == \"mousemove\" && w.type == \"number\") {\n                    w.value += event.deltaX * 0.1 * (w.options.step || 1);\n                    if (w.options.min != null && w.value < w.options.min) {\n                        w.value = w.options.min;\n                    }\n                    if (w.options.max != null && w.value > w.options.max) {\n                        w.value = w.options.max;\n                    }\n                } else if (event.type == \"mousedown\") {\n                    var { values } = w.options;\n                    if (values && values.constructor === Function) {\n                        values = w.options.values(w, node);\n                    }\n                    var values_list = null;\n\n                    if (w.type != \"number\") values_list = values.constructor === Array ? values : Object.keys(values);\n\n                    var delta = x < 40 ? -1 : x > widget_width - 40 ? 1 : 0;\n                    if (w.type == \"number\") {\n                        w.value += delta * 0.1 * (w.options.step || 1);\n                        if (w.options.min != null && w.value < w.options.min) {\n                            w.value = w.options.min;\n                        }\n                        if (w.options.max != null && w.value > w.options.max) {\n                            w.value = w.options.max;\n                        }\n                    } else if (delta) { // clicked in arrow, used for combos\n                        let index = -1;\n                        this.last_mouseclick = 0; // avoids dobl click event\n                        if (values.constructor === Object) {\n                            index = values_list.indexOf(String(w.value)) + delta;\n                        } else {\n                            index = values_list.indexOf(w.value) + delta;\n                        }\n                        if (index >= values_list.length) {\n                            index = values_list.length - 1;\n                        }\n                        if (index < 0) {\n                            index = 0;\n                        }\n                        if (values.constructor === Array) {\n                            w.value = values[index];\n                        } else {\n                            w.value = index;\n                        }\n                    } else { // combo clicked\n                        var text_values = values != values_list ? Object.values(values) : values;\n                        const menu = new LiteGraph.ContextMenu(text_values, {\n                            scale: Math.max(1, this.ds.scale),\n                            event,\n                            className: \"dark\",\n                            callback: inner_clicked.bind(w),\n                        },\n                        ref_window);\n\n                        function inner_clicked(v, option, event) {\n                            if (values != values_list) v = text_values.indexOf(v);\n                            this.value = v;\n                            inner_value_change(this, v);\n                            that.dirty_canvas = true;\n                            return false;\n                        }\n                    }\n                } // end mousedown\n                else if (event.type == \"mouseup\" && w.type == \"number\") {\n                    var delta = x < 40 ? -1 : x > widget_width - 40 ? 1 : 0;\n                    if (event.click_time < 200 && delta == 0) {\n                        this.prompt(\"Value\", w.value, function (v) {\n                            this.value = Number(v);\n                            inner_value_change(this, this.value);\n                        }.bind(w),\n                        event);\n                    }\n                }\n\n                if (old_value != w.value) {\n                    setTimeout(\n                        function () {\n                            inner_value_change(this, this.value);\n                        }.bind(w),\n                        20,\n                    );\n                }\n                this.dirty_canvas = true;\n                break;\n            case \"toggle\":\n                if (event.type == \"mousedown\") {\n                    w.value = !w.value;\n                    setTimeout(() => {\n                        inner_value_change(w, w.value);\n                    }, 20);\n                }\n                break;\n            case \"string\":\n            case \"text\":\n                if (event.type == \"mousedown\") {\n                    this.prompt(\"Value\", w.value, function (v) {\n                        this.value = v;\n                        inner_value_change(this, v);\n                    }.bind(w),\n                    event, w.options ? w.options.multiline : false);\n                }\n                break;\n            default:\n                if (w.mouse) {\n                    this.dirty_canvas = w.mouse(event, [x, y], node);\n                }\n                break;\n        } // end switch\n\n        // value changed\n        if (old_value != w.value) {\n            if (node.onWidgetChanged) node.onWidgetChanged(w.name, w.value, old_value, w);\n            node.graph._version++;\n        }\n\n        return w;\n    }// end for\n\n    function inner_value_change(widget, value) {\n        widget.value = value;\n        if (widget.options && widget.options.property && node.properties[widget.options.property] !== undefined) {\n            node.setProperty(widget.options.property, value);\n        }\n        if (widget.callback) {\n            widget.callback(widget.value, that, node, pos, event);\n        }\n    }\n\n    return null;\n};\n\n/**\n * draws every group area in the background\n * @method drawGroups\n * */\nLGraphCanvas.prototype.drawGroups = function (canvas, ctx) {\n    if (!this.graph) {\n        return;\n    }\n\n    const groups = this.graph._groups;\n\n    ctx.save();\n    ctx.globalAlpha = 0.5 * this.editor_alpha;\n\n    for (let i = 0; i < groups.length; ++i) {\n        const group = groups[i];\n\n        if (!overlapBounding(this.visible_area, group._bounding)) {\n            continue;\n        } // out of the visible area\n\n        ctx.fillStyle = group.color || \"#335\";\n        ctx.strokeStyle = group.color || \"#335\";\n        const pos = group._pos;\n        const size = group._size;\n        ctx.globalAlpha = 0.25 * this.editor_alpha;\n        ctx.beginPath();\n        ctx.rect(pos[0] + 0.5, pos[1] + 0.5, size[0], size[1]);\n        ctx.fill();\n        ctx.globalAlpha = this.editor_alpha;\n        ctx.stroke();\n\n        ctx.beginPath();\n        ctx.moveTo(pos[0] + size[0], pos[1] + size[1]);\n        ctx.lineTo(pos[0] + size[0] - 10, pos[1] + size[1]);\n        ctx.lineTo(pos[0] + size[0], pos[1] + size[1] - 10);\n        ctx.fill();\n\n        const font_size = group.font_size || LiteGraph.DEFAULT_GROUP_FONT_SIZE;\n        ctx.font = `${font_size}px Arial`;\n        ctx.fillText(group.title, pos[0] + 4, pos[1] + font_size);\n    }\n\n    ctx.restore();\n};\n\nLGraphCanvas.prototype.adjustNodesSize = function () {\n    const nodes = this.graph._nodes;\n    for (let i = 0; i < nodes.length; ++i) {\n        nodes[i].size = nodes[i].computeSize();\n    }\n    this.setDirty(true, true);\n};\n\n/**\n * resizes the canvas to a given size, if no size is passed, then it tries to fill the\n * parentNode\n * @method resize\n * */\nLGraphCanvas.prototype.resize = function (width, height) {\n    if (!width && !height) {\n        const parent = this.canvas.parentNode;\n        width = parent.offsetWidth;\n        height = parent.offsetHeight;\n    }\n\n    if (this.canvas.width == width && this.canvas.height == height) {\n        return;\n    }\n\n    this.canvas.width = width;\n    this.canvas.height = height;\n    this.bgcanvas.width = this.canvas.width;\n    this.bgcanvas.height = this.canvas.height;\n    this.setDirty(true, true);\n};\n\n/**\n * switches to live mode (node shapes are not rendered, only the content)\n * this feature was designed when graphs where meant to create user interfaces\n * @method switchLiveMode\n * */\nLGraphCanvas.prototype.switchLiveMode = function (transition) {\n    if (!transition) {\n        this.live_mode = !this.live_mode;\n        this.dirty_canvas = true;\n        this.dirty_bgcanvas = true;\n        return;\n    }\n\n    const self = this;\n    const delta = this.live_mode ? 1.1 : 0.9;\n    if (this.live_mode) {\n        this.live_mode = false;\n        this.editor_alpha = 0.1;\n    }\n\n    var t = setInterval(() => {\n        self.editor_alpha *= delta;\n        self.dirty_canvas = true;\n        self.dirty_bgcanvas = true;\n\n        if (delta < 1 && self.editor_alpha < 0.01) {\n            clearInterval(t);\n            if (delta < 1) {\n                self.live_mode = true;\n            }\n        }\n        if (delta > 1 && self.editor_alpha > 0.99) {\n            clearInterval(t);\n            self.editor_alpha = 1;\n        }\n    }, 1);\n};\n\nLGraphCanvas.prototype.onNodeSelectionChange = function (node) {\n    // disabled\n};\n\nLGraphCanvas.prototype.touchHandler = function (event) {\n    // alert(\"foo\");\n    const touches = event.changedTouches;\n    const first = touches[0];\n    let type = \"\";\n\n    switch (event.type) {\n        case \"touchstart\":\n            type = \"mousedown\";\n            break;\n        case \"touchmove\":\n            type = \"mousemove\";\n            break;\n        case \"touchend\":\n            type = \"mouseup\";\n            break;\n        default:\n            return;\n    }\n\n    // initMouseEvent(type, canBubble, cancelable, view, clickCount,\n    //           screenX, screenY, clientX, clientY, ctrlKey,\n    //           altKey, shiftKey, metaKey, button, relatedTarget);\n\n    const window = this.getCanvasWindow();\n    const { document } = window;\n\n    const simulatedEvent = document.createEvent(\"MouseEvent\");\n    simulatedEvent.initMouseEvent(\n        type,\n        true,\n        true,\n        window,\n        1,\n        first.screenX,\n        first.screenY,\n        first.clientX,\n        first.clientY,\n        false,\n        false,\n        false,\n        false,\n        0 /* left */,\n        null,\n    );\n    first.target.dispatchEvent(simulatedEvent);\n    event.preventDefault();\n};\n\n/* CONTEXT MENU ******************* */\n\nLGraphCanvas.onGroupAdd = function (info, entry, mouse_event) {\n    const canvas = LGraphCanvas.active_canvas;\n    const ref_window = canvas.getCanvasWindow();\n\n    const group = new LiteGraph.LGraphGroup();\n    group.pos = canvas.convertEventToCanvasOffset(mouse_event);\n    canvas.graph.add(group);\n};\n\nLGraphCanvas.onMenuAdd = function (node, options, e, prev_menu, callback) {\n    const canvas = LGraphCanvas.active_canvas;\n    const ref_window = canvas.getCanvasWindow();\n    const { graph } = canvas;\n    if (!graph) return;\n\n    function inner_onMenuAdded(base_category, prev_menu) {\n        const categories = LiteGraph.getNodeTypesCategories(canvas.filter || graph.filter)\n            .filter((category) => category.startsWith(base_category));\n        const entries = [];\n\n        categories.map((category) => {\n            if (!category) {\n                return;\n            }\n\n            const base_category_regex = new RegExp(`^(${base_category})`);\n            const category_name = category.replace(base_category_regex, \"\")\n                .split(\"/\")[0];\n            const category_path = base_category === \"\" ? `${category_name}/` : `${base_category + category_name}/`;\n\n            let name = category_name;\n            if (name.indexOf(\"::\") != -1) // in case it has a namespace like \"shader::math/rand\" it hides the\n            // namespace\n            {\n                name = name.split(\"::\")[1];\n            }\n\n            const index = entries.findIndex((entry) => entry.value === category_path);\n            if (index === -1) {\n                entries.push({\n                    value: category_path,\n                    content: name,\n                    has_submenu: true,\n                    callback(value, event, mouseEvent, contextMenu) {\n                        inner_onMenuAdded(value.value, contextMenu);\n                    },\n                });\n            }\n        });\n\n        const nodes = LiteGraph.getNodeTypesInCategory(base_category.slice(0, -1), canvas.filter || graph.filter);\n        nodes.map((node) => {\n            if (node.skip_list) return;\n\n            const entry = {\n                value: node.type,\n                content: node.title,\n                has_submenu: false,\n                callback(value, event, mouseEvent, contextMenu) {\n                    const first_event = contextMenu.getFirstEvent();\n                    canvas.graph.beforeChange();\n                    const node = LiteGraph.createNode(value.value);\n                    if (node) {\n                        node.pos = canvas.convertEventToCanvasOffset(first_event);\n                        canvas.graph.add(node);\n                    }\n                    if (callback) callback(node);\n                    canvas.graph.afterChange();\n                },\n            };\n\n            entries.push(entry);\n        });\n\n        new LiteGraph.ContextMenu(entries, {\n            event: e,\n            parentMenu: prev_menu,\n        }, ref_window);\n    }\n\n    inner_onMenuAdded(\"\", prev_menu);\n    return false;\n};\n\nLGraphCanvas.onMenuCollapseAll = function () {\n};\n\nLGraphCanvas.onMenuNodeEdit = function () {\n};\n\nLGraphCanvas.showMenuNodeOptionalInputs = function (\n    v,\n    options,\n    e,\n    prev_menu,\n    node,\n) {\n    if (!node) {\n        return;\n    }\n\n    const that = this;\n    const canvas = LGraphCanvas.active_canvas;\n    const ref_window = canvas.getCanvasWindow();\n\n    var options = node.optional_inputs;\n    if (node.onGetInputs) {\n        options = node.onGetInputs();\n    }\n\n    let entries = [];\n    if (options) {\n        for (let i = 0; i < options.length; i++) {\n            const entry = options[i];\n            if (!entry) {\n                entries.push(null);\n                continue;\n            }\n            let label = entry[0];\n            if (entry[2] && entry[2].label) {\n                label = entry[2].label;\n            }\n            const data = {\n                content: label,\n                value: entry,\n            };\n            if (entry[1] == LiteGraph.ACTION) {\n                data.className = \"event\";\n            }\n            entries.push(data);\n        }\n    }\n\n    if (this.onMenuNodeInputs) {\n        entries = this.onMenuNodeInputs(entries);\n    }\n\n    if (!entries.length) {\n        console.log(\"no input entries\");\n        return;\n    }\n\n    const menu = new LiteGraph.ContextMenu(\n        entries,\n        {\n            event: e,\n            callback: inner_clicked,\n            parentMenu: prev_menu,\n            node,\n        },\n        ref_window,\n    );\n\n    function inner_clicked(v, e, prev) {\n        if (!node) {\n            return;\n        }\n\n        if (v.callback) {\n            v.callback.call(that, node, v, e, prev);\n        }\n\n        if (v.value) {\n            node.graph.beforeChange();\n            node.addInput(v.value[0], v.value[1], v.value[2]);\n            node.setDirtyCanvas(true, true);\n            node.graph.afterChange();\n        }\n    }\n\n    return false;\n};\n\nLGraphCanvas.showMenuNodeOptionalOutputs = function (\n    v,\n    options,\n    e,\n    prev_menu,\n    node,\n) {\n    if (!node) {\n        return;\n    }\n\n    const that = this;\n    const canvas = LGraphCanvas.active_canvas;\n    const ref_window = canvas.getCanvasWindow();\n\n    var options = node.optional_outputs;\n    if (node.onGetOutputs) {\n        options = node.onGetOutputs();\n    }\n\n    let entries = [];\n    if (options) {\n        for (let i = 0; i < options.length; i++) {\n            const entry = options[i];\n            if (!entry) {\n                // separator?\n                entries.push(null);\n                continue;\n            }\n\n            if (\n                node.flags\n                && node.flags.skip_repeated_outputs\n                && node.findOutputSlot(entry[0]) != -1\n            ) {\n                continue;\n            } // skip the ones already on\n            let label = entry[0];\n            if (entry[2] && entry[2].label) {\n                label = entry[2].label;\n            }\n            const data = {\n                content: label,\n                value: entry,\n            };\n            if (entry[1] == LiteGraph.EVENT) {\n                data.className = \"event\";\n            }\n            entries.push(data);\n        }\n    }\n\n    if (this.onMenuNodeOutputs) {\n        entries = this.onMenuNodeOutputs(entries);\n    }\n\n    if (!entries.length) {\n        return;\n    }\n\n    const menu = new LiteGraph.ContextMenu(\n        entries,\n        {\n            event: e,\n            callback: inner_clicked,\n            parentMenu: prev_menu,\n            node,\n        },\n        ref_window,\n    );\n\n    function inner_clicked(v, e, prev) {\n        if (!node) {\n            return;\n        }\n\n        if (v.callback) {\n            v.callback.call(that, node, v, e, prev);\n        }\n\n        if (!v.value) {\n            return;\n        }\n\n        const value = v.value[1];\n\n        if (\n            value\n            && (value.constructor === Object || value.constructor === Array)\n        ) {\n            // submenu why?\n            const entries = [];\n            for (const i in value) {\n                entries.push({\n                    content: i,\n                    value: value[i],\n                });\n            }\n            new LiteGraph.ContextMenu(entries, {\n                event: e,\n                callback: inner_clicked,\n                parentMenu: prev_menu,\n                node,\n            });\n            return false;\n        }\n        node.graph.beforeChange();\n        node.addOutput(v.value[0], v.value[1], v.value[2]);\n        node.setDirtyCanvas(true, true);\n        node.graph.afterChange();\n    }\n\n    return false;\n};\n\nLGraphCanvas.onShowMenuNodeProperties = function (\n    value,\n    options,\n    e,\n    prev_menu,\n    node,\n) {\n    if (!node || !node.properties) {\n        return;\n    }\n\n    const that = this;\n    const canvas = LGraphCanvas.active_canvas;\n    const ref_window = canvas.getCanvasWindow();\n\n    const entries = [];\n    for (const i in node.properties) {\n        var value = node.properties[i] !== undefined ? node.properties[i] : \" \";\n        if (typeof value === \"object\") value = JSON.stringify(value);\n        const info = node.getPropertyInfo(i);\n        if (info.type == \"enum\" || info.type == \"combo\") value = LGraphCanvas.getPropertyPrintableValue(value, info.values);\n\n        // value could contain invalid html characters, clean that\n        value = LGraphCanvas.decodeHTML(value);\n        entries.push({\n            content:\n                `<span class=\"property_name\">${\n                    info.label ? info.label : i\n                }</span>`\n                + `<span class=\"property_value\">${\n                    value\n                }</span>`,\n            value: i,\n        });\n    }\n    if (!entries.length) {\n        return;\n    }\n\n    const menu = new LiteGraph.ContextMenu(\n        entries,\n        {\n            event: e,\n            callback: inner_clicked,\n            parentMenu: prev_menu,\n            allow_html: true,\n            node,\n        },\n        ref_window,\n    );\n\n    function inner_clicked(v, options, e, prev) {\n        if (!node) {\n            return;\n        }\n        const rect = this.getBoundingClientRect();\n        canvas.showEditPropertyValue(node, v.value, {\n            position: [rect.left, rect.top],\n        });\n    }\n\n    return false;\n};\n\nLGraphCanvas.decodeHTML = function (str) {\n    const e = document.createElement(\"div\");\n    e.innerText = str;\n    return e.innerHTML;\n};\n\nLGraphCanvas.onResizeNode = function (value, options, e, menu, node) {\n    if (!node) {\n        return;\n    }\n    node.size = node.computeSize();\n    if (node.onResize) node.onResize(node.size);\n    node.setDirtyCanvas(true, true);\n};\n\nLGraphCanvas.prototype.showLinkMenu = function (link, e) {\n    const that = this;\n    console.log(link);\n    const options = [\"Add Node\", null, \"Delete\"];\n    const menu = new LiteGraph.ContextMenu(options, {\n        event: e,\n        title: link.data != null ? link.data.constructor.name : null,\n        callback: inner_clicked,\n    });\n\n    function inner_clicked(v, options, e) {\n        switch (v) {\n            case \"Add Node\":\n                LGraphCanvas.onMenuAdd(null, null, e, menu, (node) => {\n                    console.log(\"node autoconnect\");\n                    const node_left = that.graph.getNodeById(link.origin_id);\n                    const node_right = that.graph.getNodeById(link.target_id);\n                    if (!node.inputs || !node.inputs.length || !node.outputs || !node.outputs.length) return;\n                    if (node_left.outputs[link.origin_slot].type == node.inputs[0].type && node.outputs[0].type == node_right.inputs[0].type) {\n                        node_left.connect(link.origin_slot, node, 0);\n                        node.connect(0, node_right, link.target_slot);\n                        node.pos[0] -= node.size[0] * 0.5;\n                    }\n                });\n                break;\n            case \"Delete\":\n                that.graph.removeLink(link.id);\n                break;\n            default:\n        }\n    }\n\n    return false;\n};\n\nLGraphCanvas.onShowPropertyEditor = function (item, options, e, menu, node) {\n    const input_html = \"\";\n    const property = item.property || \"title\";\n    const value = node[property];\n\n    const dialog = document.createElement(\"div\");\n    dialog.className = \"graphdialog\";\n    dialog.innerHTML = \"<span class='name'></span><input autofocus type='text' class='value'/><button>OK</button>\";\n    // dialog.innerHTML = \"<span class='name'></span><textarea autofocus\n    // class='value'></textarea><button>OK</button>\";\n    const title = dialog.querySelector(\".name\");\n    title.innerText = property;\n    const input = dialog.querySelector(\".value\");\n    if (input) {\n        input.value = value;\n        input.addEventListener(\"blur\", function (e) {\n            this.focus();\n        });\n        input.addEventListener(\"keydown\", (e) => {\n            if (e.keyCode != 13 && e.target.localName != \"textarea\") {\n                return;\n            }\n            inner();\n            e.preventDefault();\n            e.stopPropagation();\n        });\n    }\n\n    const graphcanvas = LGraphCanvas.active_canvas;\n    const { canvas } = graphcanvas;\n\n    const rect = canvas.getBoundingClientRect();\n    let offsetx = -20;\n    let offsety = -20;\n    if (rect) {\n        offsetx -= rect.left;\n        offsety -= rect.top;\n    }\n\n    if (event) {\n        dialog.style.left = `${event.clientX + offsetx}px`;\n        dialog.style.top = `${event.clientY + offsety}px`;\n    } else {\n        dialog.style.left = `${canvas.width * 0.5 + offsetx}px`;\n        dialog.style.top = `${canvas.height * 0.5 + offsety}px`;\n    }\n\n    const button = dialog.querySelector(\"button\");\n    button.addEventListener(\"click\", inner);\n    canvas.parentNode.appendChild(dialog);\n\n    function inner() {\n        setValue(input.value);\n    }\n\n    function setValue(value) {\n        if (item.type == \"Number\") {\n            value = Number(value);\n        } else if (item.type == \"Boolean\") {\n            value = Boolean(value);\n        }\n        node[property] = value;\n        if (dialog.parentNode) {\n            dialog.parentNode.removeChild(dialog);\n        }\n        node.setDirtyCanvas(true, true);\n    }\n};\n\nLGraphCanvas.prototype.prompt = function (title, value, callback, event, multiline) {\n    const that = this;\n    const input_html = \"\";\n    title = title || \"\";\n\n    let modified = false;\n\n    const dialog = document.createElement(\"div\");\n    dialog.className = \"graphdialog rounded\";\n    if (multiline) {\n        dialog.innerHTML = \"<span class='name'></span> <textarea autofocus class='value'></textarea><button class='rounded'>OK</button>\";\n    } else {\n        dialog.innerHTML = \"<span class='name'></span> <input autofocus type='text' class='value'/><button class='rounded'>OK</button>\";\n    }\n    dialog.close = function () {\n        that.prompt_box = null;\n        if (dialog.parentNode) {\n            dialog.parentNode.removeChild(dialog);\n        }\n    };\n\n    if (this.ds.scale > 1) {\n        dialog.style.transform = `scale(${this.ds.scale})`;\n    }\n\n    dialog.addEventListener(\"mouseleave\", (e) => {\n        if (!modified) {\n            dialog.close();\n        }\n    });\n\n    if (that.prompt_box) {\n        that.prompt_box.close();\n    }\n    that.prompt_box = dialog;\n\n    const first = null;\n    const timeout = null;\n    const selected = null;\n\n    const name_element = dialog.querySelector(\".name\");\n    name_element.innerText = title;\n    const value_element = dialog.querySelector(\".value\");\n    value_element.value = value;\n\n    const input = value_element;\n    input.addEventListener(\"keydown\", function (e) {\n        modified = true;\n        if (e.keyCode == 27) {\n            // ESC\n            dialog.close();\n        } else if (e.keyCode == 13 && e.target.localName != \"textarea\") {\n            if (callback) {\n                callback(this.value);\n            }\n            dialog.close();\n        } else {\n            return;\n        }\n        e.preventDefault();\n        e.stopPropagation();\n    });\n\n    const button = dialog.querySelector(\"button\");\n    button.addEventListener(\"click\", (e) => {\n        if (callback) {\n            callback(input.value);\n        }\n        that.setDirty(true);\n        dialog.close();\n    });\n\n    const graphcanvas = LGraphCanvas.active_canvas;\n    const { canvas } = graphcanvas;\n\n    const rect = canvas.getBoundingClientRect();\n    let offsetx = -20;\n    let offsety = -20;\n    if (rect) {\n        offsetx -= rect.left;\n        offsety -= rect.top;\n    }\n\n    if (event) {\n        dialog.style.left = `${event.clientX + offsetx}px`;\n        dialog.style.top = `${event.clientY + offsety}px`;\n    } else {\n        dialog.style.left = `${canvas.width * 0.5 + offsetx}px`;\n        dialog.style.top = `${canvas.height * 0.5 + offsety}px`;\n    }\n\n    canvas.parentNode.appendChild(dialog);\n    setTimeout(() => {\n        input.focus();\n    }, 10);\n\n    return dialog;\n};\n\nLGraphCanvas.search_limit = -1;\nLGraphCanvas.prototype.showSearchBox = function (event) {\n    const that = this;\n    const input_html = \"\";\n    const graphcanvas = LGraphCanvas.active_canvas;\n    const { canvas } = graphcanvas;\n    const root_document = canvas.ownerDocument || document;\n\n    const dialog = document.createElement(\"div\");\n    dialog.className = \"litegraph litesearchbox graphdialog rounded\";\n    dialog.innerHTML = \"<span class='name'>Search</span> <input autofocus type='text' class='value rounded'/><div class='helper'></div>\";\n    dialog.close = function () {\n        that.search_box = null;\n        root_document.body.focus();\n        root_document.body.style.overflow = \"\";\n\n        setTimeout(() => {\n            that.canvas.focus();\n        }, 20); // important, if canvas loses focus keys wont be captured\n        if (dialog.parentNode) {\n            dialog.parentNode.removeChild(dialog);\n        }\n    };\n\n    let timeout_close = null;\n\n    if (this.ds.scale > 1) {\n        dialog.style.transform = `scale(${this.ds.scale})`;\n    }\n\n    dialog.addEventListener(\"mouseenter\", (e) => {\n        if (timeout_close) {\n            clearTimeout(timeout_close);\n            timeout_close = null;\n        }\n    });\n\n    dialog.addEventListener(\"mouseleave\", (e) => {\n        // dialog.close();\n        timeout_close = setTimeout(() => {\n            dialog.close();\n        }, 500);\n    });\n\n    if (that.search_box) {\n        that.search_box.close();\n    }\n    that.search_box = dialog;\n\n    const helper = dialog.querySelector(\".helper\");\n\n    let first = null;\n    let timeout = null;\n    let selected = null;\n\n    const input = dialog.querySelector(\"input\");\n    if (input) {\n        input.addEventListener(\"blur\", function (e) {\n            this.focus();\n        });\n        input.addEventListener(\"keydown\", (e) => {\n            if (e.keyCode == 38) {\n                // UP\n                changeSelection(false);\n            } else if (e.keyCode == 40) {\n                // DOWN\n                changeSelection(true);\n            } else if (e.keyCode == 27) {\n                // ESC\n                dialog.close();\n            } else if (e.keyCode == 13) {\n                if (selected) {\n                    select(selected.innerHTML);\n                } else if (first) {\n                    select(first);\n                } else {\n                    dialog.close();\n                }\n            } else {\n                if (timeout) {\n                    clearInterval(timeout);\n                }\n                timeout = setTimeout(refreshHelper, 10);\n                return;\n            }\n            e.preventDefault();\n            e.stopPropagation();\n            e.stopImmediatePropagation();\n            return true;\n        });\n    }\n\n    if (root_document.fullscreenElement) {\n        root_document.fullscreenElement.appendChild(dialog);\n    } else {\n        root_document.body.appendChild(dialog);\n        root_document.body.style.overflow = \"hidden\";\n    }\n\n    // compute best position\n    const rect = canvas.getBoundingClientRect();\n\n    const left = (event ? event.clientX : (rect.left + rect.width * 0.5)) - 80;\n    const top = (event ? event.clientY : (rect.top + rect.height * 0.5)) - 20;\n    dialog.style.left = `${left}px`;\n    dialog.style.top = `${top}px`;\n\n    // To avoid out of screen problems\n    if (event.layerY > (rect.height - 200)) {\n        helper.style.maxHeight = `${rect.height - event.layerY - 20}px`;\n    }\n\n    /*\n    var offsetx = -20;\n    var offsety = -20;\n    if (rect) {\n        offsetx -= rect.left;\n        offsety -= rect.top;\n    }\n\n    if (event) {\n        dialog.style.left = event.clientX + offsetx + \"px\";\n        dialog.style.top = event.clientY + offsety + \"px\";\n    } else {\n        dialog.style.left = canvas.width * 0.5 + offsetx + \"px\";\n        dialog.style.top = canvas.height * 0.5 + offsety + \"px\";\n    }\n    canvas.parentNode.appendChild(dialog);\n*/\n\n    input.focus();\n\n    function select(name) {\n        if (name) {\n            if (that.onSearchBoxSelection) {\n                that.onSearchBoxSelection(name, event, graphcanvas);\n            } else {\n                const extra = LiteGraph.searchbox_extras[name.toLowerCase()];\n                if (extra) {\n                    name = extra.type;\n                }\n\n                graphcanvas.graph.beforeChange();\n                const node = LiteGraph.createNode(name);\n                if (node) {\n                    node.pos = graphcanvas.convertEventToCanvasOffset(\n                        event,\n                    );\n                    graphcanvas.graph.add(node);\n                }\n\n                if (extra && extra.data) {\n                    if (extra.data.properties) {\n                        for (var i in extra.data.properties) {\n                            node.addProperty(i, extra.data.properties[i]);\n                        }\n                    }\n                    if (extra.data.inputs) {\n                        node.inputs = [];\n                        for (var i in extra.data.inputs) {\n                            node.addOutput(\n                                extra.data.inputs[i][0],\n                                extra.data.inputs[i][1],\n                            );\n                        }\n                    }\n                    if (extra.data.outputs) {\n                        node.outputs = [];\n                        for (var i in extra.data.outputs) {\n                            node.addOutput(\n                                extra.data.outputs[i][0],\n                                extra.data.outputs[i][1],\n                            );\n                        }\n                    }\n                    if (extra.data.title) {\n                        node.title = extra.data.title;\n                    }\n                    if (extra.data.json) {\n                        node.configure(extra.data.json);\n                    }\n\n                    graphcanvas.graph.afterChange();\n                }\n            }\n        }\n\n        dialog.close();\n    }\n\n    function changeSelection(forward) {\n        const prev = selected;\n        if (selected) {\n            selected.classList.remove(\"selected\");\n        }\n        if (!selected) {\n            selected = forward\n                ? helper.childNodes[0]\n                : helper.childNodes[helper.childNodes.length];\n        } else {\n            selected = forward\n                ? selected.nextSibling\n                : selected.previousSibling;\n            if (!selected) {\n                selected = prev;\n            }\n        }\n        if (!selected) {\n            return;\n        }\n        selected.classList.add(\"selected\");\n        selected.scrollIntoView({\n            block: \"end\",\n            behavior: \"smooth\",\n        });\n    }\n\n    function refreshHelper() {\n        timeout = null;\n        let str = input.value;\n        first = null;\n        helper.innerHTML = \"\";\n        if (!str) {\n            return;\n        }\n\n        if (that.onSearchBox) {\n            const list = that.onSearchBox(helper, str, graphcanvas);\n            if (list) {\n                for (var i = 0; i < list.length; ++i) {\n                    addResult(list[i]);\n                }\n            }\n        } else {\n            let c = 0;\n            str = str.toLowerCase();\n            const filter = graphcanvas.filter || graphcanvas.graph.filter;\n\n            // extras\n            for (var i in LiteGraph.searchbox_extras) {\n                const extra = LiteGraph.searchbox_extras[i];\n                if (extra.desc.toLowerCase()\n                    .indexOf(str) === -1) {\n                    continue;\n                }\n                const ctor = LiteGraph.registered_node_types[extra.type];\n                if (ctor && ctor.filter != filter) continue;\n                addResult(extra.desc, \"searchbox_extra\");\n                if (LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit) {\n                    break;\n                }\n            }\n\n            var filtered = null;\n            if (Array.prototype.filter) { // filter supported\n                const keys = Object.keys(LiteGraph.registered_node_types); // types\n                var filtered = keys.filter(inner_test_filter);\n            } else {\n                filtered = [];\n                for (var i in LiteGraph.registered_node_types) {\n                    if (inner_test_filter(i)) filtered.push(i);\n                }\n            }\n\n            for (var i = 0; i < filtered.length; i++) {\n                addResult(filtered[i]);\n                if (LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit) {\n                    break;\n                }\n            }\n\n            function inner_test_filter(type) {\n                const ctor = LiteGraph.registered_node_types[type];\n                if (filter && ctor.filter != filter) return false;\n                return type.toLowerCase()\n                    .indexOf(str) !== -1;\n            }\n        }\n\n        function addResult(type, className) {\n            const help = document.createElement(\"div\");\n            if (!first) {\n                first = type;\n            }\n            help.innerText = type;\n            help.dataset.type = escape(type);\n            help.className = \"litegraph lite-search-item\";\n            if (className) {\n                help.className += ` ${className}`;\n            }\n            help.addEventListener(\"click\", function (e) {\n                select(unescape(this.dataset.type));\n            });\n            helper.appendChild(help);\n        }\n    }\n\n    return dialog;\n};\n\nLGraphCanvas.prototype.showEditPropertyValue = function (node, property, options) {\n    if (!node || node.properties[property] === undefined) {\n        return;\n    }\n\n    options = options || {};\n    const that = this;\n\n    const info = node.getPropertyInfo(property);\n    const { type } = info;\n\n    let input_html = \"\";\n\n    if (type == \"string\" || type == \"number\" || type == \"array\" || type == \"object\") {\n        input_html = \"<input autofocus type='text' class='value'/>\";\n    } else if ((type == \"enum\" || type == \"combo\") && info.values) {\n        input_html = \"<select autofocus type='text' class='value'>\";\n        for (const i in info.values) {\n            var v = i;\n            if (info.values.constructor === Array) v = info.values[i];\n\n            input_html\n                += `<option value=\"${\n                    v\n                }\" ${\n                    v == node.properties[property] ? \"selected\" : \"\"\n                }>${\n                    info.values[i]\n                }</option>`;\n        }\n        input_html += \"</select>\";\n    } else if (type == \"boolean\") {\n        input_html = `<input autofocus type=\"checkbox\" class=\"value\" ${\n            node.properties[property] ? \"checked\" : \"\"\n        }/>`;\n    } else {\n        console.warn(`unknown type: ${type}`);\n        return;\n    }\n\n    const dialog = this.createDialog(\n        `<span class=\"name\">${\n            info.label ? info.label : property\n        }</span>${\n            input_html\n        }<button>OK</button>`,\n        options,\n    );\n\n    if ((type == \"enum\" || type == \"combo\") && info.values) {\n        var input = dialog.querySelector(\"select\");\n        input.addEventListener(\"change\", (e) => {\n            setValue(e.target.value);\n            // var index = e.target.value;\n            // setValue( e.options[e.selectedIndex].value );\n        });\n    } else if (type == \"boolean\") {\n        var input = dialog.querySelector(\"input\");\n        if (input) {\n            input.addEventListener(\"click\", (e) => {\n                setValue(!!input.checked);\n            });\n        }\n    } else {\n        var input = dialog.querySelector(\"input\");\n        if (input) {\n            input.addEventListener(\"blur\", function (e) {\n                this.focus();\n            });\n\n            var v = node.properties[property] !== undefined ? node.properties[property] : \"\";\n            if (type !== \"string\") {\n                v = JSON.stringify(v);\n            }\n\n            input.value = v;\n            input.addEventListener(\"keydown\", (e) => {\n                if (e.keyCode != 13) {\n                    return;\n                }\n                inner();\n                e.preventDefault();\n                e.stopPropagation();\n            });\n        }\n    }\n\n    const button = dialog.querySelector(\"button\");\n    button.addEventListener(\"click\", inner);\n\n    function inner() {\n        setValue(input.value);\n    }\n\n    function setValue(value) {\n        if (info && info.values && info.values.constructor === Object && info.values[value] != undefined) value = info.values[value];\n\n        if (typeof node.properties[property] === \"number\") {\n            value = Number(value);\n        }\n        if (type == \"array\" || type == \"object\") {\n            value = JSON.parse(value);\n        }\n        node.properties[property] = value;\n        if (node.graph) {\n            node.graph._version++;\n        }\n        if (node.onPropertyChanged) {\n            node.onPropertyChanged(property, value);\n        }\n        if (options.onclose) options.onclose();\n        dialog.close();\n        node.setDirtyCanvas(true, true);\n    }\n\n    return dialog;\n};\n\nLGraphCanvas.prototype.createDialog = function (html, options) {\n    options = options || {};\n\n    const dialog = document.createElement(\"div\");\n    dialog.className = \"graphdialog\";\n    dialog.innerHTML = html;\n\n    const rect = this.canvas.getBoundingClientRect();\n    let offsetx = -20;\n    let offsety = -20;\n    if (rect) {\n        offsetx -= rect.left;\n        offsety -= rect.top;\n    }\n\n    if (options.position) {\n        offsetx += options.position[0];\n        offsety += options.position[1];\n    } else if (options.event) {\n        offsetx += options.event.clientX;\n        offsety += options.event.clientY;\n    } // centered\n    else {\n        offsetx += this.canvas.width * 0.5;\n        offsety += this.canvas.height * 0.5;\n    }\n\n    dialog.style.left = `${offsetx}px`;\n    dialog.style.top = `${offsety}px`;\n\n    this.canvas.parentNode.appendChild(dialog);\n\n    dialog.close = function () {\n        if (this.parentNode) {\n            this.parentNode.removeChild(this);\n        }\n    };\n\n    return dialog;\n};\n\nLGraphCanvas.prototype.createPanel = function (title, options) {\n    options = options || {};\n\n    const ref_window = options.window || window;\n    const root = document.createElement(\"div\");\n    root.className = \"litegraph dialog\";\n    root.innerHTML = \"<div class='dialog-header'><span class='dialog-title'></span></div><div class='dialog-content'></div><div class='dialog-footer'></div>\";\n    root.header = root.querySelector(\".dialog-header\");\n\n    if (options.width) root.style.width = options.width + (options.width.constructor === Number ? \"px\" : \"\");\n    if (options.height) root.style.height = options.height + (options.height.constructor === Number ? \"px\" : \"\");\n    if (options.closable) {\n        const close = document.createElement(\"span\");\n        close.innerHTML = \"&#10005;\";\n        close.classList.add(\"close\");\n        close.addEventListener(\"click\", () => {\n            root.close();\n        });\n        root.header.appendChild(close);\n    }\n    root.title_element = root.querySelector(\".dialog-title\");\n    root.title_element.innerText = title;\n    root.content = root.querySelector(\".dialog-content\");\n    root.footer = root.querySelector(\".dialog-footer\");\n\n    root.close = function () {\n        this.parentNode.removeChild(this);\n    };\n\n    root.clear = function () {\n        this.content.innerHTML = \"\";\n    };\n\n    root.addHTML = function (code, classname, on_footer) {\n        const elem = document.createElement(\"div\");\n        if (classname) elem.className = classname;\n        elem.innerHTML = code;\n        if (on_footer) {\n            root.footer.appendChild(elem);\n        } else {\n            root.content.appendChild(elem);\n        }\n        return elem;\n    };\n\n    root.addButton = function (name, callback, options) {\n        const elem = document.createElement(\"button\");\n        elem.innerText = name;\n        elem.options = options;\n        elem.classList.add(\"btn\");\n        elem.addEventListener(\"click\", callback);\n        root.footer.appendChild(elem);\n        return elem;\n    };\n\n    root.addSeparator = function () {\n        const elem = document.createElement(\"div\");\n        elem.className = \"separator\";\n        root.content.appendChild(elem);\n    };\n\n    root.addWidget = function (type, name, value, options, callback) {\n        options = options || {};\n        var str_value = String(value);\n        type = type.toLowerCase();\n        if (type == \"number\") str_value = value.toFixed(3);\n\n        const elem = document.createElement(\"div\");\n        elem.className = \"property\";\n        elem.innerHTML = \"<span class='property_name'></span><span class='property_value'></span>\";\n        elem.querySelector(\".property_name\").innerText = name;\n        const value_element = elem.querySelector(\".property_value\");\n        value_element.innerText = str_value;\n        elem.dataset.property = name;\n        elem.dataset.type = options.type || type;\n        elem.options = options;\n        elem.value = value;\n\n        // if( type == \"code\" )\n        //\telem.addEventListener(\"click\", function(){ inner_showCodePad( node,\n        // this.dataset[\"property\"] ); });\n        if (type == \"boolean\") {\n            elem.classList.add(\"boolean\");\n            if (value) elem.classList.add(\"bool-on\");\n            elem.addEventListener(\"click\", function () {\n                // var v = node.properties[this.dataset[\"property\"]];\n                // node.setProperty(this.dataset[\"property\"],!v); this.innerText = v ? \"true\" :\n                // \"false\";\n                const propname = this.dataset.property;\n                this.value = !this.value;\n                this.classList.toggle(\"bool-on\");\n                this.querySelector(\".property_value\").innerText = this.value ? \"true\" : \"false\";\n                innerChange(propname, this.value);\n            });\n        } else if (type == \"string\" || type == \"number\") {\n            value_element.setAttribute(\"contenteditable\", true);\n            value_element.addEventListener(\"keydown\", function (e) {\n                if (e.code == \"Enter\") {\n                    e.preventDefault();\n                    this.blur();\n                }\n            });\n            value_element.addEventListener(\"blur\", function () {\n                let v = this.innerText;\n                const propname = this.parentNode.dataset.property;\n                const proptype = this.parentNode.dataset.type;\n                if (proptype == \"number\") v = Number(v);\n                innerChange(propname, v);\n            });\n        } else if (type == \"enum\" || type == \"combo\") var str_value = LGraphCanvas.getPropertyPrintableValue(value, options.values);\n        value_element.innerText = str_value;\n\n        value_element.addEventListener(\"click\", function (event) {\n            const values = options.values || [];\n            const propname = this.parentNode.dataset.property;\n            const elem_that = this;\n            const menu = new LiteGraph.ContextMenu(values, {\n                event,\n                className: \"dark\",\n                callback: inner_clicked,\n            },\n            ref_window);\n\n            function inner_clicked(v, option, event) {\n                // node.setProperty(propname,v);\n                // graphcanvas.dirty_canvas = true;\n                elem_that.innerText = v;\n                innerChange(propname, v);\n                return false;\n            }\n        });\n\n        root.content.appendChild(elem);\n\n        function innerChange(name, value) {\n            console.log(\"change\", name, value);\n            // that.dirty_canvas = true;\n            if (options.callback) options.callback(name, value);\n            if (callback) callback(name, value);\n        }\n\n        return elem;\n    };\n\n    return root;\n};\n\nLGraphCanvas.getPropertyPrintableValue = function (value, values) {\n    if (!values) return String(value);\n\n    if (values.constructor === Array) {\n        return String(value);\n    }\n\n    if (values.constructor === Object) {\n        let desc_value = \"\";\n        for (const k in values) {\n            if (values[k] != value) continue;\n            desc_value = k;\n            break;\n        }\n        return `${String(value)} (${desc_value})`;\n    }\n};\n\nLGraphCanvas.prototype.showShowNodePanel = function (node) {\n    window.SELECTED_NODE = node;\n    let panel = document.querySelector(\"#node-panel\");\n    if (panel) panel.close();\n    const ref_window = this.getCanvasWindow();\n    panel = this.createPanel(node.title || \"\", {\n        closable: true,\n        window: ref_window,\n    });\n    panel.id = \"node-panel\";\n    panel.node = node;\n    panel.classList.add(\"settings\");\n    const that = this;\n    const graphcanvas = this;\n\n    function inner_refresh() {\n        panel.content.innerHTML = \"\"; // clear\n        panel.addHTML(`<span class=\"node_type\">${node.type}</span><span class=\"node_desc\">${node.constructor.desc || \"\"}</span><span class=\"separator\"></span>`);\n\n        panel.addHTML(\"<h3>Properties</h3>\");\n\n        for (const i in node.properties) {\n            const value = node.properties[i];\n            const info = node.getPropertyInfo(i);\n            const type = info.type || \"string\";\n\n            // in case the user wants control over the side panel widget\n            if (node.onAddPropertyToPanel && node.onAddPropertyToPanel(i, panel)) continue;\n\n            panel.addWidget(info.widget || info.type, i, value, info, (name, value) => {\n                graphcanvas.graph.beforeChange(node);\n                node.setProperty(name, value);\n                graphcanvas.graph.afterChange();\n                graphcanvas.dirty_canvas = true;\n            });\n        }\n\n        panel.addSeparator();\n\n        if (node.onShowCustomPanelInfo) node.onShowCustomPanelInfo(panel);\n\n        /*\n  panel.addHTML(\"<h3>Connections</h3>\");\n  var connection_containers = panel.addHTML(\"<div class='inputs connections_side'></div><div class='outputs connections_side'></div>\",\"connections\");\n  var inputs = connection_containers.querySelector(\".inputs\");\n  var outputs = connection_containers.querySelector(\".outputs\");\n  */\n\n        panel.addButton(\"Delete\", () => {\n            if (node.block_delete) return;\n            node.graph.remove(node);\n            panel.close();\n        })\n            .classList\n            .add(\"delete\");\n    }\n\n    function inner_showCodePad(node, propname) {\n        panel.style.top = \"calc( 50% - 250px)\";\n        panel.style.left = \"calc( 50% - 400px)\";\n        panel.style.width = \"800px\";\n        panel.style.height = \"500px\";\n\n        if (window.CodeFlask) // disabled for now\n        {\n            panel.content.innerHTML = \"<div class='code'></div>\";\n            const flask = new CodeFlask(\"div.code\", { language: \"js\" });\n            flask.updateCode(node.properties[propname]);\n            flask.onUpdate((code) => {\n                node.setProperty(propname, code);\n            });\n        } else {\n            panel.content.innerHTML = \"<textarea class='code'></textarea>\";\n            var textarea = panel.content.querySelector(\"textarea\");\n            textarea.value = node.properties[propname];\n            textarea.addEventListener(\"keydown\", (e) => {\n                // console.log(e);\n                if (e.code == \"Enter\" && e.ctrlKey) {\n                    console.log(\"Assigned\");\n                    node.setProperty(propname, textarea.value);\n                }\n            });\n            textarea.style.height = \"calc(100% - 40px)\";\n        }\n        const assign = that.createButton(\"Assign\", null, () => {\n            node.setProperty(propname, textarea.value);\n        });\n        panel.content.appendChild(assign);\n        const button = that.createButton(\"Close\", null, () => {\n            panel.style.height = \"\";\n            inner_refresh();\n        });\n        button.style.float = \"right\";\n        panel.content.appendChild(button);\n    }\n\n    inner_refresh();\n\n    this.canvas.parentNode.appendChild(panel);\n};\n\nLGraphCanvas.prototype.showSubgraphPropertiesDialog = function (node) {\n    console.log(\"showing subgraph properties dialog\");\n\n    const old_panel = this.canvas.parentNode.querySelector(\".subgraph_dialog\");\n    if (old_panel) old_panel.close();\n\n    const panel = this.createPanel(\"Subgraph Inputs\", {\n        closable: true,\n        width: 500,\n    });\n    panel.node = node;\n    panel.classList.add(\"subgraph_dialog\");\n\n    function inner_refresh() {\n        panel.clear();\n\n        // show currents\n        if (node.inputs) {\n            for (let i = 0; i < node.inputs.length; ++i) {\n                const input = node.inputs[i];\n                if (input.not_subgraph_input) continue;\n                const html = \"<button>&#10005;</button> <span class='bullet_icon'></span><span class='name'></span><span class='type'></span>\";\n                const elem = panel.addHTML(html, \"subgraph_property\");\n                elem.dataset.name = input.name;\n                elem.dataset.slot = i;\n                elem.querySelector(\".name\").innerText = input.name;\n                elem.querySelector(\".type\").innerText = input.type;\n                elem.querySelector(\"button\")\n                    .addEventListener(\"click\", function (e) {\n                        node.removeInput(Number(this.parentNode.dataset.slot));\n                        inner_refresh();\n                    });\n            }\n        }\n    }\n\n    // add extra\n    const html = \" + <span class='label'>Name</span><input class='name'/><span class='label'>Type</span><input class='type'></input><button>+</button>\";\n    const elem = panel.addHTML(html, \"subgraph_property extra\", true);\n    elem.querySelector(\"button\")\n        .addEventListener(\"click\", function (e) {\n            const elem = this.parentNode;\n            const name = elem.querySelector(\".name\").value;\n            const type = elem.querySelector(\".type\").value;\n            if (!name || node.findInputSlot(name) != -1) return;\n            node.addInput(name, type);\n            elem.querySelector(\".name\").value = \"\";\n            elem.querySelector(\".type\").value = \"\";\n            inner_refresh();\n        });\n\n    inner_refresh();\n    this.canvas.parentNode.appendChild(panel);\n    return panel;\n};\n\nLGraphCanvas.prototype.checkPanels = function () {\n    if (!this.canvas) return;\n    const panels = this.canvas.parentNode.querySelectorAll(\".litegraph.dialog\");\n    for (let i = 0; i < panels.length; ++i) {\n        const panel = panels[i];\n        if (!panel.node) continue;\n        if (!panel.node.graph || panel.graph != this.graph) panel.close();\n    }\n};\n\nLGraphCanvas.onMenuNodeCollapse = function (value, options, e, menu, node) {\n    node.graph.beforeChange(node);\n    node.collapse();\n    node.graph.afterChange(node);\n};\n\nLGraphCanvas.onMenuNodePin = function (value, options, e, menu, node) {\n    node.pin();\n};\n\nLGraphCanvas.onMenuNodeMode = function (value, options, e, menu, node) {\n    new LiteGraph.ContextMenu(\n        [\"Always\", \"On Event\", \"On Trigger\", \"Never\"],\n        {\n            event: e,\n            callback: inner_clicked,\n            parentMenu: menu,\n            node,\n        },\n    );\n\n    function inner_clicked(v) {\n        if (!node) {\n            return;\n        }\n        switch (v) {\n            case \"On Event\":\n                node.mode = LiteGraph.ON_EVENT;\n                break;\n            case \"On Trigger\":\n                node.mode = LiteGraph.ON_TRIGGER;\n                break;\n            case \"Never\":\n                node.mode = LiteGraph.NEVER;\n                break;\n            case \"Always\":\n            default:\n                node.mode = LiteGraph.ALWAYS;\n                break;\n        }\n    }\n\n    return false;\n};\n\nLGraphCanvas.onMenuNodeColors = function (value, options, e, menu, node) {\n    if (!node) {\n        throw \"no node for color\";\n    }\n\n    const values = [];\n    values.push({\n        value: null,\n        content:\n            \"<span style='display: block; padding-left: 4px;'>No color</span>\",\n    });\n\n    for (const i in LGraphCanvas.node_colors) {\n        const color = LGraphCanvas.node_colors[i];\n        var value = {\n            value: i,\n            content:\n                `<span style=\"display: block; color: #999; padding-left: 4px; border-left: 8px solid ${\n                    color.color\n                }; background-color:${\n                    color.bgcolor\n                }\">${\n                    i\n                }</span>`,\n        };\n        values.push(value);\n    }\n    new LiteGraph.ContextMenu(values, {\n        event: e,\n        callback: inner_clicked,\n        parentMenu: menu,\n        node,\n    });\n\n    function inner_clicked(v) {\n        if (!node) {\n            return;\n        }\n\n        const color = v.value ? LGraphCanvas.node_colors[v.value] : null;\n        if (color) {\n            if (node.constructor === LiteGraph.LGraphGroup) {\n                node.color = color.groupcolor;\n            } else {\n                node.color = color.color;\n                node.bgcolor = color.bgcolor;\n            }\n        } else {\n            delete node.color;\n            delete node.bgcolor;\n        }\n        node.setDirtyCanvas(true, true);\n    }\n\n    return false;\n};\n\nLGraphCanvas.onMenuNodeShapes = function (value, options, e, menu, node) {\n    if (!node) {\n        throw \"no node passed\";\n    }\n\n    new LiteGraph.ContextMenu(LiteGraph.VALID_SHAPES, {\n        event: e,\n        callback: inner_clicked,\n        parentMenu: menu,\n        node,\n    });\n\n    function inner_clicked(v) {\n        if (!node) {\n            return;\n        }\n        node.graph.beforeChange(node);\n        node.shape = v;\n        node.graph.afterChange(node);\n        node.setDirtyCanvas(true);\n    }\n\n    return false;\n};\n\nLGraphCanvas.onMenuNodeRemove = function (value, options, e, menu, node) {\n    if (!node) {\n        throw \"no node passed\";\n    }\n\n    if (node.removable === false) {\n        return;\n    }\n\n    const { graph } = node;\n    graph.beforeChange();\n    graph.remove(node);\n    graph.afterChange();\n    node.setDirtyCanvas(true, true);\n};\n\nLGraphCanvas.onMenuNodeToSubgraph = function (value, options, e, menu, node) {\n    const { graph } = node;\n    const graphcanvas = LGraphCanvas.active_canvas;\n    if (!graphcanvas) // ??\n    {\n        return;\n    }\n\n    let nodes_list = Object.values(graphcanvas.selected_nodes || {});\n    if (!nodes_list.length) nodes_list = [node];\n\n    const subgraph_node = LiteGraph.createNode(\"graph/subgraph\");\n    subgraph_node.pos = node.pos.concat();\n    graph.add(subgraph_node);\n\n    subgraph_node.buildFromNodes(nodes_list);\n\n    graphcanvas.deselectAllNodes();\n    node.setDirtyCanvas(true, true);\n};\n\nLGraphCanvas.onMenuNodeClone = function (value, options, e, menu, node) {\n    if (node.clonable == false) {\n        return;\n    }\n    const newnode = node.clone();\n    if (!newnode) {\n        return;\n    }\n    newnode.pos = [node.pos[0] + 5, node.pos[1] + 5];\n\n    node.graph.beforeChange();\n    node.graph.add(newnode);\n    node.graph.afterChange();\n\n    node.setDirtyCanvas(true, true);\n};\n\nLGraphCanvas.node_colors = {\n    red: {\n        color: \"#322\",\n        bgcolor: \"#533\",\n        groupcolor: \"#A88\",\n    },\n    brown: {\n        color: \"#332922\",\n        bgcolor: \"#593930\",\n        groupcolor: \"#b06634\",\n    },\n    green: {\n        color: \"#232\",\n        bgcolor: \"#353\",\n        groupcolor: \"#8A8\",\n    },\n    blue: {\n        color: \"#223\",\n        bgcolor: \"#335\",\n        groupcolor: \"#88A\",\n    },\n    pale_blue: {\n        color: \"#2a363b\",\n        bgcolor: \"#3f5159\",\n        groupcolor: \"#3f789e\",\n    },\n    cyan: {\n        color: \"#233\",\n        bgcolor: \"#355\",\n        groupcolor: \"#8AA\",\n    },\n    purple: {\n        color: \"#323\",\n        bgcolor: \"#535\",\n        groupcolor: \"#a1309b\",\n    },\n    yellow: {\n        color: \"#432\",\n        bgcolor: \"#653\",\n        groupcolor: \"#b58b2a\",\n    },\n    black: {\n        color: \"#222\",\n        bgcolor: \"#000\",\n        groupcolor: \"#444\",\n    },\n};\n\nLGraphCanvas.prototype.getCanvasMenuOptions = function () {\n    let options = null;\n    if (this.getMenuOptions) {\n        options = this.getMenuOptions();\n    } else {\n        options = [\n            {\n                content: \"Add Node\",\n                has_submenu: true,\n                callback: LGraphCanvas.onMenuAdd,\n            },\n            {\n                content: \"Add Group\",\n                callback: LGraphCanvas.onGroupAdd,\n            },\n            // {content:\"Collapse All\", callback: LGraphCanvas.onMenuCollapseAll }\n        ];\n\n        if (this._graph_stack && this._graph_stack.length > 0) {\n            options.push(null, {\n                content: \"Close subgraph\",\n                callback: this.closeSubgraph.bind(this),\n            });\n        }\n    }\n\n    if (this.getExtraMenuOptions) {\n        const extra = this.getExtraMenuOptions(this, options);\n        if (extra) {\n            options = options.concat(extra);\n        }\n    }\n\n    return options;\n};\n\n// called by processContextMenu to extract the menu list\nLGraphCanvas.prototype.getNodeMenuOptions = function (node) {\n    let options = null;\n\n    if (node.getMenuOptions) {\n        options = node.getMenuOptions(this);\n    } else {\n        options = [\n            {\n                content: \"Inputs\",\n                has_submenu: true,\n                disabled: true,\n                callback: LGraphCanvas.showMenuNodeOptionalInputs,\n            },\n            {\n                content: \"Outputs\",\n                has_submenu: true,\n                disabled: true,\n                callback: LGraphCanvas.showMenuNodeOptionalOutputs,\n            },\n            null,\n            {\n                content: \"Properties\",\n                has_submenu: true,\n                callback: LGraphCanvas.onShowMenuNodeProperties,\n            },\n            null,\n            {\n                content: \"Title\",\n                callback: LGraphCanvas.onShowPropertyEditor,\n            },\n            {\n                content: \"Mode\",\n                has_submenu: true,\n                callback: LGraphCanvas.onMenuNodeMode,\n            },\n            {\n                content: \"Resize\",\n                callback() {\n                    if (node.resizable) {\n                        return LGraphCanvas.onResizeNode;\n                    }\n                },\n            },\n            {\n                content: \"Collapse\",\n                callback: LGraphCanvas.onMenuNodeCollapse,\n            },\n            {\n                content: \"Pin\",\n                callback: LGraphCanvas.onMenuNodePin,\n            },\n            {\n                content: \"Colors\",\n                has_submenu: true,\n                callback: LGraphCanvas.onMenuNodeColors,\n            },\n            {\n                content: \"Shapes\",\n                has_submenu: true,\n                callback: LGraphCanvas.onMenuNodeShapes,\n            },\n            null,\n        ];\n    }\n\n    if (node.onGetInputs) {\n        const inputs = node.onGetInputs();\n        if (inputs && inputs.length) {\n            options[0].disabled = false;\n        }\n    }\n\n    if (node.onGetOutputs) {\n        const outputs = node.onGetOutputs();\n        if (outputs && outputs.length) {\n            options[1].disabled = false;\n        }\n    }\n\n    if (node.getExtraMenuOptions) {\n        const extra = node.getExtraMenuOptions(this, options);\n        if (extra) {\n            extra.push(null);\n            options = extra.concat(options);\n        }\n    }\n\n    if (node.clonable !== false) {\n        options.push({\n            content: \"Clone\",\n            callback: LGraphCanvas.onMenuNodeClone,\n        });\n    }\n\n    if (0) // TODO\n    {\n        options.push({\n            content: \"To Subgraph\",\n            callback: LGraphCanvas.onMenuNodeToSubgraph,\n        });\n    }\n\n    options.push(null, {\n        content: \"Remove\",\n        disabled: !(node.removable !== false && !node.block_delete),\n        callback: LGraphCanvas.onMenuNodeRemove,\n    });\n\n    if (node.graph && node.graph.onGetNodeMenuOptions) {\n        node.graph.onGetNodeMenuOptions(options, node);\n    }\n\n    return options;\n};\n\nLGraphCanvas.prototype.getGroupMenuOptions = function (node) {\n    const o = [\n        {\n            content: \"Title\",\n            callback: LGraphCanvas.onShowPropertyEditor,\n        },\n        {\n            content: \"Color\",\n            has_submenu: true,\n            callback: LGraphCanvas.onMenuNodeColors,\n        },\n        {\n            content: \"Font size\",\n            property: \"font_size\",\n            type: \"Number\",\n            callback: LGraphCanvas.onShowPropertyEditor,\n        },\n        null,\n        {\n            content: \"Remove\",\n            callback: LGraphCanvas.onMenuNodeRemove,\n        },\n    ];\n\n    return o;\n};\n\nLGraphCanvas.prototype.processContextMenu = function (node, event) {\n    const that = this;\n    const canvas = LGraphCanvas.active_canvas;\n    const ref_window = canvas.getCanvasWindow();\n\n    let menu_info = null;\n    const options = {\n        event,\n        callback: inner_option_clicked,\n        extra: node,\n    };\n\n    if (node) options.title = node.type;\n\n    // check if mouse is in input\n    let slot = null;\n    if (node) {\n        slot = node.getSlotInPosition(event.canvasX, event.canvasY);\n        LGraphCanvas.active_node = node;\n    }\n\n    if (slot) {\n        // on slot\n        menu_info = [];\n        if (node.getSlotMenuOptions) {\n            menu_info = node.getSlotMenuOptions(slot);\n        } else {\n            if (\n                slot\n                && slot.output\n                && slot.output.links\n                && slot.output.links.length\n            ) {\n                menu_info.push({\n                    content: \"Disconnect Links\",\n                    slot,\n                });\n            }\n            const _slot = slot.input || slot.output;\n            menu_info.push(\n                _slot.locked\n                    ? \"Cannot remove\"\n                    : {\n                        content: \"Remove Slot\",\n                        slot,\n                    },\n            );\n            menu_info.push(\n                _slot.nameLocked\n                    ? \"Cannot rename\"\n                    : {\n                        content: \"Rename Slot\",\n                        slot,\n                    },\n            );\n        }\n        options.title = (slot.input ? slot.input.type : slot.output.type) || \"*\";\n        if (slot.input && slot.input.type == LiteGraph.ACTION) {\n            options.title = \"Action\";\n        }\n        if (slot.output && slot.output.type == LiteGraph.EVENT) {\n            options.title = \"Event\";\n        }\n    } else if (node) {\n        // on node\n        menu_info = this.getNodeMenuOptions(node);\n    } else {\n        menu_info = this.getCanvasMenuOptions();\n        const group = this.graph.getGroupOnPos(\n            event.canvasX,\n            event.canvasY,\n        );\n        if (group) {\n            // on group\n            menu_info.push(null, {\n                content: \"Edit Group\",\n                has_submenu: true,\n                submenu: {\n                    title: \"Group\",\n                    extra: group,\n                    options: this.getGroupMenuOptions(group),\n                },\n            });\n        }\n    }\n\n    // show menu\n    if (!menu_info) {\n        return;\n    }\n\n    const menu = new LiteGraph.ContextMenu(menu_info, options, ref_window);\n\n    function inner_option_clicked(v, options, e) {\n        if (!v) {\n            return;\n        }\n\n        if (v.content == \"Remove Slot\") {\n            var info = v.slot;\n            if (info.input) {\n                node.removeInput(info.slot);\n            } else if (info.output) {\n                node.removeOutput(info.slot);\n            }\n        } else if (v.content == \"Disconnect Links\") {\n            var info = v.slot;\n            if (info.output) {\n                node.disconnectOutput(info.slot);\n            } else if (info.input) {\n                node.disconnectInput(info.slot);\n            }\n        } else if (v.content == \"Rename Slot\") {\n            var info = v.slot;\n            const slot_info = info.input\n                ? node.getInputInfo(info.slot)\n                : node.getOutputInfo(info.slot);\n            const dialog = that.createDialog(\n                \"<span class='name'>Name</span><input autofocus type='text'/><button>OK</button>\",\n                options,\n            );\n            const input = dialog.querySelector(\"input\");\n            if (input && slot_info) {\n                input.value = slot_info.label || \"\";\n            }\n            dialog\n                .querySelector(\"button\")\n                .addEventListener(\"click\", (e) => {\n                    if (input.value) {\n                        if (slot_info) {\n                            slot_info.label = input.value;\n                        }\n                        that.setDirty(true);\n                    }\n                    dialog.close();\n                });\n        }\n\n        // if(v.callback)\n        //\treturn v.callback.call(that, node, options, e, menu, that, event );\n    }\n};\n\n// API *************************************************\n// like rect but rounded corners\nif (typeof (window) !== \"undefined\" && window.CanvasRenderingContext2D) {\n    window.CanvasRenderingContext2D.prototype.roundRect = function (\n        x,\n        y,\n        width,\n        height,\n        radius,\n        radius_low,\n    ) {\n        if (radius === undefined) {\n            radius = 5;\n        }\n\n        if (radius_low === undefined) {\n            radius_low = radius;\n        }\n\n        this.moveTo(x + radius, y);\n        this.lineTo(x + width - radius, y);\n        this.quadraticCurveTo(x + width, y, x + width, y + radius);\n\n        this.lineTo(x + width, y + height - radius_low);\n        this.quadraticCurveTo(\n            x + width,\n            y + height,\n            x + width - radius_low,\n            y + height,\n        );\n        this.lineTo(x + radius_low, y + height);\n        this.quadraticCurveTo(x, y + height, x, y + height - radius_low);\n        this.lineTo(x, y + radius);\n        this.quadraticCurveTo(x, y, x + radius, y);\n    };\n}\n\nfunction compareObjects(a, b) {\n    for (const i in a) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nLiteGraph.compareObjects = compareObjects;\n\nfunction distance(a, b) {\n    return Math.sqrt(\n        (b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1]),\n    );\n}\n\nLiteGraph.distance = distance;\n\nfunction colorToString(c) {\n    return (\n        `rgba(${\n            Math.round(c[0] * 255)\n                .toFixed()\n        },${\n            Math.round(c[1] * 255)\n                .toFixed()\n        },${\n            Math.round(c[2] * 255)\n                .toFixed()\n        },${\n            c.length == 4 ? c[3].toFixed(2) : \"1.0\"\n        })`\n    );\n}\n\nLiteGraph.colorToString = colorToString;\n\nfunction isInsideRectangle(x, y, left, top, width, height) {\n    if (left < x && left + width > x && top < y && top + height > y) {\n        return true;\n    }\n    return false;\n}\n\nLiteGraph.isInsideRectangle = isInsideRectangle;\n\n// [minx,miny,maxx,maxy]\nfunction growBounding(bounding, x, y) {\n    if (x < bounding[0]) {\n        bounding[0] = x;\n    } else if (x > bounding[2]) {\n        bounding[2] = x;\n    }\n\n    if (y < bounding[1]) {\n        bounding[1] = y;\n    } else if (y > bounding[3]) {\n        bounding[3] = y;\n    }\n}\n\nLiteGraph.growBounding = growBounding;\n\n// point inside bounding box\nfunction isInsideBounding(p, bb) {\n    if (\n        p[0] < bb[0][0]\n        || p[1] < bb[0][1]\n        || p[0] > bb[1][0]\n        || p[1] > bb[1][1]\n    ) {\n        return false;\n    }\n    return true;\n}\n\nLiteGraph.isInsideBounding = isInsideBounding;\n\n// bounding overlap, format: [ startx, starty, width, height ]\nfunction overlapBounding(a, b) {\n    const A_end_x = a[0] + a[2];\n    const A_end_y = a[1] + a[3];\n    const B_end_x = b[0] + b[2];\n    const B_end_y = b[1] + b[3];\n\n    if (\n        a[0] > B_end_x\n        || a[1] > B_end_y\n        || A_end_x < b[0]\n        || A_end_y < b[1]\n    ) {\n        return false;\n    }\n    return true;\n}\n\nLiteGraph.overlapBounding = overlapBounding;\n\n// Convert a hex value to its decimal value - the inputted hex must be in the\n//\tformat of a hex triplet - the kind we use for HTML colours. The function\n//\twill return an array with three values.\nfunction hex2num(hex) {\n    if (hex.charAt(0) == \"#\") {\n        hex = hex.slice(1);\n    } // Remove the '#' char - if there is one.\n    hex = hex.toUpperCase();\n    const hex_alphabets = \"0123456789ABCDEF\";\n    const value = new Array(3);\n    let k = 0;\n    let int1;\n    let\n        int2;\n    for (let i = 0; i < 6; i += 2) {\n        int1 = hex_alphabets.indexOf(hex.charAt(i));\n        int2 = hex_alphabets.indexOf(hex.charAt(i + 1));\n        value[k] = int1 * 16 + int2;\n        k++;\n    }\n    return value;\n}\n\nLiteGraph.hex2num = hex2num;\n\n// Give a array with three values as the argument and the function will return\n//\tthe corresponding hex triplet.\nfunction num2hex(triplet) {\n    const hex_alphabets = \"0123456789ABCDEF\";\n    let hex = \"#\";\n    let int1;\n    let\n        int2;\n    for (let i = 0; i < 3; i++) {\n        int1 = triplet[i] / 16;\n        int2 = triplet[i] % 16;\n\n        hex += hex_alphabets.charAt(int1) + hex_alphabets.charAt(int2);\n    }\n    return hex;\n}\n\nLiteGraph.num2hex = num2hex;\n\n/* LiteGraph GUI elements used for canvas editing ************************************ */\n\n/**\n * ContextMenu from LiteGUI\n *\n * @class ContextMenu\n * @constructor\n * @param {Array} values (allows object { title: \"Nice text\", callback: function ... })\n * @param {Object} options [optional] Some options:\\\n * - title: title to show on top of the menu\n * - callback: function to call when an option is clicked, it receives the item information\n * - ignore_item_callbacks: ignores the callback inside the item, it just calls the\n *     options.callback\n * - event: you can pass a MouseEvent, this way the ContextMenu appears in that position\n */\nfunction ContextMenu(values, options) {\n    options = options || {};\n    this.options = options;\n    const that = this;\n\n    // to link a menu with its parent\n    if (options.parentMenu) {\n        if (options.parentMenu.constructor !== this.constructor) {\n            console.error(\n                \"parentMenu must be of class ContextMenu, ignoring it\",\n            );\n            options.parentMenu = null;\n        } else {\n            this.parentMenu = options.parentMenu;\n            this.parentMenu.lock = true;\n            this.parentMenu.current_submenu = this;\n        }\n    }\n\n    let eventClass = null;\n    if (options.event) // use strings because comparing classes between windows doesnt work\n    {\n        eventClass = options.event.constructor.name;\n    }\n    if (eventClass !== \"MouseEvent\"\n        && eventClass !== \"CustomEvent\"\n        && eventClass !== \"PointerEvent\"\n    ) {\n        console.error(\n            \"Event passed to ContextMenu is not of type MouseEvent or CustomEvent. Ignoring it.\",\n        );\n        options.event = null;\n    }\n\n    const root = document.createElement(\"div\");\n    root.className = \"litegraph litecontextmenu litemenubar-panel\";\n    if (options.className) {\n        root.className += ` ${options.className}`;\n    }\n    root.style.minWidth = 100;\n    root.style.minHeight = 100;\n    root.style.pointerEvents = \"none\";\n    setTimeout(() => {\n        root.style.pointerEvents = \"auto\";\n    }, 100); // delay so the mouse up event is not caught by this element\n\n    // this prevents the default context browser menu to open in case this menu was created\n    // when pressing right button\n    root.addEventListener(\n        \"mouseup\",\n        (e) => {\n            e.preventDefault();\n            return true;\n        },\n        true,\n    );\n    root.addEventListener(\n        \"contextmenu\",\n        (e) => {\n            if (e.button != 2) {\n                // right button\n                return false;\n            }\n            e.preventDefault();\n            return false;\n        },\n        true,\n    );\n\n    root.addEventListener(\n        \"mousedown\",\n        (e) => {\n            if (e.button == 2) {\n                that.close();\n                e.preventDefault();\n                return true;\n            }\n        },\n        true,\n    );\n\n    function on_mouse_wheel(e) {\n        const pos = parseInt(root.style.top);\n        root.style.top = `${(pos + e.deltaY * options.scroll_speed).toFixed()}px`;\n        e.preventDefault();\n        return true;\n    }\n\n    if (!options.scroll_speed) {\n        options.scroll_speed = 0.1;\n    }\n\n    root.addEventListener(\"wheel\", on_mouse_wheel, true);\n    root.addEventListener(\"mousewheel\", on_mouse_wheel, true);\n\n    this.root = root;\n\n    // title\n    if (options.title) {\n        const element = document.createElement(\"div\");\n        element.className = \"litemenu-title\";\n        element.innerHTML = options.title;\n        root.appendChild(element);\n    }\n\n    // entries\n    let num = 0;\n    for (let i = 0; i < values.length; i++) {\n        let name = values.constructor == Array ? values[i] : i;\n        if (name != null && name.constructor !== String) {\n            name = name.content === undefined ? String(name) : name.content;\n        }\n        const value = values[i];\n        this.addItem(name, value, options);\n        num++;\n    }\n\n    // close on leave\n    root.addEventListener(\"mouseleave\", (e) => {\n        if (that.lock) {\n            return;\n        }\n        if (root.closing_timer) {\n            clearTimeout(root.closing_timer);\n        }\n        root.closing_timer = setTimeout(that.close.bind(that, e), 500);\n        // that.close(e);\n    });\n\n    root.addEventListener(\"mouseenter\", (e) => {\n        if (root.closing_timer) {\n            clearTimeout(root.closing_timer);\n        }\n    });\n\n    // insert before checking position\n    let root_document = document;\n    if (options.event) {\n        root_document = options.event.target.ownerDocument;\n    }\n\n    if (!root_document) {\n        root_document = document;\n    }\n\n    if (root_document.fullscreenElement) {\n        root_document.fullscreenElement.appendChild(root);\n    } else {\n        root_document.body.appendChild(root);\n    }\n\n    // compute best position\n    let left = options.left || 0;\n    let top = options.top || 0;\n    if (options.event) {\n        left = options.event.clientX - 10;\n        top = options.event.clientY - 10;\n        if (options.title) {\n            top -= 20;\n        }\n\n        if (options.parentMenu) {\n            const rect = options.parentMenu.root.getBoundingClientRect();\n            left = rect.left + rect.width;\n        }\n\n        const body_rect = document.body.getBoundingClientRect();\n        const root_rect = root.getBoundingClientRect();\n        if (body_rect.height == 0) console.error(\"document.body height is 0. That is dangerous, set html,body { height: 100%; }\");\n\n        if (body_rect.width && left > body_rect.width - root_rect.width - 10) {\n            left = body_rect.width - root_rect.width - 10;\n        }\n        if (body_rect.height && top > body_rect.height - root_rect.height - 10) {\n            top = body_rect.height - root_rect.height - 10;\n        }\n    }\n\n    root.style.left = `${left}px`;\n    root.style.top = `${top}px`;\n\n    if (options.scale) {\n        root.style.transform = `scale(${options.scale})`;\n    }\n}\n\nContextMenu.prototype.addItem = function (name, value, options) {\n    const that = this;\n    options = options || {};\n\n    const element = document.createElement(\"div\");\n    element.className = \"litemenu-entry submenu\";\n\n    let disabled = false;\n\n    if (value === null) {\n        element.classList.add(\"separator\");\n        // element.innerHTML = \"<hr/>\"\n        // continue;\n    } else {\n        element.innerHTML = value && value.title ? value.title : name;\n        element.value = value;\n\n        if (value) {\n            if (value.disabled) {\n                disabled = true;\n                element.classList.add(\"disabled\");\n            }\n            if (value.submenu || value.has_submenu) {\n                element.classList.add(\"has_submenu\");\n            }\n        }\n\n        if (typeof value === \"function\") {\n            element.dataset.value = name;\n            element.onclick_callback = value;\n        } else {\n            element.dataset.value = value;\n        }\n\n        if (value.className) {\n            element.className += ` ${value.className}`;\n        }\n    }\n\n    this.root.appendChild(element);\n    if (!disabled) {\n        element.addEventListener(\"click\", inner_onclick);\n    }\n    if (options.autoopen) {\n        element.addEventListener(\"mouseenter\", inner_over);\n    }\n\n    function inner_over(e) {\n        const { value } = this;\n        if (!value || !value.has_submenu) {\n            return;\n        }\n        // if it is a submenu, autoopen like the item was clicked\n        inner_onclick.call(this, e);\n    }\n\n    // menu option clicked\n    function inner_onclick(e) {\n        const { value } = this;\n        let close_parent = true;\n\n        if (that.current_submenu) {\n            that.current_submenu.close(e);\n        }\n\n        // global callback\n        if (options.callback) {\n            var r = options.callback.call(\n                this,\n                value,\n                options,\n                e,\n                that,\n                options.node,\n            );\n            if (r === true) {\n                close_parent = false;\n            }\n        }\n\n        // special cases\n        if (value) {\n            if (\n                value.callback\n                && !options.ignore_item_callbacks\n                && value.disabled !== true\n            ) {\n                // item callback\n                var r = value.callback.call(\n                    this,\n                    value,\n                    options,\n                    e,\n                    that,\n                    options.extra,\n                );\n                if (r === true) {\n                    close_parent = false;\n                }\n            }\n            if (value.submenu) {\n                if (!value.submenu.options) {\n                    throw \"ContextMenu submenu needs options\";\n                }\n                const submenu = new that.constructor(value.submenu.options, {\n                    callback: value.submenu.callback,\n                    event: e,\n                    parentMenu: that,\n                    ignore_item_callbacks:\n                    value.submenu.ignore_item_callbacks,\n                    title: value.submenu.title,\n                    extra: value.submenu.extra,\n                    autoopen: options.autoopen,\n                });\n                close_parent = false;\n            }\n        }\n\n        if (close_parent && !that.lock) {\n            that.close();\n        }\n    }\n\n    return element;\n};\n\nContextMenu.prototype.close = function (e, ignore_parent_menu) {\n    if (this.root.parentNode) {\n        this.root.parentNode.removeChild(this.root);\n    }\n    if (this.parentMenu && !ignore_parent_menu) {\n        this.parentMenu.lock = false;\n        this.parentMenu.current_submenu = null;\n        if (e === undefined) {\n            this.parentMenu.close();\n        } else if (\n            e\n            && !ContextMenu.isCursorOverElement(e, this.parentMenu.root)\n        ) {\n            ContextMenu.trigger(this.parentMenu.root, \"mouseleave\", e);\n        }\n    }\n    if (this.current_submenu) {\n        this.current_submenu.close(e, true);\n    }\n\n    if (this.root.closing_timer) {\n        clearTimeout(this.root.closing_timer);\n    }\n};\n\n// this code is used to trigger events easily (used in the context menu mouseleave\nContextMenu.trigger = function (element, event_name, params, origin) {\n    const evt = document.createEvent(\"CustomEvent\");\n    evt.initCustomEvent(event_name, true, true, params); // canBubble, cancelable, detail\n    evt.srcElement = origin;\n    if (element.dispatchEvent) {\n        element.dispatchEvent(evt);\n    } else if (element.__events) {\n        element.__events.dispatchEvent(evt);\n    }\n    // else nothing seems binded here so nothing to do\n    return evt;\n};\n\n// returns the top most menu\nContextMenu.prototype.getTopMenu = function () {\n    if (this.options.parentMenu) {\n        return this.options.parentMenu.getTopMenu();\n    }\n    return this;\n};\n\nContextMenu.prototype.getFirstEvent = function () {\n    if (this.options.parentMenu) {\n        return this.options.parentMenu.getFirstEvent();\n    }\n    return this.options.event;\n};\n\nContextMenu.isCursorOverElement = function (event, element) {\n    const left = event.clientX;\n    const top = event.clientY;\n    const rect = element.getBoundingClientRect();\n    if (!rect) {\n        return false;\n    }\n    if (\n        top > rect.top\n        && top < rect.top + rect.height\n        && left > rect.left\n        && left < rect.left + rect.width\n    ) {\n        return true;\n    }\n    return false;\n};\n\nLiteGraph.ContextMenu = ContextMenu;\n\nLiteGraph.closeAllContextMenus = function (ref_window) {\n    ref_window = ref_window || window;\n\n    const elements = ref_window.document.querySelectorAll(\".litecontextmenu\");\n    if (!elements.length) {\n        return;\n    }\n\n    const result = [];\n    for (var i = 0; i < elements.length; i++) {\n        result.push(elements[i]);\n    }\n\n    for (var i = 0; i < result.length; i++) {\n        if (result[i].close) {\n            result[i].close();\n        } else if (result[i].parentNode) {\n            result[i].parentNode.removeChild(result[i]);\n        }\n    }\n};\n\nLiteGraph.extendClass = function (target, origin) {\n    for (var i in origin) {\n        // copy class properties\n        if (target.hasOwnProperty(i)) {\n            continue;\n        }\n        target[i] = origin[i];\n    }\n\n    if (origin.prototype) {\n        // copy prototype properties\n        for (var i in origin.prototype) {\n            // only enumerable\n            if (!origin.prototype.hasOwnProperty(i)) {\n                continue;\n            }\n\n            if (target.prototype.hasOwnProperty(i)) {\n                // avoid overwriting existing ones\n                continue;\n            }\n\n            // copy getters\n            if (origin.prototype.__lookupGetter__(i)) {\n                target.prototype.__defineGetter__(\n                    i,\n                    origin.prototype.__lookupGetter__(i),\n                );\n            } else {\n                target.prototype[i] = origin.prototype[i];\n            }\n\n            // and setters\n            if (origin.prototype.__lookupSetter__(i)) {\n                target.prototype.__defineSetter__(\n                    i,\n                    origin.prototype.__lookupSetter__(i),\n                );\n            }\n        }\n    }\n};\n\n// used by some widgets to render a curve editor\nfunction CurveEditor(points) {\n    this.points = points;\n    this.selected = -1;\n    this.nearest = -1;\n    this.size = null; // stores last size used\n    this.must_update = true;\n    this.margin = 5;\n}\n\nCurveEditor.sampleCurve = function (f, points) {\n    if (!points) return;\n    for (let i = 0; i < points.length - 1; ++i) {\n        const p = points[i];\n        const pn = points[i + 1];\n        if (pn[0] < f) continue;\n        const r = (pn[0] - p[0]);\n        if (Math.abs(r) < 0.00001) return p[1];\n        const local_f = (f - p[0]) / r;\n        return p[1] * (1.0 - local_f) + pn[1] * local_f;\n    }\n    return 0;\n};\n\nCurveEditor.prototype.draw = function (ctx, size, graphcanvas, background_color, line_color, inactive) {\n    const { points } = this;\n    if (!points) return;\n    this.size = size;\n    const w = size[0] - this.margin * 2;\n    const h = size[1] - this.margin * 2;\n\n    line_color = line_color || \"#666\";\n\n    ctx.save();\n    ctx.translate(this.margin, this.margin);\n\n    if (background_color) {\n        ctx.fillStyle = \"#111\";\n        ctx.fillRect(0, 0, w, h);\n        ctx.fillStyle = \"#222\";\n        ctx.fillRect(w * 0.5, 0, 1, h);\n        ctx.strokeStyle = \"#333\";\n        ctx.strokeRect(0, 0, w, h);\n    }\n    ctx.strokeStyle = line_color;\n    if (inactive) ctx.globalAlpha = 0.5;\n    ctx.beginPath();\n    for (var i = 0; i < points.length; ++i) {\n        var p = points[i];\n        ctx.lineTo(p[0] * w, (1.0 - p[1]) * h);\n    }\n    ctx.stroke();\n    ctx.globalAlpha = 1;\n    if (!inactive) {\n        for (var i = 0; i < points.length; ++i) {\n            var p = points[i];\n            ctx.fillStyle = this.selected == i ? \"#FFF\" : (this.nearest == i ? \"#DDD\" : \"#AAA\");\n            ctx.beginPath();\n            ctx.arc(p[0] * w, (1.0 - p[1]) * h, 2, 0, Math.PI * 2);\n            ctx.fill();\n        }\n    }\n    ctx.restore();\n};\n\n// localpos is mouse in curve editor space\nCurveEditor.prototype.onMouseDown = function (localpos, graphcanvas) {\n    const { points } = this;\n    if (!points) return;\n    if (localpos[1] < 0) return;\n\n    // this.captureInput(true);\n    const w = this.size[0] - this.margin * 2;\n    const h = this.size[1] - this.margin * 2;\n    const x = localpos[0] - this.margin;\n    const y = localpos[1] - this.margin;\n    const pos = [x, y];\n    const max_dist = 30 / graphcanvas.ds.scale;\n    // search closer one\n    this.selected = this.getCloserPoint(pos, max_dist);\n    // create one\n    if (this.selected == -1) {\n        const point = [x / w, 1 - y / h];\n        points.push(point);\n        points.sort((a, b) => a[0] - b[0]);\n        this.selected = points.indexOf(point);\n        this.must_update = true;\n    }\n    if (this.selected != -1) return true;\n};\n\nCurveEditor.prototype.onMouseMove = function (localpos, graphcanvas) {\n    const { points } = this;\n    if (!points) return;\n    const s = this.selected;\n    if (s < 0) return;\n    const x = (localpos[0] - this.margin) / (this.size[0] - this.margin * 2);\n    const y = (localpos[1] - this.margin) / (this.size[1] - this.margin * 2);\n    const curvepos = [(localpos[0] - this.margin), (localpos[1] - this.margin)];\n    const max_dist = 30 / graphcanvas.ds.scale;\n    this._nearest = this.getCloserPoint(curvepos, max_dist);\n    const point = points[s];\n    if (point) {\n        const is_edge_point = s == 0 || s == points.length - 1;\n        if (!is_edge_point && (localpos[0] < -10 || localpos[0] > this.size[0] + 10 || localpos[1] < -10 || localpos[1] > this.size[1] + 10)) {\n            points.splice(s, 1);\n            this.selected = -1;\n            return;\n        }\n        if (!is_edge_point) // not edges\n        {\n            point[0] = Math.clamp(x, 0, 1);\n        } else {\n            point[0] = s == 0 ? 0 : 1;\n        }\n        point[1] = 1.0 - Math.clamp(y, 0, 1);\n        points.sort((a, b) => a[0] - b[0]);\n        this.selected = points.indexOf(point);\n        this.must_update = true;\n    }\n};\n\nCurveEditor.prototype.onMouseUp = function (localpos, graphcanvas) {\n    this.selected = -1;\n    return false;\n};\n\nCurveEditor.prototype.getCloserPoint = function (pos, max_dist) {\n    const { points } = this;\n    if (!points) return -1;\n    max_dist = max_dist || 30;\n    const w = (this.size[0] - this.margin * 2);\n    const h = (this.size[1] - this.margin * 2);\n    const num = points.length;\n    const p2 = [0, 0];\n    let min_dist = 1000000;\n    let closest = -1;\n    let last_valid = -1;\n    for (let i = 0; i < num; ++i) {\n        const p = points[i];\n        p2[0] = p[0] * w;\n        p2[1] = (1.0 - p[1]) * h;\n        if (p2[0] < pos[0]) last_valid = i;\n        const dist = vec2.distance(pos, p2);\n        if (dist > min_dist || dist > max_dist) continue;\n        closest = i;\n        min_dist = dist;\n    }\n    return closest;\n};\n\nLiteGraph.CurveEditor = CurveEditor;\n\n// used to create nodes from wrapping functions\nLiteGraph.getParameterNames = function (func) {\n    return (`${func}`)\n        .replace(/[/][/].*$/gm, \"\") // strip single-line comments\n        .replace(/\\s+/g, \"\") // strip white space\n        .replace(/[/][*][^/*]*[*][/]/g, \"\") // strip multi-line comments  /**/\n        .split(\"){\", 1)[0]\n        .replace(/^[^(]*[(]/, \"\") // extract the parameters\n        .replace(/=[^,]+/g, \"\") // strip any ES6 defaults\n        .split(\",\")\n        .filter(Boolean); // split & filter [\"\"]\n};\n\nMath.clamp = function (v, a, b) {\n    return a > v ? a : b < v ? b : v;\n};\n\nif (typeof window !== \"undefined\" && !window.requestAnimationFrame) {\n    window.requestAnimationFrame = window.webkitRequestAnimationFrame\n        || window.mozRequestAnimationFrame\n        || function (callback) {\n            window.setTimeout(callback, 1000 / 60);\n        };\n}\n\nexport default LiteGraph\n","import LiteGraph from \"./litegraph\";\n\n/**\n * LGraph is the class that contain a full graph.\n * We instantiate one and add nodes to it, and then we can run the execution loop.\n * supported callbacks:\n + onNodeAdded: when a new node is added to the graph\n + onNodeRemoved: when a node inside this graph is removed\n + onNodeConnectionChange: some connection has changed in the graph (connected or disconnected)\n *\n * @class LGraph\n * @constructor\n * @param {Object} o data from previous serialization [optional]\n */\nexport default class LGraph {\n    constructor(o) {\n        if (LiteGraph.debug) {\n            console.log(\"Graph created\");\n        }\n        this.list_of_graphcanvas = null;\n        this.clear();\n\n        if (o) {\n            this.configure(o);\n        }\n    }\n\n    getSupportedTypes() {\n        return this.supportedTypes || LGraph.supportedTypes;\n    }\n\n    STATUS_STOPPED = 1;\n\n    STATUS_RUNNING = 2;\n\n    supportedTypes = [\"number\", \"string\", \"boolean\"];\n\n    static supportedTypes = [\"number\", \"string\", \"boolean\"];\n    // used to know which types of connections support this graph (some graphs do not allow certain\n    // types)\n\n    /**\n     * Removes all nodes from this graph\n     * @method clear\n     */\n    clear() {\n        this.stop();\n        this.status = LGraph.STATUS_STOPPED;\n\n        this.last_node_id = 0;\n        this.last_link_id = 0;\n\n        this._version = -1; // used to detect changes\n\n        // safe clear\n        if (this._nodes) {\n            for (const node of this._nodes) {\n                if (node.onRemoved) node.onRemoved();\n            }\n        }\n\n        // nodes\n        this._nodes = [];\n        this._nodes_by_id = {};\n        this._nodes_in_order = []; // nodes sorted in execution order\n        this._nodes_executable = null; // nodes that contain onExecute sorted in execution order\n\n        // other scene stuff\n        this._groups = [];\n\n        // links\n        this.links = {}; // container with all the links\n\n        // iterations\n        this.iteration = 0;\n\n        // custom data\n        this.config = {};\n        this.vars = {};\n        this.extra = {}; // to store custom data\n\n        // timing\n        this.globaltime = 0;\n        this.runningtime = 0;\n        this.fixedtime = 0;\n        this.fixedtime_lapse = 0.01;\n        this.elapsed_time = 0.01;\n        this.last_update_time = 0;\n        this.starttime = 0;\n\n        this.catch_errors = true;\n\n        // subgraph_data\n        this.inputs = {};\n        this.outputs = {};\n\n        // notify canvas to redraw\n        this.change();\n\n        this.sendActionToCanvas(\"clear\");\n    }\n\n    /**\n     * Attach Canvas to this graph\n     * @method attachCanvas\n     * @param {GraphCanvas} graphcanvas\n     */\n    attachCanvas(graphcanvas) {\n        if (graphcanvas.constructor !== LGraphCanvas) {\n            throw new Error(\"attachCanvas expects a LGraphCanvas instance\");\n        }\n        if (graphcanvas.graph && graphcanvas.graph !== this) {\n            graphcanvas.graph.detachCanvas(graphcanvas);\n        }\n\n        graphcanvas.graph = this;\n\n        if (!this.list_of_graphcanvas) this.list_of_graphcanvas = [];\n        this.list_of_graphcanvas.push(graphcanvas);\n    }\n\n    /**\n     * Detach Canvas from this graph\n     * @method detachCanvas\n     * @param {GraphCanvas} graphcanvas\n     */\n    detachCanvas(graphcanvas) {\n        if (!this.list_of_graphcanvas) {\n            return;\n        }\n\n        const pos = this.list_of_graphcanvas.indexOf(graphcanvas);\n        if (pos === -1) {\n            return;\n        }\n        graphcanvas.graph = null;\n        this.list_of_graphcanvas.splice(pos, 1);\n    }\n\n    /**\n     * Starts running this graph every interval milliseconds.\n     * @method start\n     * @param {number} interval amount of milliseconds between executions, if 0 then it renders to\n     *     the monitor refresh rate\n     */\n    start(interval) {\n        if (this.status === LGraph.STATUS_RUNNING) {\n            return;\n        }\n        this.status = LGraph.STATUS_RUNNING;\n\n        if (this.onPlayEvent) {\n            this.onPlayEvent();\n        }\n\n        this.sendEventToAllNodes(\"onStart\");\n\n        // launch\n        this.starttime = LiteGraph.getTime();\n        this.last_update_time = this.starttime;\n        interval = interval || 0;\n        const that = this;\n\n        // execute once per frame\n        if (interval === 0 && typeof window !== \"undefined\" && window.requestAnimationFrame) {\n            // eslint-disable-next-line no-inner-declarations\n            function onFrame() {\n                if (that.execution_timer_id !== -1) {\n                    return;\n                }\n                window.requestAnimationFrame(onFrame);\n                if (that.onBeforeStep) that.onBeforeStep();\n                that.runStep(1, !that.catch_errors);\n                if (that.onAfterStep) that.onAfterStep();\n            }\n\n            this.execution_timer_id = -1;\n            onFrame();\n        } else { // execute every 'interval' ms\n            this.execution_timer_id = setInterval(() => {\n                // execute\n                if (that.onBeforeStep) that.onBeforeStep();\n                that.runStep(1, !that.catch_errors);\n                if (that.onAfterStep) that.onAfterStep();\n            }, interval);\n        }\n    }\n\n    /**\n     * Stops the execution loop of the graph\n     * @method stop execution\n     */\n    stop() {\n        if (this.status === LGraph.STATUS_STOPPED) {\n            return;\n        }\n\n        this.status = LGraph.STATUS_STOPPED;\n\n        if (this.onStopEvent) {\n            this.onStopEvent();\n        }\n\n        if (this.execution_timer_id !== null) {\n            if (this.execution_timer_id !== -1) {\n                clearInterval(this.execution_timer_id);\n            }\n            this.execution_timer_id = null;\n        }\n\n        this.sendEventToAllNodes(\"onStop\");\n    }\n\n    /**\n     * Run N steps (cycles) of the graph\n     * @method runStep\n     * @param {number} num number of steps to run, default is 1\n     * @param {Boolean} doNotCatchError [optional] if you want to try/catch errors\n     * @param {number} limit max number of nodes to execute (used to execute from start to a node)\n     */\n    runStep(num, doNotCatchError, limit) {\n        num = num || 1;\n\n        const start = LiteGraph.getTime();\n        this.globaltime = 0.001 * (start - this.starttime);\n\n        const nodes = this._nodes_executable\n            ? this._nodes_executable\n            : this._nodes;\n        if (!nodes) {\n            return;\n        }\n\n        limit = limit || nodes.length;\n\n        if (doNotCatchError) {\n            // iterations\n            for (let i = 0; i < num; i++) {\n                for (let j = 0; j < limit; j++) {\n                    const node = nodes[j];\n                    if (node.mode === LiteGraph.ALWAYS && node.onExecute) {\n                        node.onExecute(); // hard to send elapsed time\n                    }\n                }\n\n                this.fixedtime += this.fixedtime_lapse;\n                if (this.onExecuteStep) {\n                    this.onExecuteStep();\n                }\n            }\n\n            if (this.onAfterExecute) {\n                this.onAfterExecute();\n            }\n        } else {\n            try {\n                // iterations\n                for (let i = 0; i < num; i++) {\n                    for (let j = 0; j < limit; ++j) {\n                        const node = nodes[j];\n                        if (node.mode === LiteGraph.ALWAYS && node.onExecute) {\n                            node.onExecute();\n                        }\n                    }\n\n                    this.fixedtime += this.fixedtime_lapse;\n                    if (this.onExecuteStep) {\n                        this.onExecuteStep();\n                    }\n                }\n\n                if (this.onAfterExecute) {\n                    this.onAfterExecute();\n                }\n                this.errors_in_execution = false;\n            } catch (err) {\n                this.errors_in_execution = true;\n                if (LiteGraph.throw_errors) {\n                    throw err;\n                }\n                if (LiteGraph.debug) {\n                    console.log(`Error during execution: ${err}`);\n                }\n                this.stop();\n            }\n        }\n\n        const now = LiteGraph.getTime();\n        let elapsed = now - start;\n        if (elapsed === 0) {\n            elapsed = 1;\n        }\n        this.execution_time = 0.001 * elapsed;\n        this.globaltime += 0.001 * elapsed;\n        this.iteration += 1;\n        this.elapsed_time = (now - this.last_update_time) * 0.001;\n        this.last_update_time = now;\n    }\n\n    /**\n     * Updates the graph execution order according to relevance of the nodes (nodes with only\n     * outputs have more relevance than nodes with only inputs.\n     * @method updateExecutionOrder\n     */\n    updateExecutionOrder() {\n        this._nodes_in_order = this.computeExecutionOrder(false);\n        this._nodes_executable = [];\n        for (const node of this._nodes_in_order) {\n            if (node.onExecute) {\n                this._nodes_executable.push(node);\n            }\n        }\n    }\n\n    /**\n     * It computes the executable nodes in order and returns it\n     * @param onlyOnExecute\n     * @param setLevel\n     * @returns {this}\n     * @internal\n     */\n    computeExecutionOrder(onlyOnExecute, setLevel) {\n        let L = [];\n        const S = [];\n        const M = {};\n        const visitedLinks = {}; // to avoid repeating links\n        const remainingLinks = {}; // to a\n\n        // search for the nodes without inputs (starting nodes)\n        for (const node of this._nodes) {\n            if (onlyOnExecute && !node.onExecute) {\n                continue;\n            }\n\n            M[node.id] = node; // add to pending nodes\n\n            let num = 0; // num of input connections\n            if (node.inputs) {\n                for (let j = 0, l2 = node.inputs.length; j < l2; j++) {\n                    if (node.inputs[j] && node.inputs[j].link != null) {\n                        num += 1;\n                    }\n                }\n            }\n\n            if (num === 0) {\n                // is a starting node\n                S.push(node);\n                if (setLevel) {\n                    node._level = 1;\n                }\n            } else {\n                if (setLevel) {\n                    node._level = 0;\n                }\n                remainingLinks[node.id] = num;\n            }\n        }\n\n        while (true) {\n            if (S.length === 0) {\n                break;\n            }\n\n            // get an starting node\n            const node = S.shift();\n            L.push(node); // add to ordered list\n            delete M[node.id]; // remove from the pending nodes\n\n            if (!node.outputs) {\n                continue;\n            }\n\n            // for every output\n            for (const output of node.outputs) {\n                if (\n                    output == null\n                    || output.links == null\n                    || output.links.length === 0\n                ) {\n                    continue;\n                }\n\n                // for every connection\n                for (const linkId of output.links) {\n                    const link = this.links[linkId];\n                    if (!link) {\n                        continue;\n                    }\n\n                    // already visited link (ignore it)\n                    if (visitedLinks[link.id]) {\n                        continue;\n                    }\n\n                    const targetNode = this.getNodeById(link.target_id);\n                    if (targetNode == null) {\n                        visitedLinks[link.id] = true;\n                        continue;\n                    }\n\n                    if (\n                        setLevel\n                        && (!targetNode._level\n                        || targetNode._level <= node._level)\n                    ) {\n                        targetNode._level = node._level + 1;\n                    }\n\n                    visitedLinks[link.id] = true; // mark as visited\n                    remainingLinks[targetNode.id] -= 1; // reduce the number of links remaining\n                    if (remainingLinks[targetNode.id] === 0) {\n                        S.push(targetNode);\n                    } // if no more links, then add to starters array\n                }\n            }\n        }\n\n        // the remaining ones (loops)\n        // eslint-disable-next-line guard-for-in,no-restricted-syntax\n        for (const i in M) L.push(M[i]);\n\n        if (L.length !== this._nodes.length && LiteGraph.debug) {\n            console.warn(\"something went wrong, nodes missing\");\n        }\n\n        const l = L.length;\n\n        // save order number in the node\n        for (let i = 0; i < l; i++) L[i].order = i;\n\n        // sort now by priority\n        L = L.sort((A, B) => {\n            const Ap = A.constructor.priority || A.priority || 0;\n            const Bp = B.constructor.priority || B.priority || 0;\n            if (Ap === Bp) {\n                // if same priority, sort by order\n                return A.order - B.order;\n            }\n            return Ap - Bp; // sort by priority\n        });\n\n        // save order number in the node, again...\n        for (let i = 0; i < l; ++i) L[i].order = i;\n\n        return L;\n    }\n\n    /**\n     * Returns all the nodes that could affect this one (ancestors) by crawling all the inputs\n     * recursively. It doesn't include the node itself\n     * @method getAncestors\n     * @return {Array} an array with all the LGraphNodes that affect this node, in order of\n     *     execution\n     */\n    // eslint-disable-next-line class-methods-use-this\n    getAncestors(node) {\n        const ancestors = [];\n        const pending = [node];\n        const visited = {};\n\n        while (pending.length) {\n            const current = pending.shift();\n            if (!current.inputs) {\n                continue;\n            }\n            if (!visited[current.id] && current !== node) {\n                visited[current.id] = true;\n                ancestors.push(current);\n            }\n\n            for (let i = 0; i < current.inputs.length; ++i) {\n                const input = current.getInputNode(i);\n                if (input && ancestors.indexOf(input) === -1) {\n                    pending.push(input);\n                }\n            }\n        }\n\n        ancestors.sort((a, b) => a.order - b.order);\n        return ancestors;\n    }\n\n    /**\n     * Positions every node in a more readable manner\n     * @method arrange\n     */\n    arrange(margin) {\n        margin = margin || 100;\n\n        const nodes = this.computeExecutionOrder(false, true);\n        const columns = [];\n        for (const node of nodes) {\n            const col = node._level || 1;\n            if (!columns[col]) {\n                columns[col] = [];\n            }\n            columns[col].push(node);\n        }\n\n        let x = margin;\n\n        for (const column of columns) {\n            if (!column) {\n                continue;\n            }\n            let maxSize = 100;\n            let y = margin + LiteGraph.NODE_TITLE_HEIGHT;\n            for (const node of column) {\n                node.pos[0] = x;\n                node.pos[1] = y;\n                if (node.size[0] > maxSize) maxSize = node.size[0];\n                y += node.size[1] + margin + LiteGraph.NODE_TITLE_HEIGHT;\n            }\n            x += maxSize + margin;\n        }\n\n        this.setDirtyCanvas(true, true);\n    }\n\n    /**\n     * Returns the amount of time the graph has been running in milliseconds\n     * @method getTime\n     * @return {number} number of milliseconds the graph has been running\n     */\n    getTime() {\n        return this.globaltime;\n    }\n\n    /**\n     * Returns the amount of time accumulated using the fixedtime_lapse var. This is used in\n     * context where the time increments should be constant\n     * @method getFixedTime\n     * @return {number} number of milliseconds the graph has been running\n     */\n\n    getFixedTime() {\n        return this.fixedtime;\n    }\n\n    /**\n     * Returns the amount of time it took to compute the latest iteration. Take into account that\n     * this number could be not correct if the nodes are using graphical actions\n     * @method getElapsedTime\n     * @return {number} number of milliseconds it took the last cycle\n     */\n\n    getElapsedTime() {\n        return this.elapsed_time;\n    }\n\n    /**\n     * Sends an event to all the nodes, useful to trigger stuff\n     * @method sendEventToAllNodes\n     * @param {String} eventname the name of the event (function to be called)\n     * @param {Array} params parameters in array format\n     */\n    sendEventToAllNodes(eventname, params, mode) {\n        mode = mode || LiteGraph.ALWAYS;\n\n        const nodes = this._nodes_in_order ? this._nodes_in_order : this._nodes;\n        if (!nodes) {\n            return;\n        }\n\n        for (let j = 0, l = nodes.length; j < l; ++j) {\n            const node = nodes[j];\n\n            if (\n                node.constructor === LiteGraph.Subgraph\n                && eventname !== \"onExecute\"\n            ) {\n                if (node.mode === mode) {\n                    node.sendEventToAllNodes(eventname, params, mode);\n                }\n                continue;\n            }\n\n            if (!node[eventname] || node.mode !== mode) {\n                continue;\n            }\n            if (params === undefined) {\n                node[eventname]();\n            } else if (params && params.constructor === Array) {\n                node[eventname](...params);\n            } else {\n                node[eventname](params);\n            }\n        }\n    }\n\n    sendActionToCanvas(action, params) {\n        if (!this.list_of_graphcanvas) {\n            return;\n        }\n\n        for (let i = 0; i < this.list_of_graphcanvas.length; ++i) {\n            const c = this.list_of_graphcanvas[i];\n            if (c[action]) {\n                c[action](...params);\n            }\n        }\n    }\n\n    /**\n     * Adds a new node instance to this graph\n     * @method add\n     * @param {LGraphNode} node the instance of the node\n     * @param {boolean} skipComputeOrder\n     */\n\n    add(node, skipComputeOrder) {\n        if (!node) {\n            return;\n        }\n\n        // groups\n        if (node.constructor === LGraphGroup) {\n            this._groups.push(node);\n            this.setDirtyCanvas(true);\n            this.change();\n            node.graph = this;\n            this._version++;\n            return;\n        }\n\n        // nodes\n        if (node.id !== -1 && this._nodes_by_id[node.id] != null) {\n            console.warn(\n                \"LiteGraph: there is already a node with this ID, changing it\",\n            );\n            node.id = ++this.last_node_id;\n        }\n\n        if (this._nodes.length >= LiteGraph.MAX_NUMBER_OF_NODES) {\n            throw new Error(\"LiteGraph: max number of nodes in a graph reached\");\n        }\n\n        // give him an id\n        if (node.id == null || node.id === -1) {\n            node.id = ++this.last_node_id;\n        } else if (this.last_node_id < node.id) {\n            this.last_node_id = node.id;\n        }\n\n        node.graph = this;\n        this._version++;\n\n        this._nodes.push(node);\n        this._nodes_by_id[node.id] = node;\n\n        if (node.onAdded) node.onAdded(this);\n\n        if (this.config.align_to_grid) node.alignToGrid();\n\n        if (!skipComputeOrder) this.updateExecutionOrder();\n\n        if (this.onNodeAdded) this.onNodeAdded(node);\n\n        this.setDirtyCanvas(true);\n        this.change();\n\n        return node; // to chain actions\n    }\n\n    /**\n     * Removes a node from the graph\n     * @method remove\n     * @param {LGraphNode} node the instance of the node\n     */\n\n    remove(node) {\n        if (node.constructor === LiteGraph.LGraphGroup) {\n            const index = this._groups.indexOf(node);\n            if (index !== -1) {\n                this._groups.splice(index, 1);\n            }\n            node.graph = null;\n            this._version++;\n            this.setDirtyCanvas(true, true);\n            this.change();\n            return;\n        }\n\n        if (this._nodes_by_id[node.id] == null) {\n            return;\n        } // not found\n\n        if (node.ignore_remove) {\n            return;\n        } // cannot be removed\n\n        this.beforeChange(); // sure?\n\n        // disconnect inputs\n        if (node.inputs) {\n            for (let i = 0; i < node.inputs.length; i++) {\n                const slot = node.inputs[i];\n                if (slot.link != null) {\n                    node.disconnectInput(i);\n                }\n            }\n        }\n\n        // disconnect outputs\n        if (node.outputs) {\n            for (let i = 0; i < node.outputs.length; i++) {\n                const slot = node.inputs[i];\n                if (slot.links != null && slot.links.length) {\n                    node.disconnectOutput(i);\n                }\n            }\n        }\n\n        // node.id = -1; //why?\n\n        // callback\n        if (node.onRemoved) {\n            node.onRemoved();\n        }\n\n        node.graph = null;\n        this._version++;\n\n        // remove from canvas render\n        if (this.list_of_graphcanvas) {\n            for (const canvas of this.list_of_graphcanvas) {\n                if (canvas.selected_nodes[node.id]) {\n                    delete canvas.selected_nodes[node.id];\n                }\n                if (canvas.node_dragged === node) {\n                    canvas.node_dragged = null;\n                }\n            }\n        }\n\n        // remove from containers\n        const pos = this._nodes.indexOf(node);\n        if (pos !== -1) {\n            this._nodes.splice(pos, 1);\n        }\n        delete this._nodes_by_id[node.id];\n\n        if (this.onNodeRemoved) {\n            this.onNodeRemoved(node);\n        }\n\n        // close panels\n        this.sendActionToCanvas(\"checkPanels\");\n\n        this.setDirtyCanvas(true, true);\n        this.afterChange(); // sure?\n        this.change();\n\n        this.updateExecutionOrder();\n    }\n\n    /**\n     * Returns a node by its id.\n     * @method getNodeById\n     * @param {Number} id\n     */\n\n    getNodeById(id) {\n        if (id == null) {\n            return null;\n        }\n        return this._nodes_by_id[id];\n    }\n\n    /**\n     * Returns a list of nodes that matches a class\n     * @method findNodesByClass\n     * @param {Class} classObject the class itself (not an string)\n     * @param {Array} result\n     * @return {Array} a list with all the nodes of this type\n     */\n    findNodesByClass(classObject, result = []) {\n        result.length = 0;\n        for (const node of this._nodes) {\n            if (node.constructor === classObject) result.push(node);\n        }\n        return result;\n    }\n\n    /**\n     * Returns a list of nodes that matches a type\n     * @method findNodesByType\n     * @param {String} type the name of the node type\n     * @param {Array} result\n     * @return {Array} a list with all the nodes of this type\n     */\n    findNodesByType(type, result = []) {\n        type = type.toLowerCase();\n        result = result || [];\n        result.length = 0;\n        for (const node of this._nodes) {\n            if (node.type.toLowerCase() === type) result.push(node);\n        }\n        return result;\n    }\n\n    /**\n     * Returns the first node that matches a name in its title\n     * @method findNodeByTitle\n     * @param {String} title the name of the node to search\n     * @return {Node} the node or null\n     */\n    findNodeByTitle(title) {\n        for (const node of this._nodes) {\n            if (node.title === title) return node;\n        }\n        return null;\n    }\n\n    /**\n     * Returns a list of nodes that matches a name\n     * @method findNodesByTitle\n     * @param {String} title the name of the node to search\n     * @return {Array} a list with all the nodes with this name\n     */\n    findNodesByTitle(title) {\n        const result = [];\n        for (const node of this._nodes) {\n            if (node.title === title) result.push(node);\n        }\n        return result;\n    }\n\n    /**\n     * Returns the top-most node in this position of the canvas\n     * @method getNodeOnPos\n     * @param {number} x the x coordinate in canvas space\n     * @param {number} y the y coordinate in canvas space\n     * @param {Array} nodesList a list with all the nodes to search from, by default is all the\n     *     nodes in the graph\n     * @param {number} margin\n     * @return {LGraphNode} the node at this position or null\n     */\n    getNodeOnPos(x, y, nodesList = this._nodes, margin) {\n        for (const n of nodesList) {\n            if (n.isPointInside(x, y, margin)) return n;\n        }\n        return null;\n    }\n\n    /**\n     * Returns the top-most group in that position\n     * @method getGroupOnPos\n     * @param {number} x the x coordinate in canvas space\n     * @param {number} y the y coordinate in canvas space\n     * @return {LGraphGroup} the group or null\n     */\n    getGroupOnPos(x, y) {\n        for (const g of this._groups) {\n            if (g.isPointInside(x, y, 2, true)) return g;\n        }\n        return null;\n    }\n\n    /**\n     * Checks that the node type matches the node type registered, used when replacing a nodetype\n     * by a newer version during execution this replaces the ones using the old version with the\n     * new version\n     * @method checkNodeTypes\n     */\n    checkNodeTypes() {\n        for (let node of this._nodes) {\n            const ctor = LiteGraph.registered_node_types[node.type];\n            if (node.constructor === ctor) {\n                continue;\n            }\n            console.log(`node being replaced by newer version: ${node.type}`);\n            const newnode = LiteGraph.createNode(node.type);\n            node = newnode;\n            newnode.configure(node.serialize());\n            newnode.graph = this;\n            this._nodes_by_id[newnode.id] = newnode;\n            if (node.inputs) {\n                newnode.inputs = node.inputs.concat();\n            }\n            if (node.outputs) {\n                newnode.outputs = node.outputs.concat();\n            }\n        }\n        this.updateExecutionOrder();\n    }\n\n    // ********** GLOBALS *****************\n\n    onAction(action, param) {\n        this._input_nodes = this.findNodesByClass(\n            LiteGraph.GraphInput,\n            this._input_nodes,\n        );\n        for (const node of this._input_nodes) {\n            if (node.properties.name !== action) {\n                continue;\n            }\n            node.onAction(action, param);\n            break;\n        }\n    }\n\n    trigger(action, param) {\n        if (this.onTrigger) {\n            this.onTrigger(action, param);\n        }\n    }\n\n    /**\n     * Tell this graph it has a global graph input of this type\n     * @method addGlobalInput\n     * @param {String} name\n     * @param {String} type\n     * @param {*} value [optional]\n     */\n    addInput(name, type, value) {\n        const input = this.inputs[name];\n        if (input) {\n            // already exist\n            return;\n        }\n\n        this.beforeChange();\n        this.inputs[name] = {\n            name,\n            type,\n            value,\n        };\n        this._version++;\n        this.afterChange();\n\n        if (this.onInputAdded) {\n            this.onInputAdded(name, type);\n        }\n\n        if (this.onInputsOutputsChange) {\n            this.onInputsOutputsChange();\n        }\n    }\n\n    /**\n     * Assign a data to the global graph input\n     * @method setGlobalInputData\n     * @param {String} name\n     * @param {*} data\n     */\n    setInputData(name, data) {\n        const input = this.inputs[name];\n        if (!input) {\n            return;\n        }\n        input.value = data;\n    }\n\n    /**\n     * Returns the current value of a global graph input\n     * @method getInputData\n     * @param {String} name\n     * @return {*} the data\n     */\n    getInputData(name) {\n        const input = this.inputs[name];\n        if (!input) {\n            return null;\n        }\n        return input.value;\n    }\n\n    /**\n     * Changes the newName of a global graph input\n     * @method renameInput\n     * @param {String} oldName\n     * @param {String} new_name\n     */\n    renameInput(oldName, newName) {\n        if (newName === oldName) {\n            return;\n        }\n\n        if (!this.inputs[oldName]) {\n            return false;\n        }\n\n        if (this.inputs[newName]) {\n            console.error(\"there is already one input with that newName\");\n            return false;\n        }\n\n        this.inputs[newName] = this.inputs[oldName];\n        delete this.inputs[oldName];\n        this._version++;\n\n        if (this.onInputRenamed) {\n            this.onInputRenamed(oldName, newName);\n        }\n\n        if (this.onInputsOutputsChange) {\n            this.onInputsOutputsChange();\n        }\n    }\n\n    /**\n     * Changes the type of a global graph input\n     * @method changeInputType\n     * @param {String} name\n     * @param {String} type\n     */\n    changeInputType(name, type) {\n        if (!this.inputs[name]) {\n            return false;\n        }\n\n        if (\n            this.inputs[name].type\n            && String(this.inputs[name].type).toLowerCase()\n            === String(type).toLowerCase()\n        ) {\n            return;\n        }\n\n        this.inputs[name].type = type;\n        this._version++;\n        if (this.onInputTypeChanged) {\n            this.onInputTypeChanged(name, type);\n        }\n    }\n\n    /**\n     * Removes a global graph input\n     * @method removeInput\n     * @param {String} name\n     */\n    removeInput(name) {\n        if (!this.inputs[name]) {\n            return false;\n        }\n\n        delete this.inputs[name];\n        this._version++;\n\n        if (this.onInputRemoved) {\n            this.onInputRemoved(name);\n        }\n\n        if (this.onInputsOutputsChange) {\n            this.onInputsOutputsChange();\n        }\n        return true;\n    }\n\n    /**\n     * Creates a global graph output\n     * @method addOutput\n     * @param {String} name\n     * @param {String} type\n     * @param {*} value\n     */\n    addOutput(name, type, value) {\n        this.outputs[name] = {\n            name,\n            type,\n            value,\n        };\n        this._version++;\n\n        if (this.onOutputAdded) {\n            this.onOutputAdded(name, type);\n        }\n\n        if (this.onInputsOutputsChange) {\n            this.onInputsOutputsChange();\n        }\n    }\n\n    /**\n     * Assign a data to the global output\n     * @method setOutputData\n     * @param {String} name\n     * @param {String} value\n     */\n    setOutputData(name, value) {\n        const output = this.outputs[name];\n        if (!output) {\n            return;\n        }\n        output.value = value;\n    }\n\n    /**\n     * Returns the current value of a global graph output\n     * @method getOutputData\n     * @param {String} name\n     * @return {*} the data\n     */\n    getOutputData(name) {\n        const output = this.outputs[name];\n        if (!output) {\n            return null;\n        }\n        return output.value;\n    }\n\n    /**\n     * Renames a global graph output\n     * @method renameOutput\n     * @param {String} oldName\n     * @param {String} newName\n     */\n    renameOutput(oldName, newName) {\n        if (!this.outputs[oldName]) {\n            return false;\n        }\n\n        if (this.outputs[newName]) {\n            console.error(\"there is already one output with that newName\");\n            return false;\n        }\n\n        this.outputs[newName] = this.outputs[oldName];\n        delete this.outputs[oldName];\n        this._version++;\n\n        if (this.onOutputRenamed) {\n            this.onOutputRenamed(oldName, newName);\n        }\n\n        if (this.onInputsOutputsChange) {\n            this.onInputsOutputsChange();\n        }\n    }\n\n    /**\n     * Changes the type of a global graph output\n     * @method changeOutputType\n     * @param {String} name\n     * @param {String} type\n     */\n    changeOutputType(name, type) {\n        if (!this.outputs[name]) {\n            return false;\n        }\n\n        if (\n            this.outputs[name].type\n            && String(this.outputs[name].type).toLowerCase()\n            === String(type).toLowerCase()\n        ) {\n            return;\n        }\n\n        this.outputs[name].type = type;\n        this._version++;\n        if (this.onOutputTypeChanged) {\n            this.onOutputTypeChanged(name, type);\n        }\n    }\n\n    /**\n     * Removes a global graph output\n     * @method removeOutput\n     * @param {String} name\n     */\n    removeOutput(name) {\n        if (!this.outputs[name]) {\n            return false;\n        }\n        delete this.outputs[name];\n        this._version++;\n\n        if (this.onOutputRemoved) {\n            this.onOutputRemoved(name);\n        }\n\n        if (this.onInputsOutputsChange) {\n            this.onInputsOutputsChange();\n        }\n        return true;\n    }\n\n    triggerInput(name, value) {\n        const nodes = this.findNodesByTitle(name);\n        for (let i = 0; i < nodes.length; ++i) {\n            nodes[i].onTrigger(value);\n        }\n    }\n\n    setCallback(name, func) {\n        const nodes = this.findNodesByTitle(name);\n        for (let i = 0; i < nodes.length; ++i) {\n            nodes[i].setTrigger(func);\n        }\n    }\n\n    // used for undo, called before any change is made to the graph\n    beforeChange(info) {\n        if (this.onBeforeChange) {\n            this.onBeforeChange(this, info);\n        }\n        this.sendActionToCanvas(\"onBeforeChange\", this);\n    }\n\n    // used to resend actions, called after any change is made to the graph\n    afterChange(info) {\n        if (this.onAfterChange) {\n            this.onAfterChange(this, info);\n        }\n        this.sendActionToCanvas(\"onAfterChange\", this);\n    }\n\n    connectionChange(node) {\n        this.updateExecutionOrder();\n        if (this.onConnectionChange) {\n            this.onConnectionChange(node);\n        }\n        this._version++;\n        this.sendActionToCanvas(\"onConnectionChange\");\n    }\n\n    /**\n     * returns if the graph is in live mode\n     * @method isLive\n     */\n\n    isLive() {\n        if (!this.list_of_graphcanvas) {\n            return false;\n        }\n\n        for (let i = 0; i < this.list_of_graphcanvas.length; ++i) {\n            const c = this.list_of_graphcanvas[i];\n            if (c.live_mode) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * clears the triggered slot animation in all links (stop visual animation)\n     * @method clearTriggeredSlots\n     */\n    clearTriggeredSlots() {\n        // eslint-disable-next-line guard-for-in,no-restricted-syntax\n        for (const i in this.links) {\n            const linkInfo = this.links[i];\n            if (!linkInfo) {\n                continue;\n            }\n            if (linkInfo._last_time) {\n                linkInfo._last_time = 0;\n            }\n        }\n    }\n\n    /* Called when something visually changed (not the graph!) */\n    change() {\n        if (LiteGraph.debug) {\n            console.log(\"Graph changed\");\n        }\n        this.sendActionToCanvas(\"setDirty\", [true, true]);\n        if (this.on_change) {\n            this.on_change(this);\n        }\n    }\n\n    setDirtyCanvas(fg, bg) {\n        this.sendActionToCanvas(\"setDirty\", [fg, bg]);\n    }\n\n    /**\n     * Destroys a link\n     * @method removeLink\n     * @param {Number} linkId\n     */\n    removeLink(linkId) {\n        const link = this.links[linkId];\n        if (!link) {\n            return;\n        }\n        const node = this.getNodeById(link.target_id);\n        if (node) {\n            node.disconnectInput(link.target_slot);\n        }\n    }\n\n    // save and recover app state ***************************************\n    /**\n     * Creates a Object containing all the info about this graph, it can be serialized\n     * @method serialize\n     * @return {Object} value of the node\n     */\n    serialize() {\n        const nodesInfo = [];\n        for (const node of this._nodes) {\n            nodesInfo.push(node.serialize());\n        }\n\n        // pack link info into a non-verbose format\n        const links = [];\n        // eslint-disable-next-line guard-for-in,no-restricted-syntax\n        for (const i in this.links) {\n            // links is an OBJECT\n            let link = this.links[i];\n            if (!link.serialize) {\n                // weird bug I havent solved yet\n                console.warn(\n                    \"weird LLink bug, link info is not a LLink but a regular object\",\n                );\n                const link2 = new LLink();\n                // eslint-disable-next-line guard-for-in,no-restricted-syntax\n                for (const j in link) {\n                    link2[j] = link[j];\n                }\n                this.links[i] = link2;\n                link = link2;\n            }\n\n            links.push(link.serialize());\n        }\n\n        const groupsInfo = [];\n        for (const group of this._groups) groupsInfo.push(group.serialize());\n\n        const data = {\n            last_node_id: this.last_node_id,\n            last_link_id: this.last_link_id,\n            nodes: nodesInfo,\n            links,\n            groups: groupsInfo,\n            config: this.config,\n            extra: this.extra,\n            version: LiteGraph.VERSION,\n        };\n\n        if (this.onSerialize) this.onSerialize(data);\n\n        return data;\n    }\n\n    /**\n     * Configure a graph from a JSON string\n     * @method configure\n     * @param {String} str configure a graph from a JSON string\n     * @param {Boolean} returns if there was any error parsing\n     */\n    configure(data, keepOld) {\n        if (!data) {\n            return;\n        }\n\n        if (!keepOld) this.clear();\n\n        const { nodes } = data;\n\n        // decode links info (they are very verbose)\n        if (data.links && data.links.constructor === Array) {\n            const links = [];\n            for (const linkData of data.links) {\n                if (!linkData) {\n                    console.warn(\"serialized graph link data contains errors, skipping.\");\n                    continue;\n                }\n                const link = new LLink();\n                link.configure(linkData);\n                links[link.id] = link;\n            }\n            data.links = links;\n        }\n\n        // copy all stored fields\n        // eslint-disable-next-line guard-for-in,no-restricted-syntax\n        for (const i in data) {\n            if (i === \"nodes\" || i === \"groups\") {\n                continue;\n            }\n            this[i] = data[i];\n        }\n\n        let error = false;\n\n        // create nodes\n        this._nodes = [];\n        if (nodes) {\n            for (const nInfo of nodes) {\n                let node = LiteGraph.createNode(nInfo.type, nInfo.title);\n                if (!node) {\n                    if (LiteGraph.debug) {\n                        console.log(\n                            `Node not found or has errors: ${nInfo.type}`,\n                        );\n                    }\n\n                    // in case of error we create a replacement node to avoid losing info\n                    node = new LGraphNode();\n                    node.last_serialization = nInfo;\n                    node.has_errors = true;\n                    error = true;\n                    // continue;\n                }\n\n                node.id = nInfo.id; // id it or it will create a new id\n                this.add(node, true); // add before configure, otherwise configure cannot create\n                // links\n            }\n\n            // configure nodes afterwards so they can reach each other\n            for (const nInfo of nodes) {\n                const node = this.getNodeById(nInfo.id);\n                if (node) {\n                    node.configure(nInfo);\n                }\n            }\n        }\n\n        // groups\n        this._groups.length = 0;\n        if (data.groups) {\n            for (const dataGroup of data.groups) {\n                const group = new LiteGraph.LGraphGroup();\n                group.configure(dataGroup);\n                this.add(group);\n            }\n        }\n\n        this.updateExecutionOrder();\n\n        this.extra = data.extra || {};\n\n        if (this.onConfigure) this.onConfigure(data);\n\n        this._version++;\n        this.setDirtyCanvas(true, true);\n        return error;\n    }\n\n    load(url, callback) {\n        const that = this;\n\n        // from file\n        if (url.constructor === File || url.constructor === Blob) {\n            const reader = new FileReader();\n            reader.addEventListener(\"load\", (event) => {\n                const data = JSON.parse(event.target.result);\n                that.configure(data);\n                if (callback) callback();\n            });\n\n            reader.readAsText(url);\n            return;\n        }\n\n        // is a string, then an URL\n        const req = new XMLHttpRequest();\n        req.open(\"GET\", url, true);\n        req.send(null);\n        req.onload(() => {\n            if (req.status !== 200) {\n                console.error(\"Error loading graph:\", req.status, req.response);\n                return;\n            }\n            const data = JSON.parse(req.response);\n            that.configure(data);\n            if (callback) callback();\n        });\n        req.onerror((err) => {\n            console.error(\"Error loading graph:\", err);\n        });\n    }\n\n    /**\n     * Node event manager\n     * @todo\n     * @param node\n     * @param msg\n     * @param color\n     */\n    onNodeTrace(node, msg, color) {\n        // TODO\n    }\n}\n","export default class LLink {\n    constructor(id, type, origin_id, origin_slot, target_id, target_slot) {\n        this.id = id;\n        this.type = type;\n        this.origin_id = origin_id;\n        this.origin_slot = origin_slot;\n        this.target_id = target_id;\n        this.target_slot = target_slot;\n\n        this._data = null;\n        this._pos = new Float32Array(2); // center\n    }\n\n    configure(o) {\n        if (o.constructor === Array) {\n            this.id = o[0];\n            this.origin_id = o[1];\n            this.origin_slot = o[2];\n            this.target_id = o[3];\n            this.target_slot = o[4];\n            this.type = o[5];\n        } else {\n            this.id = o.id;\n            this.type = o.type;\n            this.origin_id = o.origin_id;\n            this.origin_slot = o.origin_slot;\n            this.target_id = o.target_id;\n            this.target_slot = o.target_slot;\n        }\n    }\n\n    serialize() {\n        return [\n            this.id,\n            this.origin_id,\n            this.origin_slot,\n            this.target_id,\n            this.target_slot,\n            this.type,\n        ];\n    }\n}\n","import LiteGraph from \"./litegraph\";\n\n/*\ntitle: string\npos: [x,y]\nsize: [x,y]\n\ninput|output: every connection\n+  { name:string, type:string, pos: [x,y]=Optional, direction: \"input\"|\"output\", links: Array });\n\ngeneral properties:\n+ clip_area: if you render outside the node, it will be clipped\n+ unsafe_execution: not allowed for safe execution\n+ skip_repeated_outputs: when adding new outputs, it wont show if there is one already connected\n+ resizable: if set to false it wont be resizable with the mouse\n+ horizontal: slots are distributed horizontally\n+ widgets_start_y: widgets start at y distance from the top of the node\n\nflags object:\n+ collapsed: if it is collapsed\n\nsupported callbacks:\n+ onAdded: when added to graph (warning: this is called BEFORE the node is configured when loading)\n+ onRemoved: when removed from graph\n+ onStart:\twhen the graph starts playing\n+ onStop:\twhen the graph stops playing\n+ onDrawForeground: render the inside widgets inside the node\n+ onDrawBackground: render the background area inside the node (only in edit mode)\n+ onMouseDown\n+ onMouseMove\n+ onMouseUp\n+ onMouseEnter\n+ onMouseLeave\n+ onExecute: execute the node\n+ onPropertyChanged: when a property is changed in the panel (return true to skip default behaviour)\n+ onGetInputs: returns an array of possible inputs\n+ onGetOutputs: returns an array of possible outputs\n+ onBounding: in case this node has a bigger bounding than the node itself (the callback receives the bounding as [x,y,w,h])\n+ onDblClick: double clicked in the node\n+ onInputDblClick: input slot double clicked (can be used to automatically create a node connected)\n+ onOutputDblClick: output slot double clicked (can be used to automatically create a node connected)\n+ onConfigure: called after the node has been configured\n+ onSerialize: to add extra info when serializing (the callback receives the object that should be filled with the data)\n+ onSelected\n+ onDeselected\n+ onDropItem : DOM item dropped over the node\n+ onDropFile : file dropped over the node\n+ onConnectInput : if returns false the incoming connection will be canceled\n+ onConnectionsChange : a connection changed (new one or removed) (LiteGraph.INPUT or LiteGraph.OUTPUT, slot, true if connected, link_info, input_info )\n+ onAction: action slot triggered\n+ getExtraMenuOptions: to add option to context menu\n*/\n\n/**\n * Base Class for all the node type classes\n * @class LGraphNode\n * @param {String} title a name for the node\n */\n\nexport default class LGraphNode {\n    constructor(title) {\n        this._ctor(title);\n        this.title = title || \"Unnamed\";\n        this.size = [LiteGraph.NODE_WIDTH, 60];\n        this.graph = null;\n        this.id = -1; // not know till not added\n        this.type = null;\n        // inputs available: array of inputs\n        this.inputs = [];\n        this.outputs = [];\n        this.connections = [];\n\n        // local data\n        this.properties = {}; // for the values\n        this.properties_info = []; // for the info\n\n        this.flags = {};\n    }\n\n    /**\n     * Internal position array\n     * @internal\n     * @type {Float32Array}\n     * @private\n     */\n    _pos = new Float32Array(10, 10)\n\n    set pos(v) {\n        if (!v || v.length < 2) {\n            return;\n        }\n        this._pos[0] = v[0];\n        this._pos[1] = v[1];\n    }\n\n    get pos() {\n        return this._pos;\n    }\n\n    /**\n     * configure a node from an object containing the serialized info\n     * @method configure\n     */\n    configure(info) {\n        if (this.graph) {\n            this.graph._version++;\n        }\n        // eslint-disable-next-line guard-for-in,no-restricted-syntax\n        for (const j in info) {\n            if (j === \"properties\") {\n                // i don't want to clone properties, I want to reuse the old container\n                // eslint-disable-next-line guard-for-in,no-restricted-syntax\n                for (const k in info.properties) {\n                    this.properties[k] = info.properties[k];\n                    if (this.onPropertyChanged) {\n                        this.onPropertyChanged(k, info.properties[k]);\n                    }\n                }\n                continue;\n            }\n\n            if (info[j] == null) {\n                continue;\n            } else if (typeof info[j] === \"object\") {\n                // object\n                if (this[j] && this[j].configure) {\n                    this[j].configure(info[j]);\n                } else {\n                    this[j] = LiteGraph.cloneObject(info[j], this[j]);\n                }\n            } else {\n                this[j] = info[j];\n            }\n        }\n\n        if (!info.title) {\n            this.title = this.constructor.title;\n        }\n\n        if (this.onConnectionsChange) {\n            if (this.inputs) {\n                for (let i = 0; i < this.inputs.length; ++i) {\n                    const input = this.inputs[i];\n                    const linkInfo = this.graph\n                        ? this.graph.links[input.link]\n                        : null;\n                    this.onConnectionsChange(\n                        LiteGraph.INPUT,\n                        i,\n                        true,\n                        linkInfo,\n                        input,\n                    ); // linkInfo has been created now, so its updated\n                }\n            }\n\n            if (this.outputs) {\n                for (let i = 0; i < this.outputs.length; ++i) {\n                    const output = this.outputs[i];\n                    if (!output.links) {\n                        continue;\n                    }\n                    for (let j = 0; j < output.links.length; ++j) {\n                        const linkInfo = this.graph\n                            ? this.graph.links[output.links[j]]\n                            : null;\n                        this.onConnectionsChange(\n                            LiteGraph.OUTPUT,\n                            i,\n                            true,\n                            linkInfo,\n                            output,\n                        ); // link_info has been created now, so its updated\n                    }\n                }\n            }\n        }\n\n        if (this.widgets) {\n            for (const widget of this.widgets) {\n                if (!widget) continue;\n                if (widget.options\n                    && widget.options.property\n                    // eslint-disable-next-line max-len\n                    && this.properties[widget.options.property]) widget.value = JSON.parse(JSON.stringify(this.properties[widget.options.property]));\n            }\n            if (info.widgets_values) {\n                for (let i = 0; i < info.widgets_values.length; ++i) {\n                    if (this.widgets[i]) {\n                        this.widgets[i].value = info.widgets_values[i];\n                    }\n                }\n            }\n        }\n\n        if (this.onConfigure) {\n            this.onConfigure(info);\n        }\n    }\n\n    /**\n     * serialize the content\n     * @method serialize\n     */\n\n    serialize() {\n        // create serialization object\n        const o = {\n            id: this.id,\n            type: this.type,\n            pos: this.pos,\n            size: this.size,\n            flags: LiteGraph.cloneObject(this.flags),\n            order: this.order,\n            mode: this.mode,\n        };\n\n        // special case for when there were errors\n        if (this.constructor === LGraphNode && this.last_serialization) {\n            return this.last_serialization;\n        }\n\n        if (this.inputs) {\n            o.inputs = this.inputs;\n        }\n\n        if (this.outputs) {\n            // clear outputs last data (because data in connections is never serialized but stored\n            // inside the outputs info)\n            for (let i = 0; i < this.outputs.length; i++) {\n                delete this.outputs[i]._data;\n            }\n            o.outputs = this.outputs;\n        }\n\n        if (this.title && this.title != this.constructor.title) {\n            o.title = this.title;\n        }\n\n        if (this.properties) {\n            o.properties = LiteGraph.cloneObject(this.properties);\n        }\n\n        if (this.widgets && this.serialize_widgets) {\n            o.widgets_values = [];\n            for (let i = 0; i < this.widgets.length; ++i) {\n                if (this.widgets[i]) {\n                    o.widgets_values[i] = this.widgets[i].value;\n                } else {\n                    o.widgets_values[i] = null;\n                }\n            }\n        }\n\n        if (!o.type) o.type = this.constructor.type;\n\n        if (this.color) o.color = this.color;\n        if (this.bgcolor) o.bgcolor = this.bgcolor;\n        if (this.boxcolor) o.boxcolor = this.boxcolor;\n        if (this.shape) o.shape = this.shape;\n\n        if (this.onSerialize) {\n            if (this.onSerialize(o)) {\n                console.warn(\n                    \"node onSerialize shouldnt return anything, data should be stored in the object pass in the first parameter\",\n                );\n            }\n        }\n\n        return o;\n    }\n\n    /* Creates a clone of this node */\n    clone() {\n        const node = LiteGraph.createNode(this.type);\n        if (!node) {\n            return null;\n        }\n\n        // we clone it because serialize returns shared containers\n        const data = LiteGraph.cloneObject(this.serialize());\n\n        // remove links\n        if (data.inputs) {\n            for (let i = 0; i < data.inputs.length; ++i) {\n                data.inputs[i].link = null;\n            }\n        }\n\n        if (data.outputs) {\n            for (let i = 0; i < data.outputs.length; ++i) {\n                if (data.outputs[i].links) {\n                    data.outputs[i].links.length = 0;\n                }\n            }\n        }\n\n        delete data.id;\n        // remove links\n        node.configure(data);\n\n        return node;\n    }\n\n    /**\n     * serialize and stringify\n     * @method toString\n     */\n\n    toString() {\n        return JSON.stringify(this.serialize());\n    }\n    // deserialize = function(info) {} //this cannot be done from within, must\n    // be done in LiteGraph\n\n    /**\n     * get the title string\n     * @method getTitle\n     */\n\n    getTitle() {\n        return this.title || this.constructor.title;\n    }\n\n    /**\n     * sets the value of a property\n     * @method setProperty\n     * @param {String} name\n     * @param {*} value\n     */\n    setProperty(name, value) {\n        if (!this.properties) {\n            this.properties = {};\n        }\n        if (value === this.properties[name]) return;\n        const prevValue = this.properties[name];\n        this.properties[name] = value;\n        if (this.onPropertyChanged) {\n            if (this.onPropertyChanged(name, value, prevValue) === false) {\n                this.properties[name] = prevValue;\n            }\n        }\n        if (this.widgets) {\n            for (let i = 0; i < this.widgets.length; ++i) {\n                const w = this.widgets[i];\n                if (!w) continue;\n                if (w.options.property == name) {\n                    w.value = value;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Execution *************************\n    /**\n     * sets the output data\n     * @method setOutputData\n     * @param {number} slot\n     * @param {*} data\n     */\n    setOutputData(slot, data) {\n        if (!this.outputs) {\n            return;\n        }\n\n        // this maybe slow and a niche case\n        // if(slot && slot.constructor === String)\n        //\tslot = this.findOutputSlot(slot);\n\n        if (slot == -1 || slot >= this.outputs.length) {\n            return;\n        }\n\n        const output_info = this.outputs[slot];\n        if (!output_info) {\n            return;\n        }\n\n        // store data in the output itself in case we want to debug\n        output_info._data = data;\n\n        // if there are connections, pass the data to the connections\n        if (this.outputs[slot].links) {\n            for (let i = 0; i < this.outputs[slot].links.length; i++) {\n                const link_id = this.outputs[slot].links[i];\n                const link = this.graph.links[link_id];\n                if (link) link.data = data;\n            }\n        }\n    }\n\n    /**\n     * sets the output data type, useful when you want to be able to overwrite the data type\n     * @method setOutputDataType\n     * @param {number} slot\n     * @param {String} datatype\n     */\n    setOutputDataType(slot, type) {\n        if (!this.outputs) {\n            return;\n        }\n        if (slot == -1 || slot >= this.outputs.length) {\n            return;\n        }\n        const output_info = this.outputs[slot];\n        if (!output_info) {\n            return;\n        }\n        // store data in the output itself in case we want to debug\n        output_info.type = type;\n\n        // if there are connections, pass the data to the connections\n        if (this.outputs[slot].links) {\n            for (let i = 0; i < this.outputs[slot].links.length; i++) {\n                const link_id = this.outputs[slot].links[i];\n                this.graph.links[link_id].type = type;\n            }\n        }\n    }\n\n    /**\n     * Retrieves the input data (data traveling through the connection) from one slot\n     * @method getInputData\n     * @param {number} slot\n     * @param {boolean} force_update if set to true it will force the connected node of this slot\n     *     to output data into this link\n     * @return {*} data or if it is not connected returns undefined\n     */\n    getInputData(slot, force_update) {\n        if (!this.inputs) {\n            return;\n        } // undefined;\n\n        if (slot >= this.inputs.length || this.inputs[slot].link == null) {\n            return;\n        }\n\n        const link_id = this.inputs[slot].link;\n        const link = this.graph.links[link_id];\n        if (!link) {\n            // bug: weird case but it happens sometimes\n            return null;\n        }\n\n        if (!force_update) {\n            return link.data;\n        }\n\n        // special case: used to extract data from the incoming connection before the graph has\n        // been executed\n        const node = this.graph.getNodeById(link.origin_id);\n        if (!node) {\n            return link.data;\n        }\n\n        if (node.updateOutputData) {\n            node.updateOutputData(link.origin_slot);\n        } else if (node.onExecute) {\n            node.onExecute();\n        }\n\n        return link.data;\n    }\n\n    /**\n     * Retrieves the input data type (in case this supports multiple input types)\n     * @method getInputDataType\n     * @param {number} slot\n     * @return {String} datatype in string format\n     */\n    getInputDataType(slot) {\n        if (!this.inputs) {\n            return null;\n        } // undefined;\n\n        if (slot >= this.inputs.length || this.inputs[slot].link == null) {\n            return null;\n        }\n        const link_id = this.inputs[slot].link;\n        const link = this.graph.links[link_id];\n        if (!link) {\n            // bug: weird case but it happens sometimes\n            return null;\n        }\n        const node = this.graph.getNodeById(link.origin_id);\n        if (!node) {\n            return link.type;\n        }\n        const output_info = node.outputs[link.origin_slot];\n        if (output_info) {\n            return output_info.type;\n        }\n        return null;\n    }\n\n    /**\n     * Retrieves the input data from one slot using its name instead of slot number\n     * @method getInputDataByName\n     * @param {String} slot_name\n     * @param {boolean} force_update if set to true it will force the connected node of this slot\n     *     to output data into this link\n     * @return {*} data or if it is not connected returns null\n     */\n    getInputDataByName(\n        slot_name,\n        force_update,\n    ) {\n        const slot = this.findInputSlot(slot_name);\n        if (slot == -1) {\n            return null;\n        }\n        return this.getInputData(slot, force_update);\n    }\n\n    /**\n     * tells you if there is a connection in one input slot\n     * @method isInputConnected\n     * @param {number} slot\n     * @return {boolean}\n     */\n    isInputConnected(slot) {\n        if (!this.inputs) {\n            return false;\n        }\n        return slot < this.inputs.length && this.inputs[slot].link != null;\n    }\n\n    /**\n     * tells you info about an input connection (which node, type, etc)\n     * @method getInputInfo\n     * @param {number} slot\n     * @return {Object} object or null { link: id, name: string, type: string or 0 }\n     */\n    getInputInfo(slot) {\n        if (!this.inputs) {\n            return null;\n        }\n        if (slot < this.inputs.length) {\n            return this.inputs[slot];\n        }\n        return null;\n    }\n\n    /**\n     * Returns the link info in the connection of an input slot\n     * @method getInputLink\n     * @param {number} slot\n     * @return {LLink} object or null\n     */\n    getInputLink(slot) {\n        if (!this.inputs) {\n            return null;\n        }\n        if (slot < this.inputs.length) {\n            const slot_info = this.inputs[slot];\n            return this.graph.links[slot_info.link];\n        }\n        return null;\n    }\n\n    /**\n     * returns the node connected in the input slot\n     * @method getInputNode\n     * @param {number} slot\n     * @return {LGraphNode} node or null\n     */\n    getInputNode(slot) {\n        if (!this.inputs) {\n            return null;\n        }\n        if (slot >= this.inputs.length) {\n            return null;\n        }\n        const input = this.inputs[slot];\n        if (!input || input.link === null) {\n            return null;\n        }\n        const link_info = this.graph.links[input.link];\n        if (!link_info) {\n            return null;\n        }\n        return this.graph.getNodeById(link_info.origin_id);\n    }\n\n    /**\n     * returns the value of an input with this name, otherwise checks if there is a property with\n     * that name\n     * @method getInputOrProperty\n     * @param {string} name\n     * @return {*} value\n     */\n    getInputOrProperty(name) {\n        if (!this.inputs || !this.inputs.length) {\n            return this.properties ? this.properties[name] : null;\n        }\n\n        for (let i = 0, l = this.inputs.length; i < l; ++i) {\n            const input_info = this.inputs[i];\n            if (name == input_info.name && input_info.link != null) {\n                const link = this.graph.links[input_info.link];\n                if (link) {\n                    return link.data;\n                }\n            }\n        }\n        return this.properties[name];\n    }\n\n    /**\n     * tells you the last output data that went in that slot\n     * @method getOutputData\n     * @param {number} slot\n     * @return {Object}  object or null\n     */\n    getOutputData(slot) {\n        if (!this.outputs) {\n            return null;\n        }\n        if (slot >= this.outputs.length) {\n            return null;\n        }\n\n        const info = this.outputs[slot];\n        return info._data;\n    }\n\n    /**\n     * tells you info about an output connection (which node, type, etc)\n     * @method getOutputInfo\n     * @param {number} slot\n     * @return {Object}  object or null { name: string, type: string, links: [ ids of links in\n     *     number ] }\n     */\n    getOutputInfo(slot) {\n        if (!this.outputs) {\n            return null;\n        }\n        if (slot < this.outputs.length) {\n            return this.outputs[slot];\n        }\n        return null;\n    }\n\n    /**\n     * tells you if there is a connection in one output slot\n     * @method isOutputConnected\n     * @param {number} slot\n     * @return {boolean}\n     */\n    isOutputConnected(slot) {\n        if (!this.outputs) {\n            return false;\n        }\n        return (\n            slot < this.outputs.length\n            && this.outputs[slot].links\n            && this.outputs[slot].links.length\n        );\n    }\n\n    /**\n     * tells you if there is any connection in the output slots\n     * @method isAnyOutputConnected\n     * @return {boolean}\n     */\n    isAnyOutputConnected() {\n        if (!this.outputs) {\n            return false;\n        }\n        for (let i = 0; i < this.outputs.length; ++i) {\n            if (this.outputs[i].links && this.outputs[i].links.length) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * retrieves all the nodes connected to this output slot\n     * @method getOutputNodes\n     * @param {number} slot\n     * @return {array}\n     */\n    getOutputNodes(slot) {\n        if (!this.outputs || this.outputs.length == 0) {\n            return null;\n        }\n\n        if (slot >= this.outputs.length) {\n            return null;\n        }\n\n        const output = this.outputs[slot];\n        if (!output.links || output.links.length == 0) {\n            return null;\n        }\n\n        const r = [];\n        for (let i = 0; i < output.links.length; i++) {\n            const link_id = output.links[i];\n            const link = this.graph.links[link_id];\n            if (link) {\n                const target_node = this.graph.getNodeById(link.target_id);\n                if (target_node) {\n                    r.push(target_node);\n                }\n            }\n        }\n        return r;\n    }\n\n    /**\n     * Triggers an event in this node, this will trigger any output with the same name\n     * @method trigger\n     * @param {String} event name ( \"on_play\", ... ) if action is equivalent to false then the\n     *     event is send to all\n     * @param {*} param\n     */\n    trigger(action, param) {\n        if (!this.outputs || !this.outputs.length) {\n            return;\n        }\n\n        if (this.graph) this.graph._last_trigger_time = LiteGraph.getTime();\n\n        for (let i = 0; i < this.outputs.length; ++i) {\n            const output = this.outputs[i];\n            if (!output || output.type !== LiteGraph.EVENT || (action && output.name != action)) continue;\n            this.triggerSlot(i, param);\n        }\n    }\n\n    /**\n     * Triggers an slot event in this node\n     * @method triggerSlot\n     * @param {Number} slot the index of the output slot\n     * @param {*} param\n     * @param {Number} link_id [optional] in case you want to trigger and specific output link in a\n     *     slot\n     */\n    triggerSlot(slot, param, link_id) {\n        if (!this.outputs) {\n            return;\n        }\n\n        const output = this.outputs[slot];\n        if (!output) {\n            return;\n        }\n\n        const { links } = output;\n        if (!links || !links.length) {\n            return;\n        }\n\n        if (this.graph) {\n            this.graph._last_trigger_time = LiteGraph.getTime();\n        }\n\n        // for every link attached here\n        for (let k = 0; k < links.length; ++k) {\n            const id = links[k];\n            if (link_id != null && link_id != id) {\n                // to skip links\n                continue;\n            }\n            const link_info = this.graph.links[links[k]];\n            if (!link_info) {\n                // not connected\n                continue;\n            }\n            link_info._last_time = LiteGraph.getTime();\n            const node = this.graph.getNodeById(link_info.target_id);\n            if (!node) {\n                // node not found?\n                continue;\n            }\n\n            // used to mark events in graph\n            const target_connection = node.inputs[link_info.target_slot];\n\n            if (node.mode === LiteGraph.ON_TRIGGER) {\n                if (node.onExecute) {\n                    node.onExecute(param);\n                }\n            } else if (node.onAction) {\n                node.onAction(target_connection.name, param);\n            }\n        }\n    }\n\n    /**\n     * clears the trigger slot animation\n     * @method clearTriggeredSlot\n     * @param {Number} slot the index of the output slot\n     * @param {Number} link_id [optional] in case you want to trigger and specific output link in a\n     *     slot\n     */\n    clearTriggeredSlot(slot, link_id) {\n        if (!this.outputs) {\n            return;\n        }\n\n        const output = this.outputs[slot];\n        if (!output) {\n            return;\n        }\n\n        const { links } = output;\n        if (!links || !links.length) {\n            return;\n        }\n\n        // for every link attached here\n        for (let k = 0; k < links.length; ++k) {\n            const id = links[k];\n            if (link_id != null && link_id != id) {\n                // to skip links\n                continue;\n            }\n            const link_info = this.graph.links[links[k]];\n            if (!link_info) {\n                // not connected\n                continue;\n            }\n            link_info._last_time = 0;\n        }\n    }\n\n    /**\n     * changes node size and triggers callback\n     * @method setSize\n     * @param {vec2} size\n     */\n    setSize(size) {\n        this.size = size;\n        if (this.onResize) this.onResize(this.size);\n    }\n\n    /**\n     * add a new property to this node\n     * @method addProperty\n     * @param {string} name\n     * @param {*} default_value\n     * @param {string} type string defining the output type (\"vec3\",\"number\",...)\n     * @param {Object} extra_info this can be used to have special properties of the property (like\n     *     values, etc)\n     */\n    addProperty(\n        name,\n        default_value,\n        type,\n        extra_info,\n    ) {\n        const o = {\n            name,\n            type,\n            default_value,\n        };\n        if (extra_info) {\n            for (const i in extra_info) {\n                o[i] = extra_info[i];\n            }\n        }\n        if (!this.properties_info) {\n            this.properties_info = [];\n        }\n        this.properties_info.push(o);\n        if (!this.properties) {\n            this.properties = {};\n        }\n        this.properties[name] = default_value;\n        return o;\n    }\n\n    // connections\n\n    /**\n     * add a new output slot to use in this node\n     * @method addOutput\n     * @param {string} name\n     * @param {string} type string defining the output type (\"vec3\",\"number\",...)\n     * @param {Object} extra_info this can be used to have special properties of an output (label,\n     *     special color, position, etc)\n     */\n    addOutput(name, type, extra_info) {\n        const o = {\n            name,\n            type,\n            links: null,\n        };\n        if (extra_info) {\n            for (const i in extra_info) {\n                o[i] = extra_info[i];\n            }\n        }\n\n        if (!this.outputs) {\n            this.outputs = [];\n        }\n        this.outputs.push(o);\n        if (this.onOutputAdded) {\n            this.onOutputAdded(o);\n        }\n        this.setSize(this.computeSize());\n        this.setDirtyCanvas(true, true);\n        return o;\n    }\n\n    /**\n     * add a new output slot to use in this node\n     * @method addOutputs\n     * @param {Array} array of triplets like [[name,type,extra_info],[...]]\n     */\n    addOutputs(array) {\n        for (let i = 0; i < array.length; ++i) {\n            const info = array[i];\n            const o = {\n                name: info[0],\n                type: info[1],\n                link: null,\n            };\n            if (array[2]) {\n                for (const j in info[2]) {\n                    o[j] = info[2][j];\n                }\n            }\n\n            if (!this.outputs) {\n                this.outputs = [];\n            }\n            this.outputs.push(o);\n            if (this.onOutputAdded) {\n                this.onOutputAdded(o);\n            }\n        }\n\n        this.setSize(this.computeSize());\n        this.setDirtyCanvas(true, true);\n    }\n\n    /**\n     * remove an existing output slot\n     * @method removeOutput\n     * @param {number} slot\n     */\n    removeOutput(slot) {\n        this.disconnectOutput(slot);\n        this.outputs.splice(slot, 1);\n        for (let i = slot; i < this.outputs.length; ++i) {\n            if (!this.outputs[i] || !this.outputs[i].links) {\n                continue;\n            }\n            const { links } = this.outputs[i];\n            for (let j = 0; j < links.length; ++j) {\n                const link = this.graph.links[links[j]];\n                if (!link) {\n                    continue;\n                }\n                link.origin_slot -= 1;\n            }\n        }\n\n        this.setSize(this.computeSize());\n        if (this.onOutputRemoved) {\n            this.onOutputRemoved(slot);\n        }\n        this.setDirtyCanvas(true, true);\n    }\n\n    /**\n     * add a new input slot to use in this node\n     * @method addInput\n     * @param {string} name\n     * @param {string} type string defining the input type (\"vec3\",\"number\",...), it its a generic\n     *     one use 0\n     * @param {Object} extra_info this can be used to have special properties of an input (label,\n     *     color, position, etc)\n     */\n    addInput(name, type, extra_info) {\n        type = type || 0;\n        const o = {\n            name,\n            type,\n            link: null,\n        };\n        if (extra_info) {\n            for (const i in extra_info) {\n                o[i] = extra_info[i];\n            }\n        }\n\n        if (!this.inputs) {\n            this.inputs = [];\n        }\n\n        this.inputs.push(o);\n        this.setSize(this.computeSize());\n\n        if (this.onInputAdded) {\n            this.onInputAdded(o);\n        }\n\n        this.setDirtyCanvas(true, true);\n        return o;\n    }\n\n    /**\n     * add several new input slots in this node\n     * @method addInputs\n     * @param {Array} array of triplets like [[name,type,extra_info],[...]]\n     */\n    addInputs(array) {\n        for (let i = 0; i < array.length; ++i) {\n            const info = array[i];\n            const o = {\n                name: info[0],\n                type: info[1],\n                link: null,\n            };\n            if (array[2]) {\n                for (const j in info[2]) {\n                    o[j] = info[2][j];\n                }\n            }\n\n            if (!this.inputs) {\n                this.inputs = [];\n            }\n            this.inputs.push(o);\n            if (this.onInputAdded) {\n                this.onInputAdded(o);\n            }\n        }\n\n        this.setSize(this.computeSize());\n        this.setDirtyCanvas(true, true);\n    }\n\n    /**\n     * remove an existing input slot\n     * @method removeInput\n     * @param {number} slot\n     */\n    removeInput(slot) {\n        this.disconnectInput(slot);\n        const slot_info = this.inputs.splice(slot, 1);\n        for (let i = slot; i < this.inputs.length; ++i) {\n            if (!this.inputs[i]) {\n                continue;\n            }\n            const link = this.graph.links[this.inputs[i].link];\n            if (!link) {\n                continue;\n            }\n            link.target_slot -= 1;\n        }\n        this.setSize(this.computeSize());\n        if (this.onInputRemoved) {\n            this.onInputRemoved(slot, slot_info[0]);\n        }\n        this.setDirtyCanvas(true, true);\n    }\n\n    /**\n     * add an special connection to this node (used for special kinds of graphs)\n     * @method addConnection\n     * @param {string} name\n     * @param {string} type string defining the input type (\"vec3\",\"number\",...)\n     * @param {[x,y]} pos position of the connection inside the node\n     * @param {string} direction if is input or output\n     */\n    addConnection(name, type, pos, direction) {\n        const o = {\n            name,\n            type,\n            pos,\n            direction,\n            links: null,\n        };\n        this.connections.push(o);\n        return o;\n    }\n\n    /**\n     * computes the minimum size of a node according to its inputs and output slots\n     * @method computeSize\n     * @param {number} minHeight\n     * @return {number} the total size\n     */\n    computeSize(out) {\n        if (this.constructor.size) {\n            return this.constructor.size.concat();\n        }\n\n        let rows = Math.max(\n            this.inputs ? this.inputs.length : 1,\n            this.outputs ? this.outputs.length : 1,\n        );\n        const size = out || new Float32Array([0, 0]);\n        rows = Math.max(rows, 1);\n        var font_size = LiteGraph.NODE_TEXT_SIZE; // although it should be\n        // graphcanvas.inner_text_font size\n\n        var font_size = font_size;\n        const title_width = compute_text_size(this.title);\n        let input_width = 0;\n        let output_width = 0;\n\n        if (this.inputs) {\n            for (var i = 0, l = this.inputs.length; i < l; ++i) {\n                const input = this.inputs[i];\n                var text = input.label || input.name || \"\";\n                var text_width = compute_text_size(text);\n                if (input_width < text_width) {\n                    input_width = text_width;\n                }\n            }\n        }\n\n        if (this.outputs) {\n            for (var i = 0, l = this.outputs.length; i < l; ++i) {\n                const output = this.outputs[i];\n                var text = output.label || output.name || \"\";\n                var text_width = compute_text_size(text);\n                if (output_width < text_width) {\n                    output_width = text_width;\n                }\n            }\n        }\n\n        size[0] = Math.max(input_width + output_width + 10, title_width);\n        size[0] = Math.max(size[0], LiteGraph.NODE_WIDTH);\n        if (this.widgets && this.widgets.length) {\n            size[0] = Math.max(size[0], LiteGraph.NODE_WIDTH * 1.5);\n        }\n\n        size[1] = (this.constructor.slot_start_y || 0) + rows * LiteGraph.NODE_SLOT_HEIGHT;\n\n        let widgets_height = 0;\n        if (this.widgets && this.widgets.length) {\n            for (var i = 0, l = this.widgets.length; i < l; ++i) {\n                if (this.widgets[i].computeSize) {\n                    widgets_height += this.widgets[i].computeSize(size[0])[1] + 4;\n                } else {\n                    widgets_height += LiteGraph.NODE_WIDGET_HEIGHT + 4;\n                }\n            }\n            widgets_height += 8;\n        }\n\n        // compute height using widgets height\n        if (this.widgets_up) {\n            size[1] = Math.max(size[1], widgets_height);\n        } else if (this.widgets_start_y != null) {\n            size[1] = Math.max(size[1], widgets_height + this.widgets_start_y);\n        } else {\n            size[1] += widgets_height;\n        }\n\n        function compute_text_size(text) {\n            if (!text) {\n                return 0;\n            }\n            return font_size * text.length * 0.6;\n        }\n\n        if (\n            this.constructor.min_height\n            && size[1] < this.constructor.min_height\n        ) {\n            size[1] = this.constructor.min_height;\n        }\n\n        size[1] += 6; // margin\n\n        return size;\n    }\n\n    /**\n     * returns all the info available about a property of this node.\n     *\n     * @method getPropertyInfo\n     * @param {String} property name of the property\n     * @return {Object} the object with all the available info\n     */\n    getPropertyInfo(property) {\n        let info = null;\n\n        // there are several ways to define info about a property\n        // legacy mode\n        if (this.properties_info) {\n            for (let i = 0; i < this.properties_info.length; ++i) {\n                if (this.properties_info[i].name == property) {\n                    info = this.properties_info[i];\n                    break;\n                }\n            }\n        }\n        // litescene mode using the constructor\n        if (this.constructor[`@${property}`]) info = this.constructor[`@${property}`];\n\n        if (this.constructor.widgets_info && this.constructor.widgets_info[property]) info = this.constructor.widgets_info[property];\n\n        // litescene mode using the constructor\n        if (!info && this.onGetPropertyInfo) {\n            info = this.onGetPropertyInfo(property);\n        }\n\n        if (!info) info = {};\n        if (!info.type) info.type = typeof this.properties[property];\n        if (info.widget == \"combo\") info.type = \"enum\";\n\n        return info;\n    }\n\n    /**\n     * Defines a widget inside the node, it will be rendered on top of the node, you can control\n     * lots of properties\n     *\n     * @method addWidget\n     * @param {String} type the widget type (could be \"number\",\"string\",\"combo\"\n     * @param {String} name the text to show on the widget\n     * @param {String} value the default value\n     * @param {Function|String} callback function to call when it changes (optionally, it can be\n     *     the name of the property to modify)\n     * @param {Object} options the object that contains special properties of this widget\n     * @return {Object} the created widget object\n     */\n    addWidget(type, name, value, callback, options) {\n        if (!this.widgets) {\n            this.widgets = [];\n        }\n\n        if (!options && callback && callback.constructor === Object) {\n            options = callback;\n            callback = null;\n        }\n\n        if (options && options.constructor === String) // options can be the property name\n        {\n            options = { property: options };\n        }\n\n        if (callback && callback.constructor === String) // callback can be the property name\n        {\n            if (!options) options = {};\n            options.property = callback;\n            callback = null;\n        }\n\n        if (callback && callback.constructor !== Function) {\n            console.warn(\"addWidget: callback must be a function\");\n            callback = null;\n        }\n\n        const w = {\n            type: type.toLowerCase(),\n            name,\n            value,\n            callback,\n            options: options || {},\n        };\n\n        if (w.options.y !== undefined) {\n            w.y = w.options.y;\n        }\n\n        if (!callback && !w.options.callback && !w.options.property) {\n            console.warn(\"LiteGraph addWidget(...) without a callback or property assigned\");\n        }\n        if (type == \"combo\" && !w.options.values) {\n            throw \"LiteGraph addWidget('combo',...) requires to pass values in options: { values:['red','blue'] }\";\n        }\n        this.widgets.push(w);\n        this.setSize(this.computeSize());\n        return w;\n    }\n\n    addCustomWidget(custom_widget) {\n        if (!this.widgets) {\n            this.widgets = [];\n        }\n        this.widgets.push(custom_widget);\n        return custom_widget;\n    }\n\n    /**\n     * returns the bounding of the object, used for rendering purposes\n     * bounding is: [topleft_cornerx, topleft_cornery, width, height]\n     * @method getBounding\n     * @return {Float32Array[4]} the total size\n     */\n    getBounding(out) {\n        out = out || new Float32Array(4);\n        out[0] = this.pos[0] - 4;\n        out[1] = this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT;\n        out[2] = this.size[0] + 4;\n        out[3] = this.size[1] + LiteGraph.NODE_TITLE_HEIGHT;\n\n        if (this.onBounding) {\n            this.onBounding(out);\n        }\n        return out;\n    }\n\n    /**\n     * checks if a point is inside the shape of a node\n     * @method isPointInside\n     * @param {number} x\n     * @param {number} y\n     * @return {boolean}\n     */\n    isPointInside(x, y, margin, skip_title) {\n        margin = margin || 0;\n\n        let margin_top = this.graph && this.graph.isLive() ? 0 : LiteGraph.NODE_TITLE_HEIGHT;\n        if (skip_title) {\n            margin_top = 0;\n        }\n        if (this.flags && this.flags.collapsed) {\n            // if ( distance([x,y], [this.pos[0] + this.size[0]*0.5, this.pos[1] +\n            // this.size[1]*0.5]) < LiteGraph.NODE_COLLAPSED_RADIUS)\n            if (\n                isInsideRectangle(\n                    x,\n                    y,\n                    this.pos[0] - margin,\n                    this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT - margin,\n                    (this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH)\n                    + 2 * margin,\n                    LiteGraph.NODE_TITLE_HEIGHT + 2 * margin,\n                )\n            ) {\n                return true;\n            }\n        } else if (\n            this.pos[0] - 4 - margin < x\n            && this.pos[0] + this.size[0] + 4 + margin > x\n            && this.pos[1] - margin_top - margin < y\n            && this.pos[1] + this.size[1] + margin > y\n        ) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * checks if a point is inside a node slot, and returns info about which slot\n     * @method getSlotInPosition\n     * @param {number} x\n     * @param {number} y\n     * @return {Object} if found the object contains { input|output: slot object, slot: number,\n     *     link_pos: [x,y] }\n     */\n    getSlotInPosition(x, y) {\n        // search for inputs\n        const link_pos = new Float32Array(2);\n        if (this.inputs) {\n            for (var i = 0, l = this.inputs.length; i < l; ++i) {\n                const input = this.inputs[i];\n                this.getConnectionPos(true, i, link_pos);\n                if (\n                    isInsideRectangle(\n                        x,\n                        y,\n                        link_pos[0] - 10,\n                        link_pos[1] - 5,\n                        20,\n                        10,\n                    )\n                ) {\n                    return {\n                        input,\n                        slot: i,\n                        link_pos,\n                    };\n                }\n            }\n        }\n\n        if (this.outputs) {\n            for (var i = 0, l = this.outputs.length; i < l; ++i) {\n                const output = this.outputs[i];\n                this.getConnectionPos(false, i, link_pos);\n                if (\n                    isInsideRectangle(\n                        x,\n                        y,\n                        link_pos[0] - 10,\n                        link_pos[1] - 5,\n                        20,\n                        10,\n                    )\n                ) {\n                    return {\n                        output,\n                        slot: i,\n                        link_pos,\n                    };\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * returns the input slot with a given name (used for dynamic slots), -1 if not found\n     * @method findInputSlot\n     * @param {string} name the name of the slot\n     * @return {number} the slot (-1 if not found)\n     */\n    findInputSlot(name) {\n        if (!this.inputs) {\n            return -1;\n        }\n        for (let i = 0, l = this.inputs.length; i < l; ++i) {\n            if (name == this.inputs[i].name) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * returns the output slot with a given name (used for dynamic slots), -1 if not found\n     * @method findOutputSlot\n     * @param {string} name the name of the slot\n     * @return {number} the slot (-1 if not found)\n     */\n    findOutputSlot(name) {\n        if (!this.outputs) {\n            return -1;\n        }\n        for (let i = 0, l = this.outputs.length; i < l; ++i) {\n            if (name == this.outputs[i].name) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * connect this node output to the input of another node\n     * @method connect\n     * @param {number_or_string} slot (could be the number of the slot or the string with the name\n     *     of the slot)\n     * @param {LGraphNode} node the target node\n     * @param {number_or_string} target_slot the input slot of the target node (could be the number\n     *     of the slot or the string with the name of the slot, or -1 to connect a trigger)\n     * @return {Object} the link_info is created, otherwise null\n     */\n    connect(slot, target_node, target_slot) {\n        target_slot = target_slot || 0;\n\n        if (!this.graph) {\n            // could be connected before adding it to a graph\n            console.log(\n                \"Connect: Error, node doesn't belong to any graph. Nodes must be added first to a graph before connecting them.\",\n            ); // due to link ids being associated with graphs\n            return null;\n        }\n\n        // seek for the output slot\n        if (slot.constructor === String) {\n            slot = this.findOutputSlot(slot);\n            if (slot == -1) {\n                if (LiteGraph.debug) {\n                    console.log(`Connect: Error, no slot of name ${slot}`);\n                }\n                return null;\n            }\n        } else if (!this.outputs || slot >= this.outputs.length) {\n            if (LiteGraph.debug) {\n                console.log(\"Connect: Error, slot number not found\");\n            }\n            return null;\n        }\n\n        if (target_node && target_node.constructor === Number) {\n            target_node = this.graph.getNodeById(target_node);\n        }\n        if (!target_node) {\n            throw \"target node is null\";\n        }\n\n        // avoid loopback\n        if (target_node == this) {\n            return null;\n        }\n\n        // you can specify the slot by name\n        if (target_slot.constructor === String) {\n            target_slot = target_node.findInputSlot(target_slot);\n            if (target_slot == -1) {\n                if (LiteGraph.debug) {\n                    console.log(\n                        `Connect: Error, no slot of name ${target_slot}`,\n                    );\n                }\n                return null;\n            }\n        } else if (target_slot === LiteGraph.EVENT) {\n            // search for first slot with event?\n            /*\n    //create input for trigger\n    var input = target_node.addInput(\"onTrigger\", LiteGraph.EVENT );\n    target_slot = target_node.inputs.length - 1; //last one is the one created\n    target_node.mode = LiteGraph.ON_TRIGGER;\n    */\n            return null;\n        } else if (\n            !target_node.inputs\n            || target_slot >= target_node.inputs.length\n        ) {\n            if (LiteGraph.debug) {\n                console.log(\"Connect: Error, slot number not found\");\n            }\n            return null;\n        }\n\n        let changed = false;\n\n        // if there is something already plugged there, disconnect\n        if (target_node.inputs[target_slot].link != null) {\n            this.graph.beforeChange();\n            target_node.disconnectInput(target_slot);\n            changed = true;\n        }\n\n        // why here??\n        // this.setDirtyCanvas(false,true);\n        // this.graph.connectionChange( this );\n\n        const output = this.outputs[slot];\n\n        // allows nodes to block connection\n        if (target_node.onConnectInput) {\n            if (target_node.onConnectInput(target_slot, output.type, output, this, slot) === false) {\n                return null;\n            }\n        }\n\n        const input = target_node.inputs[target_slot];\n        let link_info = null;\n\n        // this slots cannot be connected (different types)\n        if (!LiteGraph.isValidConnection(output.type, input.type)) {\n            this.setDirtyCanvas(false, true);\n            if (changed) this.graph.connectionChange(this, link_info);\n            return null;\n        }\n\n        if (!changed) this.graph.beforeChange();\n\n        // create link class\n        link_info = new LLink(\n            ++this.graph.last_link_id,\n            input.type,\n            this.id,\n            slot,\n            target_node.id,\n            target_slot,\n        );\n\n        // add to graph links list\n        this.graph.links[link_info.id] = link_info;\n\n        // connect in output\n        if (output.links == null) {\n            output.links = [];\n        }\n        output.links.push(link_info.id);\n        // connect in input\n        target_node.inputs[target_slot].link = link_info.id;\n        if (this.graph) {\n            this.graph._version++;\n        }\n        if (this.onConnectionsChange) {\n            this.onConnectionsChange(\n                LiteGraph.OUTPUT,\n                slot,\n                true,\n                link_info,\n                output,\n            );\n        } // link_info has been created now, so its updated\n        if (target_node.onConnectionsChange) {\n            target_node.onConnectionsChange(\n                LiteGraph.INPUT,\n                target_slot,\n                true,\n                link_info,\n                input,\n            );\n        }\n        if (this.graph && this.graph.onNodeConnectionChange) {\n            this.graph.onNodeConnectionChange(\n                LiteGraph.INPUT,\n                target_node,\n                target_slot,\n                this,\n                slot,\n            );\n            this.graph.onNodeConnectionChange(\n                LiteGraph.OUTPUT,\n                this,\n                slot,\n                target_node,\n                target_slot,\n            );\n        }\n\n        this.setDirtyCanvas(false, true);\n        this.graph.afterChange();\n        this.graph.connectionChange(this, link_info);\n\n        return link_info;\n    }\n\n    /**\n     * disconnect one output to an specific node\n     * @method disconnectOutput\n     * @param {number_or_string} slot (could be the number of the slot or the string with the name\n     *     of the slot)\n     * @param {LGraphNode} target_node the target node to which this slot is connected [Optional,\n     *     if not target_node is specified all nodes will be disconnected]\n     * @return {boolean} if it was disconnected successfully\n     */\n    disconnectOutput(slot, target_node) {\n        if (slot.constructor === String) {\n            slot = this.findOutputSlot(slot);\n            if (slot == -1) {\n                if (LiteGraph.debug) {\n                    console.log(`Connect: Error, no slot of name ${slot}`);\n                }\n                return false;\n            }\n        } else if (!this.outputs || slot >= this.outputs.length) {\n            if (LiteGraph.debug) {\n                console.log(\"Connect: Error, slot number not found\");\n            }\n            return false;\n        }\n\n        // get output slot\n        const output = this.outputs[slot];\n        if (!output || !output.links || output.links.length == 0) {\n            return false;\n        }\n\n        // one of the output links in this slot\n        if (target_node) {\n            if (target_node.constructor === Number) {\n                target_node = this.graph.getNodeById(target_node);\n            }\n            if (!target_node) {\n                throw \"Target Node not found\";\n            }\n\n            for (var i = 0, l = output.links.length; i < l; i++) {\n                var link_id = output.links[i];\n                var link_info = this.graph.links[link_id];\n\n                // is the link we are searching for...\n                if (link_info.target_id == target_node.id) {\n                    output.links.splice(i, 1); // remove here\n                    var input = target_node.inputs[link_info.target_slot];\n                    input.link = null; // remove there\n                    delete this.graph.links[link_id]; // remove the link from the links pool\n                    if (this.graph) {\n                        this.graph._version++;\n                    }\n                    if (target_node.onConnectionsChange) {\n                        target_node.onConnectionsChange(\n                            LiteGraph.INPUT,\n                            link_info.target_slot,\n                            false,\n                            link_info,\n                            input,\n                        );\n                    } // link_info hasn't been modified so its ok\n                    if (this.onConnectionsChange) {\n                        this.onConnectionsChange(\n                            LiteGraph.OUTPUT,\n                            slot,\n                            false,\n                            link_info,\n                            output,\n                        );\n                    }\n                    if (this.graph && this.graph.onNodeConnectionChange) {\n                        this.graph.onNodeConnectionChange(\n                            LiteGraph.OUTPUT,\n                            this,\n                            slot,\n                        );\n                    }\n                    if (this.graph && this.graph.onNodeConnectionChange) {\n                        this.graph.onNodeConnectionChange(\n                            LiteGraph.OUTPUT,\n                            this,\n                            slot,\n                        );\n                        this.graph.onNodeConnectionChange(\n                            LiteGraph.INPUT,\n                            target_node,\n                            link_info.target_slot,\n                        );\n                    }\n                    break;\n                }\n            }\n        } // all the links in this output slot\n        else {\n            for (var i = 0, l = output.links.length; i < l; i++) {\n                var link_id = output.links[i];\n                var link_info = this.graph.links[link_id];\n                if (!link_info) {\n                    // bug: it happens sometimes\n                    continue;\n                }\n\n                var target_node = this.graph.getNodeById(link_info.target_id);\n                var input = null;\n                if (this.graph) {\n                    this.graph._version++;\n                }\n                if (target_node) {\n                    input = target_node.inputs[link_info.target_slot];\n                    input.link = null; // remove other side link\n                    if (target_node.onConnectionsChange) {\n                        target_node.onConnectionsChange(\n                            LiteGraph.INPUT,\n                            link_info.target_slot,\n                            false,\n                            link_info,\n                            input,\n                        );\n                    } // link_info hasn't been modified so its ok\n                    if (this.graph && this.graph.onNodeConnectionChange) {\n                        this.graph.onNodeConnectionChange(\n                            LiteGraph.INPUT,\n                            target_node,\n                            link_info.target_slot,\n                        );\n                    }\n                }\n                delete this.graph.links[link_id]; // remove the link from the links pool\n                if (this.onConnectionsChange) {\n                    this.onConnectionsChange(\n                        LiteGraph.OUTPUT,\n                        slot,\n                        false,\n                        link_info,\n                        output,\n                    );\n                }\n                if (this.graph && this.graph.onNodeConnectionChange) {\n                    this.graph.onNodeConnectionChange(\n                        LiteGraph.OUTPUT,\n                        this,\n                        slot,\n                    );\n                    this.graph.onNodeConnectionChange(\n                        LiteGraph.INPUT,\n                        target_node,\n                        link_info.target_slot,\n                    );\n                }\n            }\n            output.links = null;\n        }\n\n        this.setDirtyCanvas(false, true);\n        this.graph.connectionChange(this);\n        return true;\n    }\n\n    /**\n     * disconnect one input\n     * @method disconnectInput\n     * @param {number_or_string} slot (could be the number of the slot or the string with the name\n     *     of the slot)\n     * @return {boolean} if it was disconnected successfully\n     */\n    disconnectInput(slot) {\n        // seek for the output slot\n        if (slot.constructor === String) {\n            slot = this.findInputSlot(slot);\n            if (slot == -1) {\n                if (LiteGraph.debug) {\n                    console.log(`Connect: Error, no slot of name ${slot}`);\n                }\n                return false;\n            }\n        } else if (!this.inputs || slot >= this.inputs.length) {\n            if (LiteGraph.debug) {\n                console.log(\"Connect: Error, slot number not found\");\n            }\n            return false;\n        }\n\n        const input = this.inputs[slot];\n        if (!input) {\n            return false;\n        }\n\n        const link_id = this.inputs[slot].link;\n        if (link_id != null) {\n            this.inputs[slot].link = null;\n\n            // remove other side\n            const link_info = this.graph.links[link_id];\n            if (link_info) {\n                const target_node = this.graph.getNodeById(link_info.origin_id);\n                if (!target_node) {\n                    return false;\n                }\n\n                const output = target_node.outputs[link_info.origin_slot];\n                if (!output || !output.links || output.links.length == 0) {\n                    return false;\n                }\n\n                // search in the inputs list for this link\n                for (var i = 0, l = output.links.length; i < l; i++) {\n                    if (output.links[i] == link_id) {\n                        output.links.splice(i, 1);\n                        break;\n                    }\n                }\n\n                delete this.graph.links[link_id]; // remove from the pool\n                if (this.graph) {\n                    this.graph._version++;\n                }\n                if (this.onConnectionsChange) {\n                    this.onConnectionsChange(\n                        LiteGraph.INPUT,\n                        slot,\n                        false,\n                        link_info,\n                        input,\n                    );\n                }\n                if (target_node.onConnectionsChange) {\n                    target_node.onConnectionsChange(\n                        LiteGraph.OUTPUT,\n                        i,\n                        false,\n                        link_info,\n                        output,\n                    );\n                }\n                if (this.graph && this.graph.onNodeConnectionChange) {\n                    this.graph.onNodeConnectionChange(\n                        LiteGraph.OUTPUT,\n                        target_node,\n                        i,\n                    );\n                    this.graph.onNodeConnectionChange(LiteGraph.INPUT, this, slot);\n                }\n            }\n        } // link != null\n\n        this.setDirtyCanvas(false, true);\n        if (this.graph) this.graph.connectionChange(this);\n        return true;\n    }\n\n    /**\n     * returns the center of a connection point in canvas coords\n     * @method getConnectionPos\n     * @param {boolean} is_input true if if a input slot, false if it is an output\n     * @param {number_or_string} slot (could be the number of the slot or the string with the name\n     *     of the slot)\n     * @param {vec2} out [optional] a place to store the output, to free garbage\n     * @return {[x,y]} the position\n     * */\n    getConnectionPos(\n        is_input,\n        slot_number,\n        out,\n    ) {\n        out = out || new Float32Array(2);\n        let num_slots = 0;\n        if (is_input && this.inputs) {\n            num_slots = this.inputs.length;\n        }\n        if (!is_input && this.outputs) {\n            num_slots = this.outputs.length;\n        }\n\n        const offset = LiteGraph.NODE_SLOT_HEIGHT * 0.5;\n\n        if (this.flags.collapsed) {\n            const w = this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH;\n            if (this.horizontal) {\n                out[0] = this.pos[0] + w * 0.5;\n                if (is_input) {\n                    out[1] = this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT;\n                } else {\n                    out[1] = this.pos[1];\n                }\n            } else {\n                if (is_input) {\n                    out[0] = this.pos[0];\n                } else {\n                    out[0] = this.pos[0] + w;\n                }\n                out[1] = this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT * 0.5;\n            }\n            return out;\n        }\n\n        // weird feature that never got finished\n        if (is_input && slot_number == -1) {\n            out[0] = this.pos[0] + LiteGraph.NODE_TITLE_HEIGHT * 0.5;\n            out[1] = this.pos[1] + LiteGraph.NODE_TITLE_HEIGHT * 0.5;\n            return out;\n        }\n\n        // hard-coded pos\n        if (\n            is_input\n            && num_slots > slot_number\n            && this.inputs[slot_number].pos\n        ) {\n            out[0] = this.pos[0] + this.inputs[slot_number].pos[0];\n            out[1] = this.pos[1] + this.inputs[slot_number].pos[1];\n            return out;\n        }\n        if (\n            !is_input\n            && num_slots > slot_number\n            && this.outputs[slot_number].pos\n        ) {\n            out[0] = this.pos[0] + this.outputs[slot_number].pos[0];\n            out[1] = this.pos[1] + this.outputs[slot_number].pos[1];\n            return out;\n        }\n\n        // horizontal distributed slots\n        if (this.horizontal) {\n            out[0] = this.pos[0] + (slot_number + 0.5) * (this.size[0] / num_slots);\n            if (is_input) {\n                out[1] = this.pos[1] - LiteGraph.NODE_TITLE_HEIGHT;\n            } else {\n                out[1] = this.pos[1] + this.size[1];\n            }\n            return out;\n        }\n\n        // default vertical slots\n        if (is_input) {\n            out[0] = this.pos[0] + offset;\n        } else {\n            out[0] = this.pos[0] + this.size[0] + 1 - offset;\n        }\n        out[1] = this.pos[1]\n            + (slot_number + 0.7) * LiteGraph.NODE_SLOT_HEIGHT\n            + (this.constructor.slot_start_y || 0);\n        return out;\n    }\n\n    /* Force align to grid */\n    alignToGrid() {\n        this.pos[0] = LiteGraph.CANVAS_GRID_SIZE\n            * Math.round(this.pos[0] / LiteGraph.CANVAS_GRID_SIZE);\n        this.pos[1] = LiteGraph.CANVAS_GRID_SIZE\n            * Math.round(this.pos[1] / LiteGraph.CANVAS_GRID_SIZE);\n    }\n\n    /* Console output */\n    trace(msg) {\n        if (!this.console) {\n            this.console = [];\n        }\n\n        this.console.push(msg);\n        if (this.console.length > LGraphNode.MAX_CONSOLE) {\n            this.console.shift();\n        }\n\n        if (this.graph.onNodeTrace) this.graph.onNodeTrace(this, msg);\n    }\n\n    /* Forces to redraw or the main canvas (LGraphNode) or the bg canvas (links) */\n    setDirtyCanvas(\n        dirty_foreground,\n        dirty_background,\n    ) {\n        if (!this.graph) {\n            return;\n        }\n        this.graph.sendActionToCanvas(\"setDirty\", [\n            dirty_foreground,\n            dirty_background,\n        ]);\n    }\n\n    loadImage(url) {\n        const img = new Image();\n        img.src = LiteGraph.node_images_path + url;\n        img.ready = false;\n\n        img.onload = () => {\n            img.ready = true;\n            this.setDirtyCanvas(true);\n        };\n        return img;\n    }\n\n    // safe LGraphNode action execution (not sure if safe)\n    /*\n    executeAction = function(action)\n    {\n    if(action == \"\") return false;\n\n    if( action.indexOf(\";\") != -1 || action.indexOf(\"}\") != -1)\n    {\n    this.trace(\"Error: Action contains unsafe characters\");\n    return false;\n    }\n\n    var tokens = action.split(\"(\");\n    var func_name = tokens[0];\n    if( typeof(this[func_name]) != \"function\")\n    {\n    this.trace(\"Error: Action not found on node: \" + func_name);\n    return false;\n    }\n\n    var code = action;\n\n    try\n    {\n    var _foo = eval;\n    eval = null;\n    (new Function(\"with(this) { \" + code + \"}\")).call(this);\n    eval = _foo;\n    }\n    catch (err)\n    {\n    this.trace(\"Error executing action {\" + action + \"} :\" + err);\n    return false;\n    }\n\n    return true;\n    }\n    */\n\n    /* Allows to get onMouseMove and onMouseUp events even if the mouse is out of focus */\n    captureInput(v) {\n        if (!this.graph || !this.graph.list_of_graphcanvas) {\n            return;\n        }\n\n        const list = this.graph.list_of_graphcanvas;\n\n        for (let i = 0; i < list.length; ++i) {\n            const c = list[i];\n            // releasing somebody elses capture?!\n            if (!v && c.node_capturing_input != this) {\n                continue;\n            }\n\n            // change\n            c.node_capturing_input = v ? this : null;\n        }\n    }\n\n    /**\n     * Collapse the node to make it smaller on the canvas\n     * @method collapse\n     * */\n    collapse(force) {\n        this.graph._version++;\n        if (this.constructor.collapsable === false && !force) {\n            return;\n        }\n        this.flags.collapsed = !this.flags.collapsed;\n        this.setDirtyCanvas(true, true);\n    }\n\n    /**\n     * Forces the node to do not move or realign on Z\n     * @method pin\n     * */\n\n    pin(v) {\n        this.graph._version++;\n        if (v === undefined) {\n            this.flags.pinned = !this.flags.pinned;\n        } else {\n            this.flags.pinned = v;\n        }\n    }\n\n    localToScreen(x, y, graphcanvas) {\n        return [\n            (x + this.pos[0]) * graphcanvas.scale + graphcanvas.offset[0],\n            (y + this.pos[1]) * graphcanvas.scale + graphcanvas.offset[1],\n        ];\n    }\n}\n","import LGraphNode from \"./LGraphNode\";\n\nexport default class LGraphGroup {\n    constructor(title) {\n        this._ctor(title);\n    }\n\n    _ctor(title) {\n        this.title = title || \"Group\";\n        this.font_size = 24;\n        this.color = LGraphCanvas.node_colors.pale_blue\n            ? LGraphCanvas.node_colors.pale_blue.groupcolor\n            : \"#AAA\";\n        this._bounding = new Float32Array([10, 10, 140, 80]);\n        this._pos = this._bounding.subarray(0, 2);\n        this._size = this._bounding.subarray(2, 4);\n        this._nodes = [];\n        this.graph = null;\n\n        Object.defineProperty(this, \"pos\", {\n            set(v) {\n                if (!v || v.length < 2) {\n                    return;\n                }\n                this._pos[0] = v[0];\n                this._pos[1] = v[1];\n            },\n            get() {\n                return this._pos;\n            },\n            enumerable: true,\n        });\n\n        Object.defineProperty(this, \"size\", {\n            set(v) {\n                if (!v || v.length < 2) {\n                    return;\n                }\n                this._size[0] = Math.max(140, v[0]);\n                this._size[1] = Math.max(80, v[1]);\n            },\n            get() {\n                return this._size;\n            },\n            enumerable: true,\n        });\n    }\n\n    recomputeInsideNodes() {\n        this._nodes.length = 0;\n        const nodes = this.graph._nodes;\n        const node_bounding = new Float32Array(4);\n\n        for (let i = 0; i < nodes.length; ++i) {\n            const node = nodes[i];\n            node.getBounding(node_bounding);\n            if (!overlapBounding(this._bounding, node_bounding)) {\n                continue;\n            } // out of the visible area\n            this._nodes.push(node);\n        }\n    }\n\n    move(deltax, deltay, ignore_nodes) {\n        this._pos[0] += deltax;\n        this._pos[1] += deltay;\n        if (ignore_nodes) {\n            return;\n        }\n        for (let i = 0; i < this._nodes.length; ++i) {\n            const node = this._nodes[i];\n            node.pos[0] += deltax;\n            node.pos[1] += deltay;\n        }\n    }\n\n    serialize() {\n        const b = this._bounding;\n        return {\n            title: this.title,\n            bounding: [\n                Math.round(b[0]),\n                Math.round(b[1]),\n                Math.round(b[2]),\n                Math.round(b[3]),\n            ],\n            color: this.color,\n            font: this.font,\n        };\n    }\n\n    configure(o) {\n        this.title = o.title;\n        this._bounding.set(o.bounding);\n        this.color = o.color;\n        this.font = o.font;\n    }\n\n    isPointInside = LGraphNode.prototype.isPointInside\n\n    setDirtyCanvas = LGraphNode.prototype.setDirtyCanvas\n}\n","// Creates an interface to access extra features from a graph (like play, stop, live, etc)\nimport LGraph from \"./LGraph\";\n\nexport default class Editor {\n    constructor(containerId, options) {\n        options = options || {};\n\n        // fill container\n        const html = \"<div class='content'><div class='editor-area'><canvas class='graphcanvas' width='1000' height='500' tabindex=10></canvas></div></div>\";\n\n        const root = document.createElement(\"div\");\n        this.root = root;\n        root.className = \"litegraph litegraph-editor\";\n        root.innerHTML = html;\n\n        this.content = root.querySelector(\".content\");\n        this.footer = root.querySelector(\".footer\");\n\n        const canvas = root.querySelector(\".graphcanvas\");\n\n        // create graph\n        const graph = (this.graph = new LGraph());\n        const graphcanvas = (this.graphcanvas = new LGraphCanvas(canvas, graph));\n        graphcanvas.background_image = \"imgs/grid.png\";\n        graph.onAfterExecute = function () {\n            graphcanvas.draw(true);\n        };\n\n        graphcanvas.onDropItem = this.onDropItem.bind(this);\n\n        if (options.miniwindow) {\n            this.addMiniWindow(300, 200);\n        }\n\n        // append to DOM\n        const parent = document.getElementById(containerId);\n        if (parent) {\n            parent.appendChild(root);\n        }\n\n        graphcanvas.resize();\n        // graphcanvas.draw(true,true);\n    }\n\n    onDropItem(e) {\n        for (const file of e.dataTransfer.files) {\n            const ext = LGraphCanvas.getFileExtension(file.name);\n            const reader = new FileReader();\n            if (ext === \"json\") {\n                reader.onload = (event) => {\n                    this.graph.configure(JSON.parse(event.target.result));\n                };\n                reader.readAsText(file);\n            }\n        }\n    }\n\n    addMiniWindow(w, h) {\n        const miniwindow = document.createElement(\"div\");\n        miniwindow.className = \"litegraph miniwindow\";\n        miniwindow.innerHTML = `<canvas class='graphcanvas' width='${\n            w\n        }' height='${\n            h\n        }' tabindex=10></canvas>`;\n        const canvas = miniwindow.querySelector(\"canvas\");\n        const that = this;\n\n        const graphcanvas = new LGraphCanvas(canvas, this.graph);\n        graphcanvas.show_info = false;\n        graphcanvas.background_image = \"imgs/grid.png\";\n        graphcanvas.scale = 0.25;\n        graphcanvas.allow_dragnodes = false;\n        graphcanvas.allow_interaction = false;\n        graphcanvas.render_shadows = false;\n        graphcanvas.max_zoom = 0.25;\n        this.miniwindow_graphcanvas = graphcanvas;\n        graphcanvas.onClear = function () {\n            graphcanvas.scale = 0.25;\n            graphcanvas.allow_dragnodes = false;\n            graphcanvas.allow_interaction = false;\n        };\n        graphcanvas.onRenderBackground = function (canvas, ctx) {\n            ctx.strokeStyle = \"#567\";\n            let tl = that.graphcanvas.convertOffsetToCanvas([0, 0]);\n            let br = that.graphcanvas.convertOffsetToCanvas([\n                that.graphcanvas.canvas.width,\n                that.graphcanvas.canvas.height,\n            ]);\n            tl = this.convertCanvasToOffset(tl);\n            br = this.convertCanvasToOffset(br);\n            ctx.lineWidth = 1;\n            ctx.strokeRect(\n                Math.floor(tl[0]) + 0.5,\n                Math.floor(tl[1]) + 0.5,\n                Math.floor(br[0] - tl[0]),\n                Math.floor(br[1] - tl[1]),\n            );\n        };\n\n        miniwindow.style.position = \"absolute\";\n        miniwindow.style.top = \"4px\";\n        miniwindow.style.right = \"4px\";\n\n        const close_button = document.createElement(\"div\");\n        close_button.className = \"corner-button\";\n        close_button.innerHTML = \"&#10060;\";\n        close_button.addEventListener(\"click\", (e) => {\n            graphcanvas.setGraph(null);\n            miniwindow.parentNode.removeChild(miniwindow);\n        });\n        miniwindow.appendChild(close_button);\n\n        this.root.querySelector(\".content\").appendChild(miniwindow);\n    }\n}\n"],"names":["LiteGraph","VERSION","CANVAS_GRID_SIZE","NODE_TITLE_HEIGHT","NODE_TITLE_TEXT_Y","NODE_SLOT_HEIGHT","NODE_WIDGET_HEIGHT","NODE_WIDTH","NODE_MIN_WIDTH","NODE_COLLAPSED_RADIUS","NODE_COLLAPSED_WIDTH","NODE_TITLE_COLOR","NODE_SELECTED_TITLE_COLOR","NODE_TEXT_SIZE","NODE_TEXT_COLOR","NODE_SUBTEXT_SIZE","NODE_DEFAULT_COLOR","NODE_DEFAULT_BGCOLOR","NODE_DEFAULT_BOXCOLOR","NODE_DEFAULT_SHAPE","NODE_BOX_OUTLINE_COLOR","DEFAULT_SHADOW_COLOR","DEFAULT_GROUP_FONT","WIDGET_BGCOLOR","WIDGET_OUTLINE_COLOR","WIDGET_TEXT_COLOR","WIDGET_SECONDARY_TEXT_COLOR","LINK_COLOR","EVENT_LINK_COLOR","CONNECTING_LINK_COLOR","MAX_NUMBER_OF_NODES","DEFAULT_POSITION","VALID_SHAPES","BOX_SHAPE","ROUND_SHAPE","CIRCLE_SHAPE","CARD_SHAPE","ARROW_SHAPE","INPUT","OUTPUT","EVENT","ACTION","ALWAYS","ON_EVENT","NEVER","ON_TRIGGER","UP","DOWN","LEFT","RIGHT","CENTER","STRAIGHT_LINK","LINEAR_LINK","SPLINE_LINK","NORMAL_TITLE","NO_TITLE","TRANSPARENT_TITLE","AUTOHIDE_TITLE","proxy","node_images_path","debug","catch_exceptions","throw_errors","allow_scripts","registered_node_types","node_types_by_file_extension","Nodes","Globals","searchbox_extras","auto_sort_node_types","registerNodeType","type","base_class","prototype","console","log","split","classname","name","pos","lastIndexOf","category","substr","title","i","LGraphNode","prev","this","Object","hasOwnProperty","defineProperty","set","v","_shape","get","enumerable","configurable","onPropertyChange","warn","supported_extensions","ext","constructor","String","toLowerCase","onNodeTypeRegistered","onNodeTypeReplaced","length","unregisterNodeType","wrapFunctionAsNode","func","param_types","return_type","properties","params","Array","code","names","getParameterNames","JSON","stringify","classobj","Function","pop","desc","onExecute","getInputData","r","apply","setOutputData","clearRegisteredTypes","addNodeMethod","createNode","options","node","err","error","properties_info","flags","size","computeSize","concat","mode","getNodeType","getNodeTypesInCategory","filter","push","sort","getNodeTypesCategories","categories","skip_list","result","reloadNodes","folder_wildcard","tmp","document","getElementsByTagName","script_files","docHeadObj","location","href","src","dynamicScript","createElement","appendChild","removeChild","cloneObject","obj","target","parse","isValidConnection","type_a","type_b","indexOf","supported_types_a","supported_types_b","j","registerSearchboxExtra","node_type","description","data","fetchFile","url","on_complete","on_error","fetch","then","response","ok","Error","arrayBuffer","text","json","blob","catch","File","Blob","reader","FileReader","onload","e","readAsArrayBuffer","readAsText","readAsBinaryString","DragAndScale","element","skip_events","offset","Float32Array","scale","max_scale","min_scale","onredraw","enabled","last_mouse","visible_area","bindEvents","LGraphCanvas","canvas","graph","background_image","DEFAULT_BACKGROUND_IMAGE","querySelector","ds","zoom_modify_alpha","title_text_font","inner_text_font","node_title_color","default_link_color","default_connection_color","input_off","input_on","output_off","output_on","highquality_render","use_gradients","editor_alpha","pause_rendering","clear_background","read_only","render_only_selected","live_mode","show_info","allow_dragcanvas","allow_dragnodes","allow_interaction","allow_searchbox","allow_reconnect_links","drag_mode","dragging_rectangle","set_canvas_dirty_on_mouse_event","always_render_background","render_shadows","render_canvas_border","render_connections_shadows","render_connections_border","render_curved_connections","render_connection_arrows","render_collapsed_slots","render_execution_order","render_title_colored","render_link_tooltip","links_render_mode","mouse","graph_mouse","canvas_mouse","onSearchBox","onSearchBoxSelection","onMouse","onDrawBackground","onDrawForeground","onDrawOverlay","onDrawLinkTooltip","onNodeMoved","onSelectionChange","onConnectingChange","onBeforeChange","onAfterChange","connections_width","round_radius","current_node","node_widget","over_link_center","last_mouse_position","visible_links","attachCanvas","setCanvas","clear","skip_render","startRendering","autoresize","performance","getTime","now","bind","Date","process","t","hrtime","_binded_mouse_callback","addEventListener","computeVisibleArea","width","height","startx","starty","endx","endy","rect","getBoundingClientRect","x","clientX","left","y","clientY","top","canvasx","canvasy","dragging","ignore","onmouse","removeEventListener","body","deltax","deltay","mouseDrag","eventType","wheel","deltaY","wheelDeltaY","detail","delta","wheelDelta","changeDeltaScale","preventDefault","stopPropagation","toCanvasContext","ctx","translate","convertOffsetToCanvas","convertCanvasToOffset","out","changeScale","value","zooming_center","center","Math","abs","new_center","delta_offset","reset","link_type_colors","number","gradients","frame","last_draw_time","render_time","fps","selected_nodes","selected_group","visible_nodes","node_dragged","node_over","node_capturing_input","connecting_node","highlighted_links","dragging_canvas","dirty_canvas","dirty_bgcanvas","dirty_area","node_in_panel","last_mouseclick","onClear","setGraph","skip_clear","_graph_stack","setDirty","detachCanvas","getTopGraph","openSubgraph","checkPanels","closeSubgraph","subgraph_node","_subgraph_node","centerOnNode","selectNodes","getCurrentGraph","getElementById","unbindEvents","className","tabindex","bgcanvas","getContext","localName","webgl_enabled","enableWebGL","_mousemove_callback","processMouseMove","_mouseup_callback","processMouseUp","_doNothing","_doReturnTrue","_events_binded","getCanvasWindow","_mousedown_callback","processMouseDown","_mousewheel_callback","processMouseWheel","touchHandler","_key_callback","processKey","_ondrop_callback","processDrop","getFileExtension","question","point","undefined","GL","enableWebGLCanvas","gl","webgl","bgctx","fgcanvas","window","doc","ownerDocument","defaultView","parentWindow","is_rendering","renderFrame","draw","requestAnimationFrame","call","stopRendering","blockClick","block_click","adjustMouseEvent","ref_window","active_canvas","that","getNodeOnPos","canvasX","canvasY","skip_action","is_double_click","localX","localY","last_click_position","focus","closeAllContextMenus","which","ctrlKey","clicking_canvas_bg","pinned","bringToFront","collapsed","resizable","isInsideRectangle","beforeChange","resizing_node","style","cursor","outputs","l","output","link_pos","getConnectionPos","connecting_output","connecting_pos","connecting_slot","shiftKey","disconnectOutput","onOutputDblClick","onOutputClick","inputs","input","onInputDblClick","onInputClick","link","link_info","links","disconnectInput","_nodes_by_id","origin_id","origin_slot","block_drag_node","widget","processNodeWidgets","id","onDblClick","processNodeDblClicked","onMouseDown","subgraph","skip_subgraph_button","setTimeout","processNodeSelected","_pos","showLinkMenu","getGroupOnPos","selected_group_resizing","distance","recomputeInsideNodes","showSearchBox","processContextMenu","last_mouse_dragging","change","activeElement","nodeName","resize","move","_nodes","mouseOver","onMouseLeave","redraw_on_mouse","onMouseEnter","onMouseMove","_highlight_input","isOverNodeBox","slot","isOverNodeInput","slot_type","over_link","n","desired_size","min_size","max","setSize","click_time","diffx","round","diffy","nodes","node_bounding","deselectAllNodes","w","h","to_select","getBounding","overlapBounding","connect","getInputInfo","afterChange","collapse","config","align_to_grid","alignToGrid","onMouseUp","title_height","slot_pos","horizontal","block_default","keyCode","metaKey","copyToClipboard","pasteFromClipboard","deleteSelectedNodes","onKeyDown","onKeyUp","stopImmediatePropagation","clipboard_info","index","selected_nodes_array","_relative_id","cloned","clone","serialize","target_node","getNodeById","target_slot","localStorage","setItem","getItem","node_data","configure","add","origin_node","onDropItem","event","checkDropItem","onDropFile","onDropData","files","dataTransfer","file","filename","readAsDataURL","nodetype","onShowNodePanel","showShowNodePanel","onNodeDblClicked","selectNode","onNodeSelected","add_to_current_selection","is_selected","onSelected","k","deselectNode","onDeselected","onNodeDeselected","block_delete","input_link","output_link","input_node","getInputNode","output_node","getOutputNodes","remove","b","deltaX","setZoom","convertEventToCanvasOffset","splice","sendToBack","unshift","temp","computeVisibleNodes","force_canvas","force_bgcanvas","_last_trigger_time","drawBackCanvas","drawFrontCanvas","start2D","restore","setTransform","save","beginPath","clip","clearRect","drawImage","onRender","renderInfo","drawNode","drawExecutionOrder","links_ontop","drawConnections","lineWidth","link_color","renderLink","dir","shape","arc","PI","fill","fillStyle","strokeStyle","strokeRect","drawLinkTooltip","visible_rect","drawSubgraphPanel","finish2D","subnode","num","floor","globalAlpha","roundRect","font","textAlign","fillText","drawButton","not_subgraph_input","input_node_type","newnode","setProperty","tw","measureText","showSubgraphPropertiesDialog","bgcolor","hovercolor","textcolor","hover","clicked","was_clicked","isAreaClicked","hold_click","globaltime","toFixed","iteration","_version","start","getTitle","bg_already_painted","onRenderBackground","imageSmoothingEnabled","mozImageSmoothingEnabled","_bg_img","Image","pattern","_pattern","createPattern","_pattern_img","fillRect","_groups","drawGroups","onBackgroundRender","shadowColor","shadowOffsetX","shadowOffsetY","shadowBlur","finish","temp_vec2","color","low_quality","onDrawCollapsed","_collapsed_width","min","clip_area","has_errors","drawNodeShape","render_text","out_slot","max_y","input_slot","output_slot","moveTo","lineTo","closePath","color_on","color_off","label","stroke","widgets","widgets_y","widgets_up","widgets_start_y","drawNodeWidgets","Number","Boolean","toToolTip","tmp_area","fgcolor","selected","mouse_over","title_mode","render_title","area","old_alpha","onDrawTitleBar","title_color","grad","createLinearGradient","addColorStop","box_size","onDrawTitleBox","boxcolor","onDrawTitleText","title_text_color","over","onDrawTitle","onBounding","margin_area","link_bounding","tempA","tempB","a","sqrt","A_end_x","A_end_y","B_end_x","B_end_y","ContextMenu","values","parentMenu","lock","current_submenu","eventClass","root","on_mouse_wheel","parseInt","scroll_speed","minWidth","minHeight","pointerEvents","button","close","innerHTML","content","addItem","closing_timer","clearTimeout","root_document","fullscreenElement","body_rect","root_rect","transform","CurveEditor","points","nearest","must_update","margin","link_id","start_node","start_node_slot","start_node_slotpos","end_node_slotpos","start_slot","end_slot","start_dir","end_dir","_last_time","f","skip_border","flow","num_sublines","dist","lineJoin","offsety","start_offset_x","start_offset_y","end_offset_x","end_offset_y","bezierCurveTo","start_x","start_y","end_x","end_y","computeConnectionPoint","posA","posB","posC","posD","angleA","angleB","atan2","rotate","p0","p1","p2","p3","c1","c2","c3","c4","order","posY","active_widget","H","show_text","outline_color","background_color","text_color","secondary_text_color","last_y","disabled","widget_width","on","off","range","nvalue","marker","marker_nvalue","precision","widget_height","old_value","callback","clamp","inner_value_change","step","values_list","keys","text_values","option","prompt","multiline","onWidgetChanged","property","groups","group","_bounding","_size","font_size","DEFAULT_GROUP_FONT_SIZE","adjustNodesSize","parent","parentNode","offsetWidth","offsetHeight","switchLiveMode","transition","self","setInterval","clearInterval","onNodeSelectionChange","first","changedTouches","simulatedEvent","createEvent","initMouseEvent","screenX","screenY","dispatchEvent","onGroupAdd","info","entry","mouse_event","LGraphGroup","onMenuAdd","prev_menu","inner_onMenuAdded","base_category","startsWith","entries","map","base_category_regex","RegExp","category_name","replace","category_path","findIndex","has_submenu","mouseEvent","contextMenu","slice","first_event","getFirstEvent","onMenuCollapseAll","onMenuNodeEdit","showMenuNodeOptionalInputs","optional_inputs","onGetInputs","onMenuNodeInputs","addInput","setDirtyCanvas","showMenuNodeOptionalOutputs","optional_outputs","onGetOutputs","skip_repeated_outputs","findOutputSlot","onMenuNodeOutputs","inner_clicked","addOutput","onShowMenuNodeProperties","_typeof","getPropertyInfo","getPropertyPrintableValue","decodeHTML","showEditPropertyValue","position","allow_html","str","innerText","onResizeNode","menu","onResize","node_left","node_right","target_id","removeLink","onShowPropertyEditor","item","dialog","inner","offsetx","setValue","modified","prompt_box","value_element","search_limit","graphcanvas","search_box","overflow","timeout_close","helper","timeout","changeSelection","refreshHelper","select","extra","addProperty","forward","classList","nextSibling","previousSibling","childNodes","scrollIntoView","block","behavior","list","addResult","inner_test_filter","ctor","c","filtered","help","dataset","escape","unescape","layerY","maxHeight","input_html","createDialog","checked","onPropertyChanged","onclose","html","createPanel","header","closable","title_element","footer","addHTML","on_footer","elem","addButton","addSeparator","addWidget","str_value","propname","toggle","innerChange","setAttribute","blur","elem_that","desc_value","SELECTED_NODE","panel","onAddPropertyToPanel","onShowCustomPanelInfo","inner_refresh","old_panel","removeInput","findInputSlot","panels","querySelectorAll","onMenuNodeCollapse","onMenuNodePin","pin","onMenuNodeMode","onMenuNodeColors","node_colors","groupcolor","onMenuNodeShapes","onMenuNodeRemove","removable","onMenuNodeToSubgraph","nodes_list","buildFromNodes","onMenuNodeClone","clonable","red","brown","green","blue","pale_blue","cyan","purple","yellow","black","getCanvasMenuOptions","getMenuOptions","getExtraMenuOptions","getNodeMenuOptions","onGetNodeMenuOptions","getGroupMenuOptions","menu_info","removeOutput","slot_info","getOutputInfo","getSlotInPosition","active_node","getSlotMenuOptions","_slot","locked","nameLocked","submenu","CanvasRenderingContext2D","radius","radius_low","quadraticCurveTo","compareObjects","colorToString","growBounding","bounding","isInsideBounding","p","bb","hex2num","hex","charAt","toUpperCase","int1","int2","hex_alphabets","num2hex","triplet","inner_onclick","close_parent","ignore_item_callbacks","autoopen","onclick_callback","ignore_parent_menu","isCursorOverElement","trigger","event_name","origin","evt","initCustomEvent","srcElement","__events","getTopMenu","elements","extendClass","__lookupGetter__","__defineGetter__","__lookupSetter__","__defineSetter__","sampleCurve","pn","local_f","line_color","inactive","localpos","max_dist","getCloserPoint","s","curvepos","_nearest","is_edge_point","min_dist","closest","vec2","webkitRequestAnimationFrame","mozRequestAnimationFrame","LGraph","o","list_of_graphcanvas","supportedTypes","stop","status","STATUS_STOPPED","last_node_id","last_link_id","onRemoved","_nodes_in_order","_nodes_executable","vars","runningtime","fixedtime","fixedtime_lapse","elapsed_time","last_update_time","starttime","catch_errors","sendActionToCanvas","interval","STATUS_RUNNING","onPlayEvent","sendEventToAllNodes","execution_timer_id","onFrame","onBeforeStep","runStep","onAfterStep","onStopEvent","doNotCatchError","limit","onExecuteStep","onAfterExecute","errors_in_execution","elapsed","execution_time","computeExecutionOrder","onlyOnExecute","setLevel","L","S","M","visitedLinks","remainingLinks","l2","_level","shift","linkId","targetNode","A","B","Ap","priority","Bp","ancestors","pending","visited","current","columns","col","column","maxSize","eventname","Subgraph","action","skipComputeOrder","onAdded","updateExecutionOrder","onNodeAdded","ignore_remove","onNodeRemoved","classObject","nodesList","isPointInside","g","param","_input_nodes","findNodesByClass","GraphInput","onAction","onTrigger","onInputAdded","onInputsOutputsChange","oldName","newName","onInputRenamed","onInputTypeChanged","onInputRemoved","onOutputAdded","onOutputRenamed","onOutputTypeChanged","onOutputRemoved","findNodesByTitle","setTrigger","onConnectionChange","linkInfo","on_change","fg","bg","nodesInfo","link2","LLink","groupsInfo","version","onSerialize","keepOld","linkData","nInfo","last_serialization","dataGroup","onConfigure","req","XMLHttpRequest","open","send","onerror","msg","_data","_ctor","connections","onConnectionsChange","widgets_values","serialize_widgets","prevValue","output_info","force_update","updateOutputData","slot_name","input_info","triggerSlot","target_connection","default_value","extra_info","array","direction","rows","title_width","compute_text_size","input_width","output_width","text_width","slot_start_y","widgets_height","min_height","widgets_info","onGetPropertyInfo","custom_widget","skip_title","margin_top","isLive","changed","onConnectInput","onNodeConnectionChange","connectionChange","is_input","slot_number","num_slots","MAX_CONSOLE","onNodeTrace","dirty_foreground","dirty_background","img","ready","_this","force","collapsable","subarray","ignore_nodes","Editor","containerId","miniwindow","addMiniWindow","max_zoom","miniwindow_graphcanvas","tl","br","right","close_button"],"mappings":"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"}